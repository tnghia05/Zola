"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client@2.16.0_@types+dom-mediacapture-record@1.0.22";
exports.ids = ["vendor-chunks/livekit-client@2.16.0_@types+dom-mediacapture-record@1.0.22"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/livekit-client@2.16.0_@types+dom-mediacapture-record@1.0.22/node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/livekit-client@2.16.0_@types+dom-mediacapture-record@1.0.22/node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BackupCodecPolicy: () => (/* binding */ BackupCodecPolicy),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   CheckStatus: () => (/* binding */ CheckStatus),\n/* harmony export */   Checker: () => (/* binding */ Checker),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionErrorReason: () => (/* binding */ ConnectionErrorReason),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorError: () => (/* binding */ CryptorError),\n/* harmony export */   CryptorErrorReason: () => (/* binding */ CryptorErrorReason),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DataStreamError: () => (/* binding */ DataStreamError),\n/* harmony export */   DataStreamErrorReason: () => (/* binding */ DataStreamErrorReason),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   Encryption_Type: () => (/* binding */ Encryption_Type),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalTrackRecorder: () => (/* binding */ LocalTrackRecorder),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   LoggerNames: () => (/* binding */ LoggerNames),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   Mutex: () => (/* binding */ _),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   ParticipantKind: () => (/* binding */ ParticipantInfo_Kind),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   PublishTrackError: () => (/* binding */ PublishTrackError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   SignalRequestError: () => (/* binding */ SignalRequestError),\n/* harmony export */   SubscriptionError: () => (/* binding */ SubscriptionError),\n/* harmony export */   TokenSource: () => (/* binding */ TokenSource),\n/* harmony export */   TokenSourceConfigurable: () => (/* binding */ TokenSourceConfigurable),\n/* harmony export */   TokenSourceFixed: () => (/* binding */ TokenSourceFixed),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   TrackType: () => (/* binding */ TrackType),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   areTokenSourceFetchOptionsEqual: () => (/* binding */ areTokenSourceFetchOptionsEqual),\n/* harmony export */   asEncryptablePacket: () => (/* binding */ asEncryptablePacket),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   attributes: () => (/* binding */ attributeTypings),\n/* harmony export */   audioCodecs: () => (/* binding */ audioCodecs),\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   decodeTokenPayload: () => (/* binding */ decodeTokenPayload),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getBrowser: () => (/* binding */ getBrowser),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isAudioCodec: () => (/* binding */ isAudioCodec),\n/* harmony export */   isAudioTrack: () => (/* binding */ isAudioTrack),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBackupVideoCodec: () => (/* binding */ isBackupVideoCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isLocalParticipant: () => (/* binding */ isLocalParticipant),\n/* harmony export */   isLocalTrack: () => (/* binding */ isLocalTrack),\n/* harmony export */   isRemoteParticipant: () => (/* binding */ isRemoteParticipant),\n/* harmony export */   isRemoteTrack: () => (/* binding */ isRemoteTrack),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoCodec: () => (/* binding */ isVideoCodec),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   isVideoTrack: () => (/* binding */ isVideoTrack),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsAudioOutputSelection: () => (/* binding */ supportsAudioOutputSelection),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== \"default\" && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar e = Object.defineProperty;\nvar h = (i, s, t)=>s in i ? e(i, s, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: t\n    }) : i[s] = t;\nvar o = (i, s, t)=>h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\nclass _ {\n    constructor(){\n        o(this, \"_locking\");\n        o(this, \"_locks\");\n        this._locking = Promise.resolve(), this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let s;\n        const t = new Promise((l)=>s = ()=>{\n                this._locks -= 1, l();\n            }), c = this._locking.then(()=>s);\n        return this._locking = this._locking.then(()=>t), c;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -2147483648;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   * Note that this function disregards extensions and unknown fields.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(\"int64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(\"uint64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the zero value for the given scalar type.\n */ function scalarZeroValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\n *\n * In proto3, zero-values are not written to the wire, unless the field is\n * optional or repeated.\n */ function isScalarZeroValue(type, value) {\n    switch(type){\n        case ScalarType.BOOL:\n            return value === false;\n        case ScalarType.STRING:\n            return value === \"\";\n        case ScalarType.BYTES:\n            return value instanceof Uint8Array && !value.byteLength;\n        default:\n            return value == 0;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n   * in editions with message_encoding = DELIMITED.\n   */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n   * End of a tag-delimited aggregate.\n   */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element and return the skipped data.\n   *\n   * When skipping StartGroup, provide the tags field number to check for\n   * matching field number in the EndGroup tag.\n   */ skip(wireType, fieldNo) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                for(;;){\n                    const [fn, wt] = this.tag();\n                    if (wt === WireType.EndGroup) {\n                        if (fieldNo !== undefined && fn !== fieldNo) {\n                            throw new Error(\"invalid end group tag\");\n                        }\n                        break;\n                    }\n                    this.skip(wt, fn);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new extension using the given runtime.\n */ function makeExtension(runtime, typeName, extendee, field) {\n    let fi;\n    return {\n        typeName,\n        extendee,\n        get field () {\n            if (!fi) {\n                const i = typeof field == \"function\" ? field() : field;\n                i.name = typeName.split(\".\").pop();\n                i.jsonName = \"[\".concat(typeName, \"]\");\n                fi = runtime.util.newFieldList([\n                    i\n                ]).list()[0];\n            }\n            return fi;\n        },\n        runtime\n    };\n}\n/**\n * Create a container that allows us to read extension fields into it with the\n * same logic as regular fields.\n */ function createExtensionContainer(extension) {\n    const localName = extension.field.localName;\n    const container = Object.create(null);\n    container[localName] = initExtensionField(extension);\n    return [\n        container,\n        ()=>container[localName]\n    ];\n}\nfunction initExtensionField(ext) {\n    const field = ext.field;\n    if (field.repeated) {\n        return [];\n    }\n    if (field.default !== undefined) {\n        return field.default;\n    }\n    switch(field.kind){\n        case \"enum\":\n            return field.T.values[0].no;\n        case \"scalar\":\n            return scalarZeroValue(field.T, field.L);\n        case \"message\":\n            // eslint-disable-next-line no-case-declarations\n            const T = field.T, value = new T();\n            return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\n        case \"map\":\n            throw \"map fields are not allowed to be extensions\";\n    }\n}\n/**\n * Helper to filter unknown fields, optimized based on field type.\n */ function filterUnknownFields(unknownFields, field) {\n    if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\n        // singular scalar fields do not merge, we pick the last\n        for(let i = unknownFields.length - 1; i >= 0; --i){\n            if (unknownFields[i].no == field.no) {\n                return [\n                    unknownFields[i]\n                ];\n            }\n        }\n        return [];\n    }\n    return unknownFields.filter((uf)=>uf.no === field.no);\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\t\":\n                    case \" \":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Retrieve an extension value from a message.\n *\n * The function never returns undefined. Use hasExtension() to check whether an\n * extension is set. If the extension is not set, this function returns the\n * default value (if one was specified in the protobuf source), or the zero value\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\n * an empty message instance for message fields).\n *\n * Extensions are stored as unknown fields on a message. To mutate an extension\n * value, make sure to store the new value with setExtension() after mutating.\n *\n * If the extension does not extend the given message, an error is raised.\n */ function getExtension(message, extension, options) {\n    assertExtendee(extension, message);\n    const opt = extension.runtime.bin.makeReadOptions(options);\n    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\n    const [container, get] = createExtensionContainer(extension);\n    for (const uf of ufs){\n        extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\n    }\n    return get();\n}\n/**\n * Set an extension value on a message. If the message already has a value for\n * this extension, the value is replaced.\n *\n * If the extension does not extend the given message, an error is raised.\n */ function setExtension(message, extension, value, options) {\n    assertExtendee(extension, message);\n    const readOpt = extension.runtime.bin.makeReadOptions(options);\n    const writeOpt = extension.runtime.bin.makeWriteOptions(options);\n    if (hasExtension(message, extension)) {\n        const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf)=>uf.no != extension.field.no);\n        message.getType().runtime.bin.discardUnknownFields(message);\n        for (const uf of ufs){\n            message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\n        }\n    }\n    const writer = writeOpt.writerFactory();\n    let f = extension.field;\n    // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\n    // We patch the field info to use explicit presence:\n    if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\n        f = Object.assign(Object.assign({}, extension.field), {\n            opt: true\n        });\n    }\n    extension.runtime.bin.writeField(f, value, writer, writeOpt);\n    const reader = readOpt.readerFactory(writer.finish());\n    while(reader.pos < reader.len){\n        const [no, wireType] = reader.tag();\n        const data = reader.skip(wireType, no);\n        message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\n    }\n}\n/**\n * Check whether an extension is set on a message.\n */ function hasExtension(message, extension) {\n    const messageType = message.getType();\n    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf)=>uf.no == extension.field.no);\n}\nfunction assertExtendee(extension, message) {\n    assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if the field is set.\n */ function isFieldSet(field, target) {\n    const localName = field.localName;\n    if (field.repeated) {\n        return target[localName].length > 0;\n    }\n    if (field.oneof) {\n        return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\n    }\n    switch(field.kind){\n        case \"enum\":\n        case \"scalar\":\n            if (field.opt || field.req) {\n                // explicit presence\n                return target[localName] !== undefined;\n            }\n            // implicit presence\n            if (field.kind == \"enum\") {\n                return target[localName] !== field.T.values[0].no;\n            }\n            return !isScalarZeroValue(field.T, target[localName]);\n        case \"message\":\n            return target[localName] !== undefined;\n        case \"map\":\n            return Object.keys(target[localName]).length > 0;\n    }\n}\n/**\n * Resets the field, so that isFieldSet() will return false.\n */ function clearField(field, target) {\n    const localName = field.localName;\n    const implicitPresence = !field.opt && !field.req;\n    if (field.repeated) {\n        target[localName] = [];\n    } else if (field.oneof) {\n        target[field.oneof.localName] = {\n            case: undefined\n        };\n    } else {\n        switch(field.kind){\n            case \"map\":\n                target[localName] = {};\n                break;\n            case \"enum\":\n                target[localName] = implicitPresence ? field.T.values[0].no : undefined;\n                break;\n            case \"scalar\":\n                target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\n                break;\n            case \"message\":\n                target[localName] = undefined;\n                break;\n        }\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Check whether the given object is any subtype of Message or is a specific\n * Message by passing the type.\n *\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\n * `isMessage` is that it compares identity by the message type name, not by\n * class identity. This makes it robust against the dual package hazard and\n * similar situations, where the same message is duplicated.\n *\n * This function is _mostly_ equivalent to the `instanceof` operator. For\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\n * `isMessage` should be preferred over `instanceof`.\n *\n * However, due to the fact that `isMessage` does not use class identity, there\n * are subtle differences between this function and `instanceof`. Notably,\n * calling `isMessage` on an explicit type of Message will return false.\n */ function isMessage(arg, type) {\n    if (arg === null || typeof arg != \"object\") {\n        return false;\n    }\n    if (!Object.getOwnPropertyNames(Message.prototype).every((m)=>m in arg && typeof arg[m] == \"function\")) {\n        return false;\n    }\n    const actualType = arg.getType();\n    if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\n        return false;\n    }\n    return type === undefined ? true : actualType.typeName == type.typeName;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (isMessage(value) || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nconst tokenNull = Symbol();\nconst tokenIgnoredUnknownEnum = Symbol();\nfunction makeJsonFormat() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = new Map();\n            const registry = options.typeRegistry;\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (field) {\n                    if (field.oneof) {\n                        if (jsonValue === null && field.kind == \"scalar\") {\n                            continue;\n                        }\n                        const seen = oneofSeen.get(field.oneof);\n                        if (seen !== undefined) {\n                            throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: multiple keys for oneof \"').concat(field.oneof.name, '\" present: \"').concat(seen, '\", \"').concat(jsonKey, '\"'));\n                        }\n                        oneofSeen.set(field.oneof, jsonKey);\n                    }\n                    readField$1(message, jsonValue, field, options, type);\n                } else {\n                    let found = false;\n                    if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\n                        const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\n                        if (ext && ext.extendee.typeName == type.typeName) {\n                            found = true;\n                            const [container, get] = createExtensionContainer(ext);\n                            readField$1(container, jsonValue, ext.field, options, ext);\n                            // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\n                            // so that users can bring their own binary reader and writer factories\n                            // if necessary.\n                            setExtension(message, ext, get(), options);\n                        }\n                    }\n                    if (!found && !options.ignoreUnknownFields) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: key \"').concat(jsonKey, '\" is unknown'));\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (field of type.fields.byNumber()){\n                    if (!isFieldSet(field, message)) {\n                        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                        if (field.req) {\n                            throw \"required field not set\";\n                        }\n                        if (!options.emitDefaultValues) {\n                            continue;\n                        }\n                        if (!canEmitFieldDefaultValue(field)) {\n                            continue;\n                        }\n                    }\n                    const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n                    const jsonValue = writeField$1(field, value, options);\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n                const registry = options.typeRegistry;\n                if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\n                    for (const uf of type.runtime.bin.listUnknownFields(message)){\n                        const ext = registry.findExtensionFor(type.typeName, uf.no);\n                        if (ext && hasExtension(message, ext)) {\n                            // We pass on the options as BinaryReadOptions, so that users can bring their own\n                            // binary reader factory if necessary.\n                            const value = getExtension(message, ext, options);\n                            const jsonValue = writeField$1(ext.field, value, options);\n                            if (jsonValue !== undefined) {\n                                json[ext.field.jsonName] = jsonValue;\n                            }\n                        }\n                    }\n                }\n            } catch (e) {\n                const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n            }\n            return json;\n        },\n        readScalar (type, json, longType) {\n            // The signature of our internal function has changed. For backwards-\n            // compatibility, we support the old form that is part of the public API\n            // through the interface JsonFormat.\n            return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\n        },\n        writeScalar (type, value, emitDefaultValues) {\n            // The signature of our internal function has changed. For backwards-\n            // compatibility, we support the old form that is part of the public API\n            // through the interface JsonFormat.\n            if (value === undefined) {\n                return undefined;\n            }\n            if (emitDefaultValues || isScalarZeroValue(type, value)) {\n                return writeScalar$1(type, value);\n            }\n            return undefined;\n        },\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : '\"'.concat(json.split('\"').join('\\\\\"'), '\"');\n        default:\n            return String(json);\n    }\n}\n// Read a JSON value for a field.\n// The \"parentType\" argument is only used to provide context in errors.\nfunction readField$1(target, jsonValue, field, options, parentType) {\n    let localName = field.localName;\n    if (field.repeated) {\n        assert(field.kind != \"map\");\n        if (jsonValue === null) {\n            return;\n        }\n        if (!Array.isArray(jsonValue)) {\n            throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n        }\n        const targetArray = target[localName];\n        for (const jsonItem of jsonValue){\n            if (jsonItem === null) {\n                throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\n            }\n            switch(field.kind){\n                case \"message\":\n                    targetArray.push(field.T.fromJson(jsonItem, options));\n                    break;\n                case \"enum\":\n                    const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\n                    if (enumValue !== tokenIgnoredUnknownEnum) {\n                        targetArray.push(enumValue);\n                    }\n                    break;\n                case \"scalar\":\n                    try {\n                        targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\n                    } catch (e) {\n                        let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\n                        if (e instanceof Error && e.message.length > 0) {\n                            m += \": \".concat(e.message);\n                        }\n                        throw new Error(m);\n                    }\n                    break;\n            }\n        }\n    } else if (field.kind == \"map\") {\n        if (jsonValue === null) {\n            return;\n        }\n        if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\n            throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n        }\n        const targetMap = target[localName];\n        for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n            if (jsonMapValue === null) {\n                throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n            }\n            let key;\n            try {\n                key = readMapKey(field.K, jsonMapKey);\n            } catch (e) {\n                let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                if (e instanceof Error && e.message.length > 0) {\n                    m += \": \".concat(e.message);\n                }\n                throw new Error(m);\n            }\n            switch(field.V.kind){\n                case \"message\":\n                    targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\n                    break;\n                case \"enum\":\n                    const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\n                    if (enumValue !== tokenIgnoredUnknownEnum) {\n                        targetMap[key] = enumValue;\n                    }\n                    break;\n                case \"scalar\":\n                    try {\n                        targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\n                    } catch (e) {\n                        let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                        if (e instanceof Error && e.message.length > 0) {\n                            m += \": \".concat(e.message);\n                        }\n                        throw new Error(m);\n                    }\n                    break;\n            }\n        }\n    } else {\n        if (field.oneof) {\n            target = target[field.oneof.localName] = {\n                case: localName\n            };\n            localName = \"value\";\n        }\n        switch(field.kind){\n            case \"message\":\n                const messageType = field.T;\n                if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                    return;\n                }\n                let currentValue = target[localName];\n                if (isMessage(currentValue)) {\n                    currentValue.fromJson(jsonValue, options);\n                } else {\n                    target[localName] = currentValue = messageType.fromJson(jsonValue, options);\n                    if (messageType.fieldWrapper && !field.oneof) {\n                        target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\n                    }\n                }\n                break;\n            case \"enum\":\n                const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\n                switch(enumValue){\n                    case tokenNull:\n                        clearField(field, target);\n                        break;\n                    case tokenIgnoredUnknownEnum:\n                        break;\n                    default:\n                        target[localName] = enumValue;\n                        break;\n                }\n                break;\n            case \"scalar\":\n                try {\n                    const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\n                    switch(scalarValue){\n                        case tokenNull:\n                            clearField(field, target);\n                            break;\n                        default:\n                            target[localName] = scalarValue;\n                            break;\n                    }\n                } catch (e) {\n                    let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                    if (e instanceof Error && e.message.length > 0) {\n                        m += \": \".concat(e.message);\n                    }\n                    throw new Error(m);\n                }\n                break;\n        }\n    }\n}\nfunction readMapKey(type, json) {\n    if (type === ScalarType.BOOL) {\n        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n        switch(json){\n            case \"true\":\n                json = true;\n                break;\n            case \"false\":\n                json = false;\n                break;\n        }\n    }\n    return readScalar$1(type, json, LongType.BIGINT, true).toString();\n}\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\n    if (json === null) {\n        if (nullAsZeroValue) {\n            return scalarZeroValue(type, longType);\n        }\n        return tokenNull;\n    }\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\n    if (json === null) {\n        if (type.typeName == \"google.protobuf.NullValue\") {\n            return 0; // google.protobuf.NullValue.NULL_VALUE = 0\n        }\n        return nullAsZeroValue ? type.values[0].no : tokenNull;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            if (value !== undefined) {\n                return value.no;\n            }\n            if (ignoreUnknownFields) {\n                return tokenIgnoredUnknownEnum;\n            }\n            break;\n    }\n    throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\nfunction canEmitFieldDefaultValue(field) {\n    if (field.repeated || field.kind == \"map\") {\n        // maps are {}, repeated fields are []\n        return true;\n    }\n    if (field.oneof) {\n        // oneof fields are never emitted\n        return false;\n    }\n    if (field.kind == \"message\") {\n        // singular message field are allowed to emit JSON null, but we do not\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (field.opt || field.req) {\n        // the field uses explicit presence, so we cannot emit a zero value\n        return false;\n    }\n    return true;\n}\nfunction writeField$1(field, value, options) {\n    if (field.kind == \"map\") {\n        assert(typeof value == \"object\" && value != null);\n        const jsonObj = {};\n        const entries = Object.entries(value);\n        switch(field.V.kind){\n            case \"scalar\":\n                for (const [entryKey, entryValue] of entries){\n                    jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\n                }\n                break;\n            case \"message\":\n                for (const [entryKey, entryValue] of entries){\n                    // JSON standard allows only (double quoted) string as property key\n                    jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                }\n                break;\n            case \"enum\":\n                const enumType = field.V.T;\n                for (const [entryKey, entryValue] of entries){\n                    // JSON standard allows only (double quoted) string as property key\n                    jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\n                }\n                break;\n        }\n        return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\n    }\n    if (field.repeated) {\n        assert(Array.isArray(value));\n        const jsonArr = [];\n        switch(field.kind){\n            case \"scalar\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(writeScalar$1(field.T, value[i]));\n                }\n                break;\n            case \"enum\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\n                }\n                break;\n            case \"message\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(value[i].toJson(options));\n                }\n                break;\n        }\n        return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n    }\n    switch(field.kind){\n        case \"scalar\":\n            return writeScalar$1(field.T, value);\n        case \"enum\":\n            return writeEnum(field.T, value, options.enumAsInteger);\n        case \"message\":\n            return wrapField(field.T, value).toJson(options);\n    }\n}\nfunction writeEnum(type, value, enumAsInteger) {\n    var _a;\n    assert(typeof value == \"number\");\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar$1(type, value) {\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            return value.toString();\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return protoBase64.enc(value);\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormat() {\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\n            const type = message.getType();\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\n            let fieldNo, wireType;\n            while(reader.pos < end){\n                [fieldNo, wireType] = reader.tag();\n                if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\n                    break;\n                }\n                const field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType, fieldNo);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                readField(message, reader, field, wireType, options);\n            }\n            if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n            (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\n                throw new Error(\"invalid end group tag\");\n            }\n        },\n        readField,\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                if (!isFieldSet(field, message)) {\n                    if (field.req) {\n                        throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\n                    }\n                    continue;\n                }\n                const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n                writeField(field, value, writer, options);\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        },\n        writeField (field, value, writer, options) {\n            // The behavior of our internal function has changed, it does no longer\n            // accept `undefined` values for singular scalar and map.\n            // For backwards-compatibility, we support the old form that is part of\n            // the public API through the interface BinaryFormat.\n            if (value === undefined) {\n                return undefined;\n            }\n            writeField(field, value, writer, options);\n        }\n    };\n}\nfunction readField(target, // eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\nreader, field, wireType, options) {\n    let { repeated, localName } = field;\n    if (field.oneof) {\n        target = target[field.oneof.localName];\n        if (target.case != localName) {\n            delete target.value;\n        }\n        target.case = localName;\n        localName = \"value\";\n    }\n    switch(field.kind){\n        case \"scalar\":\n        case \"enum\":\n            const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n            let read = readScalar;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            if (field.kind == \"scalar\" && field.L > 0) {\n                read = readScalarLTString;\n            }\n            if (repeated) {\n                let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\n                if (isPacked) {\n                    let e = reader.uint32() + reader.pos;\n                    while(reader.pos < e){\n                        arr.push(read(reader, scalarType));\n                    }\n                } else {\n                    arr.push(read(reader, scalarType));\n                }\n            } else {\n                target[localName] = read(reader, scalarType);\n            }\n            break;\n        case \"message\":\n            const messageType = field.T;\n            if (repeated) {\n                // safe to assume presence of array, oneof cannot contain repeated values\n                target[localName].push(readMessageField(reader, new messageType(), options, field));\n            } else {\n                if (isMessage(target[localName])) {\n                    readMessageField(reader, target[localName], options, field);\n                } else {\n                    target[localName] = readMessageField(reader, new messageType(), options, field);\n                    if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                        target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                    }\n                }\n            }\n            break;\n        case \"map\":\n            let [mapKey, mapVal] = readMapEntry(field, reader, options);\n            // safe to assume presence of map object, oneof cannot contain repeated values\n            target[localName][mapKey] = mapVal;\n            break;\n    }\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options, field) {\n    const format = message.getType().runtime.bin;\n    const delimited = field === null || field === void 0 ? void 0 : field.delimited;\n    format.readMessage(message, reader, delimited ? field.no : reader.uint32(), // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n    options, delimited);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        const [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options, undefined);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        key = scalarZeroValue(field.K, LongType.BIGINT);\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarZeroValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = field.V.T.values[0].no;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeField(field, value, writer, options) {\n    assert(value !== undefined);\n    const repeated = field.repeated;\n    switch(field.kind){\n        case \"scalar\":\n        case \"enum\":\n            let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n            if (repeated) {\n                assert(Array.isArray(value));\n                if (field.packed) {\n                    writePacked(writer, scalarType, field.no, value);\n                } else {\n                    for (const item of value){\n                        writeScalar(writer, scalarType, field.no, item);\n                    }\n                }\n            } else {\n                writeScalar(writer, scalarType, field.no, value);\n            }\n            break;\n        case \"message\":\n            if (repeated) {\n                assert(Array.isArray(value));\n                for (const item of value){\n                    writeMessageField(writer, options, field, item);\n                }\n            } else {\n                writeMessageField(writer, options, field, value);\n            }\n            break;\n        case \"map\":\n            assert(typeof value == \"object\" && value != null);\n            for (const [key, val] of Object.entries(value)){\n                writeMapEntry(writer, options, field, key, val);\n            }\n            break;\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar(writer, field.K, 1, keyValue);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar(writer, field.V.T, 2, value);\n            break;\n        case \"enum\":\n            writeScalar(writer, ScalarType.INT32, 2, value);\n            break;\n        case \"message\":\n            assert(value !== undefined);\n            writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\n            break;\n    }\n    writer.join();\n}\n// Value must not be undefined\nfunction writeMessageField(writer, options, field, value) {\n    const message = wrapField(field.T, value);\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);\n    else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\n}\nfunction writeScalar(writer, type, fieldNo, value) {\n    assert(value !== undefined);\n    let [wireType, method] = scalarTypeInfo(type);\n    writer.tag(fieldNo, wireType)[method](value);\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ // TODO replace call-sites writeScalar() and writePacked(), then remove\nfunction scalarTypeInfo(type) {\n    let wireType = WireType.Varint;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.BYTES:\n        case ScalarType.STRING:\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.DOUBLE:\n        case ScalarType.FIXED64:\n        case ScalarType.SFIXED64:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method\n    ];\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] == null) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>isMessage(val, mt) ? val : new mt(val));\n                        } else {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = isMessage(val, mt) ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        // TODO use isFieldSet() here to support future field presence\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(\"repeated cannot contain \".concat(m.kind));\n                }\n                switch(m.kind){\n                    case \"message\":\n                        let a1 = va;\n                        let b1 = vb;\n                        if (m.T.fieldWrapper) {\n                            if (a1 !== undefined && !isMessage(a1)) {\n                                a1 = m.T.fieldWrapper.wrapField(a1);\n                            }\n                            if (b1 !== undefined && !isMessage(b1)) {\n                                b1 = m.T.fieldWrapper.wrapField(b1);\n                            }\n                        }\n                        return m.T.equals(a1, b1);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(\"oneof cannot contain \".concat(s.kind));\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        // TODO use isFieldSet() here to support future field presence\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            for (const uf of type.runtime.bin.listUnknownFields(message)){\n                type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (isMessage(value)) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\n    return {\n        syntax,\n        json: makeJsonFormat(),\n        bin: makeBinaryFormat(),\n        util: Object.assign(Object.assign({}, makeUtilCommon()), {\n            newFieldList,\n            initFields\n        }),\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType,\n        makeExtension (typeName, extendee, field) {\n            return makeExtension(this, typeName, extendee, field);\n        }\n    };\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>\"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.req = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Convert a collection of field info to an array of normalized FieldInfo.\n *\n * The argument `packedByDefault` specifies whether fields that do not specify\n * `packed` should be packed (proto3) or unpacked (proto2).\n */ function normalizeFieldInfos(fieldInfos, packedByDefault) {\n    var _a, _b, _c, _d, _e, _f;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\n        f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\n        f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\n        if (field.packed === undefined) {\n            {\n                f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n            }\n        }\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", (fields)=>{\n    return new InternalFieldList(fields, (source)=>normalizeFieldInfos(source));\n}, // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\n(target)=>{\n    for (const member of target.getType().fields.byMember()){\n        if (member.opt) {\n            continue;\n        }\n        const name = member.localName, t = target;\n        if (member.repeated) {\n            t[name] = [];\n            continue;\n        }\n        switch(member.kind){\n            case \"oneof\":\n                t[name] = {\n                    case: undefined\n                };\n                break;\n            case \"enum\":\n                t[name] = 0;\n                break;\n            case \"map\":\n                t[name] = {};\n                break;\n            case \"scalar\":\n                t[name] = scalarZeroValue(member.T, member.L);\n                break;\n        }\n    }\n});\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        if (this.nanos < 0) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            } else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            } else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"seconds\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"nanos\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst MetricsBatch = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MetricsBatch\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"normalized_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"str_data\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"time_series\",\n            kind: \"message\",\n            T: TimeSeriesMetric,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"events\",\n            kind: \"message\",\n            T: EventMetric,\n            repeated: true\n        }\n    ]);\nconst TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TimeSeriesMetric\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"samples\",\n            kind: \"message\",\n            T: MetricSample,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"rid\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst MetricSample = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MetricSample\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"normalized_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"value\",\n            kind: \"scalar\",\n            T: 2\n        }\n    ]);\nconst EventMetric = /* @__PURE__ */ proto3.makeMessageType(\"livekit.EventMetric\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"start_timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 5,\n            name: \"end_timestamp_ms\",\n            kind: \"scalar\",\n            T: 3,\n            opt: true\n        },\n        {\n            no: 6,\n            name: \"normalized_start_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 7,\n            name: \"normalized_end_timestamp\",\n            kind: \"message\",\n            T: Timestamp,\n            opt: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"rid\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst AudioCodec = /* @__PURE__ */ proto3.makeEnum(\"livekit.AudioCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_AC\"\n    },\n    {\n        no: 1,\n        name: \"OPUS\"\n    },\n    {\n        no: 2,\n        name: \"AAC\"\n    },\n    {\n        no: 3,\n        name: \"AC_MP3\"\n    }\n]);\nconst VideoCodec = /* @__PURE__ */ proto3.makeEnum(\"livekit.VideoCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_VC\"\n    },\n    {\n        no: 1,\n        name: \"H264_BASELINE\"\n    },\n    {\n        no: 2,\n        name: \"H264_MAIN\"\n    },\n    {\n        no: 3,\n        name: \"H264_HIGH\"\n    },\n    {\n        no: 4,\n        name: \"VP8\"\n    }\n]);\nconst ImageCodec = /* @__PURE__ */ proto3.makeEnum(\"livekit.ImageCodec\", [\n    {\n        no: 0,\n        name: \"IC_DEFAULT\"\n    },\n    {\n        no: 1,\n        name: \"IC_JPEG\"\n    }\n]);\nconst BackupCodecPolicy$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.BackupCodecPolicy\", [\n    {\n        no: 0,\n        name: \"PREFER_REGRESSION\"\n    },\n    {\n        no: 1,\n        name: \"SIMULCAST\"\n    },\n    {\n        no: 2,\n        name: \"REGRESSION\"\n    }\n]);\nconst TrackType = /* @__PURE__ */ proto3.makeEnum(\"livekit.TrackType\", [\n    {\n        no: 0,\n        name: \"AUDIO\"\n    },\n    {\n        no: 1,\n        name: \"VIDEO\"\n    },\n    {\n        no: 2,\n        name: \"DATA\"\n    }\n]);\nconst TrackSource = /* @__PURE__ */ proto3.makeEnum(\"livekit.TrackSource\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"CAMERA\"\n    },\n    {\n        no: 2,\n        name: \"MICROPHONE\"\n    },\n    {\n        no: 3,\n        name: \"SCREEN_SHARE\"\n    },\n    {\n        no: 4,\n        name: \"SCREEN_SHARE_AUDIO\"\n    }\n]);\nconst VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.VideoQuality\", [\n    {\n        no: 0,\n        name: \"LOW\"\n    },\n    {\n        no: 1,\n        name: \"MEDIUM\"\n    },\n    {\n        no: 2,\n        name: \"HIGH\"\n    },\n    {\n        no: 3,\n        name: \"OFF\"\n    }\n]);\nconst ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.ConnectionQuality\", [\n    {\n        no: 0,\n        name: \"POOR\"\n    },\n    {\n        no: 1,\n        name: \"GOOD\"\n    },\n    {\n        no: 2,\n        name: \"EXCELLENT\"\n    },\n    {\n        no: 3,\n        name: \"LOST\"\n    }\n]);\nconst ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum(\"livekit.ClientConfigSetting\", [\n    {\n        no: 0,\n        name: \"UNSET\"\n    },\n    {\n        no: 1,\n        name: \"DISABLED\"\n    },\n    {\n        no: 2,\n        name: \"ENABLED\"\n    }\n]);\nconst DisconnectReason = /* @__PURE__ */ proto3.makeEnum(\"livekit.DisconnectReason\", [\n    {\n        no: 0,\n        name: \"UNKNOWN_REASON\"\n    },\n    {\n        no: 1,\n        name: \"CLIENT_INITIATED\"\n    },\n    {\n        no: 2,\n        name: \"DUPLICATE_IDENTITY\"\n    },\n    {\n        no: 3,\n        name: \"SERVER_SHUTDOWN\"\n    },\n    {\n        no: 4,\n        name: \"PARTICIPANT_REMOVED\"\n    },\n    {\n        no: 5,\n        name: \"ROOM_DELETED\"\n    },\n    {\n        no: 6,\n        name: \"STATE_MISMATCH\"\n    },\n    {\n        no: 7,\n        name: \"JOIN_FAILURE\"\n    },\n    {\n        no: 8,\n        name: \"MIGRATION\"\n    },\n    {\n        no: 9,\n        name: \"SIGNAL_CLOSE\"\n    },\n    {\n        no: 10,\n        name: \"ROOM_CLOSED\"\n    },\n    {\n        no: 11,\n        name: \"USER_UNAVAILABLE\"\n    },\n    {\n        no: 12,\n        name: \"USER_REJECTED\"\n    },\n    {\n        no: 13,\n        name: \"SIP_TRUNK_FAILURE\"\n    },\n    {\n        no: 14,\n        name: \"CONNECTION_TIMEOUT\"\n    },\n    {\n        no: 15,\n        name: \"MEDIA_FAILURE\"\n    }\n]);\nconst ReconnectReason = /* @__PURE__ */ proto3.makeEnum(\"livekit.ReconnectReason\", [\n    {\n        no: 0,\n        name: \"RR_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"RR_SIGNAL_DISCONNECTED\"\n    },\n    {\n        no: 2,\n        name: \"RR_PUBLISHER_FAILED\"\n    },\n    {\n        no: 3,\n        name: \"RR_SUBSCRIBER_FAILED\"\n    },\n    {\n        no: 4,\n        name: \"RR_SWITCH_CANDIDATE\"\n    }\n]);\nconst SubscriptionError = /* @__PURE__ */ proto3.makeEnum(\"livekit.SubscriptionError\", [\n    {\n        no: 0,\n        name: \"SE_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"SE_CODEC_UNSUPPORTED\"\n    },\n    {\n        no: 2,\n        name: \"SE_TRACK_NOTFOUND\"\n    }\n]);\nconst AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum(\"livekit.AudioTrackFeature\", [\n    {\n        no: 0,\n        name: \"TF_STEREO\"\n    },\n    {\n        no: 1,\n        name: \"TF_NO_DTX\"\n    },\n    {\n        no: 2,\n        name: \"TF_AUTO_GAIN_CONTROL\"\n    },\n    {\n        no: 3,\n        name: \"TF_ECHO_CANCELLATION\"\n    },\n    {\n        no: 4,\n        name: \"TF_NOISE_SUPPRESSION\"\n    },\n    {\n        no: 5,\n        name: \"TF_ENHANCED_NOISE_CANCELLATION\"\n    },\n    {\n        no: 6,\n        name: \"TF_PRECONNECT_BUFFER\"\n    }\n]);\nconst Room$1 = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Room\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 14,\n            name: \"departure_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"creation_time\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 15,\n            name: \"creation_time_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 6,\n            name: \"turn_password\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"enabled_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"num_participants\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 11,\n            name: \"num_publishers\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 10,\n            name: \"active_recording\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 13,\n            name: \"version\",\n            kind: \"message\",\n            T: TimedVersion\n        }\n    ]);\nconst Codec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Codec\", ()=>[\n        {\n            no: 1,\n            name: \"mime\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"fmtp_line\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantPermission\", ()=>[\n        {\n            no: 1,\n            name: \"can_subscribe\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"can_publish\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"can_publish_data\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 9,\n            name: \"can_publish_sources\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"hidden\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"recorder\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 10,\n            name: \"can_update_metadata\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 11,\n            name: \"agent\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 12,\n            name: \"can_subscribe_metrics\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: \"tracks\",\n            kind: \"message\",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"joined_at\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 17,\n            name: \"joined_at_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 9,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 11,\n            name: \"permission\",\n            kind: \"message\",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 13,\n            name: \"is_publisher\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 14,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_Kind)\n        },\n        {\n            no: 15,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 16,\n            name: \"disconnect_reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        },\n        {\n            no: 18,\n            name: \"kind_details\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_KindDetail),\n            repeated: true\n        }\n    ]);\nconst ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.State\", [\n    {\n        no: 0,\n        name: \"JOINING\"\n    },\n    {\n        no: 1,\n        name: \"JOINED\"\n    },\n    {\n        no: 2,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 3,\n        name: \"DISCONNECTED\"\n    }\n]);\nconst ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.Kind\", [\n    {\n        no: 0,\n        name: \"STANDARD\"\n    },\n    {\n        no: 1,\n        name: \"INGRESS\"\n    },\n    {\n        no: 2,\n        name: \"EGRESS\"\n    },\n    {\n        no: 3,\n        name: \"SIP\"\n    },\n    {\n        no: 4,\n        name: \"AGENT\"\n    },\n    {\n        no: 7,\n        name: \"CONNECTOR\"\n    }\n]);\nconst ParticipantInfo_KindDetail = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.KindDetail\", [\n    {\n        no: 0,\n        name: \"CLOUD_AGENT\"\n    },\n    {\n        no: 1,\n        name: \"FORWARDED\"\n    }\n]);\nconst Encryption_Type = /* @__PURE__ */ proto3.makeEnum(\"livekit.Encryption.Type\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GCM\"\n    },\n    {\n        no: 2,\n        name: \"CUSTOM\"\n    }\n]);\nconst SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulcastCodecInfo\", ()=>[\n        {\n            no: 1,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"video_layer_mode\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoLayer_Mode)\n        },\n        {\n            no: 6,\n            name: \"sdp_cid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst TrackInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 7,\n            name: \"simulcast\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 9,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 12,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 13,\n            name: \"codecs\",\n            kind: \"message\",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 15,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 16,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 18,\n            name: \"version\",\n            kind: \"message\",\n            T: TimedVersion\n        },\n        {\n            no: 19,\n            name: \"audio_features\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioTrackFeature),\n            repeated: true\n        },\n        {\n            no: 20,\n            name: \"backup_codec_policy\",\n            kind: \"enum\",\n            T: proto3.getEnumType(BackupCodecPolicy$1)\n        }\n    ]);\nconst VideoLayer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.VideoLayer\", ()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"ssrc\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"spatial_layer\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 7,\n            name: \"rid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst VideoLayer_Mode = /* @__PURE__ */ proto3.makeEnum(\"livekit.VideoLayer.Mode\", [\n    {\n        no: 0,\n        name: \"MODE_UNUSED\"\n    },\n    {\n        no: 1,\n        name: \"ONE_SPATIAL_LAYER_PER_STREAM\"\n    },\n    {\n        no: 2,\n        name: \"MULTIPLE_SPATIAL_LAYERS_PER_STREAM\"\n    },\n    {\n        no: 3,\n        name: \"ONE_SPATIAL_LAYER_PER_STREAM_INCOMPLETE_RTCP_SR\"\n    }\n]);\nconst DataPacket = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataPacket\", ()=>[\n        {\n            no: 1,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"speaker\",\n            kind: \"message\",\n            T: ActiveSpeakerUpdate,\n            oneof: \"value\"\n        },\n        {\n            no: 6,\n            name: \"sip_dtmf\",\n            kind: \"message\",\n            T: SipDTMF,\n            oneof: \"value\"\n        },\n        {\n            no: 7,\n            name: \"transcription\",\n            kind: \"message\",\n            T: Transcription,\n            oneof: \"value\"\n        },\n        {\n            no: 8,\n            name: \"metrics\",\n            kind: \"message\",\n            T: MetricsBatch,\n            oneof: \"value\"\n        },\n        {\n            no: 9,\n            name: \"chat_message\",\n            kind: \"message\",\n            T: ChatMessage,\n            oneof: \"value\"\n        },\n        {\n            no: 10,\n            name: \"rpc_request\",\n            kind: \"message\",\n            T: RpcRequest,\n            oneof: \"value\"\n        },\n        {\n            no: 11,\n            name: \"rpc_ack\",\n            kind: \"message\",\n            T: RpcAck,\n            oneof: \"value\"\n        },\n        {\n            no: 12,\n            name: \"rpc_response\",\n            kind: \"message\",\n            T: RpcResponse,\n            oneof: \"value\"\n        },\n        {\n            no: 13,\n            name: \"stream_header\",\n            kind: \"message\",\n            T: DataStream_Header,\n            oneof: \"value\"\n        },\n        {\n            no: 14,\n            name: \"stream_chunk\",\n            kind: \"message\",\n            T: DataStream_Chunk,\n            oneof: \"value\"\n        },\n        {\n            no: 15,\n            name: \"stream_trailer\",\n            kind: \"message\",\n            T: DataStream_Trailer,\n            oneof: \"value\"\n        },\n        {\n            no: 18,\n            name: \"encrypted_packet\",\n            kind: \"message\",\n            T: EncryptedPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 16,\n            name: \"sequence\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 17,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum(\"livekit.DataPacket.Kind\", [\n    {\n        no: 0,\n        name: \"RELIABLE\"\n    },\n    {\n        no: 1,\n        name: \"LOSSY\"\n    }\n]);\nconst EncryptedPacket = /* @__PURE__ */ proto3.makeMessageType(\"livekit.EncryptedPacket\", ()=>[\n        {\n            no: 1,\n            name: \"encryption_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 2,\n            name: \"iv\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 3,\n            name: \"key_index\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"encrypted_value\",\n            kind: \"scalar\",\n            T: 12\n        }\n    ]);\nconst EncryptedPacketPayload = /* @__PURE__ */ proto3.makeMessageType(\"livekit.EncryptedPacketPayload\", ()=>[\n        {\n            no: 1,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"chat_message\",\n            kind: \"message\",\n            T: ChatMessage,\n            oneof: \"value\"\n        },\n        {\n            no: 4,\n            name: \"rpc_request\",\n            kind: \"message\",\n            T: RpcRequest,\n            oneof: \"value\"\n        },\n        {\n            no: 5,\n            name: \"rpc_ack\",\n            kind: \"message\",\n            T: RpcAck,\n            oneof: \"value\"\n        },\n        {\n            no: 6,\n            name: \"rpc_response\",\n            kind: \"message\",\n            T: RpcResponse,\n            oneof: \"value\"\n        },\n        {\n            no: 7,\n            name: \"stream_header\",\n            kind: \"message\",\n            T: DataStream_Header,\n            oneof: \"value\"\n        },\n        {\n            no: 8,\n            name: \"stream_chunk\",\n            kind: \"message\",\n            T: DataStream_Chunk,\n            oneof: \"value\"\n        },\n        {\n            no: 9,\n            name: \"stream_trailer\",\n            kind: \"message\",\n            T: DataStream_Trailer,\n            oneof: \"value\"\n        }\n    ]);\nconst ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ActiveSpeakerUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\nconst SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SpeakerInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"level\",\n            kind: \"scalar\",\n            T: 2\n        },\n        {\n            no: 3,\n            name: \"active\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst UserPacket = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UserPacket\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 3,\n            name: \"destination_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 8,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 9,\n            name: \"start_time\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 10,\n            name: \"end_time\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 11,\n            name: \"nonce\",\n            kind: \"scalar\",\n            T: 12\n        }\n    ]);\nconst SipDTMF = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SipDTMF\", ()=>[\n        {\n            no: 3,\n            name: \"code\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"digit\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst Transcription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Transcription\", ()=>[\n        {\n            no: 2,\n            name: \"transcribed_participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"track_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"segments\",\n            kind: \"message\",\n            T: TranscriptionSegment,\n            repeated: true\n        }\n    ]);\nconst TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TranscriptionSegment\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"text\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"start_time\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 4,\n            name: \"end_time\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 5,\n            name: \"final\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 6,\n            name: \"language\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ChatMessage = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ChatMessage\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 3,\n            name: \"edit_timestamp\",\n            kind: \"scalar\",\n            T: 3,\n            opt: true\n        },\n        {\n            no: 4,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"deleted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 6,\n            name: \"generated\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst RpcRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcRequest\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"method\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"response_timeout_ms\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst RpcAck = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcAck\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst RpcResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcResponse\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 9,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"error\",\n            kind: \"message\",\n            T: RpcError$1,\n            oneof: \"value\"\n        }\n    ]);\nconst RpcError$1 = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcError\", ()=>[\n        {\n            no: 1,\n            name: \"code\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"data\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantTracks\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        }\n    ]);\nconst ServerInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ServerInfo\", ()=>[\n        {\n            no: 1,\n            name: \"edition\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"node_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"debug_info\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"agent_protocol\",\n            kind: \"scalar\",\n            T: 5\n        }\n    ]);\nconst ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum(\"livekit.ServerInfo.Edition\", [\n    {\n        no: 0,\n        name: \"Standard\"\n    },\n    {\n        no: 1,\n        name: \"Cloud\"\n    }\n]);\nconst ClientInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ClientInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sdk\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"os\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"os_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"device_model\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"browser\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 8,\n            name: \"browser_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"address\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"network\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 11,\n            name: \"other_sdks\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum(\"livekit.ClientInfo.SDK\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"JS\"\n    },\n    {\n        no: 2,\n        name: \"SWIFT\"\n    },\n    {\n        no: 3,\n        name: \"ANDROID\"\n    },\n    {\n        no: 4,\n        name: \"FLUTTER\"\n    },\n    {\n        no: 5,\n        name: \"GO\"\n    },\n    {\n        no: 6,\n        name: \"UNITY\"\n    },\n    {\n        no: 7,\n        name: \"REACT_NATIVE\"\n    },\n    {\n        no: 8,\n        name: \"RUST\"\n    },\n    {\n        no: 9,\n        name: \"PYTHON\"\n    },\n    {\n        no: 10,\n        name: \"CPP\"\n    },\n    {\n        no: 11,\n        name: \"UNITY_WEB\"\n    },\n    {\n        no: 12,\n        name: \"NODE\"\n    },\n    {\n        no: 13,\n        name: \"UNREAL\"\n    },\n    {\n        no: 14,\n        name: \"ESP32\"\n    }\n]);\nconst ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ClientConfiguration\", ()=>[\n        {\n            no: 1,\n            name: \"video\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: \"screen\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: \"resume_connection\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: \"disabled_codecs\",\n            kind: \"message\",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: \"force_relay\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\nconst VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType(\"livekit.VideoConfiguration\", ()=>[\n        {\n            no: 1,\n            name: \"hardware_encoder\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\nconst DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DisabledCodecs\", ()=>[\n        {\n            no: 1,\n            name: \"codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"publish\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        }\n    ]);\nconst TimedVersion = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TimedVersion\", ()=>[\n        {\n            no: 1,\n            name: \"unix_micro\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"ticks\",\n            kind: \"scalar\",\n            T: 5\n        }\n    ]);\nconst DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum(\"livekit.DataStream.OperationType\", [\n    {\n        no: 0,\n        name: \"CREATE\"\n    },\n    {\n        no: 1,\n        name: \"UPDATE\"\n    },\n    {\n        no: 2,\n        name: \"DELETE\"\n    },\n    {\n        no: 3,\n        name: \"REACTION\"\n    }\n]);\nconst DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.TextHeader\", ()=>[\n        {\n            no: 1,\n            name: \"operation_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataStream_OperationType)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 3,\n            name: \"reply_to_stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"attached_stream_ids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"generated\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ], {\n    localName: \"DataStream_TextHeader\"\n});\nconst DataStream_ByteHeader = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.ByteHeader\", ()=>[\n        {\n            no: 1,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ], {\n    localName: \"DataStream_ByteHeader\"\n});\nconst DataStream_Header = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Header\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 3,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"total_length\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 7,\n            name: \"encryption_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 8,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 9,\n            name: \"text_header\",\n            kind: \"message\",\n            T: DataStream_TextHeader,\n            oneof: \"content_header\"\n        },\n        {\n            no: 10,\n            name: \"byte_header\",\n            kind: \"message\",\n            T: DataStream_ByteHeader,\n            oneof: \"content_header\"\n        }\n    ], {\n    localName: \"DataStream_Header\"\n});\nconst DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Chunk\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"chunk_index\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 3,\n            name: \"content\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 4,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 5,\n            name: \"iv\",\n            kind: \"scalar\",\n            T: 12,\n            opt: true\n        }\n    ], {\n    localName: \"DataStream_Chunk\"\n});\nconst DataStream_Trailer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Trailer\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        }\n    ], {\n    localName: \"DataStream_Trailer\"\n});\nconst FilterParams = /* @__PURE__ */ proto3.makeMessageType(\"livekit.FilterParams\", ()=>[\n        {\n            no: 1,\n            name: \"include_events\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"exclude_events\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        }\n    ]);\nconst WebhookConfig = /* @__PURE__ */ proto3.makeMessageType(\"livekit.WebhookConfig\", ()=>[\n        {\n            no: 1,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"signing_key\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"filter_params\",\n            kind: \"message\",\n            T: FilterParams\n        }\n    ]);\nconst SubscribedAudioCodec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedAudioCodec\", ()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst RoomAgentDispatch = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomAgentDispatch\", ()=>[\n        {\n            no: 1,\n            name: \"agent_name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst EncodedFileType = /* @__PURE__ */ proto3.makeEnum(\"livekit.EncodedFileType\", [\n    {\n        no: 0,\n        name: \"DEFAULT_FILETYPE\"\n    },\n    {\n        no: 1,\n        name: \"MP4\"\n    },\n    {\n        no: 2,\n        name: \"OGG\"\n    },\n    {\n        no: 3,\n        name: \"MP3\"\n    }\n]);\nconst SegmentedFileProtocol = /* @__PURE__ */ proto3.makeEnum(\"livekit.SegmentedFileProtocol\", [\n    {\n        no: 0,\n        name: \"DEFAULT_SEGMENTED_FILE_PROTOCOL\"\n    },\n    {\n        no: 1,\n        name: \"HLS_PROTOCOL\"\n    }\n]);\nconst SegmentedFileSuffix = /* @__PURE__ */ proto3.makeEnum(\"livekit.SegmentedFileSuffix\", [\n    {\n        no: 0,\n        name: \"INDEX\"\n    },\n    {\n        no: 1,\n        name: \"TIMESTAMP\"\n    }\n]);\nconst ImageFileSuffix = /* @__PURE__ */ proto3.makeEnum(\"livekit.ImageFileSuffix\", [\n    {\n        no: 0,\n        name: \"IMAGE_SUFFIX_INDEX\"\n    },\n    {\n        no: 1,\n        name: \"IMAGE_SUFFIX_TIMESTAMP\"\n    },\n    {\n        no: 2,\n        name: \"IMAGE_SUFFIX_NONE_OVERWRITE\"\n    }\n]);\nconst StreamProtocol = /* @__PURE__ */ proto3.makeEnum(\"livekit.StreamProtocol\", [\n    {\n        no: 0,\n        name: \"DEFAULT_PROTOCOL\"\n    },\n    {\n        no: 1,\n        name: \"RTMP\"\n    },\n    {\n        no: 2,\n        name: \"SRT\"\n    }\n]);\nconst AudioMixing = /* @__PURE__ */ proto3.makeEnum(\"livekit.AudioMixing\", [\n    {\n        no: 0,\n        name: \"DEFAULT_MIXING\"\n    },\n    {\n        no: 1,\n        name: \"DUAL_CHANNEL_AGENT\"\n    },\n    {\n        no: 2,\n        name: \"DUAL_CHANNEL_ALTERNATE\"\n    }\n]);\nconst EncodingOptionsPreset = /* @__PURE__ */ proto3.makeEnum(\"livekit.EncodingOptionsPreset\", [\n    {\n        no: 0,\n        name: \"H264_720P_30\"\n    },\n    {\n        no: 1,\n        name: \"H264_720P_60\"\n    },\n    {\n        no: 2,\n        name: \"H264_1080P_30\"\n    },\n    {\n        no: 3,\n        name: \"H264_1080P_60\"\n    },\n    {\n        no: 4,\n        name: \"PORTRAIT_H264_720P_30\"\n    },\n    {\n        no: 5,\n        name: \"PORTRAIT_H264_720P_60\"\n    },\n    {\n        no: 6,\n        name: \"PORTRAIT_H264_1080P_30\"\n    },\n    {\n        no: 7,\n        name: \"PORTRAIT_H264_1080P_60\"\n    }\n]);\nconst RoomCompositeEgressRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomCompositeEgressRequest\", ()=>[\n        {\n            no: 1,\n            name: \"room_name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"layout\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"audio_only\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 15,\n            name: \"audio_mixing\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioMixing)\n        },\n        {\n            no: 4,\n            name: \"video_only\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 5,\n            name: \"custom_base_url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"file\",\n            kind: \"message\",\n            T: EncodedFileOutput,\n            oneof: \"output\"\n        },\n        {\n            no: 7,\n            name: \"stream\",\n            kind: \"message\",\n            T: StreamOutput,\n            oneof: \"output\"\n        },\n        {\n            no: 10,\n            name: \"segments\",\n            kind: \"message\",\n            T: SegmentedFileOutput,\n            oneof: \"output\"\n        },\n        {\n            no: 8,\n            name: \"preset\",\n            kind: \"enum\",\n            T: proto3.getEnumType(EncodingOptionsPreset),\n            oneof: \"options\"\n        },\n        {\n            no: 9,\n            name: \"advanced\",\n            kind: \"message\",\n            T: EncodingOptions,\n            oneof: \"options\"\n        },\n        {\n            no: 11,\n            name: \"file_outputs\",\n            kind: \"message\",\n            T: EncodedFileOutput,\n            repeated: true\n        },\n        {\n            no: 12,\n            name: \"stream_outputs\",\n            kind: \"message\",\n            T: StreamOutput,\n            repeated: true\n        },\n        {\n            no: 13,\n            name: \"segment_outputs\",\n            kind: \"message\",\n            T: SegmentedFileOutput,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"image_outputs\",\n            kind: \"message\",\n            T: ImageOutput,\n            repeated: true\n        },\n        {\n            no: 16,\n            name: \"webhooks\",\n            kind: \"message\",\n            T: WebhookConfig,\n            repeated: true\n        }\n    ]);\nconst EncodedFileOutput = /* @__PURE__ */ proto3.makeMessageType(\"livekit.EncodedFileOutput\", ()=>[\n        {\n            no: 1,\n            name: \"file_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(EncodedFileType)\n        },\n        {\n            no: 2,\n            name: \"filepath\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"disable_manifest\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"s3\",\n            kind: \"message\",\n            T: S3Upload,\n            oneof: \"output\"\n        },\n        {\n            no: 4,\n            name: \"gcp\",\n            kind: \"message\",\n            T: GCPUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 5,\n            name: \"azure\",\n            kind: \"message\",\n            T: AzureBlobUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 7,\n            name: \"aliOSS\",\n            kind: \"message\",\n            T: AliOSSUpload,\n            oneof: \"output\"\n        }\n    ]);\nconst SegmentedFileOutput = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SegmentedFileOutput\", ()=>[\n        {\n            no: 1,\n            name: \"protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SegmentedFileProtocol)\n        },\n        {\n            no: 2,\n            name: \"filename_prefix\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"playlist_name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 11,\n            name: \"live_playlist_name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"segment_duration\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 10,\n            name: \"filename_suffix\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SegmentedFileSuffix)\n        },\n        {\n            no: 8,\n            name: \"disable_manifest\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 5,\n            name: \"s3\",\n            kind: \"message\",\n            T: S3Upload,\n            oneof: \"output\"\n        },\n        {\n            no: 6,\n            name: \"gcp\",\n            kind: \"message\",\n            T: GCPUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 7,\n            name: \"azure\",\n            kind: \"message\",\n            T: AzureBlobUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 9,\n            name: \"aliOSS\",\n            kind: \"message\",\n            T: AliOSSUpload,\n            oneof: \"output\"\n        }\n    ]);\nconst ImageOutput = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ImageOutput\", ()=>[\n        {\n            no: 1,\n            name: \"capture_interval\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"filename_prefix\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"filename_suffix\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ImageFileSuffix)\n        },\n        {\n            no: 6,\n            name: \"image_codec\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ImageCodec)\n        },\n        {\n            no: 7,\n            name: \"disable_manifest\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"s3\",\n            kind: \"message\",\n            T: S3Upload,\n            oneof: \"output\"\n        },\n        {\n            no: 9,\n            name: \"gcp\",\n            kind: \"message\",\n            T: GCPUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 10,\n            name: \"azure\",\n            kind: \"message\",\n            T: AzureBlobUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 11,\n            name: \"aliOSS\",\n            kind: \"message\",\n            T: AliOSSUpload,\n            oneof: \"output\"\n        }\n    ]);\nconst S3Upload = /* @__PURE__ */ proto3.makeMessageType(\"livekit.S3Upload\", ()=>[\n        {\n            no: 1,\n            name: \"access_key\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"secret\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 11,\n            name: \"session_token\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 12,\n            name: \"assume_role_arn\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 13,\n            name: \"assume_role_external_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"endpoint\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"bucket\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"force_path_style\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 7,\n            name: \"metadata\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 8,\n            name: \"tagging\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"content_disposition\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"proxy\",\n            kind: \"message\",\n            T: ProxyConfig\n        }\n    ]);\nconst GCPUpload = /* @__PURE__ */ proto3.makeMessageType(\"livekit.GCPUpload\", ()=>[\n        {\n            no: 1,\n            name: \"credentials\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"bucket\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"proxy\",\n            kind: \"message\",\n            T: ProxyConfig\n        }\n    ]);\nconst AzureBlobUpload = /* @__PURE__ */ proto3.makeMessageType(\"livekit.AzureBlobUpload\", ()=>[\n        {\n            no: 1,\n            name: \"account_name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"account_key\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"container_name\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst AliOSSUpload = /* @__PURE__ */ proto3.makeMessageType(\"livekit.AliOSSUpload\", ()=>[\n        {\n            no: 1,\n            name: \"access_key\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"secret\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"endpoint\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"bucket\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ProxyConfig = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ProxyConfig\", ()=>[\n        {\n            no: 1,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"password\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst StreamOutput = /* @__PURE__ */ proto3.makeMessageType(\"livekit.StreamOutput\", ()=>[\n        {\n            no: 1,\n            name: \"protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamProtocol)\n        },\n        {\n            no: 2,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        }\n    ]);\nconst EncodingOptions = /* @__PURE__ */ proto3.makeMessageType(\"livekit.EncodingOptions\", ()=>[\n        {\n            no: 1,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 2,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 3,\n            name: \"depth\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"framerate\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 5,\n            name: \"audio_codec\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioCodec)\n        },\n        {\n            no: 6,\n            name: \"audio_bitrate\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 11,\n            name: \"audio_quality\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 7,\n            name: \"audio_frequency\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 8,\n            name: \"video_codec\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoCodec)\n        },\n        {\n            no: 9,\n            name: \"video_bitrate\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 12,\n            name: \"video_quality\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 10,\n            name: \"key_frame_interval\",\n            kind: \"scalar\",\n            T: 1\n        }\n    ]);\nconst AutoParticipantEgress = /* @__PURE__ */ proto3.makeMessageType(\"livekit.AutoParticipantEgress\", ()=>[\n        {\n            no: 1,\n            name: \"preset\",\n            kind: \"enum\",\n            T: proto3.getEnumType(EncodingOptionsPreset),\n            oneof: \"options\"\n        },\n        {\n            no: 2,\n            name: \"advanced\",\n            kind: \"message\",\n            T: EncodingOptions,\n            oneof: \"options\"\n        },\n        {\n            no: 3,\n            name: \"file_outputs\",\n            kind: \"message\",\n            T: EncodedFileOutput,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"segment_outputs\",\n            kind: \"message\",\n            T: SegmentedFileOutput,\n            repeated: true\n        }\n    ]);\nconst AutoTrackEgress = /* @__PURE__ */ proto3.makeMessageType(\"livekit.AutoTrackEgress\", ()=>[\n        {\n            no: 1,\n            name: \"filepath\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"disable_manifest\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"s3\",\n            kind: \"message\",\n            T: S3Upload,\n            oneof: \"output\"\n        },\n        {\n            no: 3,\n            name: \"gcp\",\n            kind: \"message\",\n            T: GCPUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 4,\n            name: \"azure\",\n            kind: \"message\",\n            T: AzureBlobUpload,\n            oneof: \"output\"\n        },\n        {\n            no: 6,\n            name: \"aliOSS\",\n            kind: \"message\",\n            T: AliOSSUpload,\n            oneof: \"output\"\n        }\n    ]);\nconst RoomEgress = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomEgress\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: RoomCompositeEgressRequest\n        },\n        {\n            no: 3,\n            name: \"participant\",\n            kind: \"message\",\n            T: AutoParticipantEgress\n        },\n        {\n            no: 2,\n            name: \"tracks\",\n            kind: \"message\",\n            T: AutoTrackEgress\n        }\n    ]);\nconst RoomConfiguration = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomConfiguration\", ()=>[\n        {\n            no: 1,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"departure_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 11,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"egress\",\n            kind: \"message\",\n            T: RoomEgress\n        },\n        {\n            no: 7,\n            name: \"min_playout_delay\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 8,\n            name: \"max_playout_delay\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 9,\n            name: \"sync_streams\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 10,\n            name: \"agents\",\n            kind: \"message\",\n            T: RoomAgentDispatch,\n            repeated: true\n        }\n    ]);\nconst SignalTarget = /* @__PURE__ */ proto3.makeEnum(\"livekit.SignalTarget\", [\n    {\n        no: 0,\n        name: \"PUBLISHER\"\n    },\n    {\n        no: 1,\n        name: \"SUBSCRIBER\"\n    }\n]);\nconst StreamState = /* @__PURE__ */ proto3.makeEnum(\"livekit.StreamState\", [\n    {\n        no: 0,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 1,\n        name: \"PAUSED\"\n    }\n]);\nconst CandidateProtocol = /* @__PURE__ */ proto3.makeEnum(\"livekit.CandidateProtocol\", [\n    {\n        no: 0,\n        name: \"UDP\"\n    },\n    {\n        no: 1,\n        name: \"TCP\"\n    },\n    {\n        no: 2,\n        name: \"TLS\"\n    }\n]);\nconst SignalRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SignalRequest\", ()=>[\n        {\n            no: 1,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription,\n            oneof: \"message\"\n        },\n        {\n            no: 7,\n            name: \"track_setting\",\n            kind: \"message\",\n            T: UpdateTrackSettings,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"update_layers\",\n            kind: \"message\",\n            T: UpdateVideoLayers,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"subscription_permission\",\n            kind: \"message\",\n            T: SubscriptionPermission,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"simulate\",\n            kind: \"message\",\n            T: SimulateScenario,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"ping\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"ping_req\",\n            kind: \"message\",\n            T: Ping,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"update_audio_track\",\n            kind: \"message\",\n            T: UpdateLocalAudioTrack,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"update_video_track\",\n            kind: \"message\",\n            T: UpdateLocalVideoTrack,\n            oneof: \"message\"\n        }\n    ]);\nconst SignalResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SignalResponse\", ()=>[\n        {\n            no: 1,\n            name: \"join\",\n            kind: \"message\",\n            T: JoinResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"update\",\n            kind: \"message\",\n            T: ParticipantUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"track_published\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 9,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"speakers_changed\",\n            kind: \"message\",\n            T: SpeakersChanged,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"room_update\",\n            kind: \"message\",\n            T: RoomUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"connection_quality\",\n            kind: \"message\",\n            T: ConnectionQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"stream_state_update\",\n            kind: \"message\",\n            T: StreamStateUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"subscribed_quality_update\",\n            kind: \"message\",\n            T: SubscribedQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"subscription_permission_update\",\n            kind: \"message\",\n            T: SubscriptionPermissionUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"refresh_token\",\n            kind: \"scalar\",\n            T: 9,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"track_unpublished\",\n            kind: \"message\",\n            T: TrackUnpublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"pong\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"message\"\n        },\n        {\n            no: 19,\n            name: \"reconnect\",\n            kind: \"message\",\n            T: ReconnectResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 20,\n            name: \"pong_resp\",\n            kind: \"message\",\n            T: Pong,\n            oneof: \"message\"\n        },\n        {\n            no: 21,\n            name: \"subscription_response\",\n            kind: \"message\",\n            T: SubscriptionResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 22,\n            name: \"request_response\",\n            kind: \"message\",\n            T: RequestResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 23,\n            name: \"track_subscribed\",\n            kind: \"message\",\n            T: TrackSubscribed,\n            oneof: \"message\"\n        },\n        {\n            no: 24,\n            name: \"room_moved\",\n            kind: \"message\",\n            T: RoomMovedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 25,\n            name: \"media_sections_requirement\",\n            kind: \"message\",\n            T: MediaSectionsRequirement,\n            oneof: \"message\"\n        },\n        {\n            no: 26,\n            name: \"subscribed_audio_codec_update\",\n            kind: \"message\",\n            T: SubscribedAudioCodecUpdate,\n            oneof: \"message\"\n        }\n    ]);\nconst SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulcastCodec\", ()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"video_layer_mode\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoLayer_Mode)\n        }\n    ]);\nconst AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.AddTrackRequest\", ()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 7,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"simulcast_codecs\",\n            kind: \"message\",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 12,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 13,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 14,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 16,\n            name: \"backup_codec_policy\",\n            kind: \"enum\",\n            T: proto3.getEnumType(BackupCodecPolicy$1)\n        },\n        {\n            no: 17,\n            name: \"audio_features\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioTrackFeature),\n            repeated: true\n        }\n    ]);\nconst TrickleRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrickleRequest\", ()=>[\n        {\n            no: 1,\n            name: \"candidateInit\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        },\n        {\n            no: 3,\n            name: \"final\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MuteTrackRequest\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst JoinResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.JoinResponse\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"server_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"subscriber_primary\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 7,\n            name: \"alternative_url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 8,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: \"server_region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"ping_timeout\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 11,\n            name: \"ping_interval\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 12,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: \"sif_trailer\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 14,\n            name: \"enabled_publish_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 15,\n            name: \"fast_publish\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ReconnectResponse\", ()=>[\n        {\n            no: 1,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 3,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 4,\n            name: \"last_message_seq\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackPublishedResponse\", ()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track\",\n            kind: \"message\",\n            T: TrackInfo\n        }\n    ]);\nconst TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackUnpublishedResponse\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SessionDescription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SessionDescription\", ()=>[\n        {\n            no: 1,\n            name: \"type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"sdp\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"mid_to_track_id\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        }\n    ]);\nconst ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\nconst UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateSubscription\", ()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"subscribe\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"participant_tracks\",\n            kind: \"message\",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\nconst UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateTrackSettings\", ()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"disabled\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 4,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 7,\n            name: \"fps\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 8,\n            name: \"priority\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateLocalAudioTrack\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"features\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioTrackFeature),\n            repeated: true\n        }\n    ]);\nconst UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateLocalVideoTrack\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst LeaveRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.LeaveRequest\", ()=>[\n        {\n            no: 1,\n            name: \"can_reconnect\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        },\n        {\n            no: 3,\n            name: \"action\",\n            kind: \"enum\",\n            T: proto3.getEnumType(LeaveRequest_Action)\n        },\n        {\n            no: 4,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionSettings\n        }\n    ]);\nconst LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum(\"livekit.LeaveRequest.Action\", [\n    {\n        no: 0,\n        name: \"DISCONNECT\"\n    },\n    {\n        no: 1,\n        name: \"RESUME\"\n    },\n    {\n        no: 2,\n        name: \"RECONNECT\"\n    }\n]);\nconst UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateVideoLayers\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\nconst UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateParticipantMetadata\", ()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 4,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst ICEServer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ICEServer\", ()=>[\n        {\n            no: 1,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"credential\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SpeakersChanged\", ()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\nconst RoomUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        }\n    ]);\nconst ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ConnectionQualityInfo\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 2\n        }\n    ]);\nconst ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ConnectionQualityUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"updates\",\n            kind: \"message\",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\nconst StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.StreamStateInfo\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\nconst StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.StreamStateUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"stream_states\",\n            kind: \"message\",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\nconst SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedQuality\", ()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedCodec\", ()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\nconst SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedQualityUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"subscribed_qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"subscribed_codecs\",\n            kind: \"message\",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\nconst SubscribedAudioCodecUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedAudioCodecUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"subscribed_audio_codecs\",\n            kind: \"message\",\n            T: SubscribedAudioCodec,\n            repeated: true\n        }\n    ]);\nconst TrackPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackPermission\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"all_tracks\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionPermission\", ()=>[\n        {\n            no: 1,\n            name: \"all_participants\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"track_permissions\",\n            kind: \"message\",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\nconst SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionPermissionUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"allowed\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst RoomMovedResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomMovedResponse\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"token\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 4,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\nconst SyncState = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SyncState\", ()=>[\n        {\n            no: 1,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: \"publish_tracks\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"data_channels\",\n            kind: \"message\",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 6,\n            name: \"track_sids_disabled\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"datachannel_receive_states\",\n            kind: \"message\",\n            T: DataChannelReceiveState,\n            repeated: true\n        }\n    ]);\nconst DataChannelReceiveState = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataChannelReceiveState\", ()=>[\n        {\n            no: 1,\n            name: \"publisher_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"last_seq\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataChannelInfo\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\nconst SimulateScenario = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulateScenario\", ()=>[\n        {\n            no: 1,\n            name: \"speaker_update\",\n            kind: \"scalar\",\n            T: 5,\n            oneof: \"scenario\"\n        },\n        {\n            no: 2,\n            name: \"node_failure\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 3,\n            name: \"migration\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 4,\n            name: \"server_leave\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 5,\n            name: \"switch_candidate_protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: \"scenario\"\n        },\n        {\n            no: 6,\n            name: \"subscriber_bandwidth\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"scenario\"\n        },\n        {\n            no: 7,\n            name: \"disconnect_signal_on_resume\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 8,\n            name: \"disconnect_signal_on_resume_no_messages\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 9,\n            name: \"leave_request_full_reconnect\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        }\n    ]);\nconst Ping = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Ping\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"rtt\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst Pong = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Pong\", ()=>[\n        {\n            no: 1,\n            name: \"last_ping_timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst RegionSettings = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RegionSettings\", ()=>[\n        {\n            no: 1,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\nconst RegionInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RegionInfo\", ()=>[\n        {\n            no: 1,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"distance\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionResponse\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"err\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nconst RequestResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RequestResponse\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(RequestResponse_Reason)\n        },\n        {\n            no: 3,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"request\"\n        },\n        {\n            no: 5,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"request\"\n        },\n        {\n            no: 6,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"request\"\n        },\n        {\n            no: 7,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"request\"\n        },\n        {\n            no: 8,\n            name: \"update_audio_track\",\n            kind: \"message\",\n            T: UpdateLocalAudioTrack,\n            oneof: \"request\"\n        },\n        {\n            no: 9,\n            name: \"update_video_track\",\n            kind: \"message\",\n            T: UpdateLocalVideoTrack,\n            oneof: \"request\"\n        }\n    ]);\nconst RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum(\"livekit.RequestResponse.Reason\", [\n    {\n        no: 0,\n        name: \"OK\"\n    },\n    {\n        no: 1,\n        name: \"NOT_FOUND\"\n    },\n    {\n        no: 2,\n        name: \"NOT_ALLOWED\"\n    },\n    {\n        no: 3,\n        name: \"LIMIT_EXCEEDED\"\n    },\n    {\n        no: 4,\n        name: \"QUEUED\"\n    },\n    {\n        no: 5,\n        name: \"UNSUPPORTED_TYPE\"\n    },\n    {\n        no: 6,\n        name: \"UNCLASSIFIED_ERROR\"\n    }\n]);\nconst TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackSubscribed\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ConnectionSettings = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ConnectionSettings\", ()=>[\n        {\n            no: 1,\n            name: \"auto_subscribe\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"adaptive_stream\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"subscriber_allow_pause\",\n            kind: \"scalar\",\n            T: 8,\n            opt: true\n        },\n        {\n            no: 4,\n            name: \"disable_ice_lite\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst JoinRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.JoinRequest\", ()=>[\n        {\n            no: 1,\n            name: \"client_info\",\n            kind: \"message\",\n            T: ClientInfo\n        },\n        {\n            no: 2,\n            name: \"connection_settings\",\n            kind: \"message\",\n            T: ConnectionSettings\n        },\n        {\n            no: 3,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"participant_attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 5,\n            name: \"add_track_requests\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"publisher_offer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 7,\n            name: \"reconnect\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"reconnect_reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ReconnectReason)\n        },\n        {\n            no: 9,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState\n        }\n    ]);\nconst WrappedJoinRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.WrappedJoinRequest\", ()=>[\n        {\n            no: 1,\n            name: \"compression\",\n            kind: \"enum\",\n            T: proto3.getEnumType(WrappedJoinRequest_Compression)\n        },\n        {\n            no: 2,\n            name: \"join_request\",\n            kind: \"scalar\",\n            T: 12\n        }\n    ]);\nconst WrappedJoinRequest_Compression = /* @__PURE__ */ proto3.makeEnum(\"livekit.WrappedJoinRequest.Compression\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GZIP\"\n    }\n]);\nconst MediaSectionsRequirement = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MediaSectionsRequirement\", ()=>[\n        {\n            no: 1,\n            name: \"num_audios\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"num_videos\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst TokenSourceRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TokenSourceRequest\", ()=>[\n        {\n            no: 1,\n            name: \"room_name\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 2,\n            name: \"participant_name\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 3,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 4,\n            name: \"participant_metadata\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 5,\n            name: \"participant_attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 6,\n            name: \"room_config\",\n            kind: \"message\",\n            T: RoomConfiguration,\n            opt: true\n        }\n    ]);\nconst TokenSourceResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TokenSourceResponse\", ()=>[\n        {\n            no: 1,\n            name: \"server_url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"participant_token\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar loglevel$1 = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ var loglevel = loglevel$1.exports;\nvar hasRequiredLoglevel;\nfunction requireLoglevel() {\n    if (hasRequiredLoglevel) return loglevel$1.exports;\n    hasRequiredLoglevel = 1;\n    (function(module) {\n        (function(root, definition) {\n            if (module.exports) {\n                module.exports = definition();\n            } else {\n                root.log = definition();\n            }\n        })(loglevel, function() {\n            // Slightly dubious tricks to cut down minimized file size\n            var noop = function() {};\n            var undefinedType = \"undefined\";\n            var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n            var logMethods = [\n                \"trace\",\n                \"debug\",\n                \"info\",\n                \"warn\",\n                \"error\"\n            ];\n            var _loggersByName = {};\n            var defaultLogger = null;\n            // Cross-browser bind equivalent that works at least back to IE6\n            function bindMethod(obj, methodName) {\n                var method = obj[methodName];\n                if (typeof method.bind === \"function\") {\n                    return method.bind(obj);\n                } else {\n                    try {\n                        return Function.prototype.bind.call(method, obj);\n                    } catch (e) {\n                        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                        return function() {\n                            return Function.prototype.apply.apply(method, [\n                                obj,\n                                arguments\n                            ]);\n                        };\n                    }\n                }\n            }\n            // Trace() doesn't print the message in IE, so for that case we need to wrap it\n            function traceForIE() {\n                if (console.log) {\n                    if (console.log.apply) {\n                        console.log.apply(console, arguments);\n                    } else {\n                        // In old IE, native console methods themselves don't have apply().\n                        Function.prototype.apply.apply(console.log, [\n                            console,\n                            arguments\n                        ]);\n                    }\n                }\n                if (console.trace) console.trace();\n            }\n            // Build the best logging method possible for this env\n            // Wherever possible we want to bind, not wrap, to preserve stack traces\n            function realMethod(methodName) {\n                if (methodName === \"debug\") {\n                    methodName = \"log\";\n                }\n                if (typeof console === undefinedType) {\n                    return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n                } else if (methodName === \"trace\" && isIE) {\n                    return traceForIE;\n                } else if (console[methodName] !== undefined) {\n                    return bindMethod(console, methodName);\n                } else if (console.log !== undefined) {\n                    return bindMethod(console, \"log\");\n                } else {\n                    return noop;\n                }\n            }\n            // These private functions always need `this` to be set properly\n            function replaceLoggingMethods() {\n                /*jshint validthis:true */ var level = this.getLevel();\n                // Replace the actual methods.\n                for(var i = 0; i < logMethods.length; i++){\n                    var methodName = logMethods[i];\n                    this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n                }\n                // Define log.log as an alias for log.debug\n                this.log = this.debug;\n                // Return any important warnings.\n                if (typeof console === undefinedType && level < this.levels.SILENT) {\n                    return \"No console available for logging\";\n                }\n            }\n            // In old IE versions, the console isn't present until you first open it.\n            // We build realMethod() replacements here that regenerate logging methods\n            function enableLoggingWhenConsoleArrives(methodName) {\n                return function() {\n                    if (typeof console !== undefinedType) {\n                        replaceLoggingMethods.call(this);\n                        this[methodName].apply(this, arguments);\n                    }\n                };\n            }\n            // By default, we use closely bound real methods wherever possible, and\n            // otherwise we wait for a console to appear, and then try again.\n            function defaultMethodFactory(methodName, _level, _loggerName) {\n                /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n            }\n            function Logger(name, factory) {\n                // Private instance variables.\n                var self = this;\n                /**\n         * The level inherited from a parent logger (or a global default). We\n         * cache this here rather than delegating to the parent so that it stays\n         * in sync with the actual logging methods that we have installed (the\n         * parent could change levels but we might not have rebuilt the loggers\n         * in this child yet).\n         * @type {number}\n         */ var inheritedLevel;\n                /**\n         * The default level for this logger, if any. If set, this overrides\n         * `inheritedLevel`.\n         * @type {number|null}\n         */ var defaultLevel;\n                /**\n         * A user-specific level for this logger. If set, this overrides\n         * `defaultLevel`.\n         * @type {number|null}\n         */ var userLevel;\n                var storageKey = \"loglevel\";\n                if (typeof name === \"string\") {\n                    storageKey += \":\" + name;\n                } else if (typeof name === \"symbol\") {\n                    storageKey = undefined;\n                }\n                function persistLevelIfPossible(levelNum) {\n                    var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    // Use localStorage if available\n                    try {\n                        window.localStorage[storageKey] = levelName;\n                        return;\n                    } catch (ignore) {}\n                    // Use session cookie as fallback\n                    try {\n                        window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n                    } catch (ignore) {}\n                }\n                function getPersistedLevel() {\n                    var storedLevel;\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    try {\n                        storedLevel = window.localStorage[storageKey];\n                    } catch (ignore) {}\n                    // Fallback to cookies if local storage gives us nothing\n                    if (typeof storedLevel === undefinedType) {\n                        try {\n                            var cookie = window.document.cookie;\n                            var cookieName = encodeURIComponent(storageKey);\n                            var location = cookie.indexOf(cookieName + \"=\");\n                            if (location !== -1) {\n                                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n                            }\n                        } catch (ignore) {}\n                    }\n                    // If the stored level is not valid, treat it as if nothing was stored.\n                    if (self.levels[storedLevel] === undefined) {\n                        storedLevel = undefined;\n                    }\n                    return storedLevel;\n                }\n                function clearPersistedLevel() {\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    // Use localStorage if available\n                    try {\n                        window.localStorage.removeItem(storageKey);\n                    } catch (ignore) {}\n                    // Use session cookie as fallback\n                    try {\n                        window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n                    } catch (ignore) {}\n                }\n                function normalizeLevel(input) {\n                    var level = input;\n                    if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                        level = self.levels[level.toUpperCase()];\n                    }\n                    if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                        return level;\n                    } else {\n                        throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n                    }\n                }\n                /*\n         *\n         * Public logger API - see https://github.com/pimterry/loglevel for details\n         *\n         */ self.name = name;\n                self.levels = {\n                    \"TRACE\": 0,\n                    \"DEBUG\": 1,\n                    \"INFO\": 2,\n                    \"WARN\": 3,\n                    \"ERROR\": 4,\n                    \"SILENT\": 5\n                };\n                self.methodFactory = factory || defaultMethodFactory;\n                self.getLevel = function() {\n                    if (userLevel != null) {\n                        return userLevel;\n                    } else if (defaultLevel != null) {\n                        return defaultLevel;\n                    } else {\n                        return inheritedLevel;\n                    }\n                };\n                self.setLevel = function(level, persist) {\n                    userLevel = normalizeLevel(level);\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(userLevel);\n                    }\n                    // NOTE: in v2, this should call rebuild(), which updates children.\n                    return replaceLoggingMethods.call(self);\n                };\n                self.setDefaultLevel = function(level) {\n                    defaultLevel = normalizeLevel(level);\n                    if (!getPersistedLevel()) {\n                        self.setLevel(level, false);\n                    }\n                };\n                self.resetLevel = function() {\n                    userLevel = null;\n                    clearPersistedLevel();\n                    replaceLoggingMethods.call(self);\n                };\n                self.enableAll = function(persist) {\n                    self.setLevel(self.levels.TRACE, persist);\n                };\n                self.disableAll = function(persist) {\n                    self.setLevel(self.levels.SILENT, persist);\n                };\n                self.rebuild = function() {\n                    if (defaultLogger !== self) {\n                        inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n                    }\n                    replaceLoggingMethods.call(self);\n                    if (defaultLogger === self) {\n                        for(var childName in _loggersByName){\n                            _loggersByName[childName].rebuild();\n                        }\n                    }\n                };\n                // Initialize all the internal levels.\n                inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n                var initialLevel = getPersistedLevel();\n                if (initialLevel != null) {\n                    userLevel = normalizeLevel(initialLevel);\n                }\n                replaceLoggingMethods.call(self);\n            }\n            /*\n       *\n       * Top-level API\n       *\n       */ defaultLogger = new Logger();\n            defaultLogger.getLogger = function getLogger(name) {\n                if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n                    throw new TypeError(\"You must supply a name when creating a logger.\");\n                }\n                var logger = _loggersByName[name];\n                if (!logger) {\n                    logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n                }\n                return logger;\n            };\n            // Grab the current global log variable in case of overwrite\n            var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n            defaultLogger.noConflict = function() {\n                if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n                    window.log = _log;\n                }\n                return defaultLogger;\n            };\n            defaultLogger.getLoggers = function getLoggers() {\n                return _loggersByName;\n            };\n            // ES6 default export, for compatibility\n            defaultLogger[\"default\"] = defaultLogger;\n            return defaultLogger;\n        });\n    })(loglevel$1);\n    return loglevel$1.exports;\n}\nvar loglevelExports = requireLoglevel();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n    LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n    LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n    LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n    LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n    LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(LoggerNames) {\n    LoggerNames[\"Default\"] = \"livekit\";\n    LoggerNames[\"Room\"] = \"livekit-room\";\n    LoggerNames[\"TokenSource\"] = \"livekit-token-source\";\n    LoggerNames[\"Participant\"] = \"livekit-participant\";\n    LoggerNames[\"Track\"] = \"livekit-track\";\n    LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n    LoggerNames[\"Engine\"] = \"livekit-engine\";\n    LoggerNames[\"Signal\"] = \"livekit-signal\";\n    LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n    LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n    LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger(\"livekit\");\nconst livekitLoggers = Object.values(LoggerNames).map((name)=>loglevelExports.getLogger(name));\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */ function getLogger(name) {\n    const logger = loglevelExports.getLogger(name);\n    logger.setDefaultLevel(livekitLogger.getLevel());\n    return logger;\n}\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    } else {\n        for (const logger of livekitLoggers){\n            logger.setLevel(level);\n        }\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension, logger) {\n    const loggers = logger ? [\n        logger\n    ] : livekitLoggers;\n    loggers.forEach((logR)=>{\n        const originalFactory = logR.methodFactory;\n        logR.methodFactory = (methodName, configLevel, loggerName)=>{\n            const rawMethod = originalFactory(methodName, configLevel, loggerName);\n            const logLevel = LogLevel[methodName];\n            const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n            return (msg, context)=>{\n                if (context) rawMethod(msg, context);\n                else rawMethod(msg);\n                if (needLog) {\n                    extension(logLevel, msg, context);\n                }\n            };\n        };\n        logR.setLevel(logR.getLevel());\n    });\n}\nconst workerLogger = loglevelExports.getLogger(\"lk-e2ee\");\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar hasRequiredEvents;\nfunction requireEvents() {\n    if (hasRequiredEvents) return events.exports;\n    hasRequiredEvents = 1;\n    var R = typeof Reflect === \"object\" ? Reflect : null;\n    var ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply(target, receiver, args) {\n        return Function.prototype.apply.call(target, receiver, args);\n    };\n    var ReflectOwnKeys;\n    if (R && typeof R.ownKeys === \"function\") {\n        ReflectOwnKeys = R.ownKeys;\n    } else if (Object.getOwnPropertySymbols) {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n        };\n    } else {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target);\n        };\n    }\n    function ProcessEmitWarning(warning) {\n        if (console && console.warn) console.warn(warning);\n    }\n    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n        return value !== value;\n    };\n    function EventEmitter() {\n        EventEmitter.init.call(this);\n    }\n    events.exports = EventEmitter;\n    events.exports.once = once;\n    // Backwards-compat with node 0.10.x\n    EventEmitter.EventEmitter = EventEmitter;\n    EventEmitter.prototype._events = undefined;\n    EventEmitter.prototype._eventsCount = 0;\n    EventEmitter.prototype._maxListeners = undefined;\n    // By default EventEmitters will print a warning if more than 10 listeners are\n    // added to it. This is a useful default which helps finding memory leaks.\n    var defaultMaxListeners = 10;\n    function checkListener(listener) {\n        if (typeof listener !== \"function\") {\n            throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n        }\n    }\n    Object.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n        enumerable: true,\n        get: function() {\n            return defaultMaxListeners;\n        },\n        set: function(arg) {\n            if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n                throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n            }\n            defaultMaxListeners = arg;\n        }\n    });\n    EventEmitter.init = function() {\n        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        }\n        this._maxListeners = this._maxListeners || undefined;\n    };\n    // Obviously not all Emitters should be limited to 10. This function allows\n    // that to be increased. Set to zero for unlimited.\n    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n            throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n        }\n        this._maxListeners = n;\n        return this;\n    };\n    function _getMaxListeners(that) {\n        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n    }\n    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return _getMaxListeners(this);\n    };\n    EventEmitter.prototype.emit = function emit(type) {\n        var args = [];\n        for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n        var doError = type === \"error\";\n        var events = this._events;\n        if (events !== undefined) doError = doError && events.error === undefined;\n        else if (!doError) return false;\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n            var er;\n            if (args.length > 0) er = args[0];\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        var handler = events[type];\n        if (handler === undefined) return false;\n        if (typeof handler === \"function\") {\n            ReflectApply(handler, this, args);\n        } else {\n            var len = handler.length;\n            var listeners = arrayClone(handler, len);\n            for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n        }\n        return true;\n    };\n    function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n        checkListener(listener);\n        events = target._events;\n        if (events === undefined) {\n            events = target._events = Object.create(null);\n            target._eventsCount = 0;\n        } else {\n            // To avoid recursion in the case that type === \"newListener\"! Before\n            // adding it to the listeners, first emit \"newListener\".\n            if (events.newListener !== undefined) {\n                target.emit(\"newListener\", type, listener.listener ? listener.listener : listener);\n                // Re-assign `events` because a newListener handler could have caused the\n                // this._events to be assigned to a new object\n                events = target._events;\n            }\n            existing = events[type];\n        }\n        if (existing === undefined) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            existing = events[type] = listener;\n            ++target._eventsCount;\n        } else {\n            if (typeof existing === \"function\") {\n                // Adding the second element, need to change to array.\n                existing = events[type] = prepend ? [\n                    listener,\n                    existing\n                ] : [\n                    existing,\n                    listener\n                ];\n            // If we've already got an array, just append.\n            } else if (prepend) {\n                existing.unshift(listener);\n            } else {\n                existing.push(listener);\n            }\n            // Check for listener leak\n            m = _getMaxListeners(target);\n            if (m > 0 && existing.length > m && !existing.warned) {\n                existing.warned = true;\n                // No error code for this since it is a Warning\n                // eslint-disable-next-line no-restricted-syntax\n                var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners \" + \"added. Use emitter.setMaxListeners() to \" + \"increase limit\");\n                w.name = \"MaxListenersExceededWarning\";\n                w.emitter = target;\n                w.type = type;\n                w.count = existing.length;\n                ProcessEmitWarning(w);\n            }\n        }\n        return target;\n    }\n    EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n    };\n    EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n    EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n    };\n    function onceWrapper() {\n        if (!this.fired) {\n            this.target.removeListener(this.type, this.wrapFn);\n            this.fired = true;\n            if (arguments.length === 0) return this.listener.call(this.target);\n            return this.listener.apply(this.target, arguments);\n        }\n    }\n    function _onceWrap(target, type, listener) {\n        var state = {\n            fired: false,\n            wrapFn: undefined,\n            target: target,\n            type: type,\n            listener: listener\n        };\n        var wrapped = onceWrapper.bind(state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n    }\n    EventEmitter.prototype.once = function once(type, listener) {\n        checkListener(listener);\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n    };\n    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n        checkListener(listener);\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n    };\n    // Emits a 'removeListener' event if and only if the listener was removed.\n    EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n        checkListener(listener);\n        events = this._events;\n        if (events === undefined) return this;\n        list = events[type];\n        if (list === undefined) return this;\n        if (list === listener || list.listener === listener) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else {\n                delete events[type];\n                if (events.removeListener) this.emit(\"removeListener\", type, list.listener || listener);\n            }\n        } else if (typeof list !== \"function\") {\n            position = -1;\n            for(i = list.length - 1; i >= 0; i--){\n                if (list[i] === listener || list[i].listener === listener) {\n                    originalListener = list[i].listener;\n                    position = i;\n                    break;\n                }\n            }\n            if (position < 0) return this;\n            if (position === 0) list.shift();\n            else {\n                spliceOne(list, position);\n            }\n            if (list.length === 1) events[type] = list[0];\n            if (events.removeListener !== undefined) this.emit(\"removeListener\", type, originalListener || listener);\n        }\n        return this;\n    };\n    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n        var listeners, events, i;\n        events = this._events;\n        if (events === undefined) return this;\n        // not listening for removeListener, no need to emit\n        if (events.removeListener === undefined) {\n            if (arguments.length === 0) {\n                this._events = Object.create(null);\n                this._eventsCount = 0;\n            } else if (events[type] !== undefined) {\n                if (--this._eventsCount === 0) this._events = Object.create(null);\n                else delete events[type];\n            }\n            return this;\n        }\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n            var keys = Object.keys(events);\n            var key;\n            for(i = 0; i < keys.length; ++i){\n                key = keys[i];\n                if (key === \"removeListener\") continue;\n                this.removeAllListeners(key);\n            }\n            this.removeAllListeners(\"removeListener\");\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n            return this;\n        }\n        listeners = events[type];\n        if (typeof listeners === \"function\") {\n            this.removeListener(type, listeners);\n        } else if (listeners !== undefined) {\n            // LIFO order\n            for(i = listeners.length - 1; i >= 0; i--){\n                this.removeListener(type, listeners[i]);\n            }\n        }\n        return this;\n    };\n    function _listeners(target, type, unwrap) {\n        var events = target._events;\n        if (events === undefined) return [];\n        var evlistener = events[type];\n        if (evlistener === undefined) return [];\n        if (typeof evlistener === \"function\") return unwrap ? [\n            evlistener.listener || evlistener\n        ] : [\n            evlistener\n        ];\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n    }\n    EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n    };\n    EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n    };\n    EventEmitter.listenerCount = function(emitter, type) {\n        if (typeof emitter.listenerCount === \"function\") {\n            return emitter.listenerCount(type);\n        } else {\n            return listenerCount.call(emitter, type);\n        }\n    };\n    EventEmitter.prototype.listenerCount = listenerCount;\n    function listenerCount(type) {\n        var events = this._events;\n        if (events !== undefined) {\n            var evlistener = events[type];\n            if (typeof evlistener === \"function\") {\n                return 1;\n            } else if (evlistener !== undefined) {\n                return evlistener.length;\n            }\n        }\n        return 0;\n    }\n    EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n    };\n    function arrayClone(arr, n) {\n        var copy = new Array(n);\n        for(var i = 0; i < n; ++i)copy[i] = arr[i];\n        return copy;\n    }\n    function spliceOne(list, index) {\n        for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n        list.pop();\n    }\n    function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n        for(var i = 0; i < ret.length; ++i){\n            ret[i] = arr[i].listener || arr[i];\n        }\n        return ret;\n    }\n    function once(emitter, name) {\n        return new Promise(function(resolve, reject) {\n            function errorListener(err) {\n                emitter.removeListener(name, resolver);\n                reject(err);\n            }\n            function resolver() {\n                if (typeof emitter.removeListener === \"function\") {\n                    emitter.removeListener(\"error\", errorListener);\n                }\n                resolve([].slice.call(arguments));\n            }\n            eventTargetAgnosticAddListener(emitter, name, resolver, {\n                once: true\n            });\n            if (name !== \"error\") {\n                addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                    once: true\n                });\n            }\n        });\n    }\n    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n        if (typeof emitter.on === \"function\") {\n            eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n        }\n    }\n    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n        if (typeof emitter.on === \"function\") {\n            if (flags.once) {\n                emitter.once(name, listener);\n            } else {\n                emitter.on(name, listener);\n            }\n        } else if (typeof emitter.addEventListener === \"function\") {\n            // EventTarget does not have `error` event semantics like Node\n            // EventEmitters, we do not listen for `error` events here.\n            emitter.addEventListener(name, function wrapListener(arg) {\n                // IE does not have builtin `{ once: true }` support so we\n                // have to do it manually.\n                if (flags.once) {\n                    emitter.removeEventListener(name, wrapListener);\n                }\n                listener(arg);\n            });\n        } else {\n            throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n        }\n    }\n    return events.exports;\n}\nvar eventsExports = requireEvents();\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseFloat(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n        get () {\n            return this[\"_on\" + eventNameToWrap];\n        },\n        set (cb) {\n            if (this[\"_on\" + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]);\n                delete this[\"_on\" + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    logDisabled_ = bool;\n    return bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\";\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    deprecationWarnings_ = !bool;\n    return \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\");\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it's not a browser\n    if (typeof window1 === \"undefined\" || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = \"Not a browser.\";\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    // Prefer navigator.userAgentData.\n    if (navigator1.userAgentData && navigator1.userAgentData.brands) {\n        const chromium = navigator1.userAgentData.brands.find((brand)=>{\n            return brand.brand === \"Chromium\";\n        });\n        if (chromium) {\n            return {\n                browser: \"chrome\",\n                version: parseInt(chromium.version, 10)\n            };\n        }\n    }\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = \"firefox\";\n        result.version = parseInt(extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1));\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = \"chrome\";\n        result.version = parseInt(extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2));\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = \"safari\";\n        result.version = parseInt(extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1));\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && \"currentDirection\" in window1.RTCRtpTransceiver.prototype;\n        // Only for internal usage.\n        result._safariVersion = extractVersion(navigator1.userAgent, /Version\\/(\\d+(\\.?\\d+))/, 1);\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = \"Not a supported browser.\";\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject$1(val) {\n    return Object.prototype.toString.call(val) === \"[object Object]\";\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */ function compactObject(data) {\n    if (!isObject$1(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject$1(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith(\"Id\")) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith(\"Ids\")) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\";\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === \"track\" && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== \"object\" || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === \"require\" || key === \"advanced\" || key === \"mediaSource\") {\n                return;\n            }\n            const r = typeof c[key] === \"object\" ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === \"number\") {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === \"deviceId\" ? \"sourceId\" : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === \"number\") {\n                    oc[oldname_(\"min\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_(\"max\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_(\"\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== \"number\") {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_(\"\", key)] = r.exact;\n            } else {\n                [\n                    \"min\",\n                    \"max\"\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === \"object\") {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\");\n            remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === \"object\") {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === \"object\" ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === \"user\" || face.exact === \"environment\" || face.ideal === \"user\" || face.ideal === \"environment\") && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === \"environment\" || face.ideal === \"environment\") {\n                    matches = [\n                        \"back\",\n                        \"rear\"\n                    ];\n                } else if (face.exact === \"user\" || face.ideal === \"user\") {\n                    matches = [\n                        \"front\"\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === \"videoinput\");\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes(\"back\")) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging(\"chrome: \" + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging(\"chrome: \" + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: \"NotAllowedError\",\n                PermissionDismissedError: \"NotAllowedError\",\n                InvalidStateError: \"NotAllowedError\",\n                DevicesNotFoundError: \"NotFoundError\",\n                ConstraintNotSatisfiedError: \"OverconstrainedError\",\n                TrackStartError: \"NotReadableError\",\n                MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n                MediaDeviceKillSwitchOn: \"NotAllowedError\",\n                TabCaptureError: \"AbortError\",\n                ScreenCaptureError: \"AbortError\",\n                DeviceCaptureError: \"AbortError\"\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && \": \") + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException(\"\", \"NotFoundError\");\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"ontrack\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"ontrack\", {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener(\"track\", this._ontrack);\n                }\n                this.addEventListener(\"track\", this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener(\"addtrack\", (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener(\"addstream\", this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, \"transceiver\", {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"getSenders\" in window1.RTCPeerConnection.prototype) && \"createDTMFSender\" in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === \"audio\") {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === \"object\" && window1.RTCPeerConnection && \"getSenders\" in window1.RTCPeerConnection.prototype && \"createDTMFSender\" in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !(\"dtmf\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, \"dtmf\", {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === \"audio\") {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!(\"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype && \"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\"));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException(\"The adapter.js addTrack polyfill only supports a single \" + \" stream which is associated with the specified track.\", \"NotSupportedError\");\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event(\"negotiationneeded\"));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        \"createOffer\",\n        \"createAnswer\"\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === \"function\";\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, \"localDescription\");\n    Object.defineProperty(window1.RTCPeerConnection.prototype, \"localDescription\", {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === \"\") {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack \" + \"does not implement interface RTCRtpSender.\", \"TypeError\");\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event(\"negotiationneeded\"));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, \"negotiationneeded\", (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === \"plan-b\") {\n            if (pc.signalingState !== \"stable\") {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+'s deprecation warning with unprefixed version.\n        deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === \"object\" && typeof c.audio === \"object\") {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\");\n                remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\");\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, \"mozAutoGainControl\", \"autoGainControl\");\n                remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\");\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === \"audio\" && typeof c === \"object\") {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, \"autoGainControl\", \"mozAutoGainControl\");\n                    remap(c, \"noiseSuppression\", \"mozNoiseSuppression\");\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && \"getDisplayMedia\" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException(\"getDisplayMedia without video \" + \"constraints is undefined\");\n            err.name = \"NotFoundError\";\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== \"object\" || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== \"TypeError\") {\n                        throw e;\n                    }\n                    // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || \"removeStream\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated(\"removeStream\", \"removeTrack\");\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if (\"rid\" in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError(\"Invalid RID value provided.\");\n                        }\n                    }\n                    if (\"scaleResolutionDownBy\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n                        }\n                    }\n                    if (\"maxFramerate\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError(\"max_framerate must be >= 0.0\");\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!(\"encodings\" in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!(\"encodings\" in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getLocalStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!(\"addStream\" in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome's behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!(\"removeStream\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getRemoteStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!(\"onaddstream\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"onaddstream\", {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener(\"addstream\", this._onaddstream);\n                    this.removeEventListener(\"track\", this._onaddstreampoly);\n                }\n                this.addEventListener(\"addstream\", this._onaddstream = f);\n                this.addEventListener(\"track\", this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener(\"track\", this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if (\"generateCertificate\" in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, \"generateCertificate\", {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"audio\");\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === \"sendrecv\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        audioTransceiver.direction = \"sendonly\";\n                    }\n                } else if (audioTransceiver.direction === \"recvonly\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"inactive\");\n                    } else {\n                        audioTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver(\"audio\", {\n                    direction: \"recvonly\"\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"video\");\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === \"sendrecv\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        videoTransceiver.direction = \"sendonly\";\n                    }\n                } else if (videoTransceiver.direction === \"recvonly\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"inactive\");\n                    } else {\n                        videoTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver(\"video\", {\n                    direction: \"recvonly\"\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== \"object\" || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ var hasRequiredSdp;\nfunction requireSdp() {\n    if (hasRequiredSdp) return sdp$1.exports;\n    hasRequiredSdp = 1;\n    (function(module) {\n        // SDP helpers.\n        const SDPUtils = {};\n        // Generate an alphanumeric identifier for cname or mids.\n        // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n        SDPUtils.generateIdentifier = function() {\n            return Math.random().toString(36).substring(2, 12);\n        };\n        // The RTCP CNAME used by all peerconnections from the same JS.\n        SDPUtils.localCName = SDPUtils.generateIdentifier();\n        // Splits SDP into lines, dealing with both CRLF and LF.\n        SDPUtils.splitLines = function(blob) {\n            return blob.trim().split(\"\\n\").map((line)=>line.trim());\n        };\n        // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n        SDPUtils.splitSections = function(blob) {\n            const parts = blob.split(\"\\nm=\");\n            return parts.map((part, index)=>(index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\");\n        };\n        // Returns the session description.\n        SDPUtils.getDescription = function(blob) {\n            const sections = SDPUtils.splitSections(blob);\n            return sections && sections[0];\n        };\n        // Returns the individual media sections.\n        SDPUtils.getMediaSections = function(blob) {\n            const sections = SDPUtils.splitSections(blob);\n            sections.shift();\n            return sections;\n        };\n        // Returns lines that start with a certain prefix.\n        SDPUtils.matchPrefix = function(blob, prefix) {\n            return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n        };\n        // Parses an ICE candidate line. Sample input:\n        // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n        // rport 55996\"\n        // Input can be prefixed with a=.\n        SDPUtils.parseCandidate = function(line) {\n            let parts;\n            // Parse both variants.\n            if (line.indexOf(\"a=candidate:\") === 0) {\n                parts = line.substring(12).split(\" \");\n            } else {\n                parts = line.substring(10).split(\" \");\n            }\n            const candidate = {\n                foundation: parts[0],\n                component: {\n                    1: \"rtp\",\n                    2: \"rtcp\"\n                }[parts[1]] || parts[1],\n                protocol: parts[2].toLowerCase(),\n                priority: parseInt(parts[3], 10),\n                ip: parts[4],\n                address: parts[4],\n                // address is an alias for ip.\n                port: parseInt(parts[5], 10),\n                // skip parts[6] == 'typ'\n                type: parts[7]\n            };\n            for(let i = 8; i < parts.length; i += 2){\n                switch(parts[i]){\n                    case \"raddr\":\n                        candidate.relatedAddress = parts[i + 1];\n                        break;\n                    case \"rport\":\n                        candidate.relatedPort = parseInt(parts[i + 1], 10);\n                        break;\n                    case \"tcptype\":\n                        candidate.tcpType = parts[i + 1];\n                        break;\n                    case \"ufrag\":\n                        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                        candidate.usernameFragment = parts[i + 1];\n                        break;\n                    default:\n                        // extension handling, in particular ufrag. Don't overwrite.\n                        if (candidate[parts[i]] === undefined) {\n                            candidate[parts[i]] = parts[i + 1];\n                        }\n                        break;\n                }\n            }\n            return candidate;\n        };\n        // Translates a candidate object into SDP candidate attribute.\n        // This does not include the a= prefix!\n        SDPUtils.writeCandidate = function(candidate) {\n            const sdp = [];\n            sdp.push(candidate.foundation);\n            const component = candidate.component;\n            if (component === \"rtp\") {\n                sdp.push(1);\n            } else if (component === \"rtcp\") {\n                sdp.push(2);\n            } else {\n                sdp.push(component);\n            }\n            sdp.push(candidate.protocol.toUpperCase());\n            sdp.push(candidate.priority);\n            sdp.push(candidate.address || candidate.ip);\n            sdp.push(candidate.port);\n            const type = candidate.type;\n            sdp.push(\"typ\");\n            sdp.push(type);\n            if (type !== \"host\" && candidate.relatedAddress && candidate.relatedPort) {\n                sdp.push(\"raddr\");\n                sdp.push(candidate.relatedAddress);\n                sdp.push(\"rport\");\n                sdp.push(candidate.relatedPort);\n            }\n            if (candidate.tcpType && candidate.protocol.toLowerCase() === \"tcp\") {\n                sdp.push(\"tcptype\");\n                sdp.push(candidate.tcpType);\n            }\n            if (candidate.usernameFragment || candidate.ufrag) {\n                sdp.push(\"ufrag\");\n                sdp.push(candidate.usernameFragment || candidate.ufrag);\n            }\n            return \"candidate:\" + sdp.join(\" \");\n        };\n        // Parses an ice-options line, returns an array of option tags.\n        // Sample input:\n        // a=ice-options:foo bar\n        SDPUtils.parseIceOptions = function(line) {\n            return line.substring(14).split(\" \");\n        };\n        // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n        // a=rtpmap:111 opus/48000/2\n        SDPUtils.parseRtpMap = function(line) {\n            let parts = line.substring(9).split(\" \");\n            const parsed = {\n                payloadType: parseInt(parts.shift(), 10) // was: id\n            };\n            parts = parts[0].split(\"/\");\n            parsed.name = parts[0];\n            parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n            parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n            // legacy alias, got renamed back to channels in ORTC.\n            parsed.numChannels = parsed.channels;\n            return parsed;\n        };\n        // Generates a rtpmap line from RTCRtpCodecCapability or\n        // RTCRtpCodecParameters.\n        SDPUtils.writeRtpMap = function(codec) {\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            const channels = codec.channels || codec.numChannels || 1;\n            return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (channels !== 1 ? \"/\" + channels : \"\") + \"\\r\\n\";\n        };\n        // Parses a extmap line (headerextension from RFC 5285). Sample input:\n        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n        // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n        SDPUtils.parseExtmap = function(line) {\n            const parts = line.substring(9).split(\" \");\n            return {\n                id: parseInt(parts[0], 10),\n                direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n                uri: parts[1],\n                attributes: parts.slice(2).join(\" \")\n            };\n        };\n        // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n        // RTCRtpHeaderExtension.\n        SDPUtils.writeExtmap = function(headerExtension) {\n            return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== \"sendrecv\" ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + (headerExtension.attributes ? \" \" + headerExtension.attributes : \"\") + \"\\r\\n\";\n        };\n        // Parses a fmtp line, returns dictionary. Sample input:\n        // a=fmtp:96 vbr=on;cng=on\n        // Also deals with vbr=on; cng=on\n        SDPUtils.parseFmtp = function(line) {\n            const parsed = {};\n            let kv;\n            const parts = line.substring(line.indexOf(\" \") + 1).split(\";\");\n            for(let j = 0; j < parts.length; j++){\n                kv = parts[j].trim().split(\"=\");\n                parsed[kv[0].trim()] = kv[1];\n            }\n            return parsed;\n        };\n        // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n        SDPUtils.writeFmtp = function(codec) {\n            let line = \"\";\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            if (codec.parameters && Object.keys(codec.parameters).length) {\n                const params = [];\n                Object.keys(codec.parameters).forEach((param)=>{\n                    if (codec.parameters[param] !== undefined) {\n                        params.push(param + \"=\" + codec.parameters[param]);\n                    } else {\n                        params.push(param);\n                    }\n                });\n                line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n            }\n            return line;\n        };\n        // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n        // a=rtcp-fb:98 nack rpsi\n        SDPUtils.parseRtcpFb = function(line) {\n            const parts = line.substring(line.indexOf(\" \") + 1).split(\" \");\n            return {\n                type: parts.shift(),\n                parameter: parts.join(\" \")\n            };\n        };\n        // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n        SDPUtils.writeRtcpFb = function(codec) {\n            let lines = \"\";\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n                // FIXME: special handling for trr-int?\n                codec.rtcpFeedback.forEach((fb)=>{\n                    lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n                });\n            }\n            return lines;\n        };\n        // Parses a RFC 5576 ssrc media attribute. Sample input:\n        // a=ssrc:3735928559 cname:something\n        SDPUtils.parseSsrcMedia = function(line) {\n            const sp = line.indexOf(\" \");\n            const parts = {\n                ssrc: parseInt(line.substring(7, sp), 10)\n            };\n            const colon = line.indexOf(\":\", sp);\n            if (colon > -1) {\n                parts.attribute = line.substring(sp + 1, colon);\n                parts.value = line.substring(colon + 1);\n            } else {\n                parts.attribute = line.substring(sp + 1);\n            }\n            return parts;\n        };\n        // Parse a ssrc-group line (see RFC 5576). Sample input:\n        // a=ssrc-group:semantics 12 34\n        SDPUtils.parseSsrcGroup = function(line) {\n            const parts = line.substring(13).split(\" \");\n            return {\n                semantics: parts.shift(),\n                ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n            };\n        };\n        // Extracts the MID (RFC 5888) from a media section.\n        // Returns the MID or undefined if no mid line was found.\n        SDPUtils.getMid = function(mediaSection) {\n            const mid = SDPUtils.matchPrefix(mediaSection, \"a=mid:\")[0];\n            if (mid) {\n                return mid.substring(6);\n            }\n        };\n        // Parses a fingerprint line for DTLS-SRTP.\n        SDPUtils.parseFingerprint = function(line) {\n            const parts = line.substring(14).split(\" \");\n            return {\n                algorithm: parts[0].toLowerCase(),\n                // algorithm is case-sensitive in Edge.\n                value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n            };\n        };\n        // Extracts DTLS parameters from SDP media section or sessionpart.\n        // FIXME: for consistency with other functions this should only\n        //   get the fingerprint line as input. See also getIceParameters.\n        SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n            const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\");\n            // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n            return {\n                role: \"auto\",\n                fingerprints: lines.map(SDPUtils.parseFingerprint)\n            };\n        };\n        // Serializes DTLS parameters to SDP.\n        SDPUtils.writeDtlsParameters = function(params, setupType) {\n            let sdp = \"a=setup:\" + setupType + \"\\r\\n\";\n            params.fingerprints.forEach((fp)=>{\n                sdp += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n            });\n            return sdp;\n        };\n        // Parses a=crypto lines into\n        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n        SDPUtils.parseCryptoLine = function(line) {\n            const parts = line.substring(9).split(\" \");\n            return {\n                tag: parseInt(parts[0], 10),\n                cryptoSuite: parts[1],\n                keyParams: parts[2],\n                sessionParams: parts.slice(3)\n            };\n        };\n        SDPUtils.writeCryptoLine = function(parameters) {\n            return \"a=crypto:\" + parameters.tag + \" \" + parameters.cryptoSuite + \" \" + (typeof parameters.keyParams === \"object\" ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? \" \" + parameters.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n        };\n        // Parses the crypto key parameters into\n        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n        SDPUtils.parseCryptoKeyParams = function(keyParams) {\n            if (keyParams.indexOf(\"inline:\") !== 0) {\n                return null;\n            }\n            const parts = keyParams.substring(7).split(\"|\");\n            return {\n                keyMethod: \"inline\",\n                keySalt: parts[0],\n                lifeTime: parts[1],\n                mkiValue: parts[2] ? parts[2].split(\":\")[0] : undefined,\n                mkiLength: parts[2] ? parts[2].split(\":\")[1] : undefined\n            };\n        };\n        SDPUtils.writeCryptoKeyParams = function(keyParams) {\n            return keyParams.keyMethod + \":\" + keyParams.keySalt + (keyParams.lifeTime ? \"|\" + keyParams.lifeTime : \"\") + (keyParams.mkiValue && keyParams.mkiLength ? \"|\" + keyParams.mkiValue + \":\" + keyParams.mkiLength : \"\");\n        };\n        // Extracts all SDES parameters.\n        SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n            const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=crypto:\");\n            return lines.map(SDPUtils.parseCryptoLine);\n        };\n        // Parses ICE information from SDP media section or sessionpart.\n        // FIXME: for consistency with other functions this should only\n        //   get the ice-ufrag and ice-pwd lines as input.\n        SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n            const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-ufrag:\")[0];\n            const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-pwd:\")[0];\n            if (!(ufrag && pwd)) {\n                return null;\n            }\n            return {\n                usernameFragment: ufrag.substring(12),\n                password: pwd.substring(10)\n            };\n        };\n        // Serializes ICE parameters to SDP.\n        SDPUtils.writeIceParameters = function(params) {\n            let sdp = \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\n\" + \"a=ice-pwd:\" + params.password + \"\\r\\n\";\n            if (params.iceLite) {\n                sdp += \"a=ice-lite\\r\\n\";\n            }\n            return sdp;\n        };\n        // Parses the SDP media section and returns RTCRtpParameters.\n        SDPUtils.parseRtpParameters = function(mediaSection) {\n            const description = {\n                codecs: [],\n                headerExtensions: [],\n                fecMechanisms: [],\n                rtcp: []\n            };\n            const lines = SDPUtils.splitLines(mediaSection);\n            const mline = lines[0].split(\" \");\n            description.profile = mline[2];\n            for(let i = 3; i < mline.length; i++){\n                // find all codecs from mline[3..]\n                const pt = mline[i];\n                const rtpmapline = SDPUtils.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n                if (rtpmapline) {\n                    const codec = SDPUtils.parseRtpMap(rtpmapline);\n                    const fmtps = SDPUtils.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n                    // Only the first a=fmtp:<pt> is considered.\n                    codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                    codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils.parseRtcpFb);\n                    description.codecs.push(codec);\n                    // parse FEC mechanisms from rtpmap lines.\n                    switch(codec.name.toUpperCase()){\n                        case \"RED\":\n                        case \"ULPFEC\":\n                            description.fecMechanisms.push(codec.name.toUpperCase());\n                            break;\n                    }\n                }\n            }\n            SDPUtils.matchPrefix(mediaSection, \"a=extmap:\").forEach((line)=>{\n                description.headerExtensions.push(SDPUtils.parseExtmap(line));\n            });\n            const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:* \").map(SDPUtils.parseRtcpFb);\n            description.codecs.forEach((codec)=>{\n                wildcardRtcpFb.forEach((fb)=>{\n                    const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                        return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                    });\n                    if (!duplicate) {\n                        codec.rtcpFeedback.push(fb);\n                    }\n                });\n            });\n            // FIXME: parse rtcp.\n            return description;\n        };\n        // Generates parts of the SDP media section describing the capabilities /\n        // parameters.\n        SDPUtils.writeRtpDescription = function(kind, caps) {\n            let sdp = \"\";\n            // Build the mline.\n            sdp += \"m=\" + kind + \" \";\n            sdp += caps.codecs.length > 0 ? \"9\" : \"0\"; // reject if no codecs.\n            sdp += \" \" + (caps.profile || \"UDP/TLS/RTP/SAVPF\") + \" \";\n            sdp += caps.codecs.map((codec)=>{\n                if (codec.preferredPayloadType !== undefined) {\n                    return codec.preferredPayloadType;\n                }\n                return codec.payloadType;\n            }).join(\" \") + \"\\r\\n\";\n            sdp += \"c=IN IP4 0.0.0.0\\r\\n\";\n            sdp += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n            // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n            caps.codecs.forEach((codec)=>{\n                sdp += SDPUtils.writeRtpMap(codec);\n                sdp += SDPUtils.writeFmtp(codec);\n                sdp += SDPUtils.writeRtcpFb(codec);\n            });\n            let maxptime = 0;\n            caps.codecs.forEach((codec)=>{\n                if (codec.maxptime > maxptime) {\n                    maxptime = codec.maxptime;\n                }\n            });\n            if (maxptime > 0) {\n                sdp += \"a=maxptime:\" + maxptime + \"\\r\\n\";\n            }\n            if (caps.headerExtensions) {\n                caps.headerExtensions.forEach((extension)=>{\n                    sdp += SDPUtils.writeExtmap(extension);\n                });\n            }\n            // FIXME: write fecMechanisms.\n            return sdp;\n        };\n        // Parses the SDP media section and returns an array of\n        // RTCRtpEncodingParameters.\n        SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n            const encodingParameters = [];\n            const description = SDPUtils.parseRtpParameters(mediaSection);\n            const hasRed = description.fecMechanisms.indexOf(\"RED\") !== -1;\n            const hasUlpfec = description.fecMechanisms.indexOf(\"ULPFEC\") !== -1;\n            // filter a=ssrc:... cname:, ignore PlanB-msid\n            const ssrcs = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === \"cname\");\n            const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n            let secondarySsrc;\n            const flows = SDPUtils.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map((line)=>{\n                const parts = line.substring(17).split(\" \");\n                return parts.map((part)=>parseInt(part, 10));\n            });\n            if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n                secondarySsrc = flows[0][1];\n            }\n            description.codecs.forEach((codec)=>{\n                if (codec.name.toUpperCase() === \"RTX\" && codec.parameters.apt) {\n                    let encParam = {\n                        ssrc: primarySsrc,\n                        codecPayloadType: parseInt(codec.parameters.apt, 10)\n                    };\n                    if (primarySsrc && secondarySsrc) {\n                        encParam.rtx = {\n                            ssrc: secondarySsrc\n                        };\n                    }\n                    encodingParameters.push(encParam);\n                    if (hasRed) {\n                        encParam = JSON.parse(JSON.stringify(encParam));\n                        encParam.fec = {\n                            ssrc: primarySsrc,\n                            mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n                        };\n                        encodingParameters.push(encParam);\n                    }\n                }\n            });\n            if (encodingParameters.length === 0 && primarySsrc) {\n                encodingParameters.push({\n                    ssrc: primarySsrc\n                });\n            }\n            // we support both b=AS and b=TIAS but interpret AS as TIAS.\n            let bandwidth = SDPUtils.matchPrefix(mediaSection, \"b=\");\n            if (bandwidth.length) {\n                if (bandwidth[0].indexOf(\"b=TIAS:\") === 0) {\n                    bandwidth = parseInt(bandwidth[0].substring(7), 10);\n                } else if (bandwidth[0].indexOf(\"b=AS:\") === 0) {\n                    // use formula from JSEP to convert b=AS to TIAS value.\n                    bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n                } else {\n                    bandwidth = undefined;\n                }\n                encodingParameters.forEach((params)=>{\n                    params.maxBitrate = bandwidth;\n                });\n            }\n            return encodingParameters;\n        };\n        // parses http://draft.ortc.org/#rtcrtcpparameters*\n        SDPUtils.parseRtcpParameters = function(mediaSection) {\n            const rtcpParameters = {};\n            // Gets the first SSRC. Note that with RTX there might be multiple\n            // SSRCs.\n            const remoteSsrc = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === \"cname\")[0];\n            if (remoteSsrc) {\n                rtcpParameters.cname = remoteSsrc.value;\n                rtcpParameters.ssrc = remoteSsrc.ssrc;\n            }\n            // Edge uses the compound attribute instead of reducedSize\n            // compound is !reducedSize\n            const rsize = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n            rtcpParameters.reducedSize = rsize.length > 0;\n            rtcpParameters.compound = rsize.length === 0;\n            // parses the rtcp-mux attrbute.\n            // Note that Edge does not support unmuxed RTCP.\n            const mux = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-mux\");\n            rtcpParameters.mux = mux.length > 0;\n            return rtcpParameters;\n        };\n        SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n            let sdp = \"\";\n            if (rtcpParameters.reducedSize) {\n                sdp += \"a=rtcp-rsize\\r\\n\";\n            }\n            if (rtcpParameters.mux) {\n                sdp += \"a=rtcp-mux\\r\\n\";\n            }\n            if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n                sdp += \"a=ssrc:\" + rtcpParameters.ssrc + \" cname:\" + rtcpParameters.cname + \"\\r\\n\";\n            }\n            return sdp;\n        };\n        // parses either a=msid: or a=ssrc:... msid lines and returns\n        // the id of the MediaStream and MediaStreamTrack.\n        SDPUtils.parseMsid = function(mediaSection) {\n            let parts;\n            const spec = SDPUtils.matchPrefix(mediaSection, \"a=msid:\");\n            if (spec.length === 1) {\n                parts = spec[0].substring(7).split(\" \");\n                return {\n                    stream: parts[0],\n                    track: parts[1]\n                };\n            }\n            const planB = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === \"msid\");\n            if (planB.length > 0) {\n                parts = planB[0].value.split(\" \");\n                return {\n                    stream: parts[0],\n                    track: parts[1]\n                };\n            }\n        };\n        // SCTP\n        // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n        // to draft-ietf-mmusic-sctp-sdp-05\n        SDPUtils.parseSctpDescription = function(mediaSection) {\n            const mline = SDPUtils.parseMLine(mediaSection);\n            const maxSizeLine = SDPUtils.matchPrefix(mediaSection, \"a=max-message-size:\");\n            let maxMessageSize;\n            if (maxSizeLine.length > 0) {\n                maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n            }\n            if (isNaN(maxMessageSize)) {\n                maxMessageSize = 65536;\n            }\n            const sctpPort = SDPUtils.matchPrefix(mediaSection, \"a=sctp-port:\");\n            if (sctpPort.length > 0) {\n                return {\n                    port: parseInt(sctpPort[0].substring(12), 10),\n                    protocol: mline.fmt,\n                    maxMessageSize\n                };\n            }\n            const sctpMapLines = SDPUtils.matchPrefix(mediaSection, \"a=sctpmap:\");\n            if (sctpMapLines.length > 0) {\n                const parts = sctpMapLines[0].substring(10).split(\" \");\n                return {\n                    port: parseInt(parts[0], 10),\n                    protocol: parts[1],\n                    maxMessageSize\n                };\n            }\n        };\n        // SCTP\n        // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n        // support by now receiving in this format, unless we originally parsed\n        // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n        // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n        SDPUtils.writeSctpDescription = function(media, sctp) {\n            let output = [];\n            if (media.protocol !== \"DTLS/SCTP\") {\n                output = [\n                    \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.protocol + \"\\r\\n\",\n                    \"c=IN IP4 0.0.0.0\\r\\n\",\n                    \"a=sctp-port:\" + sctp.port + \"\\r\\n\"\n                ];\n            } else {\n                output = [\n                    \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.port + \"\\r\\n\",\n                    \"c=IN IP4 0.0.0.0\\r\\n\",\n                    \"a=sctpmap:\" + sctp.port + \" \" + sctp.protocol + \" 65535\\r\\n\"\n                ];\n            }\n            if (sctp.maxMessageSize !== undefined) {\n                output.push(\"a=max-message-size:\" + sctp.maxMessageSize + \"\\r\\n\");\n            }\n            return output.join(\"\");\n        };\n        // Generate a session ID for SDP.\n        // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n        // recommends using a cryptographically random +ve 64-bit value\n        // but right now this should be acceptable and within the right range\n        SDPUtils.generateSessionId = function() {\n            return Math.random().toString().substr(2, 22);\n        };\n        // Write boiler plate for start of SDP\n        // sessId argument is optional - if not supplied it will\n        // be generated randomly\n        // sessVersion is optional and defaults to 2\n        // sessUser is optional and defaults to 'thisisadapterortc'\n        SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n            let sessionId;\n            const version = sessVer !== undefined ? sessVer : 2;\n            if (sessId) {\n                sessionId = sessId;\n            } else {\n                sessionId = SDPUtils.generateSessionId();\n            }\n            const user = sessUser || \"thisisadapterortc\";\n            // FIXME: sess-id should be an NTP timestamp.\n            return \"v=0\\r\\n\" + \"o=\" + user + \" \" + sessionId + \" \" + version + \" IN IP4 127.0.0.1\\r\\n\" + \"s=-\\r\\n\" + \"t=0 0\\r\\n\";\n        };\n        // Gets the direction from the mediaSection or the sessionpart.\n        SDPUtils.getDirection = function(mediaSection, sessionpart) {\n            // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n            const lines = SDPUtils.splitLines(mediaSection);\n            for(let i = 0; i < lines.length; i++){\n                switch(lines[i]){\n                    case \"a=sendrecv\":\n                    case \"a=sendonly\":\n                    case \"a=recvonly\":\n                    case \"a=inactive\":\n                        return lines[i].substring(2);\n                }\n            }\n            if (sessionpart) {\n                return SDPUtils.getDirection(sessionpart);\n            }\n            return \"sendrecv\";\n        };\n        SDPUtils.getKind = function(mediaSection) {\n            const lines = SDPUtils.splitLines(mediaSection);\n            const mline = lines[0].split(\" \");\n            return mline[0].substring(2);\n        };\n        SDPUtils.isRejected = function(mediaSection) {\n            return mediaSection.split(\" \", 2)[1] === \"0\";\n        };\n        SDPUtils.parseMLine = function(mediaSection) {\n            const lines = SDPUtils.splitLines(mediaSection);\n            const parts = lines[0].substring(2).split(\" \");\n            return {\n                kind: parts[0],\n                port: parseInt(parts[1], 10),\n                protocol: parts[2],\n                fmt: parts.slice(3).join(\" \")\n            };\n        };\n        SDPUtils.parseOLine = function(mediaSection) {\n            const line = SDPUtils.matchPrefix(mediaSection, \"o=\")[0];\n            const parts = line.substring(2).split(\" \");\n            return {\n                username: parts[0],\n                sessionId: parts[1],\n                sessionVersion: parseInt(parts[2], 10),\n                netType: parts[3],\n                addressType: parts[4],\n                address: parts[5]\n            };\n        };\n        // a very naive interpretation of a valid SDP.\n        SDPUtils.isValidSDP = function(blob) {\n            if (typeof blob !== \"string\" || blob.length === 0) {\n                return false;\n            }\n            const lines = SDPUtils.splitLines(blob);\n            for(let i = 0; i < lines.length; i++){\n                if (lines[i].length < 2 || lines[i].charAt(1) !== \"=\") {\n                    return false;\n                }\n            // TODO: check the modifier a bit more.\n            }\n            return true;\n        };\n        // Expose public methods.\n        {\n            module.exports = SDPUtils;\n        }\n    })(sdp$1);\n    return sdp$1.exports;\n}\nvar sdpExports = requireSdp();\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"foundation\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn't be part of the candidate string.\n        if (typeof args === \"object\" && args.candidate && args.candidate.indexOf(\"a=\") === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, \"candidate\", {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: \"false\"\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"relayProtocol\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === \"relay\") {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: \"tls\",\n                    1: \"tcp\",\n                    2: \"udp\"\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"sctp\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"sctp\", {\n            get () {\n                return typeof this._sctp === \"undefined\" ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === \"application\" && mLine.protocol.indexOf(\"SCTP\") !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === \"firefox\") {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === \"firefox\" && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === \"firefox\" && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an 'ugly worakaround'\n        // to cover up the mess.\n        if (browserDetails.browser === \"chrome\" && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === \"plan-b\") {\n                Object.defineProperty(this, \"sctp\", {\n                    get () {\n                        return typeof this._sctp === \"undefined\" ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, \"maxMessageSize\", {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && \"createDataChannel\" in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === \"open\" && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, \"datachannel\", (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || \"connectionState\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, \"connectionState\", {\n        get () {\n            return ({\n                completed: \"connected\",\n                checking: \"connecting\"\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, \"onconnectionstatechange\", {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        \"setLocalDescription\",\n        \"setRemoteDescription\"\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event(\"connectionstatechange\", e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === \"chrome\" && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === \"safari\" && browserDetails._safariVersion >= 13.1) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf(\"\\na=extmap-allow-mixed\") !== -1) {\n            const sdp = desc.sdp.split(\"\\n\").filter((line)=>{\n                return line.trim() !== \"a=extmap-allow-mixed\";\n            }).join(\"\\n\");\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: \"\", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === \"chrome\" && browserDetails.version < 78 || browserDetails.browser === \"firefox\" && browserDetails.version < 68 || browserDetails.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\") {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== \"object\" || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection's operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can't reduce the glare\n        // window to zero on imperfect implementations, there's value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case \"stable\":\n                case \"have-local-offer\":\n                case \"have-remote-pranswer\":\n                    desc.type = \"offer\";\n                    break;\n                default:\n                    desc.type = \"answer\";\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== \"offer\" && desc.type !== \"answer\") {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === \"offer\" ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case \"chrome\":\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging(\"Chrome shim is not included in this adapter release.\");\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging(\"Chrome shim can not determine version, not shimming.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming chrome.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case \"firefox\":\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging(\"Firefox shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming firefox.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case \"safari\":\n            if (!safariShim || !options.shimSafari) {\n                logging(\"Safari shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming safari.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging(\"Unsupported browser!\");\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = \"AES-GCM\";\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = \"lk_e2ee\";\nconst SALT = \"LKFrameEncryptionKey\";\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n    keyringSize: 16\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent[\"SetKey\"] = \"setKey\";\n    /** Event for requesting to ratchet the key used to encrypt the stream */ KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n    /** Emitted when a key is ratcheted. Could be after auto-ratcheting on decryption failure or\n   *  following a `RatchetRequest`, will contain the ratcheted key material */ KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    /** Emitted when a key has been ratcheted. Is emitted when any key has been ratcheted\n   * i.e. when the FrameCryptor tried to ratchet when decryption is failing  */ KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== \"undefined\";\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== \"undefined\" && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== \"undefined\";\n}\nfunction isVideoFrame(frame) {\n    return \"type\" in frame;\n}\nfunction importKey(keyBytes_1) {\n    return __awaiter(this, arguments, void 0, function(keyBytes) {\n        let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            name: ENCRYPTION_ALGORITHM\n        };\n        let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"encrypt\";\n        return function*() {\n            // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n            return crypto.subtle.importKey(\"raw\", keyBytes, algorithm, false, usage === \"derive\" ? [\n                \"deriveBits\",\n                \"deriveKey\"\n            ] : [\n                \"encrypt\",\n                \"decrypt\"\n            ]);\n        }();\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", enc.encode(password), {\n            name: \"PBKDF2\"\n        }, false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", cryptoBuffer, \"HKDF\", false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case \"HKDF\":\n            return {\n                name: \"HKDF\",\n                salt: encodedSalt,\n                hash: \"SHA-256\",\n                info: new ArrayBuffer(128)\n            };\n        case \"PBKDF2\":\n            {\n                return {\n                    name: \"PBKDF2\",\n                    salt: encodedSalt,\n                    hash: \"SHA-256\",\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nfunction asEncryptablePacket(packet) {\n    var _a, _b, _c, _d, _e;\n    if (((_a = packet.value) === null || _a === void 0 ? void 0 : _a.case) !== \"sipDtmf\" && ((_b = packet.value) === null || _b === void 0 ? void 0 : _b.case) !== \"metrics\" && ((_c = packet.value) === null || _c === void 0 ? void 0 : _c.case) !== \"speaker\" && ((_d = packet.value) === null || _d === void 0 ? void 0 : _d.case) !== \"transcription\" && ((_e = packet.value) === null || _e === void 0 ? void 0 : _e.case) !== \"encryptedPacket\") {\n        return new EncryptedPacketPayload({\n            value: packet.value\n        });\n    }\n    return undefined;\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * Callback being invoked after a key has been ratcheted.\n     * Can happen when:\n     * - A decryption failure occurs and the key is auto-ratcheted\n     * - A ratchet request is sent (see {@link ratchetKey()})\n     * @param ratchetResult Contains the ratcheted chain key (exportable to other participants) and the derived new key material.\n     * @param participantId\n     * @param keyIndex\n     */ this.onKeyRatcheted = (ratchetResult, participantId, keyIndex)=>{\n            livekitLogger.debug(\"key ratcheted event received\", {\n                ratchetResult,\n                participantId,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        if (!this.options.sharedKey && !participantIdentity) {\n            throw new Error(\"participant identity needs to be passed for encryption key if sharedKey option is false\");\n        }\n        this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : \"shared\", \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won't try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === \"string\" ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || \"an error has occured\");\n        this.name = \"LiveKitError\";\n        this.code = code;\n    }\n}\nvar ConnectionErrorReason;\n(function(ConnectionErrorReason) {\n    ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\n    ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\n    ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n    ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\n    ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\n    ConnectionErrorReason[ConnectionErrorReason[\"Timeout\"] = 5] = \"Timeout\";\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status, context){\n        super(1, message);\n        this.name = \"ConnectionError\";\n        this.status = status;\n        this.reason = reason;\n        this.context = context;\n        this.reasonName = ConnectionErrorReason[reason];\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : \"device is unsupported\");\n        this.name = \"DeviceUnsupportedError\";\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : \"track is invalid\");\n        this.name = \"TrackInvalidError\";\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : \"unsupported server\");\n        this.name = \"UnsupportedServer\";\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : \"unexpected connection state\");\n        this.name = \"UnexpectedConnectionState\";\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : \"unable to negotiate\");\n        this.name = \"NegotiationError\";\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(14, message !== null && message !== void 0 ? message : \"unable to publish data\");\n        this.name = \"PublishDataError\";\n    }\n}\nclass PublishTrackError extends LivekitError {\n    constructor(message, status){\n        super(15, message);\n        this.name = \"PublishTrackError\";\n        this.status = status;\n    }\n}\nclass SignalRequestError extends LivekitError {\n    constructor(message, reason){\n        super(15, message);\n        this.reason = reason;\n        this.reasonName = typeof reason === \"string\" ? reason : RequestResponse_Reason[reason];\n    }\n}\n// NOTE: matches with https://github.com/livekit/client-sdk-swift/blob/f37bbd260d61e165084962db822c79f995f1a113/Sources/LiveKit/DataStream/StreamError.swift#L17\nvar DataStreamErrorReason;\n(function(DataStreamErrorReason) {\n    // Unable to open a stream with the same ID more than once.\n    DataStreamErrorReason[DataStreamErrorReason[\"AlreadyOpened\"] = 0] = \"AlreadyOpened\";\n    // Stream closed abnormally by remote participant.\n    DataStreamErrorReason[DataStreamErrorReason[\"AbnormalEnd\"] = 1] = \"AbnormalEnd\";\n    // Incoming chunk data could not be decoded.\n    DataStreamErrorReason[DataStreamErrorReason[\"DecodeFailed\"] = 2] = \"DecodeFailed\";\n    // Read length exceeded total length specified in stream header.\n    DataStreamErrorReason[DataStreamErrorReason[\"LengthExceeded\"] = 3] = \"LengthExceeded\";\n    // Read length less than total length specified in stream header.\n    DataStreamErrorReason[DataStreamErrorReason[\"Incomplete\"] = 4] = \"Incomplete\";\n    // Unable to register a stream handler more than once.\n    DataStreamErrorReason[DataStreamErrorReason[\"HandlerAlreadyRegistered\"] = 7] = \"HandlerAlreadyRegistered\";\n    // Encryption type mismatch.\n    DataStreamErrorReason[DataStreamErrorReason[\"EncryptionTypeMismatch\"] = 8] = \"EncryptionTypeMismatch\";\n})(DataStreamErrorReason || (DataStreamErrorReason = {}));\nclass DataStreamError extends LivekitError {\n    constructor(message, reason){\n        super(16, message);\n        this.name = \"DataStreamError\";\n        this.reason = reason;\n        this.reasonName = DataStreamErrorReason[reason];\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n    // device is not available\n    MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n    MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && \"name\" in error) {\n            if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\nvar CryptorErrorReason;\n(function(CryptorErrorReason) {\n    CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\n    CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\n    CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n})(CryptorErrorReason || (CryptorErrorReason = {}));\nclass CryptorError extends LivekitError {\n    constructor(message){\n        let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\n        let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\n        super(40, message);\n        this.reason = reason;\n        this.participantIdentity = participantIdentity;\n    }\n}\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent[\"Connected\"] = \"connected\";\n    /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */ RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n    /**\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\n   */ RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent[\"Reconnected\"] = \"reconnected\";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured.\n   *\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\n   *\n   * args: ([[DisconnectReason]])\n   */ RoomEvent[\"Disconnected\"] = \"disconnected\";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n    /**\n   * When participant has been moved to a different room by the service request.\n   * The behavior looks like the participant has been disconnected and reconnected to a different room\n   * seamlessly without connection state transition.\n   * A new token will be provided for reconnecting to the new room if needed.\n   *\n   * args: ([[room: string, token: string]])\n   */ RoomEvent[\"Moved\"] = \"moved\";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\n    /**\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\n   *\n   * args: (participant: [[Participant]])\n   */ RoomEvent[\"ParticipantActive\"] = \"participantActive\";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * SIP DTMF tones received from another participant.\n   *\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\n   */ RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n    /**\n   * Transcription received from a participant's track.\n   * @beta\n   */ RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n    RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n    RoomEvent[\"ChatMessage\"] = \"chatMessage\";\n    /**\n   * fired when the first remote participant has subscribed to the localParticipant's track\n   */ RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    /**\n   * fired when the client receives connection metrics from other participants\n   */ RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * A local track has been constrained by cpu.\n   * This event is useful to know when to reduce the capture resolution of the track.\n   *\n   * This event is emitted on the local participant.\n   *\n   * args: ([[LocalVideoTrack]], [[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackCpuConstrained\"] = \"localTrackCpuConstrained\";\n    /**\n   * @internal\n   */ ParticipantEvent[\"LocalSenderCreated\"] = \"localSenderCreated\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * SIP DTMF tones received from this participant as sender.\n   *\n   * args: (dtmf: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n    /**\n   * Transcription received from this participant as data source.\n   * @beta\n   */ ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * a local track has been constrained by cpu\n   */ ParticipantEvent[\"TrackCpuConstrained\"] = \"trackCpuConstrained\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n    /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /** @internal */ ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n    /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\n   * args: (changedAttributes: [[Record<string, string]])\n   */ ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\n    /**\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\n   */ ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    /** only emitted on local participant */ ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\n    /**\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\n   */ ParticipantEvent[\"Active\"] = \"active\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n    EngineEvent[\"Connected\"] = \"connected\";\n    EngineEvent[\"Disconnected\"] = \"disconnected\";\n    EngineEvent[\"Resuming\"] = \"resuming\";\n    EngineEvent[\"Resumed\"] = \"resumed\";\n    EngineEvent[\"Restarting\"] = \"restarting\";\n    EngineEvent[\"Restarted\"] = \"restarted\";\n    EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n    EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n    EngineEvent[\"Closing\"] = \"closing\";\n    EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n    EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n    EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n    EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n    EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n    EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n    EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n    EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n    EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n    EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n    EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n    EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n    EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n    EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    EngineEvent[\"Offline\"] = \"offline\";\n    EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\n    EngineEvent[\"SignalConnected\"] = \"signalConnected\";\n    EngineEvent[\"RoomMoved\"] = \"roomMoved\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent[\"Message\"] = \"message\";\n    TrackEvent[\"Muted\"] = \"muted\";\n    TrackEvent[\"Unmuted\"] = \"unmuted\";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent[\"Restarted\"] = \"restarted\";\n    TrackEvent[\"Ended\"] = \"ended\";\n    TrackEvent[\"Subscribed\"] = \"subscribed\";\n    TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n    TrackEvent[\"CpuConstrained\"] = \"cpuConstrained\";\n    /** @internal */ TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n    /** @internal */ TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n    /** @internal */ TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n    /** @internal */ TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n    /** @internal */ TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n    /** @internal */ TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n    /** @internal */ TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n    /** @internal */ TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n    /** @internal */ TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n    /** @internal */ TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n    /**\n   * @internal\n   */ TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\n    /**\n   * @internal\n   */ TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\n    /**\n   * @beta\n   */ TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * @experimental\n   */ TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\n    /**\n   * @internal\n   */ TrackEvent[\"PreConnectBufferFlushed\"] = \"preConnectBufferFlushed\";\n})(TrackEvent || (TrackEvent = {}));\nfunction cloneDeep(value) {\n    if (typeof value === \"undefined\") {\n        return value;\n    }\n    if (typeof structuredClone === \"function\") {\n        if (typeof value === \"object\" && value !== null) {\n            // ensure that the value is not a proxy by spreading it\n            return structuredClone(Object.assign({}, value));\n        }\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === \"undefined\" && typeof navigator === \"undefined\") {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: \"Firefox\",\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"fxios\") ? \"iOS\" : undefined,\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: \"Chrome\",\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"crios\") ? \"iOS\" : undefined,\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: \"Safari\",\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes(\"mobile/\") ? \"iOS\" : \"macOS\",\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || \"\";\n}\nfunction getOSVersion(ua) {\n    return ua.includes(\"mac os\") ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, \".\") : undefined;\n}\nvar version$1 = \"2.16.0\";\nconst version = version$1;\nconst protocolVersion = 16;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\nCriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval\nfunction() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nvar VideoQuality;\n(function(VideoQuality) {\n    VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n    VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n})(VideoQuality || (VideoQuality = {}));\nclass Track extends eventsExports.EventEmitter {\n    /**\n   * indicates current state of stream, it'll indicate `paused` if the track\n   * has been paused by congestion controller\n   */ get streamState() {\n        return this._streamState;\n    }\n    /** @internal */ setStreamState(value) {\n        this._streamState = value;\n    }\n    constructor(mediaTrack, kind){\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        this._streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.log = livekitLogger;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === \"hidden\") {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = \"audio\";\n        if (this.kind === Track.Kind.Video) {\n            elementType = \"video\";\n        }\n        if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === \"audio\") {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it's already attached to the element, it's possible\n        // the element's srcObject was set to something else out of band.\n        // we'll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === \"audio\");\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === \"NotAllowedError\") {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === \"AbortError\") {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug(\"\".concat(hasAudio ? \"audio\" : \"video\", \" playback aborted, likely due to new play request\"));\n            } else {\n                livekitLogger.warn(\"could not playback \".concat(hasAudio ? \"audio\" : \"video\"), e);\n            }\n            // If audio playback isn't allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === \"video\") && e.name === \"NotAllowedError\") {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n        if (this.timeSyncHandle) {\n            cancelAnimationFrame(this.timeSyncHandle);\n        }\n    }\n    /** @internal */ updateLoggerOptions(loggerOptions) {\n        if (loggerOptions.loggerName) {\n            this.log = getLogger(loggerOptions.loggerName);\n        }\n        if (loggerOptions.loggerContextCb) {\n            this.loggerContextCb = loggerOptions.loggerContextCb;\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            if (!this.isInBackground && this.kind === Track.Kind.Video) {\n                setTimeout(()=>this.attachedElements.forEach((el)=>el.play().catch(()=>{\n                        /** catch clause necessary for Safari */ })), 0);\n            }\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === \"audio\") {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn't actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind[\"Audio\"] = \"audio\";\n        Kind[\"Video\"] = \"video\";\n        Kind[\"Unknown\"] = \"unknown\";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source[\"Camera\"] = \"camera\";\n        Source[\"Microphone\"] = \"microphone\";\n        Source[\"ScreenShare\"] = \"screen_share\";\n        Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n        Source[\"Unknown\"] = \"unknown\";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState[\"Active\"] = \"active\";\n        StreamState[\"Paused\"] = \"paused\";\n        StreamState[\"Unknown\"] = \"unknown\";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nclass VideoPreset {\n    constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority){\n        if (typeof widthOrOptions === \"object\") {\n            this.width = widthOrOptions.width;\n            this.height = widthOrOptions.height;\n            this.aspectRatio = widthOrOptions.aspectRatio;\n            this.encoding = {\n                maxBitrate: widthOrOptions.maxBitrate,\n                maxFramerate: widthOrOptions.maxFramerate,\n                priority: widthOrOptions.priority\n            };\n        } else if (height !== undefined && maxBitrate !== undefined) {\n            this.width = widthOrOptions;\n            this.height = height;\n            this.aspectRatio = widthOrOptions / height;\n            this.encoding = {\n                maxBitrate,\n                maxFramerate,\n                priority\n            };\n        } else {\n            throw new TypeError(\"Unsupported options: provide at least width, height and maxBitrate\");\n        }\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.aspectRatio\n        };\n    }\n}\n// `red` is not technically a codec, but treated as one in signalling protocol\nconst audioCodecs = [\n    \"opus\",\n    \"red\"\n];\nconst backupVideoCodecs = [\n    \"vp8\",\n    \"h264\"\n];\nconst videoCodecs = [\n    \"vp8\",\n    \"h264\",\n    \"vp9\",\n    \"av1\",\n    \"h265\"\n];\nfunction isBackupVideoCodec(codec) {\n    return !!backupVideoCodecs.find((backup)=>backup === codec);\n}\n/** @deprecated Use {@link isBackupVideoCodec} instead */ const isBackupCodec = isBackupVideoCodec;\nvar BackupCodecPolicy;\n(function(BackupCodecPolicy) {\n    // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed\n    BackupCodecPolicy[BackupCodecPolicy[\"PREFER_REGRESSION\"] = 0] = \"PREFER_REGRESSION\";\n    // multi-codec simulcast, publish both primary and backup codec at the same time\n    BackupCodecPolicy[BackupCodecPolicy[\"SIMULCAST\"] = 1] = \"SIMULCAST\";\n    // always use backup codec only\n    BackupCodecPolicy[BackupCodecPolicy[\"REGRESSION\"] = 2] = \"REGRESSION\";\n})(BackupCodecPolicy || (BackupCodecPolicy = {}));\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 24000\n    };\n    AudioPresets.music = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 96000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 128000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, \"medium\"),\n    h360fps15: new VideoPreset(640, 360, 400000, 15, \"medium\"),\n    h720fps5: new VideoPreset(1280, 720, 800000, 5, \"medium\"),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, \"medium\"),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, \"medium\"),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, \"medium\"),\n    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, \"medium\"),\n    // original resolution, without resizing\n    original: new VideoPreset(0, 0, 7000000, 30, \"medium\")\n};\nconst separator = \"|\";\nconst ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        \"\"\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari() || isFireFox()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        // Firefox does support AV1, but SVC publishing is not supported\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType.toLowerCase() === \"video/av1\") {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, \"16\") < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n        if ((browser === null || browser === void 0 ? void 0 : browser.os) === \"iOS\" && (browser === null || browser === void 0 ? void 0 : browser.osVersion) && compareVersions(browser.osVersion, \"16\") < 0) {\n            // Safari 16 and below on iOS does not support VP9 we need the iOS check to account for other browsers running webkit under the hood\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType.toLowerCase() === \"video/vp9\") {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === \"av1\" || codec === \"vp9\";\n}\nfunction supportsSetSinkId(elm) {\n    if (!document || isSafariBased()) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement(\"audio\");\n    }\n    return \"setSinkId\" in elm;\n}\n/**\n * Checks whether or not setting an audio output via {@link Room#setActiveDevice}\n * is supported for the current browser.\n */ function supportsAudioOutputSelection() {\n    // Note: this is method publicly exported under a user friendly name and currently only proxying `supportsSetSinkId`\n    return supportsSetSinkId();\n}\nfunction isBrowserSupported() {\n    if (typeof RTCPeerConnection === \"undefined\") {\n        return false;\n    }\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Firefox\";\n}\nfunction isChromiumBased() {\n    const browser = getBrowser();\n    return !!browser && browser.name === \"Chrome\" && browser.os !== \"iOS\";\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Safari\";\n}\nfunction isSafariBased() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === \"Safari\" || (b === null || b === void 0 ? void 0 : b.os) === \"iOS\";\n}\nfunction isSafari17Based() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === \"Safari\" && b.version.startsWith(\"17.\") || (b === null || b === void 0 ? void 0 : b.os) === \"iOS\" && !!(b === null || b === void 0 ? void 0 : b.osVersion) && compareVersions(b.osVersion, \"17\") >= 0;\n}\nfunction isSafariSvcApi(browser) {\n    if (!browser) {\n        browser = getBrowser();\n    }\n    // Safari 18.4 requires legacy svc api and scaleResolutionDown to be set\n    return (browser === null || browser === void 0 ? void 0 : browser.name) === \"Safari\" && compareVersions(browser.version, \"18.3\") > 0 || (browser === null || browser === void 0 ? void 0 : browser.os) === \"iOS\" && !!(browser === null || browser === void 0 ? void 0 : browser.osVersion) && compareVersions(browser.osVersion, \"18.3\") > 0;\n}\nfunction isMobile() {\n    var _a, _b;\n    if (!isWeb()) return false;\n    return(// @ts-expect-error `userAgentData` is not yet part of typescript\n    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent));\n}\nfunction isE2EESimulcastSupported() {\n    const browser = getBrowser();\n    const supportedSafariVersion = \"17.2\"; // see https://bugs.webkit.org/show_bug.cgi?id=257803\n    if (browser) {\n        if (browser.name !== \"Safari\" && browser.os !== \"iOS\") {\n            return true;\n        } else if (browser.os === \"iOS\" && browser.osVersion && compareVersions(browser.osVersion, supportedSafariVersion) >= 0) {\n            return true;\n        } else if (browser.name === \"Safari\" && compareVersions(browser.version, supportedSafariVersion) >= 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\nfunction isWeb() {\n    return typeof document !== \"undefined\";\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == \"ReactNative\";\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith(\".livekit.cloud\") || serverUrl.hostname.endsWith(\".livekit.run\");\n}\nfunction extractProjectFromUrl(serverUrl) {\n    if (!isCloud(serverUrl)) {\n        return null;\n    }\n    return serverUrl.hostname.split(\".\")[0];\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\n/**\n * @param v1 - The first version string to compare.\n * @param v2 - The second version string to compare.\n * @returns A number indicating the order of the versions:\n *   - 1 if v1 is greater than v2\n *   - -1 if v1 is less than v2\n *   - 0 if v1 and v2 are equal\n */ function compareVersions(v1, v2) {\n    const parts1 = v1.split(\".\");\n    const parts2 = v2.split(\".\");\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === \"\" && v2 !== \"\") {\n        return -1;\n    } else if (v2 === \"\") {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: \"0px\"\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : \"\";\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement(\"canvas\");\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = \"grey\";\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error(\"Could not get empty media stream video track\");\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error(\"Could not get empty media stream audio track\");\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    get isResolved() {\n        return this._isResolved;\n    }\n    constructor(futureBase, onFinally){\n        this._isResolved = false;\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            this._isResolved = true;\n            (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error(\"Audio Context not supported on this browser\");\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nfunction isAudioCodec(maybeCodec) {\n    return audioCodecs.includes(maybeCodec);\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === \"string\" || typeof constraint === \"number\") {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact !== undefined) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal !== undefined) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error(\"could not unwrap constraint\");\n}\nfunction toWebsocketUrl(url) {\n    if (url.startsWith(\"http\")) {\n        return url.replace(/^(http)/, \"ws\");\n    }\n    return url;\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith(\"ws\")) {\n        return url.replace(/^(ws)/, \"http\");\n    }\n    return url;\n}\nfunction extractTranscriptionSegments(transcription, firstReceivedTimesMap) {\n    return transcription.segments.map((_ref)=>{\n        let { id, text, language, startTime, endTime, final } = _ref;\n        var _a;\n        const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();\n        const lastReceivedTime = Date.now();\n        if (final) {\n            firstReceivedTimesMap.delete(id);\n        } else {\n            firstReceivedTimesMap.set(id, firstReceivedTime);\n        }\n        return {\n            id,\n            text,\n            startTime: Number.parseInt(startTime.toString()),\n            endTime: Number.parseInt(endTime.toString()),\n            final,\n            language,\n            firstReceivedTime,\n            lastReceivedTime\n        };\n    });\n}\nfunction extractChatMessage(msg) {\n    const { id, timestamp, message, editTimestamp } = msg;\n    return {\n        id,\n        timestamp: Number.parseInt(timestamp.toString()),\n        editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,\n        message\n    };\n}\nfunction getDisconnectReasonFromConnectionError(e) {\n    switch(e.reason){\n        case ConnectionErrorReason.LeaveRequest:\n            return e.context;\n        case ConnectionErrorReason.Cancelled:\n            return DisconnectReason.CLIENT_INITIATED;\n        case ConnectionErrorReason.NotAllowed:\n            return DisconnectReason.USER_REJECTED;\n        case ConnectionErrorReason.ServerUnreachable:\n            return DisconnectReason.JOIN_FAILURE;\n        default:\n            return DisconnectReason.UNKNOWN_REASON;\n    }\n}\n/** convert bigints to numbers preserving undefined values */ function bigIntToNumber(value) {\n    return value !== undefined ? Number(value) : undefined;\n}\n/** convert numbers to bigints preserving undefined values */ function numberToBigInt(value) {\n    return value !== undefined ? BigInt(value) : undefined;\n}\nfunction isLocalTrack(track) {\n    return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;\n}\nfunction isAudioTrack(track) {\n    return !!track && track.kind == Track.Kind.Audio;\n}\nfunction isVideoTrack(track) {\n    return !!track && track.kind == Track.Kind.Video;\n}\nfunction isLocalVideoTrack(track) {\n    return isLocalTrack(track) && isVideoTrack(track);\n}\nfunction isLocalAudioTrack(track) {\n    return isLocalTrack(track) && isAudioTrack(track);\n}\nfunction isRemoteTrack(track) {\n    return !!track && !track.isLocal;\n}\nfunction isRemotePub(pub) {\n    return !!pub && !pub.isLocal;\n}\nfunction isRemoteVideoTrack(track) {\n    return isRemoteTrack(track) && isVideoTrack(track);\n}\nfunction isLocalParticipant(p) {\n    return p.isLocal;\n}\nfunction isRemoteParticipant(p) {\n    return !p.isLocal;\n}\nfunction splitUtf8(s, n) {\n    // adapted from https://stackoverflow.com/a/6043797\n    const result = [];\n    let encoded = new TextEncoder().encode(s);\n    while(encoded.length > n){\n        let k = n;\n        while(k > 0){\n            const byte = encoded[k];\n            if (byte !== undefined && (byte & 0xc0) !== 0x80) {\n                break;\n            }\n            k--;\n        }\n        result.push(encoded.slice(0, k));\n        encoded = encoded.slice(k);\n    }\n    if (encoded.length > 0) {\n        result.push(encoded);\n    }\n    return result;\n}\nfunction extractMaxAgeFromRequestHeaders(headers) {\n    var _a;\n    const cacheControl = headers.get(\"Cache-Control\");\n    if (cacheControl) {\n        const maxAge = (_a = cacheControl.match(/(?:^|[,\\s])max-age=(\\d+)/)) === null || _a === void 0 ? void 0 : _a[1];\n        if (maxAge) {\n            return parseInt(maxAge, 10);\n        }\n    }\n    return undefined;\n}\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a, _b;\n    var _c, _d;\n    const { optionsWithoutProcessor, audioProcessor, videoProcessor } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});\n    const defaultAudioProcessor = audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;\n    const defaultVideoProcessor = videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;\n    const clonedOptions = optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0 ? optionsWithoutProcessor : {};\n    if (clonedOptions.audio === true) clonedOptions.audio = {};\n    if (clonedOptions.video === true) clonedOptions.video = {};\n    // use defaults\n    if (clonedOptions.audio) {\n        mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);\n        (_a = (_c = clonedOptions.audio).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n            ideal: \"default\"\n        };\n        if (audioProcessor || defaultAudioProcessor) {\n            clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;\n        }\n    }\n    if (clonedOptions.video) {\n        mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);\n        (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n            ideal: \"default\"\n        };\n        if (videoProcessor || defaultVideoProcessor) {\n            clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;\n        }\n    }\n    return clonedOptions;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    var _a, _b;\n    var _c, _d;\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === \"object\") {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case \"resolution\":\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n            (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n                ideal: \"default\"\n            };\n        } else {\n            constraints.video = options.video ? {\n                deviceId: {\n                    ideal: \"default\"\n                }\n            } : false;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === \"object\") {\n            constraints.audio = options.audio;\n            (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n                ideal: \"default\"\n            };\n        } else {\n            constraints.audio = {\n                deviceId: {\n                    ideal: \"default\"\n                }\n            };\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track_1) {\n    return __awaiter(this, arguments, void 0, function(track) {\n        let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n        return function*() {\n            const ctx = getNewAudioContext();\n            if (ctx) {\n                const analyser = ctx.createAnalyser();\n                analyser.fftSize = 2048;\n                const bufferLength = analyser.frequencyBinCount;\n                const dataArray = new Uint8Array(bufferLength);\n                const source = ctx.createMediaStreamSource(new MediaStream([\n                    track.mediaStreamTrack\n                ]));\n                source.connect(analyser);\n                yield sleep(timeOffset);\n                analyser.getByteTimeDomainData(dataArray);\n                const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n                ctx.close();\n                return !someNoise;\n            }\n            return false;\n        }();\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    var _a;\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        const audioContext = new AudioContext1({\n            latencyHint: \"interactive\"\n        });\n        // If the audio context is suspended, we need to resume it when the user clicks on the page\n        if (audioContext.state === \"suspended\" && \"undefined\" !== \"undefined\" && (0)) {}\n        return audioContext;\n    }\n}\n/**\n * @internal\n */ function kindToSource(kind) {\n    if (kind === \"audioinput\") {\n        return Track.Source.Microphone;\n    } else if (kind === \"videoinput\") {\n        return Track.Source.Camera;\n    } else {\n        return Track.Source.Unknown;\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return \"audioinput\";\n    } else if (source === Track.Source.Camera) {\n        return \"videoinput\";\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    // treat 0 as uncapped\n    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n        videoConstraints = typeof videoConstraints === \"boolean\" ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio,\n        preferCurrentTab: options.preferCurrentTab\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    return mimeType.split(\"/\")[1].toLowerCase();\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nfunction getLogContextFromTrack(track) {\n    if (\"mediaStreamTrack\" in track) {\n        return {\n            trackID: track.sid,\n            source: track.source,\n            muted: track.isMuted,\n            enabled: track.mediaStreamTrack.enabled,\n            kind: track.kind,\n            streamID: track.mediaStreamID,\n            streamTrackID: track.mediaStreamTrack.id\n        };\n    } else {\n        return {\n            trackID: track.trackSid,\n            enabled: track.isEnabled,\n            muted: track.isMuted,\n            trackInfo: Object.assign({\n                mimeType: track.mimeType,\n                name: track.trackName,\n                encrypted: track.isEncrypted,\n                kind: track.kind,\n                source: track.source\n            }, track.track ? getLogContextFromTrack(track.track) : {})\n        };\n    }\n}\nfunction supportsSynchronizationSources() {\n    return typeof RTCRtpReceiver !== \"undefined\" && \"getSynchronizationSources\" in RTCRtpReceiver;\n}\nfunction diffAttributes(oldValues, newValues) {\n    var _a;\n    if (oldValues === undefined) {\n        oldValues = {};\n    }\n    if (newValues === undefined) {\n        newValues = {};\n    }\n    const allKeys = [\n        ...Object.keys(newValues),\n        ...Object.keys(oldValues)\n    ];\n    const diff = {};\n    for (const key of allKeys){\n        if (oldValues[key] !== newValues[key]) {\n            diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : \"\";\n        }\n    }\n    return diff;\n}\n/** @internal */ function extractProcessorsFromOptions(options) {\n    const newOptions = Object.assign({}, options);\n    let audioProcessor;\n    let videoProcessor;\n    if (typeof newOptions.audio === \"object\" && newOptions.audio.processor) {\n        audioProcessor = newOptions.audio.processor;\n        newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {\n            processor: undefined\n        });\n    }\n    if (typeof newOptions.video === \"object\" && newOptions.video.processor) {\n        videoProcessor = newOptions.video.processor;\n        newOptions.video = Object.assign(Object.assign({}, newOptions.video), {\n            processor: undefined\n        });\n    }\n    return {\n        audioProcessor,\n        videoProcessor,\n        optionsWithoutProcessor: cloneDeep(newOptions)\n    };\n}\nfunction getTrackSourceFromProto(source) {\n    switch(source){\n        case TrackSource.CAMERA:\n            return Track.Source.Camera;\n        case TrackSource.MICROPHONE:\n            return Track.Source.Microphone;\n        case TrackSource.SCREEN_SHARE:\n            return Track.Source.ScreenShare;\n        case TrackSource.SCREEN_SHARE_AUDIO:\n            return Track.Source.ScreenShareAudio;\n        default:\n            return Track.Source.Unknown;\n    }\n}\nfunction areDimensionsSmaller(a, b) {\n    return a.width * a.height < b.width * b.height;\n}\nfunction layerDimensionsFor(trackInfo, quality) {\n    var _a;\n    return (_a = trackInfo.layers) === null || _a === void 0 ? void 0 : _a.find((l)=>l.quality === quality);\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options, dcEncryptionEnabled){\n        super();\n        this.decryptDataRequests = new Map();\n        this.encryptDataRequests = new Map();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case \"error\":\n                    livekitLogger.error(data.error.message);\n                    // If error has uuid, it's from an async operation (encrypt/decrypt)\n                    // Reject the corresponding future\n                    if (data.uuid) {\n                        const decryptFuture = this.decryptDataRequests.get(data.uuid);\n                        if (decryptFuture === null || decryptFuture === void 0 ? void 0 : decryptFuture.reject) {\n                            decryptFuture.reject(data.error);\n                            break; // Don't emit general error if it's handled by future\n                        }\n                        const encryptFuture = this.encryptDataRequests.get(data.uuid);\n                        if (encryptFuture === null || encryptFuture === void 0 ? void 0 : encryptFuture.reject) {\n                            encryptFuture.reject(data.error);\n                            break; // Don't emit general error if it's handled by future\n                        }\n                    }\n                    // Emit general error event for unhandled errors\n                    this.emit(EncryptionEvent.EncryptionError, data.error, data.participantIdentity);\n                    break;\n                case \"initAck\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case \"enable\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    break;\n                case \"ratchetKey\":\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.ratchetResult, data.participantIdentity, data.keyIndex);\n                    break;\n                case \"decryptDataResponse\":\n                    const decryptFuture = this.decryptDataRequests.get(data.uuid);\n                    if (decryptFuture === null || decryptFuture === void 0 ? void 0 : decryptFuture.resolve) {\n                        decryptFuture.resolve(data);\n                    }\n                    break;\n                case \"encryptDataResponse\":\n                    const encryptFuture = this.encryptDataRequests.get(data.uuid);\n                    if (encryptFuture === null || encryptFuture === void 0 ? void 0 : encryptFuture.resolve) {\n                        encryptFuture.resolve(data);\n                    }\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error(\"e2ee worker encountered an error:\", {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error, undefined);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n        this.dataChannelEncryptionEnabled = dcEncryptionEnabled;\n    }\n    get isEnabled() {\n        return this.encryptionEnabled;\n    }\n    get isDataChannelEncryptionEnabled() {\n        return this.isEnabled && this.dataChannelEncryptionEnabled;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError(\"tried to setup end-to-end encryption on an unsupported browser\");\n        }\n        livekitLogger.info(\"setting up e2ee\");\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker('');\n            const msg = {\n                kind: \"init\",\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions(),\n                    loglevel: workerLogger.getLevel()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info(\"initializing worker\", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.remoteParticipants.forEach((participant)=>{\n                    participant.trackPublications.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: \"removeTransform\",\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError(\"expected room to be present on signal connect\");\n            }\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n        });\n        room.localParticipant.on(ParticipantEvent.LocalSenderCreated, (sender, track)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(track, sender);\n            }));\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>{\n            // Safari doesn't support retrieving payload information on RTCEncodedVideoFrame, so we need to update the codec manually once we have the trackInfo from the server\n            if (!isVideoTrack(publication.track) || !isSafariBased()) {\n                return;\n            }\n            const msg = {\n                kind: \"updateCodec\",\n                data: {\n                    trackId: publication.track.mediaStreamID,\n                    codec: mimeTypeToVideoCodecString(publication.trackInfo.codecs[0].mimeType),\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg);\n        });\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex));\n    }\n    encryptData(data) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                throw Error(\"could not encrypt data, worker is missing\");\n            }\n            const uuid = crypto.randomUUID();\n            const msg = {\n                kind: \"encryptDataRequest\",\n                data: {\n                    uuid,\n                    payload: data,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            const future = new Future();\n            future.onFinally = ()=>{\n                this.encryptDataRequests.delete(uuid);\n            };\n            this.encryptDataRequests.set(uuid, future);\n            this.worker.postMessage(msg);\n            return future.promise;\n        });\n    }\n    handleEncryptedData(payload, iv, participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error(\"could not handle encrypted data, worker is missing\");\n        }\n        const uuid = crypto.randomUUID();\n        const msg = {\n            kind: \"decryptDataRequest\",\n            data: {\n                uuid,\n                payload,\n                iv,\n                participantIdentity,\n                keyIndex\n            }\n        };\n        const future = new Future();\n        future.onFinally = ()=>{\n            this.decryptDataRequests.delete(uuid);\n        };\n        this.decryptDataRequests.set(uuid, future);\n        this.worker.postMessage(msg);\n        return future.promise;\n    }\n    postRatchetRequest(participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error(\"could not ratchet key, worker is missing\");\n        }\n        const msg = {\n            kind: \"ratchetRequest\",\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error(\"could not set key, worker is missing\");\n        }\n        const msg = {\n            kind: \"setKey\",\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: \"enable\",\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError(\"failed to enable e2ee, worker is not ready\");\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError(\"could not post rtp map, worker is missing\");\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError(\"could not post rtp map, local participant identity is missing\");\n        }\n        const msg = {\n            kind: \"setRTPMap\",\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error(\"could not post SIF trailer, worker is missing\");\n        }\n        const msg = {\n            kind: \"setSifTrailer\",\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === \"\") {\n            throw new TypeError(\"MimeType missing from trackInfo, cannot set up E2EE cryptor\");\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === \"video\" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!isLocalTrack(track) || !sender) {\n            if (!sender) livekitLogger.warn(\"early return because sender is not ready\");\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported() && // Chrome occasionally throws an `InvalidState` error when using script transforms directly after introducing this API in 141.\n            // Disabling it for Chrome based browsers until the API has stabilized\n            !isChromiumBased()) {\n                const options = {\n                    kind: \"decode\",\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: \"updateCodec\",\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: \"decode\",\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity,\n                        isReuse: E2EE_FLAG in receiver\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === \"\") {\n            throw TypeError(\"local identity needs to be known in order to set up encrypted sender\");\n        }\n        if (isScriptTransformSupported() && // Chrome occasionally throws an `InvalidState` error when using script transforms directly after introducing this API in 141.\n        // Disabling it for Chrome based browsers until the API has stabilized\n        !isChromiumBased()) {\n            livekitLogger.info(\"initialize script transform\");\n            const options = {\n                kind: \"encode\",\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info(\"initialize encoded streams\");\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: \"encode\",\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity,\n                    isReuse: false\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nconst CONNECTION_BACKOFF_MIN_MS = 500;\nconst CONNECTION_BACKOFF_MAX_MS = 15000;\n/**\n * BackOffStrategy implements exponential backoff for connection failures.\n *\n * When severe connection failures occur (e.g., network issues, server unavailability),\n * this strategy introduces increasing delays between reconnection attempts to avoid\n * overwhelming the server and to give transient issues time to resolve.\n *\n * This strategy is only applied to LiveKit Cloud projects. It identifies\n * projects by extracting the project name from the connection URL and tracks failures\n * per project. Self-hosted deployments (URLs without a project identifier) are not\n * subject to backoff delays.\n *\n * The class is implemented as a singleton to maintain consistent backoff state across\n * the entire application lifecycle instead of room instance lifecycle.\n */ class BackOffStrategy {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    constructor(){\n        this.failedConnectionAttempts = new Map();\n        this.backOffPromises = new Map();\n    }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new BackOffStrategy();\n        }\n        return this._instance;\n    }\n    addFailedConnectionAttempt(urlString) {\n        var _a;\n        const url = new URL(urlString);\n        const projectName = extractProjectFromUrl(url);\n        if (!projectName) {\n            return;\n        }\n        let failureCount = (_a = this.failedConnectionAttempts.get(projectName)) !== null && _a !== void 0 ? _a : 0;\n        this.failedConnectionAttempts.set(projectName, failureCount + 1);\n        this.backOffPromises.set(projectName, sleep(Math.min(CONNECTION_BACKOFF_MIN_MS * Math.pow(2, failureCount), CONNECTION_BACKOFF_MAX_MS)));\n    }\n    getBackOffPromise(urlString) {\n        const url = new URL(urlString);\n        const projectName = url && extractProjectFromUrl(url);\n        const backoffPromise = projectName && this.backOffPromises.get(projectName);\n        return backoffPromise || Promise.resolve();\n    }\n    resetFailedConnectionAttempts(urlString) {\n        const url = new URL(urlString);\n        const projectName = url && extractProjectFromUrl(url);\n        if (projectName) {\n            this.failedConnectionAttempts.set(projectName, 0);\n            this.backOffPromises.set(projectName, Promise.resolve());\n        }\n    }\n    resetAll() {\n        this.backOffPromises.clear();\n        this.failedConnectionAttempts.clear();\n    }\n}\nBackOffStrategy._instance = null;\nconst defaultId = \"default\";\nclass DeviceManager {\n    constructor(){\n        this._previousDevices = [];\n    }\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    get previousDevices() {\n        return this._previousDevices;\n    }\n    getDevices(kind_1) {\n        return __awaiter(this, arguments, void 0, function(kind) {\n            var _this = this;\n            let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a;\n                if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                    livekitLogger.debug(\"awaiting getUserMedia promise\");\n                    try {\n                        if (kind) {\n                            yield DeviceManager.userMediaPromiseMap.get(kind);\n                        } else {\n                            yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                        }\n                    } catch (e) {\n                        livekitLogger.warn(\"error waiting for media permissons\");\n                    }\n                }\n                let devices = yield navigator.mediaDevices.enumerateDevices();\n                if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n                !(isSafari() && _this.hasDeviceInUse(kind))) {\n                    const isDummyDeviceOrEmpty = devices.filter((d)=>d.kind === kind).length === 0 || devices.some((device)=>{\n                        const noLabel = device.label === \"\";\n                        const isRelevant = kind ? device.kind === kind : true;\n                        return noLabel && isRelevant;\n                    });\n                    if (isDummyDeviceOrEmpty) {\n                        const permissionsToAcquire = {\n                            video: kind !== \"audioinput\" && kind !== \"audiooutput\",\n                            audio: kind !== \"videoinput\" && {\n                                deviceId: {\n                                    ideal: \"default\"\n                                }\n                            }\n                        };\n                        const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                        devices = yield navigator.mediaDevices.enumerateDevices();\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                    }\n                }\n                _this._previousDevices = devices;\n                if (kind) {\n                    devices = devices.filter((device)=>device.kind === kind);\n                }\n                return devices;\n            }();\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it's 'default': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const defaultDevice = devices.find((d)=>d.deviceId === defaultId);\n            if (!defaultDevice) {\n                livekitLogger.warn(\"could not reliably determine default device\");\n                return undefined;\n            }\n            const device = devices.find((d)=>d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));\n            if (!device) {\n                livekitLogger.warn(\"could not reliably determine default device\");\n                return undefined;\n            }\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    \"audioinput\",\n    \"audiooutput\",\n    \"videoinput\"\n];\nDeviceManager.userMediaPromiseMap = new Map();\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n    QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new _();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\n/**\n * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) with [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API)\n *\n * @see https://web.dev/websocketstream/\n */ class WebSocketStream {\n    get readyState() {\n        return this.ws.readyState;\n    }\n    constructor(url){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a, _b;\n        if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            throw new DOMException(\"This operation was aborted\", \"AbortError\");\n        }\n        this.url = url;\n        const ws = new WebSocket(url, (_b = options.protocols) !== null && _b !== void 0 ? _b : []);\n        ws.binaryType = \"arraybuffer\";\n        this.ws = ws;\n        const closeWithInfo = function() {\n            let { closeCode: code, reason } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            return ws.close(code, reason);\n        };\n        this.opened = new Promise((resolve, reject)=>{\n            ws.onopen = ()=>{\n                resolve({\n                    readable: new ReadableStream({\n                        start (controller) {\n                            ws.onmessage = (_ref)=>{\n                                let { data } = _ref;\n                                return controller.enqueue(data);\n                            };\n                            ws.onerror = (e)=>controller.error(e);\n                        },\n                        cancel: closeWithInfo\n                    }),\n                    writable: new WritableStream({\n                        write (chunk) {\n                            ws.send(chunk);\n                        },\n                        abort () {\n                            ws.close();\n                        },\n                        close: closeWithInfo\n                    }),\n                    protocol: ws.protocol,\n                    extensions: ws.extensions\n                });\n                ws.removeEventListener(\"error\", reject);\n            };\n            ws.addEventListener(\"error\", reject);\n        });\n        this.closed = new Promise((resolve, reject)=>{\n            const rejectHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                    const closePromise = new Promise((res)=>{\n                        if (ws.readyState === WebSocket.CLOSED) return;\n                        else {\n                            ws.addEventListener(\"close\", (closeEv)=>{\n                                res(closeEv);\n                            }, {\n                                once: true\n                            });\n                        }\n                    });\n                    const reason = yield Promise.race([\n                        sleep(250),\n                        closePromise\n                    ]);\n                    if (!reason) {\n                        reject(new Error(\"Encountered unspecified websocket error without a timely close event\"));\n                    } else {\n                        // if we can infer the close reason from the close event then resolve the promise, we don't need to throw\n                        resolve(reason);\n                    }\n                });\n            ws.onclose = (_ref2)=>{\n                let { code, reason } = _ref2;\n                resolve({\n                    closeCode: code,\n                    reason\n                });\n                ws.removeEventListener(\"error\", rejectHandler);\n            };\n            ws.addEventListener(\"error\", rejectHandler);\n        });\n        if (options.signal) {\n            options.signal.onabort = ()=>ws.close();\n        }\n        this.close = closeWithInfo;\n    }\n}\nfunction createRtcUrl(url, searchParams) {\n    const urlObj = new URL(toWebsocketUrl(url));\n    searchParams.forEach((value, key)=>{\n        urlObj.searchParams.set(key, value);\n    });\n    return appendUrlPath(urlObj, \"rtc\");\n}\nfunction createValidateUrl(rtcWsUrl) {\n    const urlObj = new URL(toHttpUrl(rtcWsUrl));\n    return appendUrlPath(urlObj, \"validate\");\n}\nfunction ensureTrailingSlash(path) {\n    return path.endsWith(\"/\") ? path : \"\".concat(path, \"/\");\n}\nfunction appendUrlPath(urlObj, path) {\n    urlObj.pathname = \"\".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);\n    return urlObj.toString();\n}\nfunction parseSignalResponse(value) {\n    if (typeof value === \"string\") {\n        return SignalResponse.fromJson(JSON.parse(value), {\n            ignoreUnknownFields: true\n        });\n    } else if (value instanceof ArrayBuffer) {\n        return SignalResponse.fromBinary(new Uint8Array(value));\n    }\n    throw new Error(\"could not decode websocket message: \".concat(typeof value));\n}\nfunction getAbortReasonAsString(signal) {\n    let defaultMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Unknown reason\";\n    if (!(signal instanceof AbortSignal)) {\n        return defaultMessage;\n    }\n    const reason = signal.reason;\n    switch(typeof reason){\n        case \"string\":\n            return reason;\n        case \"object\":\n            return reason instanceof Error ? reason.message : defaultMessage;\n        default:\n            return \"toString\" in reason ? reason.toString() : defaultMessage;\n    }\n}\nconst passThroughQueueSignals = [\n    \"syncState\",\n    \"trickle\",\n    \"offer\",\n    \"answer\",\n    \"simulate\",\n    \"leave\"\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace(\"request allowed to bypass queue:\", {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** specifies how much time (in ms) we allow for the ws to close its connection gracefully before continuing */ const MAX_WS_CLOSE_TIME = 250;\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    get isEstablishingConnection() {\n        return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n    }\n    getNextRequestId() {\n        this._requestId += 1;\n        return this._requestId;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        this.log = livekitLogger;\n        this._requestId = 0;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n            this.onMediaSectionsRequirement = undefined;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new _();\n        this.connectionLock = new _();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    get logContext() {\n        var _a, _b;\n        return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we'd want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                this.log.warn(\"attempted to reconnect without signal options being set, ignoring\", this.logContext);\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.connectionLock.lock();\n            this.connectOptions = opts;\n            const clientInfo = getClientInfo();\n            const params = opts.singlePeerConnection ? createJoinRequestConnectionParams(token, clientInfo, opts) : createConnectionParams(token, clientInfo, opts);\n            const rtcUrl = createRtcUrl(url, params);\n            const validateUrl = createValidateUrl(rtcUrl);\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    try {\n                        let alreadyAborted = false;\n                        const abortHandler = (eventOrError)=>__awaiter(this, void 0, void 0, function*() {\n                                if (alreadyAborted) {\n                                    return;\n                                }\n                                alreadyAborted = true;\n                                const target = eventOrError instanceof Event ? eventOrError.currentTarget : eventOrError;\n                                const reason = getAbortReasonAsString(target, \"Abort handler called\");\n                                // send leave if we have an active stream writer (connection is open)\n                                if (this.streamWriter && !this.isDisconnected) {\n                                    this.sendLeave().then(()=>this.close(reason)).catch((e)=>{\n                                        this.log.error(e);\n                                        this.close();\n                                    });\n                                } else {\n                                    this.close();\n                                }\n                                cleanupAbortHandlers();\n                                reject(target instanceof AbortSignal ? target.reason : target);\n                            });\n                        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", abortHandler);\n                        const cleanupAbortHandlers = ()=>{\n                            clearTimeout(wsTimeout);\n                            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                        };\n                        const wsTimeout = setTimeout(()=>{\n                            abortHandler(new ConnectionError(\"room connection has timed out (signal)\", ConnectionErrorReason.ServerUnreachable));\n                        }, opts.websocketTimeout);\n                        const handleSignalConnected = (connection, firstMessage)=>{\n                            this.handleSignalConnected(connection, wsTimeout, firstMessage);\n                        };\n                        const redactedUrl = new URL(rtcUrl);\n                        if (redactedUrl.searchParams.has(\"access_token\")) {\n                            redactedUrl.searchParams.set(\"access_token\", \"<redacted>\");\n                        }\n                        this.log.debug(\"connecting to \".concat(redactedUrl), Object.assign({\n                            reconnect: opts.reconnect,\n                            reconnectReason: opts.reconnectReason\n                        }, this.logContext));\n                        if (this.ws) {\n                            yield this.close(false);\n                        }\n                        this.ws = new WebSocketStream(rtcUrl);\n                        try {\n                            this.ws.closed.then((closeInfo)=>{\n                                var _a;\n                                if (this.isEstablishingConnection) {\n                                    reject(new ConnectionError(\"Websocket got closed during a (re)connection attempt: \".concat(closeInfo.reason), ConnectionErrorReason.InternalError));\n                                }\n                                if (closeInfo.closeCode !== 1000) {\n                                    this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n                                        reason: closeInfo.reason,\n                                        code: closeInfo.closeCode,\n                                        wasClean: closeInfo.closeCode === 1000,\n                                        state: this.state\n                                    }));\n                                    if (this.state === SignalConnectionState.CONNECTED) {\n                                        this.handleOnClose((_a = closeInfo.reason) !== null && _a !== void 0 ? _a : \"Unexpected WS error\");\n                                    }\n                                }\n                                return;\n                            }).catch((reason)=>{\n                                if (this.isEstablishingConnection) {\n                                    reject(new ConnectionError(\"Websocket error during a (re)connection attempt: \".concat(reason), ConnectionErrorReason.InternalError));\n                                }\n                            });\n                            const connection = yield this.ws.opened.catch((reason)=>__awaiter(this, void 0, void 0, function*() {\n                                    if (this.state !== SignalConnectionState.CONNECTED) {\n                                        this.state = SignalConnectionState.DISCONNECTED;\n                                        clearTimeout(wsTimeout);\n                                        const error = yield this.handleConnectionError(reason, validateUrl);\n                                        reject(error);\n                                        return;\n                                    }\n                                    // other errors, handle\n                                    this.handleWSError(reason);\n                                    reject(reason);\n                                    return;\n                                }));\n                            clearTimeout(wsTimeout);\n                            if (!connection) {\n                                return;\n                            }\n                            const signalReader = connection.readable.getReader();\n                            this.streamWriter = connection.writable.getWriter();\n                            const firstMessage = yield signalReader.read();\n                            signalReader.releaseLock();\n                            if (!firstMessage.value) {\n                                throw new ConnectionError(\"no message received as first message\", ConnectionErrorReason.InternalError);\n                            }\n                            const firstSignalResponse = parseSignalResponse(firstMessage.value);\n                            // Validate the first message\n                            const validation = this.validateFirstMessage(firstSignalResponse, (_a = opts.reconnect) !== null && _a !== void 0 ? _a : false);\n                            if (!validation.isValid) {\n                                reject(validation.error);\n                                return;\n                            }\n                            // Handle join response - set up ping configuration\n                            if (((_b = firstSignalResponse.message) === null || _b === void 0 ? void 0 : _b.case) === \"join\") {\n                                this.pingTimeoutDuration = firstSignalResponse.message.value.pingTimeout;\n                                this.pingIntervalDuration = firstSignalResponse.message.value.pingInterval;\n                                if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                    this.log.debug(\"ping config\", Object.assign(Object.assign({}, this.logContext), {\n                                        timeout: this.pingTimeoutDuration,\n                                        interval: this.pingIntervalDuration\n                                    }));\n                                }\n                            }\n                            // Handle successful connection\n                            const firstMessageToProcess = validation.shouldProcessFirstMessage ? firstSignalResponse : undefined;\n                            handleSignalConnected(connection, firstMessageToProcess);\n                            resolve(validation.response);\n                        } catch (e) {\n                            reject(e);\n                        } finally{\n                            cleanupAbortHandlers();\n                        }\n                    } finally{\n                        unlock();\n                    }\n                }));\n        });\n    }\n    startReadingLoop(signalReader, firstMessage) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (firstMessage) {\n                this.handleSignalResponse(firstMessage);\n            }\n            while(true){\n                if (this.signalLatency) {\n                    yield sleep(this.signalLatency);\n                }\n                const { done, value } = yield signalReader.read();\n                if (done) {\n                    break;\n                }\n                const resp = parseSignalResponse(value);\n                this.handleSignalResponse(resp);\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this = this;\n            let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Close method called on signal client\";\n            return function*() {\n                if ([\n                    SignalConnectionState.DISCONNECTING || SignalConnectionState.DISCONNECTED\n                ].includes(_this.state)) {\n                    _this.log.debug(\"ignoring signal close as it's already in disconnecting state\");\n                    return;\n                }\n                const unlock = yield _this.closingLock.lock();\n                try {\n                    _this.clearPingInterval();\n                    if (updateState) {\n                        _this.state = SignalConnectionState.DISCONNECTING;\n                    }\n                    if (_this.ws) {\n                        _this.ws.close({\n                            closeCode: 1000,\n                            reason\n                        });\n                        // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                        const closePromise = _this.ws.closed;\n                        _this.ws = undefined;\n                        _this.streamWriter = undefined;\n                        yield Promise.race([\n                            closePromise,\n                            sleep(MAX_WS_CLOSE_TIME)\n                        ]);\n                    }\n                } catch (e) {\n                    _this.log.debug(\"websocket error while closing\", Object.assign(Object.assign({}, _this.logContext), {\n                        error: e\n                    }));\n                } finally{\n                    if (updateState) {\n                        _this.state = SignalConnectionState.DISCONNECTED;\n                    }\n                    unlock();\n                }\n            }();\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer, offerId) {\n        this.log.debug(\"sending offer\", Object.assign(Object.assign({}, this.logContext), {\n            offerSdp: offer.sdp\n        }));\n        this.sendRequest({\n            case: \"offer\",\n            value: toProtoSessionDescription(offer, offerId)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer, offerId) {\n        this.log.debug(\"sending answer\", Object.assign(Object.assign({}, this.logContext), {\n            answerSdp: answer.sdp\n        }));\n        return this.sendRequest({\n            case: \"answer\",\n            value: toProtoSessionDescription(answer, offerId)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        this.log.debug(\"sending ice candidate\", Object.assign(Object.assign({}, this.logContext), {\n            candidate\n        }));\n        return this.sendRequest({\n            case: \"trickle\",\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: \"mute\",\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: \"addTrack\",\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata_1, name_1) {\n        return __awaiter(this, arguments, void 0, function(metadata, name) {\n            var _this2 = this;\n            let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            return function*() {\n                const requestId = _this2.getNextRequestId();\n                yield _this2.sendRequest({\n                    case: \"updateMetadata\",\n                    value: new UpdateParticipantMetadata({\n                        requestId,\n                        metadata,\n                        name,\n                        attributes\n                    })\n                });\n                return requestId;\n            }();\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: \"trackSetting\",\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: \"subscription\",\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: \"syncState\",\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: \"updateLayers\",\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: \"subscriptionPermission\",\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: \"simulate\",\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: \"ping\",\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: \"pingReq\",\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendUpdateLocalAudioTrack(trackSid, features) {\n        return this.sendRequest({\n            case: \"updateAudioTrack\",\n            value: new UpdateLocalAudioTrack({\n                trackSid,\n                features\n            })\n        });\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: \"leave\",\n            value: new LeaveRequest({\n                reason: DisconnectReason.CLIENT_INITIATED,\n                // server doesn't process this field, keeping it here to indicate the intent of a full disconnect\n                action: LeaveRequest_Action.DISCONNECT\n            })\n        });\n    }\n    sendRequest(message_1) {\n        return __awaiter(this, arguments, void 0, function(message) {\n            var _this3 = this;\n            let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            return function*() {\n                // capture all requests while reconnecting and put them in a queue\n                // unless the request originates from the queue, then don't enqueue again\n                const canQueue = !fromQueue && !canPassThroughQueue(message);\n                if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {\n                    _this3.queuedRequests.push(()=>__awaiter(_this3, void 0, void 0, function*() {\n                            yield this.sendRequest(message, true);\n                        }));\n                    return;\n                }\n                // make sure previously queued requests are being sent first\n                if (!fromQueue) {\n                    yield _this3.requestQueue.flush();\n                }\n                if (_this3.signalLatency) {\n                    yield sleep(_this3.signalLatency);\n                }\n                if (_this3.isDisconnected) {\n                    // Skip requests if the signal layer is disconnected\n                    // This can happen if an event is sent in the mist of room.connect() initializing\n                    _this3.log.debug(\"skipping signal request (type: \".concat(message.case, \") - SignalClient disconnected\"));\n                    return;\n                }\n                if (!_this3.streamWriter) {\n                    _this3.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);\n                    return;\n                }\n                const req = new SignalRequest({\n                    message\n                });\n                try {\n                    if (_this3.useJSON) {\n                        yield _this3.streamWriter.write(req.toJsonString());\n                    } else {\n                        yield _this3.streamWriter.write(req.toBinary());\n                    }\n                } catch (e) {\n                    _this3.log.error(\"error sending signal message\", Object.assign(Object.assign({}, _this3.logContext), {\n                        error: e\n                    }));\n                }\n            }();\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            this.log.debug(\"received unsupported message\", this.logContext);\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === \"answer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd, msg.value.id, msg.value.midToTrackId);\n            }\n        } else if (msg.case === \"offer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd, msg.value.id, msg.value.midToTrackId);\n            }\n        } else if (msg.case === \"trickle\") {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === \"update\") {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === \"trackPublished\") {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === \"speakersChanged\") {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === \"leave\") {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === \"mute\") {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === \"roomUpdate\") {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === \"connectionQuality\") {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === \"streamStateUpdate\") {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscribedQualityUpdate\") {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscriptionPermissionUpdate\") {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === \"refreshToken\") {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === \"trackUnpublished\") {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === \"subscriptionResponse\") {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === \"pong\") ;\n        else if (msg.case === \"pongResp\") {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else if (msg.case === \"requestResponse\") {\n            if (this.onRequestResponse) {\n                this.onRequestResponse(msg.value);\n            }\n        } else if (msg.case === \"trackSubscribed\") {\n            if (this.onLocalTrackSubscribed) {\n                this.onLocalTrackSubscribed(msg.value.trackSid);\n            }\n        } else if (msg.case === \"roomMoved\") {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value.token);\n            }\n            if (this.onRoomMoved) {\n                this.onRoomMoved(msg.value);\n            }\n        } else if (msg.case === \"mediaSectionsRequirement\") {\n            if (this.onMediaSectionsRequirement) {\n                this.onMediaSectionsRequirement(msg.value);\n            }\n        } else {\n            this.log.debug(\"unsupported message\", Object.assign(Object.assign({}, this.logContext), {\n                msgCase: msg.case\n            }));\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close(undefined, reason);\n            this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n                reason\n            }));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(error) {\n        this.log.error(\"websocket error\", Object.assign(Object.assign({}, this.logContext), {\n            error\n        }));\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            this.log.warn(\"ping timeout duration not set\", this.logContext);\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n            this.handleOnClose(\"ping timeout\");\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            this.log.warn(\"ping interval duration not set\", this.logContext);\n            return;\n        }\n        this.log.debug(\"start ping interval\", this.logContext);\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        this.log.debug(\"clearing ping interval\", this.logContext);\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n    /**\n   * Handles the successful connection to the signal server\n   * @param connection The WebSocket connection\n   * @param timeoutHandle The timeout handle to clear\n   * @param firstMessage Optional first message to process\n   * @internal\n   */ handleSignalConnected(connection, timeoutHandle, firstMessage) {\n        this.state = SignalConnectionState.CONNECTED;\n        clearTimeout(timeoutHandle);\n        this.startPingInterval();\n        this.startReadingLoop(connection.readable.getReader(), firstMessage);\n    }\n    /**\n   * Validates the first message received from the signal server\n   * @param firstSignalResponse The first signal response received\n   * @param isReconnect Whether this is a reconnection attempt\n   * @returns Validation result with response or error\n   * @internal\n   */ validateFirstMessage(firstSignalResponse, isReconnect) {\n        var _a, _b, _c, _d, _e;\n        if (((_a = firstSignalResponse.message) === null || _a === void 0 ? void 0 : _a.case) === \"join\") {\n            return {\n                isValid: true,\n                response: firstSignalResponse.message.value\n            };\n        } else if (this.state === SignalConnectionState.RECONNECTING && ((_b = firstSignalResponse.message) === null || _b === void 0 ? void 0 : _b.case) !== \"leave\") {\n            if (((_c = firstSignalResponse.message) === null || _c === void 0 ? void 0 : _c.case) === \"reconnect\") {\n                return {\n                    isValid: true,\n                    response: firstSignalResponse.message.value\n                };\n            } else {\n                // in reconnecting, any message received means signal reconnected and we still need to process it\n                this.log.debug(\"declaring signal reconnected without reconnect response received\", this.logContext);\n                return {\n                    isValid: true,\n                    response: undefined,\n                    shouldProcessFirstMessage: true\n                };\n            }\n        } else if (this.isEstablishingConnection && ((_d = firstSignalResponse.message) === null || _d === void 0 ? void 0 : _d.case) === \"leave\") {\n            return {\n                isValid: false,\n                error: new ConnectionError(\"Received leave request while trying to (re)connect\", ConnectionErrorReason.LeaveRequest, undefined, firstSignalResponse.message.value.reason)\n            };\n        } else if (!isReconnect) {\n            // non-reconnect case, should receive join response first\n            return {\n                isValid: false,\n                error: new ConnectionError(\"did not receive join response, got \".concat((_e = firstSignalResponse.message) === null || _e === void 0 ? void 0 : _e.case, \" instead\"), ConnectionErrorReason.InternalError)\n            };\n        }\n        return {\n            isValid: false,\n            error: new ConnectionError(\"Unexpected first message\", ConnectionErrorReason.InternalError)\n        };\n    }\n    /**\n   * Handles WebSocket connection errors by validating with the server\n   * @param reason The error that occurred\n   * @param validateUrl The URL to validate the connection with\n   * @returns A ConnectionError with appropriate reason and status\n   * @internal\n   */ handleConnectionError(reason, validateUrl) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const resp = yield fetch(validateUrl);\n                if (resp.status.toFixed(0).startsWith(\"4\")) {\n                    const msg = yield resp.text();\n                    return new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status);\n                } else if (reason instanceof ConnectionError) {\n                    return reason;\n                } else {\n                    return new ConnectionError(\"Encountered unknown websocket error during connection: \".concat(reason), ConnectionErrorReason.InternalError, resp.status);\n                }\n            } catch (e) {\n                return e instanceof ConnectionError ? e : new ConnectionError(e instanceof Error ? e.message : \"server was not reachable\", ConnectionErrorReason.ServerUnreachable);\n            }\n        });\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: \"offer\",\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case \"answer\":\n        case \"offer\":\n        case \"pranswer\":\n        case \"rollback\":\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd, id) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type,\n        id\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set(\"access_token\", token);\n    // opts\n    if (opts.reconnect) {\n        params.set(\"reconnect\", \"1\");\n        if (opts.sid) {\n            params.set(\"sid\", opts.sid);\n        }\n    }\n    params.set(\"auto_subscribe\", opts.autoSubscribe ? \"1\" : \"0\");\n    // ClientInfo\n    params.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\");\n    params.set(\"version\", info.version);\n    params.set(\"protocol\", info.protocol.toString());\n    if (info.deviceModel) {\n        params.set(\"device_model\", info.deviceModel);\n    }\n    if (info.os) {\n        params.set(\"os\", info.os);\n    }\n    if (info.osVersion) {\n        params.set(\"os_version\", info.osVersion);\n    }\n    if (info.browser) {\n        params.set(\"browser\", info.browser);\n    }\n    if (info.browserVersion) {\n        params.set(\"browser_version\", info.browserVersion);\n    }\n    if (opts.adaptiveStream) {\n        params.set(\"adaptive_stream\", \"1\");\n    }\n    if (opts.reconnectReason) {\n        params.set(\"reconnect_reason\", opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set(\"network\", navigator.connection.type);\n    }\n    return params;\n}\nfunction createJoinRequestConnectionParams(token, info, opts) {\n    const params = new URLSearchParams();\n    params.set(\"access_token\", token);\n    const joinRequest = new JoinRequest({\n        clientInfo: info,\n        connectionSettings: new ConnectionSettings({\n            autoSubscribe: !!opts.autoSubscribe,\n            adaptiveStream: !!opts.adaptiveStream\n        }),\n        reconnect: !!opts.reconnect,\n        participantSid: opts.sid ? opts.sid : undefined\n    });\n    if (opts.reconnectReason) {\n        joinRequest.reconnectReason = opts.reconnectReason;\n    }\n    const wrappedJoinRequest = new WrappedJoinRequest({\n        joinRequest: joinRequest.toBinary()\n    });\n    params.set(\"join_request\", btoa(new TextDecoder(\"utf-8\").decode(wrappedJoinRequest.toBinary())));\n    return params;\n}\nclass DataPacketBuffer {\n    constructor(){\n        this.buffer = [];\n        this._totalSize = 0;\n    }\n    push(item) {\n        this.buffer.push(item);\n        this._totalSize += item.data.byteLength;\n    }\n    pop() {\n        const item = this.buffer.shift();\n        if (item) {\n            this._totalSize -= item.data.byteLength;\n        }\n        return item;\n    }\n    getAll() {\n        return this.buffer.slice();\n    }\n    popToSequence(sequence) {\n        while(this.buffer.length > 0){\n            const first = this.buffer[0];\n            if (first.sequence <= sequence) {\n                this.pop();\n            } else {\n                break;\n            }\n        }\n    }\n    alignBufferedAmount(bufferedAmount) {\n        while(this.buffer.length > 0){\n            const first = this.buffer[0];\n            if (this._totalSize - first.data.byteLength <= bufferedAmount) {\n                break;\n            }\n            this.pop();\n        }\n    }\n    get length() {\n        return this.buffer.length;\n    }\n}\nclass TTLMap {\n    /**\n   * @param ttl ttl of the key (ms)\n   */ constructor(ttl){\n        this._map = new Map();\n        this._lastCleanup = 0;\n        this.ttl = ttl;\n    }\n    set(key, value) {\n        const now = Date.now();\n        if (now - this._lastCleanup > this.ttl / 2) {\n            this.cleanup();\n        }\n        const expiresAt = now + this.ttl;\n        this._map.set(key, {\n            value,\n            expiresAt\n        });\n        return this;\n    }\n    get(key) {\n        const entry = this._map.get(key);\n        if (!entry) return undefined;\n        if (entry.expiresAt < Date.now()) {\n            this._map.delete(key);\n            return undefined;\n        }\n        return entry.value;\n    }\n    has(key) {\n        const entry = this._map.get(key);\n        if (!entry) return false;\n        if (entry.expiresAt < Date.now()) {\n            this._map.delete(key);\n            return false;\n        }\n        return true;\n    }\n    delete(key) {\n        return this._map.delete(key);\n    }\n    clear() {\n        this._map.clear();\n    }\n    cleanup() {\n        const now = Date.now();\n        for (const [key, entry] of this._map.entries()){\n            if (entry.expiresAt < now) {\n                this._map.delete(key);\n            }\n        }\n        this._lastCleanup = now;\n    }\n    get size() {\n        this.cleanup();\n        return this._map.size;\n    }\n    forEach(callback) {\n        this.cleanup();\n        for (const [key, entry] of this._map.entries()){\n            if (entry.expiresAt >= Date.now()) {\n                callback(entry.value, key, this.asValueMap());\n            }\n        }\n    }\n    map(callback) {\n        this.cleanup();\n        const result = [];\n        const valueMap = this.asValueMap();\n        for (const [key, value] of valueMap.entries()){\n            result.push(callback(value, key, valueMap));\n        }\n        return result;\n    }\n    asValueMap() {\n        const result = new Map();\n        for (const [key, entry] of this._map.entries()){\n            if (entry.expiresAt >= Date.now()) {\n                result.set(key, entry.value);\n            }\n        }\n        return result;\n    }\n}\nvar lib = {};\nvar parser = {};\nvar grammar = {\n    exports: {}\n};\nvar hasRequiredGrammar;\nfunction requireGrammar() {\n    if (hasRequiredGrammar) return grammar.exports;\n    hasRequiredGrammar = 1;\n    var grammar$1 = grammar.exports = {\n        v: [\n            {\n                name: \"version\",\n                reg: /^(\\d*)$/\n            }\n        ],\n        o: [\n            {\n                // o=- 20518 0 IN IP4 203.0.113.1\n                // NB: sessionId will be a String in most cases because it is huge\n                name: \"origin\",\n                reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n                names: [\n                    \"username\",\n                    \"sessionId\",\n                    \"sessionVersion\",\n                    \"netType\",\n                    \"ipVer\",\n                    \"address\"\n                ],\n                format: \"%s %s %d %s IP%d %s\"\n            }\n        ],\n        // default parsing of these only (though some of these feel outdated)\n        s: [\n            {\n                name: \"name\"\n            }\n        ],\n        i: [\n            {\n                name: \"description\"\n            }\n        ],\n        u: [\n            {\n                name: \"uri\"\n            }\n        ],\n        e: [\n            {\n                name: \"email\"\n            }\n        ],\n        p: [\n            {\n                name: \"phone\"\n            }\n        ],\n        z: [\n            {\n                name: \"timezones\"\n            }\n        ],\n        // TODO: this one can actually be parsed properly...\n        r: [\n            {\n                name: \"repeats\"\n            }\n        ],\n        // TODO: this one can also be parsed properly\n        // k: [{}], // outdated thing ignored\n        t: [\n            {\n                // t=0 0\n                name: \"timing\",\n                reg: /^(\\d*) (\\d*)/,\n                names: [\n                    \"start\",\n                    \"stop\"\n                ],\n                format: \"%d %d\"\n            }\n        ],\n        c: [\n            {\n                // c=IN IP4 10.47.197.26\n                name: \"connection\",\n                reg: /^IN IP(\\d) (\\S*)/,\n                names: [\n                    \"version\",\n                    \"ip\"\n                ],\n                format: \"IN IP%d %s\"\n            }\n        ],\n        b: [\n            {\n                // b=AS:4000\n                push: \"bandwidth\",\n                reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n                names: [\n                    \"type\",\n                    \"limit\"\n                ],\n                format: \"%s:%s\"\n            }\n        ],\n        m: [\n            {\n                // m=video 51744 RTP/AVP 126 97 98 34 31\n                // NB: special - pushes to session\n                // TODO: rtp/fmtp should be filtered by the payloads found here?\n                reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n                names: [\n                    \"type\",\n                    \"port\",\n                    \"protocol\",\n                    \"payloads\"\n                ],\n                format: \"%s %d %s %s\"\n            }\n        ],\n        a: [\n            {\n                // a=rtpmap:110 opus/48000/2\n                push: \"rtp\",\n                reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n                names: [\n                    \"payload\",\n                    \"codec\",\n                    \"rate\",\n                    \"encoding\"\n                ],\n                format: function(o) {\n                    return o.encoding ? \"rtpmap:%d %s/%s/%s\" : o.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n                }\n            },\n            {\n                // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n                // a=fmtp:111 minptime=10; useinbandfec=1\n                push: \"fmtp\",\n                reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n                names: [\n                    \"payload\",\n                    \"config\"\n                ],\n                format: \"fmtp:%d %s\"\n            },\n            {\n                // a=control:streamid=0\n                name: \"control\",\n                reg: /^control:(.*)/,\n                format: \"control:%s\"\n            },\n            {\n                // a=rtcp:65179 IN IP4 193.84.77.194\n                name: \"rtcp\",\n                reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n                names: [\n                    \"port\",\n                    \"netType\",\n                    \"ipVer\",\n                    \"address\"\n                ],\n                format: function(o) {\n                    return o.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n                }\n            },\n            {\n                // a=rtcp-fb:98 trr-int 100\n                push: \"rtcpFbTrrInt\",\n                reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n                names: [\n                    \"payload\",\n                    \"value\"\n                ],\n                format: \"rtcp-fb:%s trr-int %d\"\n            },\n            {\n                // a=rtcp-fb:98 nack rpsi\n                push: \"rtcpFb\",\n                reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n                names: [\n                    \"payload\",\n                    \"type\",\n                    \"subtype\"\n                ],\n                format: function(o) {\n                    return o.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n                }\n            },\n            {\n                // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n                // a=extmap:1/recvonly URI-gps-string\n                // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n                push: \"ext\",\n                reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"value\",\n                    \"direction\",\n                    \"encrypt-uri\",\n                    \"uri\",\n                    \"config\"\n                ],\n                format: function(o) {\n                    return \"extmap:%d\" + (o.direction ? \"/%s\" : \"%v\") + (o[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (o.config ? \" %s\" : \"\");\n                }\n            },\n            {\n                // a=extmap-allow-mixed\n                name: \"extmapAllowMixed\",\n                reg: /^(extmap-allow-mixed)/\n            },\n            {\n                // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n                push: \"crypto\",\n                reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"id\",\n                    \"suite\",\n                    \"config\",\n                    \"sessionConfig\"\n                ],\n                format: function(o) {\n                    return o.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n                }\n            },\n            {\n                // a=setup:actpass\n                name: \"setup\",\n                reg: /^setup:(\\w*)/,\n                format: \"setup:%s\"\n            },\n            {\n                // a=connection:new\n                name: \"connectionType\",\n                reg: /^connection:(new|existing)/,\n                format: \"connection:%s\"\n            },\n            {\n                // a=mid:1\n                name: \"mid\",\n                reg: /^mid:([^\\s]*)/,\n                format: \"mid:%s\"\n            },\n            {\n                // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n                name: \"msid\",\n                reg: /^msid:(.*)/,\n                format: \"msid:%s\"\n            },\n            {\n                // a=ptime:20\n                name: \"ptime\",\n                reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n                format: \"ptime:%d\"\n            },\n            {\n                // a=maxptime:60\n                name: \"maxptime\",\n                reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n                format: \"maxptime:%d\"\n            },\n            {\n                // a=sendrecv\n                name: \"direction\",\n                reg: /^(sendrecv|recvonly|sendonly|inactive)/\n            },\n            {\n                // a=ice-lite\n                name: \"icelite\",\n                reg: /^(ice-lite)/\n            },\n            {\n                // a=ice-ufrag:F7gI\n                name: \"iceUfrag\",\n                reg: /^ice-ufrag:(\\S*)/,\n                format: \"ice-ufrag:%s\"\n            },\n            {\n                // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n                name: \"icePwd\",\n                reg: /^ice-pwd:(\\S*)/,\n                format: \"ice-pwd:%s\"\n            },\n            {\n                // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n                name: \"fingerprint\",\n                reg: /^fingerprint:(\\S*) (\\S*)/,\n                names: [\n                    \"type\",\n                    \"hash\"\n                ],\n                format: \"fingerprint:%s %s\"\n            },\n            {\n                // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n                // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n                // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n                // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n                // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n                push: \"candidates\",\n                reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n                names: [\n                    \"foundation\",\n                    \"component\",\n                    \"transport\",\n                    \"priority\",\n                    \"ip\",\n                    \"port\",\n                    \"type\",\n                    \"raddr\",\n                    \"rport\",\n                    \"tcptype\",\n                    \"generation\",\n                    \"network-id\",\n                    \"network-cost\"\n                ],\n                format: function(o) {\n                    var str = \"candidate:%s %d %s %d %s %d typ %s\";\n                    str += o.raddr != null ? \" raddr %s rport %d\" : \"%v%v\";\n                    // NB: candidate has three optional chunks, so %void middles one if it's missing\n                    str += o.tcptype != null ? \" tcptype %s\" : \"%v\";\n                    if (o.generation != null) {\n                        str += \" generation %d\";\n                    }\n                    str += o[\"network-id\"] != null ? \" network-id %d\" : \"%v\";\n                    str += o[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\";\n                    return str;\n                }\n            },\n            {\n                // a=end-of-candidates (keep after the candidates line for readability)\n                name: \"endOfCandidates\",\n                reg: /^(end-of-candidates)/\n            },\n            {\n                // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n                name: \"remoteCandidates\",\n                reg: /^remote-candidates:(.*)/,\n                format: \"remote-candidates:%s\"\n            },\n            {\n                // a=ice-options:google-ice\n                name: \"iceOptions\",\n                reg: /^ice-options:(\\S*)/,\n                format: \"ice-options:%s\"\n            },\n            {\n                // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n                push: \"ssrcs\",\n                reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n                names: [\n                    \"id\",\n                    \"attribute\",\n                    \"value\"\n                ],\n                format: function(o) {\n                    var str = \"ssrc:%d\";\n                    if (o.attribute != null) {\n                        str += \" %s\";\n                        if (o.value != null) {\n                            str += \":%s\";\n                        }\n                    }\n                    return str;\n                }\n            },\n            {\n                // a=ssrc-group:FEC 1 2\n                // a=ssrc-group:FEC-FR 3004364195 1080772241\n                push: \"ssrcGroups\",\n                // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n                reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n                names: [\n                    \"semantics\",\n                    \"ssrcs\"\n                ],\n                format: \"ssrc-group:%s %s\"\n            },\n            {\n                // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n                name: \"msidSemantic\",\n                reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n                names: [\n                    \"semantic\",\n                    \"token\"\n                ],\n                format: \"msid-semantic: %s %s\" // space after ':' is not accidental\n            },\n            {\n                // a=group:BUNDLE audio video\n                push: \"groups\",\n                reg: /^group:(\\w*) (.*)/,\n                names: [\n                    \"type\",\n                    \"mids\"\n                ],\n                format: \"group:%s %s\"\n            },\n            {\n                // a=rtcp-mux\n                name: \"rtcpMux\",\n                reg: /^(rtcp-mux)/\n            },\n            {\n                // a=rtcp-rsize\n                name: \"rtcpRsize\",\n                reg: /^(rtcp-rsize)/\n            },\n            {\n                // a=sctpmap:5000 webrtc-datachannel 1024\n                name: \"sctpmap\",\n                reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"sctpmapNumber\",\n                    \"app\",\n                    \"maxMessageSize\"\n                ],\n                format: function(o) {\n                    return o.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n                }\n            },\n            {\n                // a=x-google-flag:conference\n                name: \"xGoogleFlag\",\n                reg: /^x-google-flag:([^\\s]*)/,\n                format: \"x-google-flag:%s\"\n            },\n            {\n                // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n                push: \"rids\",\n                reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n                names: [\n                    \"id\",\n                    \"direction\",\n                    \"params\"\n                ],\n                format: function(o) {\n                    return o.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n                }\n            },\n            {\n                // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n                // a=imageattr:* send [x=800,y=640] recv *\n                // a=imageattr:100 recv [x=320,y=240]\n                push: \"imageattrs\",\n                reg: new RegExp(// a=imageattr:97\n                \"^imageattr:(\\\\d+|\\\\*)\" + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n                \"[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)\" + // recv [x=330,y=250]\n                \"(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"),\n                names: [\n                    \"pt\",\n                    \"dir1\",\n                    \"attrs1\",\n                    \"dir2\",\n                    \"attrs2\"\n                ],\n                format: function(o) {\n                    return \"imageattr:%s %s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n                }\n            },\n            {\n                // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n                // a=simulcast:recv 1;4,5 send 6;7\n                name: \"simulcast\",\n                reg: new RegExp(// a=simulcast:\n                \"^simulcast:\" + // send 1,2,3;~4,~5\n                \"(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)\" + // space + recv 6;~7,~8\n                \"(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?\" + // end\n                \"$\"),\n                names: [\n                    \"dir1\",\n                    \"list1\",\n                    \"dir2\",\n                    \"list2\"\n                ],\n                format: function(o) {\n                    return \"simulcast:%s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n                }\n            },\n            {\n                // old simulcast draft 03 (implemented by Firefox)\n                //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n                // a=simulcast: recv pt=97;98 send pt=97\n                // a=simulcast: send rid=5;6;7 paused=6,7\n                name: \"simulcast_03\",\n                reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n                names: [\n                    \"value\"\n                ],\n                format: \"simulcast: %s\"\n            },\n            {\n                // a=framerate:25\n                // a=framerate:29.97\n                name: \"framerate\",\n                reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n                format: \"framerate:%s\"\n            },\n            {\n                // RFC4570\n                // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n                name: \"sourceFilter\",\n                reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n                names: [\n                    \"filterMode\",\n                    \"netType\",\n                    \"addressTypes\",\n                    \"destAddress\",\n                    \"srcList\"\n                ],\n                format: \"source-filter: %s %s %s %s %s\"\n            },\n            {\n                // a=bundle-only\n                name: \"bundleOnly\",\n                reg: /^(bundle-only)/\n            },\n            {\n                // a=label:1\n                name: \"label\",\n                reg: /^label:(.+)/,\n                format: \"label:%s\"\n            },\n            {\n                // RFC version 26 for SCTP over DTLS\n                // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n                name: \"sctpPort\",\n                reg: /^sctp-port:(\\d+)$/,\n                format: \"sctp-port:%s\"\n            },\n            {\n                // RFC version 26 for SCTP over DTLS\n                // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n                name: \"maxMessageSize\",\n                reg: /^max-message-size:(\\d+)$/,\n                format: \"max-message-size:%s\"\n            },\n            {\n                // RFC7273\n                // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n                push: \"tsRefClocks\",\n                reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n                names: [\n                    \"clksrc\",\n                    \"clksrcExt\"\n                ],\n                format: function(o) {\n                    return \"ts-refclk:%s\" + (o.clksrcExt != null ? \"=%s\" : \"\");\n                }\n            },\n            {\n                // RFC7273\n                // a=mediaclk:direct=963214424\n                name: \"mediaClk\",\n                reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n                names: [\n                    \"id\",\n                    \"mediaClockName\",\n                    \"mediaClockValue\",\n                    \"rateNumerator\",\n                    \"rateDenominator\"\n                ],\n                format: function(o) {\n                    var str = \"mediaclk:\";\n                    str += o.id != null ? \"id=%s %s\" : \"%v%s\";\n                    str += o.mediaClockValue != null ? \"=%s\" : \"\";\n                    str += o.rateNumerator != null ? \" rate=%s\" : \"\";\n                    str += o.rateDenominator != null ? \"/%s\" : \"\";\n                    return str;\n                }\n            },\n            {\n                // a=keywds:keywords\n                name: \"keywords\",\n                reg: /^keywds:(.+)$/,\n                format: \"keywds:%s\"\n            },\n            {\n                // a=content:main\n                name: \"content\",\n                reg: /^content:(.+)/,\n                format: \"content:%s\"\n            },\n            // BFCP https://tools.ietf.org/html/rfc4583\n            {\n                // a=floorctrl:c-s\n                name: \"bfcpFloorCtrl\",\n                reg: /^floorctrl:(c-only|s-only|c-s)/,\n                format: \"floorctrl:%s\"\n            },\n            {\n                // a=confid:1\n                name: \"bfcpConfId\",\n                reg: /^confid:(\\d+)/,\n                format: \"confid:%s\"\n            },\n            {\n                // a=userid:1\n                name: \"bfcpUserId\",\n                reg: /^userid:(\\d+)/,\n                format: \"userid:%s\"\n            },\n            {\n                // a=floorid:1\n                name: \"bfcpFloorId\",\n                reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n                names: [\n                    \"id\",\n                    \"mStream\"\n                ],\n                format: \"floorid:%s mstrm:%s\"\n            },\n            {\n                // any a= that we don't understand is kept verbatim on media.invalid\n                push: \"invalid\",\n                names: [\n                    \"value\"\n                ]\n            }\n        ]\n    };\n    // set sensible defaults to avoid polluting the grammar with boring details\n    Object.keys(grammar$1).forEach(function(key) {\n        var objs = grammar$1[key];\n        objs.forEach(function(obj) {\n            if (!obj.reg) {\n                obj.reg = /(.*)/;\n            }\n            if (!obj.format) {\n                obj.format = \"%s\";\n            }\n        });\n    });\n    return grammar.exports;\n}\nvar hasRequiredParser;\nfunction requireParser() {\n    if (hasRequiredParser) return parser;\n    hasRequiredParser = 1;\n    (function(exports$1) {\n        var toIntIfInt = function(v) {\n            return String(Number(v)) === v ? Number(v) : v;\n        };\n        var attachProperties = function(match, location, names, rawName) {\n            if (rawName && !names) {\n                location[rawName] = toIntIfInt(match[1]);\n            } else {\n                for(var i = 0; i < names.length; i += 1){\n                    if (match[i + 1] != null) {\n                        location[names[i]] = toIntIfInt(match[i + 1]);\n                    }\n                }\n            }\n        };\n        var parseReg = function(obj, location, content) {\n            var needsBlank = obj.name && obj.names;\n            if (obj.push && !location[obj.push]) {\n                location[obj.push] = [];\n            } else if (needsBlank && !location[obj.name]) {\n                location[obj.name] = {};\n            }\n            var keyLocation = obj.push ? {} : // blank object that will be pushed\n            needsBlank ? location[obj.name] : location; // otherwise, named location or root\n            attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n            if (obj.push) {\n                location[obj.push].push(keyLocation);\n            }\n        };\n        var grammar = requireGrammar();\n        var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n        exports$1.parse = function(sdp) {\n            var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n            // parse lines we understand\n            sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n                var type = l[0];\n                var content = l.slice(2);\n                if (type === \"m\") {\n                    media.push({\n                        rtp: [],\n                        fmtp: []\n                    });\n                    location = media[media.length - 1]; // point at latest media line\n                }\n                for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                    var obj = grammar[type][j];\n                    if (obj.reg.test(content)) {\n                        return parseReg(obj, location, content);\n                    }\n                }\n            });\n            session.media = media; // link it up\n            return session;\n        };\n        var paramReducer = function(acc, expr) {\n            var s = expr.split(/=(.+)/, 2);\n            if (s.length === 2) {\n                acc[s[0]] = toIntIfInt(s[1]);\n            } else if (s.length === 1 && expr.length > 1) {\n                acc[s[0]] = undefined;\n            }\n            return acc;\n        };\n        exports$1.parseParams = function(str) {\n            return str.split(/;\\s?/).reduce(paramReducer, {});\n        };\n        // For backward compatibility - alias will be removed in 3.0.0\n        exports$1.parseFmtpConfig = exports$1.parseParams;\n        exports$1.parsePayloads = function(str) {\n            return str.toString().split(\" \").map(Number);\n        };\n        exports$1.parseRemoteCandidates = function(str) {\n            var candidates = [];\n            var parts = str.split(\" \").map(toIntIfInt);\n            for(var i = 0; i < parts.length; i += 3){\n                candidates.push({\n                    component: parts[i],\n                    ip: parts[i + 1],\n                    port: parts[i + 2]\n                });\n            }\n            return candidates;\n        };\n        exports$1.parseImageAttributes = function(str) {\n            return str.split(\" \").map(function(item) {\n                return item.substring(1, item.length - 1).split(\",\").reduce(paramReducer, {});\n            });\n        };\n        exports$1.parseSimulcastStreamList = function(str) {\n            return str.split(\";\").map(function(stream) {\n                return stream.split(\",\").map(function(format) {\n                    var scid, paused = false;\n                    if (format[0] !== \"~\") {\n                        scid = toIntIfInt(format);\n                    } else {\n                        scid = toIntIfInt(format.substring(1, format.length));\n                        paused = true;\n                    }\n                    return {\n                        scid: scid,\n                        paused: paused\n                    };\n                });\n            });\n        };\n    })(parser);\n    return parser;\n}\nvar writer;\nvar hasRequiredWriter;\nfunction requireWriter() {\n    if (hasRequiredWriter) return writer;\n    hasRequiredWriter = 1;\n    var grammar = requireGrammar();\n    // customized util.format - discards excess arguments and can void middle ones\n    var formatRegExp = /%[sdv%]/g;\n    var format = function(formatStr) {\n        var i = 1;\n        var args = arguments;\n        var len = args.length;\n        return formatStr.replace(formatRegExp, function(x) {\n            if (i >= len) {\n                return x; // missing argument\n            }\n            var arg = args[i];\n            i += 1;\n            switch(x){\n                case \"%%\":\n                    return \"%\";\n                case \"%s\":\n                    return String(arg);\n                case \"%d\":\n                    return Number(arg);\n                case \"%v\":\n                    return \"\";\n            }\n        });\n    // NB: we discard excess arguments - they are typically undefined from makeLine\n    };\n    var makeLine = function(type, obj, location) {\n        var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n        var args = [\n            type + \"=\" + str\n        ];\n        if (obj.names) {\n            for(var i = 0; i < obj.names.length; i += 1){\n                var n = obj.names[i];\n                if (obj.name) {\n                    args.push(location[obj.name][n]);\n                } else {\n                    // for mLine and push attributes\n                    args.push(location[obj.names[i]]);\n                }\n            }\n        } else {\n            args.push(location[obj.name]);\n        }\n        return format.apply(null, args);\n    };\n    // RFC specified order\n    // TODO: extend this with all the rest\n    var defaultOuterOrder = [\n        \"v\",\n        \"o\",\n        \"s\",\n        \"i\",\n        \"u\",\n        \"e\",\n        \"p\",\n        \"c\",\n        \"b\",\n        \"t\",\n        \"r\",\n        \"z\",\n        \"a\"\n    ];\n    var defaultInnerOrder = [\n        \"i\",\n        \"c\",\n        \"b\",\n        \"a\"\n    ];\n    writer = function(session, opts) {\n        opts = opts || {};\n        // ensure certain properties exist\n        if (session.version == null) {\n            session.version = 0; // 'v=0' must be there (only defined version atm)\n        }\n        if (session.name == null) {\n            session.name = \" \"; // 's= ' must be there if no meaningful name set\n        }\n        session.media.forEach(function(mLine) {\n            if (mLine.payloads == null) {\n                mLine.payloads = \"\";\n            }\n        });\n        var outerOrder = opts.outerOrder || defaultOuterOrder;\n        var innerOrder = opts.innerOrder || defaultInnerOrder;\n        var sdp = [];\n        // loop through outerOrder for matching properties on session\n        outerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in session && session[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, session));\n                } else if (obj.push in session && session[obj.push] != null) {\n                    session[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n        // then for each media line, follow the innerOrder\n        session.media.forEach(function(mLine) {\n            sdp.push(makeLine(\"m\", grammar.m[0], mLine));\n            innerOrder.forEach(function(type) {\n                grammar[type].forEach(function(obj) {\n                    if (obj.name in mLine && mLine[obj.name] != null) {\n                        sdp.push(makeLine(type, obj, mLine));\n                    } else if (obj.push in mLine && mLine[obj.push] != null) {\n                        mLine[obj.push].forEach(function(el) {\n                            sdp.push(makeLine(type, obj, el));\n                        });\n                    }\n                });\n            });\n        });\n        return sdp.join(\"\\r\\n\") + \"\\r\\n\";\n    };\n    return writer;\n}\nvar hasRequiredLib;\nfunction requireLib() {\n    if (hasRequiredLib) return lib;\n    hasRequiredLib = 1;\n    var parser = requireParser();\n    var writer = requireWriter();\n    var grammar = requireGrammar();\n    lib.grammar = grammar;\n    lib.write = writer;\n    lib.parse = parser.parse;\n    lib.parseParams = parser.parseParams;\n    lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\n    lib.parsePayloads = parser.parsePayloads;\n    lib.parseRemoteCandidates = parser.parseRemoteCandidates;\n    lib.parseImageAttributes = parser.parseImageAttributes;\n    lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n    return lib;\n}\nvar libExports = requireLib();\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst debounceInterval = 20;\nconst PCEvents = {\n    NegotiationStarted: \"negotiationStarted\",\n    NegotiationComplete: \"negotiationComplete\",\n    RTPVideoPayloadTypes: \"rtpVideoPayloadTypes\"\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        super();\n        this.log = livekitLogger;\n        this.ddExtID = 0;\n        this.latestOfferId = 0;\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), debounceInterval);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n        this.loggerOptions = loggerOptions;\n        this.config = config;\n        this._pc = this.createPC();\n        this.offerLock = new _();\n    }\n    createPC() {\n        const pc = new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\");\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd, offerId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (sd.type === \"answer\" && this.latestOfferId > 0 && offerId > 0 && offerId !== this.latestOfferId) {\n                this.log.warn(\"ignoring answer for old offer\", Object.assign(Object.assign({}, this.logContext), {\n                    offerId,\n                    latestOfferId: this.latestOfferId\n                }));\n                return false;\n            }\n            let mungedSDP = undefined;\n            if (sd.type === \"offer\") {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === \"answer\") {\n                const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : \"\");\n                sdpParsed.media.forEach((media)=>{\n                    const mid = getMidString(media.mid);\n                    if (media.type === \"audio\") {\n                        // munge sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(\";\").filter((attr)=>!attr.includes(\"maxaveragebitrate\")).join(\";\");\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = libExports.write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === \"answer\") {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = libExports.parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === \"video\") {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n            return true;\n        });\n    }\n    createAndSendOffer(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.offerLock.lock();\n            try {\n                if (this.onOffer === undefined) {\n                    return;\n                }\n                if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                    this.log.debug(\"restarting ICE\", this.logContext);\n                    this.restartingIce = true;\n                }\n                if (this._pc && this._pc.signalingState === \"have-local-offer\") {\n                    // we're waiting for the peer to accept our offer, so we'll just wait\n                    // the only exception to this is when ICE restart is needed\n                    const currentSD = this._pc.remoteDescription;\n                    if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                        // TODO: handle when ICE restart is needed but we don't have a remote description\n                        // the best thing to do is to recreate the peerconnection\n                        yield this._pc.setRemoteDescription(currentSD);\n                    } else {\n                        this.renegotiate = true;\n                        return;\n                    }\n                } else if (!this._pc || this._pc.signalingState === \"closed\") {\n                    this.log.warn(\"could not createOffer with closed peer connection\", this.logContext);\n                    return;\n                }\n                // actually negotiate\n                this.log.debug(\"starting to negotiate\", this.logContext);\n                // increase the offer id at the start to ensure the offer is always > 0 so that we can use 0 as a default value for legacy behavior\n                const offerId = this.latestOfferId + 1;\n                this.latestOfferId = offerId;\n                const offer = yield this.pc.createOffer(options);\n                this.log.debug(\"original offer\", Object.assign({\n                    sdp: offer.sdp\n                }, this.logContext));\n                const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n                sdpParsed.media.forEach((media)=>{\n                    ensureIPAddrMatchVersion(media);\n                    if (media.type === \"audio\") {\n                        ensureAudioNackAndStereo(media, [\n                            \"all\"\n                        ], []);\n                    } else if (media.type === \"video\") {\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            if (isSVCCodec(trackbr.codec) && !isSafari()) {\n                                this.ensureVideoDDExtensionForSVC(media, sdpParsed);\n                            }\n                            // mung sdp for bitrate setting that can't apply by sendEncoding\n                            if (!isSVCCodec(trackbr.codec)) {\n                                return true;\n                            }\n                            const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    // if another track's fmtp already is set, we cannot override the bitrate\n                                    // this has the unfortunate consequence of being forced to use the\n                                    // initial track's bitrate for all tracks\n                                    if (!fmtp.config.includes(\"x-google-start-bitrate\")) {\n                                        fmtp.config += \";x-google-start-bitrate=\".concat(startBitrate);\n                                    }\n                                    break;\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                if (this.latestOfferId > offerId) {\n                    this.log.warn(\"latestOfferId mismatch\", Object.assign(Object.assign({}, this.logContext), {\n                        latestOfferId: this.latestOfferId,\n                        offerId\n                    }));\n                    return;\n                }\n                yield this.setMungedSDP(offer, libExports.write(sdpParsed));\n                this.onOffer(offer, this.latestOfferId);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    createAndSetAnswer() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                ensureIPAddrMatchVersion(media);\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, libExports.write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTransceiverOfKind(kind, transceiverInit) {\n        return this.pc.addTransceiver(kind, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot add track\");\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot configure\");\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = \"\";\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case \"transport\":\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case \"candidate-pair\":\n                        if (selectedCandidatePairId === \"\" && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case \"remote-candidate\":\n                        candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === \"\") {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    this.log.debug(\"setting munged \".concat(remote ? \"remote\" : \"local\", \" description\"), this.logContext);\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n                        error: e,\n                        sdp: munged\n                    }));\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                let msg = \"unknown error\";\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === \"string\") {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n                    fields\n                }));\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n    ensureVideoDDExtensionForSVC(media, sdp) {\n        var _a, _b;\n        const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some((ext)=>{\n            if (ext.uri === ddExtensionURI) {\n                return true;\n            }\n            return false;\n        });\n        if (!ddFound) {\n            if (this.ddExtID === 0) {\n                let maxID = 0;\n                sdp.media.forEach((m)=>{\n                    var _a;\n                    if (m.type !== \"video\") {\n                        return;\n                    }\n                    (_a = m.ext) === null || _a === void 0 ? void 0 : _a.forEach((ext)=>{\n                        if (ext.value > maxID) {\n                            maxID = ext.value;\n                        }\n                    });\n                });\n                this.ddExtID = maxID + 1;\n            }\n            (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({\n                value: this.ddExtID,\n                uri: ddExtensionURI\n            });\n        }\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // sdp-transform types don't include number however the parser outputs mids as numbers in some cases\n    const mid = getMidString(media.mid);\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === \"opus\") {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: \"nack\"\n            });\n        }\n        if (stereoMids.includes(mid) || stereoMids.length === 1 && stereoMids[0] === \"all\") {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes(\"stereo=1\")) {\n                        fmtp.config += \";stereo=1\";\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        const mid = getMidString(media.mid);\n        if (media.type === \"audio\") {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === \"opus\") {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n                nackMids.push(mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes(\"sprop-stereo=1\")) {\n                        stereoMids.push(mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nfunction ensureIPAddrMatchVersion(media) {\n    // Chrome could generate sdp with c = IN IP4 <ipv6 addr>\n    // in edge case and return error when set sdp.This is not a\n    // sdk error but correct it if the issue detected.\n    if (media.connection) {\n        const isV6 = media.connection.ip.indexOf(\":\") >= 0;\n        if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {\n            // fallback to dummy address\n            media.connection.ip = \"0.0.0.0\";\n            media.connection.version = 4;\n        }\n    }\n}\nfunction getMidString(mid) {\n    return typeof mid === \"number\" ? mid.toFixed(0) : mid;\n}\nconst defaultVideoCodec = \"vp8\";\nconst publishDefaults = {\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true,\n    preConnectBuffer: false\n};\nconst audioDefaults = {\n    deviceId: {\n        ideal: \"default\"\n    },\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true,\n    voiceIsolation: true\n};\nconst videoDefaults = {\n    deviceId: {\n        ideal: \"default\"\n    },\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    webAudioMix: false,\n    singlePeerConnection: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n    PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n    PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n    PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, mode, loggerOptions){\n        var _a;\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.log = livekitLogger;\n        this.updateState = ()=>{\n            var _a, _b;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === \"connected\")) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === \"failed\")) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === \"connecting\")) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === \"new\")) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.getConnectionState());\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n        this.loggerOptions = loggerOptions;\n        this.isPublisherConnectionRequired = mode !== \"subscriber-primary\";\n        this.isSubscriberConnectionRequired = mode === \"subscriber-primary\";\n        this.publisher = new PCTransport(rtcConfig, loggerOptions);\n        if (mode !== \"publisher-only\") {\n            this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n            this.subscriber.onConnectionStateChange = this.updateState;\n            this.subscriber.onIceConnectionStateChange = this.updateState;\n            this.subscriber.onSignalingStatechange = this.updateState;\n            this.subscriber.onIceCandidate = (candidate)=>{\n                var _a;\n                (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n            };\n            // in subscriber primary mode, server side opens sub data channels.\n            this.subscriber.onDataChannel = (ev)=>{\n                var _a;\n                (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n            };\n            this.subscriber.onTrack = (ev)=>{\n                var _a;\n                (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n            };\n        }\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.publisher.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer, offerId)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer, offerId);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new _();\n        this.remoteOfferLock = new _();\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd, offerId) {\n        return this.publisher.setRemoteDescription(sd, offerId);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (this.publisher && this.publisher.getSignallingState() !== \"closed\") {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn't have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not removeTrack\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.subscriber) {\n                this.subscriber.restartingIce = true;\n            }\n            // only restart publisher if it's needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd, offerId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            this.log.debug(\"received server offer\", Object.assign(Object.assign({}, this.logContext), {\n                RTCSdpType: sd.type,\n                sdp: sd.sdp,\n                signalingState: (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.getSignallingState().toString()\n            }));\n            const unlock = yield this.remoteOfferLock.lock();\n            try {\n                const success = yield (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.setRemoteDescription(sd, offerId);\n                if (!success) {\n                    return undefined;\n                }\n                // answer the offer\n                const answer = yield (_c = this.subscriber) === null || _c === void 0 ? void 0 : _c.createAndSetAnswer();\n                return answer;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        var _a;\n        this.publisher.setConfiguration(config);\n        (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== \"connected\" && this.publisher.getConnectionState() !== \"connecting\") {\n                    this.log.debug(\"negotiation required, start negotiating\", this.logContext);\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject(\"negotiation timed out\");\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(\"negotiation aborted\");\n                    };\n                    abortController.signal.addEventListener(\"abort\", abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTransceiverOfKind(kind, transceiverInit) {\n        return this.publisher.addTransceiverOfKind(kind, transceiverInit);\n    }\n    getMidForReceiver(receiver) {\n        const transceivers = this.subscriber ? this.subscriber.getTransceivers() : this.publisher.getTransceivers();\n        const matchingTransceiver = transceivers.find((transceiver)=>transceiver.receiver === receiver);\n        return matchingTransceiver === null || matchingTransceiver === void 0 ? void 0 : matchingTransceiver.mid;\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport's address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired && this.subscriber) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport_1, abortController_1) {\n        return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {\n            var _this = this;\n            let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n            return function*() {\n                const connectionState = pcTransport.getConnectionState();\n                if (connectionState === \"connected\") {\n                    return;\n                }\n                return new Promise((resolve, reject)=>__awaiter(_this, void 0, void 0, function*() {\n                        const abortHandler = ()=>{\n                            this.log.warn(\"abort transport connection\", this.logContext);\n                            CriticalTimers.clearTimeout(connectTimeout);\n                            reject(new ConnectionError(\"room connection has been cancelled\", ConnectionErrorReason.Cancelled));\n                        };\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            abortHandler();\n                        }\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", abortHandler);\n                        const connectTimeout = CriticalTimers.setTimeout(()=>{\n                            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                            reject(new ConnectionError(\"could not establish pc connection\", ConnectionErrorReason.InternalError));\n                        }, timeout);\n                        while(this.state !== PCTransportState.CONNECTED){\n                            yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                                reject(new ConnectionError(\"room connection has been cancelled\", ConnectionErrorReason.Cancelled));\n                                return;\n                            }\n                        }\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        resolve();\n                    }));\n            }();\n        });\n    }\n}\nconst DEFAULT_MAX_AGE_MS = 5000;\nconst STOP_REFETCH_DELAY_MS = 30000;\nclass RegionUrlProvider {\n    static fetchRegionSettings(serverUrl, token, signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield RegionUrlProvider.fetchLock.lock();\n            try {\n                const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(serverUrl), \"/regions\"), {\n                    headers: {\n                        authorization: \"Bearer \".concat(token)\n                    },\n                    signal\n                });\n                if (regionSettingsResponse.ok) {\n                    const maxAge = extractMaxAgeFromRequestHeaders(regionSettingsResponse.headers);\n                    const maxAgeInMs = maxAge ? maxAge * 1000 : DEFAULT_MAX_AGE_MS;\n                    const regionSettings = yield regionSettingsResponse.json();\n                    return {\n                        regionSettings,\n                        updatedAtInMs: Date.now(),\n                        maxAgeInMs\n                    };\n                } else {\n                    throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);\n                }\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    // rethrow connection errors\n                    throw e;\n                } else if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n                    throw new ConnectionError(\"Region fetching was aborted\", ConnectionErrorReason.Cancelled);\n                } else {\n                    // wrap other errors as connection errors (e.g. timeouts)\n                    throw new ConnectionError(\"Could not fetch region settings, \".concat(e instanceof Error ? \"\".concat(e.name, \": \").concat(e.message) : e), ConnectionErrorReason.ServerUnreachable, 500);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    static scheduleRefetch(url, token, maxAgeInMs) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const timeout = RegionUrlProvider.settingsTimeouts.get(url.hostname);\n            clearTimeout(timeout);\n            RegionUrlProvider.settingsTimeouts.set(url.hostname, setTimeout(()=>__awaiter(this, void 0, void 0, function*() {\n                    try {\n                        const newSettings = yield RegionUrlProvider.fetchRegionSettings(url, token);\n                        RegionUrlProvider.updateCachedRegionSettings(url, token, newSettings);\n                    } catch (error) {\n                        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\n                            livekitLogger.debug(\"token is not valid, cancelling auto region refresh\");\n                            return;\n                        }\n                        livekitLogger.debug(\"auto refetching of region settings failed\", {\n                            error\n                        });\n                        // continue retrying with the same max age\n                        RegionUrlProvider.scheduleRefetch(url, token, maxAgeInMs);\n                    }\n                }), maxAgeInMs));\n        });\n    }\n    static updateCachedRegionSettings(url, token, settings) {\n        RegionUrlProvider.cache.set(url.hostname, settings);\n        RegionUrlProvider.scheduleRefetch(url, token, settings.maxAgeInMs);\n    }\n    static stopRefetch(hostname) {\n        const timeout = RegionUrlProvider.settingsTimeouts.get(hostname);\n        if (timeout) {\n            clearTimeout(timeout);\n            RegionUrlProvider.settingsTimeouts.delete(hostname);\n        }\n    }\n    static scheduleCleanup(hostname) {\n        let tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n        if (!tracker) {\n            return;\n        }\n        // Cancel any existing cleanup timeout\n        if (tracker.cleanupTimeout) {\n            clearTimeout(tracker.cleanupTimeout);\n        }\n        // Schedule cleanup to stop refetch after delay\n        tracker.cleanupTimeout = setTimeout(()=>{\n            const currentTracker = RegionUrlProvider.connectionTrackers.get(hostname);\n            if (currentTracker && currentTracker.connectionCount === 0) {\n                livekitLogger.debug(\"stopping region refetch after disconnect delay\", {\n                    hostname\n                });\n                RegionUrlProvider.stopRefetch(hostname);\n            }\n            if (currentTracker) {\n                currentTracker.cleanupTimeout = undefined;\n            }\n        }, STOP_REFETCH_DELAY_MS);\n    }\n    static cancelCleanup(hostname) {\n        const tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n        if (tracker === null || tracker === void 0 ? void 0 : tracker.cleanupTimeout) {\n            clearTimeout(tracker.cleanupTimeout);\n            tracker.cleanupTimeout = undefined;\n        }\n    }\n    notifyConnected() {\n        const hostname = this.serverUrl.hostname;\n        let tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n        if (!tracker) {\n            tracker = {\n                connectionCount: 0\n            };\n            RegionUrlProvider.connectionTrackers.set(hostname, tracker);\n        }\n        tracker.connectionCount++;\n        // Cancel any scheduled cleanup since we have an active connection\n        RegionUrlProvider.cancelCleanup(hostname);\n    }\n    notifyDisconnected() {\n        const hostname = this.serverUrl.hostname;\n        const tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n        if (!tracker) {\n            return;\n        }\n        tracker.connectionCount = Math.max(0, tracker.connectionCount - 1);\n        // If no more connections, schedule cleanup\n        if (tracker.connectionCount === 0) {\n            RegionUrlProvider.scheduleCleanup(hostname);\n        }\n    }\n    constructor(url, token){\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    /** @internal */ fetchRegionSettings(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return RegionUrlProvider.fetchRegionSettings(this.serverUrl, this.token, abortSignal);\n        });\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n            }\n            let cachedSettings = RegionUrlProvider.cache.get(this.serverUrl.hostname);\n            if (!cachedSettings || Date.now() - cachedSettings.updatedAtInMs > cachedSettings.maxAgeInMs) {\n                cachedSettings = yield this.fetchRegionSettings(abortSignal);\n                RegionUrlProvider.updateCachedRegionSettings(this.serverUrl, this.token, cachedSettings);\n            }\n            const regionsLeft = cachedSettings.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    setServerReportedRegions(settings) {\n        RegionUrlProvider.updateCachedRegionSettings(this.serverUrl, this.token, settings);\n    }\n}\nRegionUrlProvider.cache = new Map();\nRegionUrlProvider.settingsTimeouts = new Map();\nRegionUrlProvider.connectionTrackers = new Map();\nRegionUrlProvider.fetchLock = new _();\nfunction getCloudConfigUrl(serverUrl) {\n    return \"\".concat(serverUrl.protocol.replace(\"ws\", \"http\"), \"//\").concat(serverUrl.host, \"/settings\");\n}\n// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Specialized error handling for RPC methods.\n *\n * Instances of this type, when thrown in a method handler, will have their `message`\n * serialized and sent across the wire. The sender will receive an equivalent error on the other side.\n *\n * Built-in types are included but developers may use any string, with a max length of 256 bytes.\n */ class RpcError extends Error {\n    /**\n   * Creates an error object with the given code and message, plus an optional data payload.\n   *\n   * If thrown in an RPC method handler, the error will be sent back to the caller.\n   *\n   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).\n   */ constructor(code, message, data){\n        super(message);\n        this.code = code;\n        this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);\n        this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;\n    }\n    /**\n   * @internal\n   */ static fromProto(proto) {\n        return new RpcError(proto.code, proto.message, proto.data);\n    }\n    /**\n   * @internal\n   */ toProto() {\n        return new RpcError$1({\n            code: this.code,\n            message: this.message,\n            data: this.data\n        });\n    }\n    /**\n   * Creates an error object from the code, with an auto-populated message.\n   *\n   * @internal\n   */ static builtIn(key, data) {\n        return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);\n    }\n}\nRpcError.MAX_MESSAGE_BYTES = 256;\nRpcError.MAX_DATA_BYTES = 15360; // 15 KB\nRpcError.ErrorCode = {\n    APPLICATION_ERROR: 1500,\n    CONNECTION_TIMEOUT: 1501,\n    RESPONSE_TIMEOUT: 1502,\n    RECIPIENT_DISCONNECTED: 1503,\n    RESPONSE_PAYLOAD_TOO_LARGE: 1504,\n    SEND_FAILED: 1505,\n    UNSUPPORTED_METHOD: 1400,\n    RECIPIENT_NOT_FOUND: 1401,\n    REQUEST_PAYLOAD_TOO_LARGE: 1402,\n    UNSUPPORTED_SERVER: 1403,\n    UNSUPPORTED_VERSION: 1404\n};\n/**\n * @internal\n */ RpcError.ErrorMessage = {\n    APPLICATION_ERROR: \"Application error in method handler\",\n    CONNECTION_TIMEOUT: \"Connection timeout\",\n    RESPONSE_TIMEOUT: \"Response timeout\",\n    RECIPIENT_DISCONNECTED: \"Recipient disconnected\",\n    RESPONSE_PAYLOAD_TOO_LARGE: \"Response payload too large\",\n    SEND_FAILED: \"Failed to send\",\n    UNSUPPORTED_METHOD: \"Method not supported at destination\",\n    RECIPIENT_NOT_FOUND: \"Recipient not found\",\n    REQUEST_PAYLOAD_TOO_LARGE: \"Request payload too large\",\n    UNSUPPORTED_SERVER: \"RPC not supported by server\",\n    UNSUPPORTED_VERSION: \"Unsupported RPC version\"\n};\n/*\n * Maximum payload size for RPC requests and responses. If a payload exceeds this size,\n * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.\n */ const MAX_PAYLOAD_BYTES = 15360; // 15 KB\n/**\n * @internal\n */ function byteLength(str) {\n    const encoder = new TextEncoder();\n    return encoder.encode(str).length;\n}\n/**\n * @internal\n */ function truncateBytes(str, maxBytes) {\n    if (byteLength(str) <= maxBytes) {\n        return str;\n    }\n    let low = 0;\n    let high = str.length;\n    const encoder = new TextEncoder();\n    while(low < high){\n        const mid = Math.floor((low + high + 1) / 2);\n        if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {\n            low = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return str.slice(0, low);\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if (\"bytesReceived\" in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if (\"bytesSent\" in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\n// Check if MediaRecorder is available\nconst isMediaRecorderAvailable = typeof MediaRecorder !== \"undefined\";\n// Fallback class for environments without MediaRecorder\nclass FallbackRecorder {\n    constructor(){\n        throw new Error(\"MediaRecorder is not available in this environment\");\n    }\n}\n// Use conditional inheritance to avoid parse-time errors\nconst RecorderBase = isMediaRecorderAvailable ? MediaRecorder : FallbackRecorder;\nclass LocalTrackRecorder extends RecorderBase {\n    constructor(track, options){\n        if (!isMediaRecorderAvailable) {\n            throw new Error(\"MediaRecorder is not available in this environment\");\n        }\n        super(new MediaStream([\n            track.mediaStreamTrack\n        ]), options);\n        let dataListener;\n        let streamController;\n        const isClosed = ()=>streamController === undefined;\n        const onStop = ()=>{\n            this.removeEventListener(\"dataavailable\", dataListener);\n            this.removeEventListener(\"stop\", onStop);\n            this.removeEventListener(\"error\", onError);\n            streamController === null || streamController === void 0 ? void 0 : streamController.close();\n            streamController = undefined;\n        };\n        const onError = (event)=>{\n            streamController === null || streamController === void 0 ? void 0 : streamController.error(event);\n            this.removeEventListener(\"dataavailable\", dataListener);\n            this.removeEventListener(\"stop\", onStop);\n            this.removeEventListener(\"error\", onError);\n            streamController = undefined;\n        };\n        this.byteStream = new ReadableStream({\n            start: (controller)=>{\n                streamController = controller;\n                dataListener = (event)=>__awaiter(this, void 0, void 0, function*() {\n                        let data;\n                        if (event.data.arrayBuffer) {\n                            const arrayBuffer = yield event.data.arrayBuffer();\n                            data = new Uint8Array(arrayBuffer);\n                        // @ts-expect-error react-native passes over Uint8Arrays directly\n                        } else if (event.data.byteArray) {\n                            // @ts-expect-error\n                            data = event.data.byteArray;\n                        } else {\n                            throw new Error(\"no data available!\");\n                        }\n                        if (isClosed()) {\n                            return;\n                        }\n                        controller.enqueue(data);\n                    });\n                this.addEventListener(\"dataavailable\", dataListener);\n            },\n            cancel: ()=>{\n                onStop();\n            }\n        });\n        this.addEventListener(\"stop\", onStop);\n        this.addEventListener(\"error\", onError);\n    }\n}\n// Helper function to check if recording is supported\nfunction isRecordingSupported() {\n    return isMediaRecorderAvailable;\n}\nconst DEFAULT_DIMENSIONS_TIMEOUT = 1000;\nconst PRE_CONNECT_BUFFER_TIMEOUT = 10000;\nclass LocalTrack extends Track {\n    /** @internal */ get sender() {\n        return this._sender;\n    }\n    /** @internal */ set sender(sender) {\n        this._sender = sender;\n    }\n    get constraints() {\n        return this._constraints;\n    }\n    get hasPreConnectBuffer() {\n        return !!this.localTrackRecorder;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, kind, loggerOptions);\n        this.manuallyStopped = false;\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>this.log.debug(\"track mute bounce got cancelled by an unmute event\", this.logContext));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel(\"unmute\");\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new _();\n        this.pauseUpstreamLock = new _();\n        this.trackChangeLock = new _();\n        this.trackChangeLock.lock().then((unlock)=>__awaiter(this, void 0, void 0, function*() {\n                try {\n                    yield this.setMediaStreamTrack(mediaTrack, true);\n                } finally{\n                    unlock();\n                }\n            }));\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    get isLocal() {\n        return true;\n    }\n    /**\n   * @internal\n   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors\n   */ getSourceTrackSettings() {\n        return this._mediaStreamTrack.getSettings();\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel(\"new-track\");\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we'll need to signal with remote that\n                // the track is \"muted\"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener(\"mute\", this.handleTrackMuteEvent);\n                newTrack.addEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack) {\n                this.log.debug(\"restarting processor\", this.logContext);\n                if (this.kind === \"unknown\") {\n                    throw TypeError(\"cannot set processor on track of unknown kind\");\n                }\n                if (this.processorElement) {\n                    attachToElement(newTrack, this.processorElement);\n                    // ensure the processorElement itself stays muted\n                    this.processorElement.muted = true;\n                }\n                yield this.processor.restart({\n                    track: newTrack,\n                    kind: this.kind,\n                    element: this.processorElement\n                });\n                processedTrack = this.processor.processedTrack;\n            }\n            if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            // if `newTrack` is different from the existing track, stop the\n            // older track just before replacing it\n            if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                this._mediaStreamTrack.stop();\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we'd want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this = this;\n            let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_DIMENSIONS_TIMEOUT;\n            return function*() {\n                var _a;\n                if (_this.kind === Track.Kind.Audio) {\n                    throw new Error(\"cannot get dimensions for audio tracks\");\n                }\n                if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === \"iOS\") {\n                    // browsers report wrong initial resolution on iOS.\n                    // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                    yield sleep(10);\n                }\n                const started = Date.now();\n                while(Date.now() - started < timeout){\n                    const dims = _this.dimensions;\n                    if (dims) {\n                        return dims;\n                    }\n                    yield sleep(50);\n                }\n                throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n            }();\n        });\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when track is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (this.isMuted) {\n                return true;\n            }\n            yield this.restartTrack();\n            return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this2 = this;\n            let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                // screen share doesn't have a usable device id\n                if (_this2.source === Track.Source.ScreenShare) {\n                    return;\n                }\n                const { deviceId, groupId } = _this2._mediaStreamTrack.getSettings();\n                const kind = _this2.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n                return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;\n            }();\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track, userProvidedOrOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.trackChangeLock.lock();\n            try {\n                if (!this.sender) {\n                    throw new TrackInvalidError(\"unable to replace an unpublished track\");\n                }\n                let userProvidedTrack;\n                let stopProcessor;\n                if (typeof userProvidedOrOptions === \"boolean\") {\n                    userProvidedTrack = userProvidedOrOptions;\n                } else if (userProvidedOrOptions !== undefined) {\n                    userProvidedTrack = userProvidedOrOptions.userProvidedTrack;\n                    stopProcessor = userProvidedOrOptions.stopProcessor;\n                }\n                this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;\n                this.log.debug(\"replace MediaStreamTrack\", this.logContext);\n                yield this.setMediaStreamTrack(track);\n                // this must be synced *after* setting mediaStreamTrack above, since it relies\n                // on the previous state in order to cleanup\n                if (stopProcessor && this.processor) {\n                    yield this.internalStopProcessor();\n                }\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.manuallyStopped = false;\n            const unlock = yield this.trackChangeLock.lock();\n            try {\n                if (!constraints) {\n                    constraints = this._constraints;\n                }\n                const { deviceId, facingMode } = constraints, otherConstraints = __rest(constraints, [\n                    \"deviceId\",\n                    \"facingMode\"\n                ]);\n                this.log.debug(\"restarting track with constraints\", Object.assign(Object.assign({}, this.logContext), {\n                    constraints\n                }));\n                const streamConstraints = {\n                    audio: false,\n                    video: false\n                };\n                if (this.kind === Track.Kind.Video) {\n                    streamConstraints.video = deviceId || facingMode ? {\n                        deviceId,\n                        facingMode\n                    } : true;\n                } else {\n                    streamConstraints.audio = deviceId ? Object.assign({\n                        deviceId\n                    }, otherConstraints) : true;\n                }\n                // these steps are duplicated from setMediaStreamTrack because we must stop\n                // the previous tracks before new tracks can be acquired\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this.mediaStreamTrack, el);\n                });\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                // on Safari, the old audio track must be stopped before attempting to acquire\n                // the new track, otherwise the new track will stop with\n                // 'A MediaStreamTrack ended due to a capture failure`\n                this._mediaStreamTrack.stop();\n                // create new track and attach\n                const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n                const newTrack = mediaStream.getTracks()[0];\n                if (this.kind === Track.Kind.Video) {\n                    // we already captured the audio track with the constraints, so we only need to apply the video constraints\n                    yield newTrack.applyConstraints(otherConstraints);\n                }\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                this.log.debug(\"re-acquired MediaStreamTrack\", this.logContext);\n                yield this.setMediaStreamTrack(newTrack);\n                this._constraints = constraints;\n                this.emit(TrackEvent.Restarted, this);\n                if (this.manuallyStopped) {\n                    this.log.warn(\"track was stopped during a restart, stopping restarted track\", this.logContext);\n                    this.stop();\n                }\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? \"muted\" : \"unmuted\"), this.logContext);\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        this.manuallyStopped = true;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n        this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to pause upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Safari\" && compareVersions(browser.version, \"12.0\") < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError(\"pauseUpstream is not supported on Safari < 12.\");\n                }\n                if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                    yield this.sender.replaceTrack(null);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to resume upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                    // this operation is noop if mediastreamtrack is already being sent\n                    yield this.sender.replaceTrack(this.mediaStreamTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor_1) {\n        return __awaiter(this, arguments, void 0, function(processor) {\n            var _this3 = this;\n            let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a;\n                const unlock = yield _this3.trackChangeLock.lock();\n                try {\n                    _this3.log.debug(\"setting up processor\", _this3.logContext);\n                    const processorElement = document.createElement(_this3.kind);\n                    const processorOptions = {\n                        kind: _this3.kind,\n                        track: _this3._mediaStreamTrack,\n                        element: processorElement,\n                        audioContext: _this3.audioContext\n                    };\n                    yield processor.init(processorOptions);\n                    _this3.log.debug(\"processor initialized\", _this3.logContext);\n                    if (_this3.processor) {\n                        yield _this3.internalStopProcessor();\n                    }\n                    if (_this3.kind === \"unknown\") {\n                        throw TypeError(\"cannot set processor on track of unknown kind\");\n                    }\n                    attachToElement(_this3._mediaStreamTrack, processorElement);\n                    processorElement.muted = true;\n                    processorElement.play().catch((error)=>{\n                        if (error instanceof DOMException && error.name === \"AbortError\") {\n                            // This happens on Safari when the processor is restarted, try again after a delay\n                            _this3.log.warn(\"failed to play processor element, retrying\", Object.assign(Object.assign({}, _this3.logContext), {\n                                error\n                            }));\n                            setTimeout(()=>{\n                                processorElement.play().catch((err)=>{\n                                    _this3.log.error(\"failed to play processor element\", Object.assign(Object.assign({}, _this3.logContext), {\n                                        err\n                                    }));\n                                });\n                            }, 100);\n                        } else {\n                            _this3.log.error(\"failed to play processor element\", Object.assign(Object.assign({}, _this3.logContext), {\n                                error\n                            }));\n                        }\n                    });\n                    _this3.processor = processor;\n                    _this3.processorElement = processorElement;\n                    if (_this3.processor.processedTrack) {\n                        for (const el of _this3.attachedElements){\n                            if (el !== _this3.processorElement && showProcessedStreamLocally) {\n                                detachTrack(_this3._mediaStreamTrack, el);\n                                attachToElement(_this3.processor.processedTrack, el);\n                            }\n                        }\n                        yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);\n                    }\n                    _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);\n                } finally{\n                    unlock();\n                }\n            }();\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this4 = this;\n            let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                const unlock = yield _this4.trackChangeLock.lock();\n                try {\n                    yield _this4.internalStopProcessor(keepElement);\n                } finally{\n                    unlock();\n                }\n            }();\n        });\n    }\n    /**\n   * @internal\n   * This method assumes the caller has acquired a trackChangeLock already.\n   * The public facing method for stopping the processor is `stopProcessor` and it wraps this method in the trackChangeLock.\n   */ internalStopProcessor() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this5 = this;\n            let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                var _a, _b;\n                if (!_this5.processor) return;\n                _this5.log.debug(\"stopping processor\", _this5.logContext);\n                (_a = _this5.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n                yield _this5.processor.destroy();\n                _this5.processor = undefined;\n                if (!keepElement) {\n                    (_b = _this5.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n                    _this5.processorElement = undefined;\n                }\n                // apply original track constraints in case the processor changed them\n                yield _this5._mediaStreamTrack.applyConstraints(_this5._constraints);\n                // force re-setting of the mediaStreamTrack on the sender\n                yield _this5.setMediaStreamTrack(_this5._mediaStreamTrack, true);\n                _this5.emit(TrackEvent.TrackProcessorUpdate);\n            }();\n        });\n    }\n    /** @internal */ startPreConnectBuffer() {\n        let timeslice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n        if (!isRecordingSupported()) {\n            this.log.warn(\"MediaRecorder is not available, cannot start preconnect buffer\", this.logContext);\n            return;\n        }\n        if (!this.localTrackRecorder) {\n            let mimeType = \"audio/webm;codecs=opus\";\n            if (!MediaRecorder.isTypeSupported(mimeType)) {\n                // iOS currently only supports video/mp4 as a mime type - even for audio.\n                mimeType = \"video/mp4\";\n            }\n            this.localTrackRecorder = new LocalTrackRecorder(this, {\n                mimeType\n            });\n        } else {\n            this.log.warn(\"preconnect buffer already started\");\n            return;\n        }\n        this.localTrackRecorder.start(timeslice);\n        this.autoStopPreConnectBuffer = setTimeout(()=>{\n            this.log.warn(\"preconnect buffer timed out, stopping recording automatically\", this.logContext);\n            this.stopPreConnectBuffer();\n        }, PRE_CONNECT_BUFFER_TIMEOUT);\n    }\n    /** @internal */ stopPreConnectBuffer() {\n        clearTimeout(this.autoStopPreConnectBuffer);\n        if (this.localTrackRecorder) {\n            this.localTrackRecorder.stop();\n            this.localTrackRecorder = undefined;\n        }\n    }\n    /** @internal */ getPreConnectBuffer() {\n        var _a;\n        return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.byteStream;\n    }\n    getPreConnectBufferMimeType() {\n        var _a;\n        return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.mimeType;\n    }\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   * boolean indicating whether enhanced noise cancellation is currently being used on this track\n   */ get enhancedNoiseCancellation() {\n        return this.isKrispNoiseFilterEnabled;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n        /** @internal */ this.stopOnMute = false;\n        this.isKrispNoiseFilterEnabled = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.handleKrispNoiseFilterEnable = ()=>{\n            this.isKrispNoiseFilterEnabled = true;\n            this.log.debug(\"Krisp noise filter enabled\", this.logContext);\n            this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);\n        };\n        this.handleKrispNoiseFilterDisable = ()=>{\n            this.isKrispNoiseFilterEnabled = false;\n            this.log.debug(\"Krisp noise filter disabled\", this.logContext);\n            this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);\n        };\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.isMuted) {\n                    this.log.debug(\"Track already muted\", this.logContext);\n                    return this;\n                }\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    this.log.debug(\"stopping mic track\", this.logContext);\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (!this.isMuted) {\n                    this.log.debug(\"Track already unmuted\", this.logContext);\n                    return this;\n                }\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\" || deviceHasChanged) && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring mic track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== \"boolean\") {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.trackChangeLock.lock();\n            try {\n                if (!isReactNative() && !this.audioContext) {\n                    throw Error(\"Audio context needs to be set on LocalAudioTrack in order to enable processors\");\n                }\n                if (this.processor) {\n                    yield this.internalStopProcessor();\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    // RN won't have or use AudioContext\n                    audioContext: this.audioContext\n                };\n                this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                    this.processor.processedTrack.addEventListener(\"enable-lk-krisp-noise-filter\", this.handleKrispNoiseFilterEnable);\n                    this.processor.processedTrack.addEventListener(\"disable-lk-krisp-noise-filter\", this.handleKrispNoiseFilterDisable);\n                }\n                this.emit(TrackEvent.TrackProcessorUpdate, this.processor);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === \"outbound-rtp\") {\n                    audioStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    this.log.debug(\"silence detected on local audio track\", this.logContext);\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n    switch(mediaStreamTrack.kind){\n        case \"audio\":\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n        case \"video\":\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n        default:\n            throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: fromPreset.encoding.maxFramerate\n        }\n    ];\n    return layers.map((t)=>{\n        var _a, _b;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    \"q\",\n    \"h\",\n    \"f\"\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren't simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug(\"using video encoding\", videoEncoding);\n    }\n    const sourceFramerate = videoEncoding.maxFramerate;\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n        }\n        // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated\n        // that SVC mode should be used. Safari still works this way.\n        // This is a bit confusing but is due to how libwebrtc interpreted the encodings field\n        // before M113.\n        // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1\n        const browser = getBrowser();\n        if (isSafariBased() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding\n        // is provided. So we'll use the legacy SVC specification for now.\n        // TODO: when we upstream libwebrtc, this will need additional verification\n        isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, \"113\") < 0) {\n            const bitratesRatio = sm.suffix == \"h\" ? 2 : 3;\n            // safari 18.4 uses a different svc API that requires scaleResolutionDownBy to be set.\n            const requireScale = isSafariSvcApi(browser);\n            for(let i = 0; i < sm.spatial; i += 1){\n                // in legacy SVC, scaleResolutionDownBy cannot be set\n                encodings.push({\n                    rid: videoRids[2 - i],\n                    maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),\n                    maxFramerate: original.encoding.maxFramerate,\n                    scaleResolutionDownBy: requireScale ? Math.pow(2, i) : undefined\n                });\n            }\n            // legacy SVC, scalabilityMode is set only on the first encoding\n            /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        } else {\n            encodings.push({\n                maxBitrate: videoEncoding.maxBitrate,\n                maxFramerate: original.encoding.maxFramerate,\n                /* @ts-ignore */ scalabilityMode: scalabilityMode\n            });\n        }\n        if (original.encoding.priority) {\n            encodings[0].priority = original.encoding.priority;\n            encodings[0].networkPriority = original.encoding.priority;\n        }\n        livekitLogger.debug(\"using svc encoding\", {\n            encodings\n        });\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. livekit-server translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ], sourceFramerate);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ], sourceFramerate);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn(\"requested a different codec than specified as backup\", {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    // disable simulcast for screenshare backup codec since L1Tx is used by primary codec\n    if (track.source === Track.Source.ScreenShare && opts.simulcast) {\n        opts.simulcast = false;\n    }\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case \"av1\":\n            case \"h265\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case \"vp9\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets, sourceFramerate) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        // ensure that the sourceFramerate is the highest framerate applied across all layers so that the\n        // original encoding doesn't get bumped unintentionally by any of the other layers\n        const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;\n        if (maxFramerate) {\n            encoding.maxFramerate = maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === \"ios\") {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n                }\n                livekitLogger.info('Setting framerate of encoding \"'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\", '\" to ').concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error(\"invalid scalability mode\");\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case \"h\":\n                case \"_KEY\":\n                case \"_KEY_SHIFT\":\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : \"\");\n    }\n}\nfunction getDefaultDegradationPreference(track) {\n    // a few of reasons we have different default paths:\n    // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue\n    // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`\n    if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {\n        return \"maintain-resolution\";\n    } else {\n        return \"balanced\";\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    get sender() {\n        return this._sender;\n    }\n    set sender(sender) {\n        this._sender = sender;\n        if (this.degradationPreference) {\n            this.setDegradationPreference(this.degradationPreference);\n        }\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.degradationPreference = \"balanced\";\n        this.isCpuConstrained = false;\n        this.optimizeForPerformance = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get video sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                const isCpuConstrained = stats.some((s)=>s.qualityLimitationReason === \"cpu\");\n                if (isCpuConstrained !== this.isCpuConstrained) {\n                    this.isCpuConstrained = isCpuConstrained;\n                    if (this.isCpuConstrained) {\n                        this.emit(TrackEvent.CpuConstrained);\n                    }\n                }\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new _();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_1, _b, _c;\n            var _d;\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_2, _b, _c;\n            var _d;\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.isMuted) {\n                    this.log.debug(\"Track already muted\", this.logContext);\n                    return this;\n                }\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"stopping camera track\", this.logContext);\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (!this.isMuted) {\n                    this.log.debug(\"Track already unmuted\", this.logContext);\n                    return this;\n                }\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring camera track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === \"outbound-rtp\") {\n                    const vs = {\n                        type: \"video\",\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        framesPerSecond: v.framesPerSecond,\n                        framesSent: v.framesSent,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationDurations: v.qualityLimitationDurations,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        targetBitrate: v.targetBitrate,\n                        timestamp: v.timestamp\n                    };\n                    //locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            // make sure highest res layer is always first\n            items.sort((a, b)=>{\n                var _a, _b;\n                return ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n        this.setPublishingLayers(isSVCCodec(this.codec), qualities);\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_3, _b, _c;\n            var _d;\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== \"boolean\") {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            // reset cpu constrained state after track is restarted\n            this.isCpuConstrained = false;\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== \"closed\") {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor_1) {\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        return __awaiter(this, arguments, void 0, function(processor) {\n            var _this = this;\n            let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a, e_4, _b, _c;\n                var _d, _e;\n                yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);\n                if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                    try {\n                        for(var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                            _c = _h.value;\n                            _f = false;\n                            const sc = _c;\n                            yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);\n                        }\n                    } catch (e_4_1) {\n                        e_4 = {\n                            error: e_4_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                        } finally{\n                            if (e_4) throw e_4.error;\n                        }\n                    }\n                }\n            }();\n        });\n    }\n    setDegradationPreference(preference) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.degradationPreference = preference;\n            if (this.sender) {\n                try {\n                    this.log.debug(\"setting degradationPreference to \".concat(preference), this.logContext);\n                    const params = this.sender.getParameters();\n                    params.degradationPreference = preference;\n                    this.sender.setParameters(params);\n                } catch (e) {\n                    this.log.warn(\"failed to set degradationPreference\", Object.assign({\n                        error: e\n                    }, this.logContext));\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            this.log.error(\"\".concat(codec, \" already added, skipping adding simulcast codec\"), this.logContext);\n            return;\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, codecs_1, codecs_1_1;\n            var _b, e_5, _c, _d;\n            this.log.debug(\"setting publishing codecs\", Object.assign(Object.assign({}, this.logContext), {\n                codecs,\n                currentCodec: this.codec\n            }));\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(isSVCCodec(codecs[0].codec), codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(isSVCCodec(codec.codec), codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n                            simulcastCodecInfo\n                        }));\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, isSVCCodec(codec.codec), this.log, this.logContext);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(isSvc, qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.optimizeForPerformance) {\n                this.log.info(\"skipping setPublishingLayers due to optimized publishing performance\", Object.assign(Object.assign({}, this.logContext), {\n                    qualities\n                }));\n                return;\n            }\n            this.log.debug(\"setting publishing layers\", Object.assign(Object.assign({}, this.logContext), {\n                qualities\n            }));\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, isSvc, this.log, this.logContext);\n        });\n    }\n    /**\n   * Designed for lower powered devices, reduces video publishing quality and disables simulcast.\n   * @experimental\n   */ prioritizePerformance() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new Error(\"sender not found\");\n            }\n            const unlock = yield this.senderLock.lock();\n            try {\n                this.optimizeForPerformance = true;\n                const params = this.sender.getParameters();\n                params.encodings = params.encodings.map((e, idx)=>{\n                    var _a;\n                    return Object.assign(Object.assign({}, e), {\n                        active: idx === 0,\n                        scaleResolutionDownBy: Math.max(1, Math.ceil(((_a = this.mediaStreamTrack.getSettings().height) !== null && _a !== void 0 ? _a : 360) / 360)),\n                        scalabilityMode: idx === 0 && isSVCCodec(this.codec) ? \"L1T3\" : undefined,\n                        maxFramerate: idx === 0 ? 15 : 0,\n                        maxBitrate: idx === 0 ? e.maxBitrate : 0\n                    });\n                });\n                this.log.debug(\"setting performance optimised encodings\", Object.assign(Object.assign({}, this.logContext), {\n                    encodings: params.encodings\n                }));\n                this.encodings = params.encodings;\n                yield this.sender.setParameters(params);\n            } catch (e) {\n                this.log.error(\"failed to set performance optimised encodings\", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n                this.optimizeForPerformance = false;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, isSVC, log, logContext) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        log.debug(\"setPublishingLayersForSender\", Object.assign(Object.assign({}, logContext), {\n            sender,\n            qualities,\n            senderEncodings\n        }));\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                log.warn(\"cannot set publishing layers, encodings mismatch\", Object.assign(Object.assign({}, logContext), {\n                    encodings,\n                    senderEncodings\n                }));\n                return;\n            }\n            let hasChanged = false;\n            /* disable closable spatial layer as it has video blur / frozen issue with current server / client\n      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a\n            low resolution frame and recover very quickly, but noticable\n      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */ const closableSpatial = false;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) ;\n            else {\n                if (isSVC) {\n                    const hasEnabledEncoding = qualities.some((q)=>q.enabled);\n                    if (hasEnabledEncoding) {\n                        qualities.forEach((q)=>q.enabled = true);\n                    }\n                }\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\";\n                    if (rid === \"\") {\n                        rid = \"q\";\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? \"enabled\" : \"disabled\"), logContext);\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n                    encodings: params.encodings\n                }));\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case \"f\":\n            return VideoQuality.HIGH;\n        case \"h\":\n            return VideoQuality.MEDIUM;\n        case \"q\":\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        const resRatio = sm.suffix == \"h\" ? 1.5 : 2;\n        const bitratesRatio = sm.suffix == \"h\" ? 2 : 3;\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,\n                width: Math.ceil(width / Math.pow(resRatio, i)),\n                height: Math.ceil(height / Math.pow(resRatio, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : \"\");\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nconst lossyDataChannel = \"_lossy\";\nconst reliableDataChannel = \"_reliable\";\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = \"leave-reconnect\";\nconst reliabeReceiveStateTTL = 30000;\nvar PCState;\n(function(PCState) {\n    PCState[PCState[\"New\"] = 0] = \"New\";\n    PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n    PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n    PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n    PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    get pendingReconnect() {\n        return !!this.reconnectTimeout;\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        /**\n     * @internal\n     */ this.latestRemoteOfferId = 0;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.log = livekitLogger;\n        this.reliableDataSequence = 1;\n        this.reliableMessageBuffer = new DataPacketBuffer();\n        this.reliableReceivedState = new TTLMap(reliabeReceiveStateTTL);\n        this.midToTrackId = {};\n        /** used to indicate whether the browser is currently waiting to reconnect */ this.isWaitingForNetworkReconnect = false;\n        this.handleDataChannel = (_a)=>__awaiter(this, [\n                _a\n            ], void 0, function(_ref) {\n                var _this = this;\n                let { channel } = _ref;\n                return function*() {\n                    if (!channel) {\n                        return;\n                    }\n                    if (channel.label === reliableDataChannel) {\n                        _this.reliableDCSub = channel;\n                    } else if (channel.label === lossyDataChannel) {\n                        _this.lossyDCSub = channel;\n                    } else {\n                        return;\n                    }\n                    _this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), _this.logContext);\n                    channel.onmessage = _this.handleDataMessage;\n                }();\n            });\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c, _d, _e;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        this.log.error(\"unsupported data type\", Object.assign(Object.assign({}, this.logContext), {\n                            data: message.data\n                        }));\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (dp.sequence > 0 && dp.participantSid !== \"\") {\n                        const lastSeq = this.reliableReceivedState.get(dp.participantSid);\n                        if (lastSeq && dp.sequence <= lastSeq) {\n                            // ignore duplicate or out-of-order packets in reliable channel\n                            return;\n                        }\n                        this.reliableReceivedState.set(dp.participantSid, dp.sequence);\n                    }\n                    if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === \"speaker\") {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === \"encryptedPacket\") {\n                        if (!this.e2eeManager) {\n                            this.log.error(\"Received encrypted packet but E2EE not set up\", this.logContext);\n                            return;\n                        }\n                        const decryptedData = yield (_c = this.e2eeManager) === null || _c === void 0 ? void 0 : _c.handleEncryptedData(dp.value.value.encryptedValue, dp.value.value.iv, dp.participantIdentity, dp.value.value.keyIndex);\n                        const decryptedPacket = EncryptedPacketPayload.fromBinary(decryptedData.payload);\n                        const newDp = new DataPacket({\n                            value: decryptedPacket.value,\n                            participantIdentity: dp.participantIdentity,\n                            participantSid: dp.participantSid\n                        });\n                        if (((_d = newDp.value) === null || _d === void 0 ? void 0 : _d.case) === \"user\") {\n                            // compatibility\n                            applyUserDataCompat(newDp, newDp.value.value);\n                        }\n                        this.emit(EngineEvent.DataPacketReceived, newDp, dp.value.value.encryptionType);\n                    } else {\n                        if (((_e = dp.value) === null || _e === void 0 ? void 0 : _e.case) === \"user\") {\n                            // compatibility\n                            applyUserDataCompat(dp, dp.value.value);\n                        }\n                        this.emit(EngineEvent.DataPacketReceived, dp, Encryption_Type.NONE);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n                    error\n                }));\n            } else {\n                this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n                    event\n                }));\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we'll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason).finally(()=>this.reconnectTimeout = undefined), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            if (kind === DataPacket_Kind.RELIABLE) {\n                const dc = this.dataChannelForKind(kind);\n                if (dc) {\n                    this.reliableMessageBuffer.alignBufferedAmount(dc.bufferedAmount);\n                }\n            }\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== \"undefined\" && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.url) {\n                    return;\n                }\n                const hasNetworkConnection = yield fetch(toHttpUrl(this.url), {\n                    method: \"HEAD\"\n                }).then((resp)=>resp.ok).catch(()=>false);\n                if (!hasNetworkConnection) {\n                    return;\n                }\n                this.log.info(\"detected network reconnected\");\n                if (// in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n                this.client.currentState === SignalConnectionState.RECONNECTING || // also if the browser went offline before and the engine still thinks it's in a connected state, treat it as a network interruption that we haven't noticed yet\n                this.isWaitingForNetworkReconnect && this.client.currentState === SignalConnectionState.CONNECTED) {\n                    this.clearReconnectTimeout();\n                    this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n                    this.isWaitingForNetworkReconnect = false;\n                }\n            });\n        this.handleBrowserOffline = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.url) {\n                    return;\n                }\n                try {\n                    yield Promise.race([\n                        fetch(toHttpUrl(this.url), {\n                            method: \"HEAD\"\n                        }),\n                        // if there's no internet connection the fetch rejects immediately, so we only use a short timeout here\n                        sleep(4000).then(()=>Promise.reject())\n                    ]);\n                } catch (e) {\n                    // only set if the browser still thinks it's offline after the request failed\n                    if (window.navigator.onLine === false) {\n                        this.log.info(\"detected network interruption\");\n                        this.isWaitingForNetworkReconnect = true;\n                    }\n                }\n            });\n        this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n        this.loggerOptions = {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.logContext\n        };\n        this.client = new SignalClient(undefined, this.loggerOptions);\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.closingLock = new _();\n        this.dataProcessLock = new _();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n        this.client.onRequestResponse = (response)=>this.emit(EngineEvent.SignalRequestResponse, response);\n    }\n    /** @internal */ get logContext() {\n        var _a, _b, _c, _d, _e, _f;\n        return {\n            room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n            roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n            participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,\n            pID: this.participantSid\n        };\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary || joinResponse.fastPublish) {\n                    this.negotiate().catch((err)=>{\n                        livekitLogger.error(err, this.logContext);\n                    });\n                }\n                this.registerOnLineListener();\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                this.emit(EngineEvent.SignalConnected, joinResponse);\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === ConnectionErrorReason.ServerUnreachable) {\n                        this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.joinAttempts = 0;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n            this.reliableMessageBuffer = new DataPacketBuffer();\n            this.reliableDataSequence = 1;\n            this.reliableReceivedState.clear();\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError(\"a track with the same ID has already been published\");\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError(\"publication of local track timed out, no response from server\", ConnectionErrorReason.Timeout));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error(\"Cancelled publication by calling unpublish\"));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            this.log.warn(\"failed to remove track\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, this.options.singlePeerConnection ? \"publisher-only\" : joinResponse.subscriberPrimary ? \"subscriber-primary\" : \"publisher-primary\", this.loggerOptions);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer, offerId)=>{\n                this.client.sendOffer(offer, offerId);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n                    if ([\n                        \"closed\",\n                        \"disconnected\",\n                        \"failed\"\n                    ].includes(publisherState)) {\n                        // reset publisher connection promise\n                        this.publisherConnectionPromise = undefined;\n                    }\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n                        if (this.pcState === PCState.Connected || this.pcState === PCState.Reconnecting) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect(\"peerconnection failed\", subscriberState === \"failed\" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                    // detect cases where both signal client and peer connection are severed and assume that user has lost network connection\n                    const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;\n                    const isPCSevered = [\n                        PCTransportState.FAILED,\n                        PCTransportState.CLOSING,\n                        PCTransportState.CLOSED\n                    ].includes(connectionState);\n                    if (isSignalSevered && isPCSevered && !this._isClosed) {\n                        this.emit(EngineEvent.Offline);\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                // this fires after the underlying transceiver is stopped and potentially\n                // peer connection closed, so do not bubble up if there are no streams\n                if (ev.streams.length === 0) return;\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {\n                this.createDataChannels();\n            }\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd, offerId, midToTrackId)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                this.log.debug(\"received server answer\", Object.assign(Object.assign({}, this.logContext), {\n                    RTCSdpType: sd.type,\n                    sdp: sd.sdp,\n                    midToTrackId\n                }));\n                this.midToTrackId = midToTrackId;\n                yield this.pcManager.setPublisherAnswer(sd, offerId);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            this.log.debug(\"got ICE candidate from peer\", Object.assign(Object.assign({}, this.logContext), {\n                candidate,\n                target\n            }));\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd, offerId, midToTrackId)=>__awaiter(this, void 0, void 0, function*() {\n                this.latestRemoteOfferId = offerId;\n                if (!this.pcManager) {\n                    return;\n                }\n                this.midToTrackId = midToTrackId;\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd, offerId);\n                if (answer) {\n                    this.client.sendAnswer(answer, offerId);\n                }\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            var _a;\n            this.log.debug(\"received trackPublishedResponse\", Object.assign(Object.assign({}, this.logContext), {\n                cid: res.cid,\n                track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n            }));\n            if (!this.pendingTrackResolvers[res.cid]) {\n                this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n                    cid: res.cid\n                }));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onLocalTrackUnpublished = (response)=>{\n            this.emit(EngineEvent.LocalTrackUnpublished, response);\n        };\n        this.client.onLocalTrackSubscribed = (trackSid)=>{\n            this.emit(EngineEvent.LocalTrackSubscribed, trackSid);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            var _a;\n            this.token = token;\n            (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.updateToken(token);\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onRoomMoved = (res)=>{\n            var _a;\n            this.participantSid = (_a = res.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            if (this.latestJoinResponse) {\n                this.latestJoinResponse.room = res.room;\n            }\n            this.emit(EngineEvent.RoomMoved, res);\n        };\n        this.client.onMediaSectionsRequirement = (requirement)=>{\n            var _a, _b;\n            const transceiverInit = {\n                direction: \"recvonly\"\n            };\n            for(let i = 0; i < requirement.numAudios; i++){\n                (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.addPublisherTransceiverOfKind(\"audio\", transceiverInit);\n            }\n            for(let i = 0; i < requirement.numVideos; i++){\n                (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.addPublisherTransceiverOfKind(\"video\", transceiverInit);\n            }\n            this.negotiate();\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            this.log.debug(\"client leave request\", Object.assign(Object.assign({}, this.logContext), {\n                reason: leave === null || leave === void 0 ? void 0 : leave.reason\n            }));\n            if (leave.regions && this.regionUrlProvider) {\n                this.log.debug(\"updating regions\", this.logContext);\n                this.regionUrlProvider.setServerReportedRegions({\n                    updatedAtInMs: Date.now(),\n                    maxAgeInMs: DEFAULT_MAX_AGE_MS,\n                    regionSettings: leave.regions\n                });\n            }\n            switch(leave.action){\n                case LeaveRequest_Action.DISCONNECT:\n                    this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                    this.close();\n                    break;\n                case LeaveRequest_Action.RECONNECT:\n                    this.fullReconnectOnNext = true;\n                    // reconnect immediately instead of waiting for next attempt\n                    this.handleDisconnect(leaveReconnect);\n                    break;\n                case LeaveRequest_Action.RESUME:\n                    // reconnect immediately instead of waiting for next attempt\n                    this.handleDisconnect(leaveReconnect);\n            }\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            this.log.debug(\"E2EE - setting up transports with insertable streams\", this.logContext);\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = \"relay\";\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = \"unified-plan\";\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = \"gather_continually\";\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            ordered: false,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                this.log.warn(\"using add-track fallback\", this.logContext);\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                this.log.debug(\"using add-track fallback\", this.logContext);\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            if (isVideoTrack(track)) {\n                track.codec = opts.videoCodec;\n            }\n            const transceiverInit = {\n                direction: \"sendonly\",\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const transceiverInit = {\n                direction: \"sendonly\"\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                livekitLogger.warn(\"already attempting reconnect, returning early\", this.logContext);\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    this.log.debug(\"received unrecoverable error\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKNOWN);\n                } else {\n                    this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            this.log.warn(\"encountered error in reconnect policy\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don't attempt reconnection\n                    throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n                }\n                this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        this.log.warn(\"attempted connection restart, without signal options present\", this.logContext);\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {\n                        throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error(\"simulated failure\");\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                // re-check signal connection state before setting engine as resumed\n                if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                    throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n                }\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we're not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!this.url || !this.token) {\n                // permanent failure, don't attempt reconnection\n                throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n            }\n            this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n            this.emit(EngineEvent.Resuming);\n            let res;\n            try {\n                this.setupSignalClientCallbacks();\n                res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n            } catch (error) {\n                let message = \"\";\n                if (error instanceof Error) {\n                    message = error.message;\n                    this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\n                    throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                }\n                if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {\n                    throw error;\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (res) {\n                const rtcConfig = this.makeRTCConfiguration(res);\n                this.pcManager.updateConfiguration(rtcConfig);\n                if (this.latestJoinResponse) {\n                    this.latestJoinResponse.serverInfo = res.serverInfo;\n                }\n            } else {\n                this.log.warn(\"Did not receive reconnect response\", this.logContext);\n            }\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error(\"simulated failure\");\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            // re-check signal connection state before setting engine as resumed\n            if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n            }\n            this.client.setReconnected();\n            // recreate publish datachannel if it's id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\" && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            if (res === null || res === void 0 ? void 0 : res.lastMessageSeq) {\n                this.resendReliableMessagesForResume(res.lastMessageSeq);\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"PC manager is closed\");\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            this.log.debug(\"waiting for peer connection to reconnect\", this.logContext);\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError(\"could not establish PC connection, \".concat(e.message), ConnectionErrorReason.InternalError);\n            }\n        });\n    }\n    /** @internal */ publishRpcResponse(destinationIdentity, requestId, payload, error) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcResponse\",\n                    value: new RpcResponse({\n                        requestId,\n                        value: error ? {\n                            case: \"error\",\n                            value: error.toProto()\n                        } : {\n                            case: \"payload\",\n                            value: payload !== null && payload !== void 0 ? payload : \"\"\n                        }\n                    })\n                }\n            });\n            yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /** @internal */ publishRpcAck(destinationIdentity, requestId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcAck\",\n                    value: new RpcAck({\n                        requestId\n                    })\n                }\n            });\n            yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            if (this.e2eeManager && this.e2eeManager.isDataChannelEncryptionEnabled) {\n                const encryptablePacket = asEncryptablePacket(packet);\n                if (encryptablePacket) {\n                    const encryptedData = yield this.e2eeManager.encryptData(encryptablePacket.toBinary());\n                    packet.value = {\n                        case: \"encryptedPacket\",\n                        value: new EncryptedPacket({\n                            encryptedValue: encryptedData.payload,\n                            iv: encryptedData.iv,\n                            keyIndex: encryptedData.keyIndex\n                        })\n                    };\n                }\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                packet.sequence = this.reliableDataSequence;\n                this.reliableDataSequence += 1;\n            }\n            const msg = packet.toBinary();\n            yield this.waitForBufferStatusLow(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                if (kind === DataPacket_Kind.RELIABLE) {\n                    this.reliableMessageBuffer.push({\n                        data: msg,\n                        sequence: packet.sequence\n                    });\n                }\n                if (this.attemptingReconnect) {\n                    return;\n                }\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    resendReliableMessagesForResume(lastMessageSeq) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.ensurePublisherConnected(DataPacket_Kind.RELIABLE);\n            const dc = this.dataChannelForKind(DataPacket_Kind.RELIABLE);\n            if (dc) {\n                this.reliableMessageBuffer.popToSequence(lastMessageSeq);\n                this.reliableMessageBuffer.getAll().forEach((msg)=>{\n                    dc.send(msg.data);\n                });\n            }\n            this.updateAndEmitDCBufferStatus(DataPacket_Kind.RELIABLE);\n        });\n    }\n    waitForBufferStatusLow(kind) {\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                if (this.isBufferStatusLow(kind)) {\n                    resolve();\n                } else {\n                    const onClosing = ()=>reject(\"Engine closed\");\n                    this.once(EngineEvent.Closing, onClosing);\n                    while(!this.dcBufferStatus.get(kind)){\n                        yield sleep(10);\n                    }\n                    this.off(EngineEvent.Closing, onClosing);\n                    resolve();\n                }\n            }));\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind_1) {\n        return __awaiter(this, arguments, void 0, function(kind) {\n            var _this2 = this;\n            let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n            return function*() {\n                var _a;\n                if (!_this2.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;\n                const transportName = subscriber ? \"Subscriber\" : \"Publisher\";\n                if (!transport) {\n                    throw new ConnectionError(\"\".concat(transportName, \" connection not set\"), ConnectionErrorReason.InternalError);\n                }\n                let needNegotiation = false;\n                if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {\n                    _this2.createDataChannels();\n                    needNegotiation = true;\n                }\n                if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== \"checking\") {\n                    needNegotiation = true;\n                }\n                if (needNegotiation) {\n                    // start negotiation\n                    _this2.negotiate().catch((err)=>{\n                        livekitLogger.error(err, _this2.logContext);\n                    });\n                }\n                const targetChannel = _this2.dataChannelForKind(kind, subscriber);\n                if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === \"open\") {\n                    return;\n                }\n                // wait until ICE connected\n                const endTime = new Date().getTime() + _this2.peerConnectionTimeout;\n                while(new Date().getTime() < endTime){\n                    if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\") {\n                        return;\n                    }\n                    yield sleep(50);\n                }\n                throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);\n            }();\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.publisherConnectionPromise) {\n                this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);\n            }\n            yield this.publisherConnectionPromise;\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError(\"PC manager is closed\"));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed\n                    if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {\n                        this.createDataChannels();\n                    }\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        this.log.debug(\"engine disconnected while negotiation was ongoing\", this.logContext);\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject(\"cannot negotiate on closed engine\");\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b, _c, _d;\n        if (!this.pcManager) {\n            this.log.warn(\"sync state cannot be sent without peer connection setup\", this.logContext);\n            return;\n        }\n        const previousPublisherOffer = this.pcManager.publisher.getLocalDescription();\n        const previousPublisherAnswer = this.pcManager.publisher.getRemoteDescription();\n        const previousSubscriberOffer = (_a = this.pcManager.subscriber) === null || _a === void 0 ? void 0 : _a.getRemoteDescription();\n        const previousSubscriberAnswer = (_b = this.pcManager.subscriber) === null || _b === void 0 ? void 0 : _b.getLocalDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_d = (_c = this.signalOpts) === null || _c === void 0 ? void 0 : _c.autoSubscribe) !== null && _d !== void 0 ? _d : true;\n        const trackSids = new Array();\n        const trackSidsDisabled = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n            if (!track.isEnabled) {\n                trackSidsDisabled.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: this.options.singlePeerConnection ? previousPublisherAnswer ? toProtoSessionDescription({\n                sdp: previousPublisherAnswer.sdp,\n                type: previousPublisherAnswer.type\n            }) : undefined : previousSubscriberAnswer ? toProtoSessionDescription({\n                sdp: previousSubscriberAnswer.sdp,\n                type: previousSubscriberAnswer.type\n            }) : undefined,\n            offer: this.options.singlePeerConnection ? previousPublisherOffer ? toProtoSessionDescription({\n                sdp: previousPublisherOffer.sdp,\n                type: previousPublisherOffer.type\n            }) : undefined : previousSubscriberOffer ? toProtoSessionDescription({\n                sdp: previousSubscriberOffer.sdp,\n                type: previousSubscriberOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo(),\n            trackSidsDisabled,\n            datachannelReceiveStates: this.reliableReceivedState.map((seq, sid)=>{\n                return new DataChannelReceiveState({\n                    publisherSid: sid,\n                    lastSeq: seq\n                });\n            })\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener(\"online\", this.handleBrowserOnLine);\n            window.addEventListener(\"offline\", this.handleBrowserOffline);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener(\"online\", this.handleBrowserOnLine);\n            window.removeEventListener(\"offline\", this.handleBrowserOffline);\n        }\n    }\n    getTrackIdForReceiver(receiver) {\n        var _a;\n        const mid = (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getMidForReceiver(receiver);\n        if (mid) {\n            const match = Object.entries(this.midToTrackId).find((_ref2)=>{\n                let [key] = _ref2;\n                return key === mid;\n            });\n            if (match) {\n                return match[1];\n            }\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nfunction supportOptionalDatachannel(protocol) {\n    return protocol !== undefined && protocol > 13;\n}\nfunction applyUserDataCompat(newObj, oldObj) {\n    const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;\n    newObj.participantIdentity = participantIdentity;\n    oldObj.participantIdentity = participantIdentity;\n    const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;\n    newObj.destinationIdentities = destinationIdentities;\n    oldObj.destinationIdentities = destinationIdentities;\n}\nclass BaseStreamReader {\n    get info() {\n        return this._info;\n    }\n    /** @internal */ validateBytesReceived() {\n        let doneReceiving = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        if (typeof this.totalByteSize !== \"number\" || this.totalByteSize === 0) {\n            return;\n        }\n        if (doneReceiving && this.bytesReceived < this.totalByteSize) {\n            throw new DataStreamError(\"Not enough chunk(s) received - expected \".concat(this.totalByteSize, \" bytes of data total, only received \").concat(this.bytesReceived, \" bytes\"), DataStreamErrorReason.Incomplete);\n        } else if (this.bytesReceived > this.totalByteSize) {\n            throw new DataStreamError(\"Extra chunk(s) received - expected \".concat(this.totalByteSize, \" bytes of data total, received \").concat(this.bytesReceived, \" bytes\"), DataStreamErrorReason.LengthExceeded);\n        }\n    }\n    constructor(info, stream, totalByteSize, outOfBandFailureRejectingFuture){\n        this.reader = stream;\n        this.totalByteSize = totalByteSize;\n        this._info = info;\n        this.bytesReceived = 0;\n        this.outOfBandFailureRejectingFuture = outOfBandFailureRejectingFuture;\n    }\n}\nclass ByteStreamReader extends BaseStreamReader {\n    handleChunkReceived(chunk) {\n        var _a;\n        this.bytesReceived += chunk.content.byteLength;\n        this.validateBytesReceived();\n        const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n        (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n    }\n    [Symbol.asyncIterator]() {\n        const reader = this.reader.getReader();\n        let rejectingSignalFuture = new Future();\n        let activeSignal = null;\n        let onAbort = null;\n        if (this.signal) {\n            const signal = this.signal;\n            onAbort = ()=>{\n                var _a;\n                (_a = rejectingSignalFuture.reject) === null || _a === void 0 ? void 0 : _a.call(rejectingSignalFuture, signal.reason);\n            };\n            signal.addEventListener(\"abort\", onAbort);\n            activeSignal = signal;\n        }\n        const cleanup = ()=>{\n            reader.releaseLock();\n            if (activeSignal && onAbort) {\n                activeSignal.removeEventListener(\"abort\", onAbort);\n            }\n            this.signal = undefined;\n        };\n        return {\n            next: ()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    try {\n                        const { done, value } = yield Promise.race([\n                            reader.read(),\n                            // Rejects if this.signal is aborted\n                            rejectingSignalFuture.promise,\n                            // Rejects if something external says it should, like a participant disconnecting, etc\n                            (_b = (_a = this.outOfBandFailureRejectingFuture) === null || _a === void 0 ? void 0 : _a.promise) !== null && _b !== void 0 ? _b : new Promise(()=>{\n                            /* never resolves */ })\n                        ]);\n                        if (done) {\n                            this.validateBytesReceived(true);\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        } else {\n                            this.handleChunkReceived(value);\n                            return {\n                                done: false,\n                                value: value.content\n                            };\n                        }\n                    } catch (err) {\n                        cleanup();\n                        throw err;\n                    }\n                }),\n            // note: `return` runs only for premature exits, see:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#errors_during_iteration\n            return () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    cleanup();\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                });\n            }\n        };\n    }\n    /**\n   * Injects an AbortSignal, which if aborted, will terminate the currently active\n   * stream iteration operation.\n   *\n   * Note that when using AbortSignal.timeout(...), the timeout applies across\n   * the whole iteration operation, not just one individual chunk read.\n   */ withAbortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    readAll() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this = this;\n            let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            return function*() {\n                var _a, e_1, _b, _c;\n                let chunks = new Set();\n                const iterator = opts.signal ? _this.withAbortSignal(opts.signal) : _this;\n                try {\n                    for(var _d = true, iterator_1 = __asyncValues(iterator), iterator_1_1; iterator_1_1 = yield iterator_1.next(), _a = iterator_1_1.done, !_a; _d = true){\n                        _c = iterator_1_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        chunks.add(chunk);\n                    }\n                } catch (e_1_1) {\n                    e_1 = {\n                        error: e_1_1\n                    };\n                } finally{\n                    try {\n                        if (!_d && !_a && (_b = iterator_1.return)) yield _b.call(iterator_1);\n                    } finally{\n                        if (e_1) throw e_1.error;\n                    }\n                }\n                return Array.from(chunks);\n            }();\n        });\n    }\n}\n/**\n * A class to read chunks from a ReadableStream and provide them in a structured format.\n */ class TextStreamReader extends BaseStreamReader {\n    /**\n   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string\n   * that has been received up to the current point in time.\n   */ constructor(info, stream, totalChunkCount, outOfBandFailureRejectingFuture){\n        super(info, stream, totalChunkCount, outOfBandFailureRejectingFuture);\n        this.receivedChunks = new Map();\n    }\n    handleChunkReceived(chunk) {\n        var _a;\n        const index = bigIntToNumber(chunk.chunkIndex);\n        const previousChunkAtIndex = this.receivedChunks.get(index);\n        if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {\n            // we have a newer version already, dropping the old one\n            return;\n        }\n        this.receivedChunks.set(index, chunk);\n        this.bytesReceived += chunk.content.byteLength;\n        this.validateBytesReceived();\n        const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n        (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n    }\n    /**\n   * Async iterator implementation to allow usage of `for await...of` syntax.\n   * Yields structured chunks from the stream.\n   *\n   */ [Symbol.asyncIterator]() {\n        const reader = this.reader.getReader();\n        const decoder = new TextDecoder(\"utf-8\", {\n            fatal: true\n        });\n        let rejectingSignalFuture = new Future();\n        let activeSignal = null;\n        let onAbort = null;\n        if (this.signal) {\n            const signal = this.signal;\n            onAbort = ()=>{\n                var _a;\n                (_a = rejectingSignalFuture.reject) === null || _a === void 0 ? void 0 : _a.call(rejectingSignalFuture, signal.reason);\n            };\n            signal.addEventListener(\"abort\", onAbort);\n            activeSignal = signal;\n        }\n        const cleanup = ()=>{\n            reader.releaseLock();\n            if (activeSignal && onAbort) {\n                activeSignal.removeEventListener(\"abort\", onAbort);\n            }\n            this.signal = undefined;\n        };\n        return {\n            next: ()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    try {\n                        const { done, value } = yield Promise.race([\n                            reader.read(),\n                            // Rejects if this.signal is aborted\n                            rejectingSignalFuture.promise,\n                            // Rejects if something external says it should, like a participant disconnecting, etc\n                            (_b = (_a = this.outOfBandFailureRejectingFuture) === null || _a === void 0 ? void 0 : _a.promise) !== null && _b !== void 0 ? _b : new Promise(()=>{\n                            /* never resolves */ })\n                        ]);\n                        if (done) {\n                            this.validateBytesReceived(true);\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        } else {\n                            this.handleChunkReceived(value);\n                            let decodedResult;\n                            try {\n                                decodedResult = decoder.decode(value.content);\n                            } catch (err) {\n                                throw new DataStreamError(\"Cannot decode datastream chunk \".concat(value.chunkIndex, \" as text: \").concat(err), DataStreamErrorReason.DecodeFailed);\n                            }\n                            return {\n                                done: false,\n                                value: decodedResult\n                            };\n                        }\n                    } catch (err) {\n                        cleanup();\n                        throw err;\n                    }\n                }),\n            // note: `return` runs only for premature exits, see:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#errors_during_iteration\n            return () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    cleanup();\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                });\n            }\n        };\n    }\n    /**\n   * Injects an AbortSignal, which if aborted, will terminate the currently active\n   * stream iteration operation.\n   *\n   * Note that when using AbortSignal.timeout(...), the timeout applies across\n   * the whole iteration operation, not just one individual chunk read.\n   */ withAbortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    readAll() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this2 = this;\n            let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            return function*() {\n                var _a, e_2, _b, _c;\n                let finalString = \"\";\n                const iterator = opts.signal ? _this2.withAbortSignal(opts.signal) : _this2;\n                try {\n                    for(var _d = true, iterator_2 = __asyncValues(iterator), iterator_2_1; iterator_2_1 = yield iterator_2.next(), _a = iterator_2_1.done, !_a; _d = true){\n                        _c = iterator_2_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        finalString += chunk;\n                    }\n                } catch (e_2_1) {\n                    e_2 = {\n                        error: e_2_1\n                    };\n                } finally{\n                    try {\n                        if (!_d && !_a && (_b = iterator_2.return)) yield _b.call(iterator_2);\n                    } finally{\n                        if (e_2) throw e_2.error;\n                    }\n                }\n                return finalString;\n            }();\n        });\n    }\n}\nclass IncomingDataStreamManager {\n    constructor(){\n        this.log = livekitLogger;\n        this.byteStreamControllers = new Map();\n        this.textStreamControllers = new Map();\n        this.byteStreamHandlers = new Map();\n        this.textStreamHandlers = new Map();\n    }\n    registerTextStreamHandler(topic, callback) {\n        if (this.textStreamHandlers.has(topic)) {\n            throw new DataStreamError('A text stream handler for topic \"'.concat(topic, '\" has already been set.'), DataStreamErrorReason.HandlerAlreadyRegistered);\n        }\n        this.textStreamHandlers.set(topic, callback);\n    }\n    unregisterTextStreamHandler(topic) {\n        this.textStreamHandlers.delete(topic);\n    }\n    registerByteStreamHandler(topic, callback) {\n        if (this.byteStreamHandlers.has(topic)) {\n            throw new DataStreamError('A byte stream handler for topic \"'.concat(topic, '\" has already been set.'), DataStreamErrorReason.HandlerAlreadyRegistered);\n        }\n        this.byteStreamHandlers.set(topic, callback);\n    }\n    unregisterByteStreamHandler(topic) {\n        this.byteStreamHandlers.delete(topic);\n    }\n    clearControllers() {\n        this.byteStreamControllers.clear();\n        this.textStreamControllers.clear();\n    }\n    validateParticipantHasNoActiveDataStreams(participantIdentity) {\n        var _a, _b, _c, _d;\n        // Terminate any in flight data stream receives from the given participant\n        const textStreamsBeingSentByDisconnectingParticipant = Array.from(this.textStreamControllers.entries()).filter((entry)=>entry[1].sendingParticipantIdentity === participantIdentity);\n        const byteStreamsBeingSentByDisconnectingParticipant = Array.from(this.byteStreamControllers.entries()).filter((entry)=>entry[1].sendingParticipantIdentity === participantIdentity);\n        if (textStreamsBeingSentByDisconnectingParticipant.length > 0 || byteStreamsBeingSentByDisconnectingParticipant.length > 0) {\n            const abnormalEndError = new DataStreamError(\"Participant \".concat(participantIdentity, \" unexpectedly disconnected in the middle of sending data\"), DataStreamErrorReason.AbnormalEnd);\n            for (const [id, controller] of byteStreamsBeingSentByDisconnectingParticipant){\n                (_b = (_a = controller.outOfBandFailureRejectingFuture).reject) === null || _b === void 0 ? void 0 : _b.call(_a, abnormalEndError);\n                this.byteStreamControllers.delete(id);\n            }\n            for (const [id, controller] of textStreamsBeingSentByDisconnectingParticipant){\n                (_d = (_c = controller.outOfBandFailureRejectingFuture).reject) === null || _d === void 0 ? void 0 : _d.call(_c, abnormalEndError);\n                this.textStreamControllers.delete(id);\n            }\n        }\n    }\n    handleDataStreamPacket(packet, encryptionType) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(packet.value.case){\n                case \"streamHeader\":\n                    return this.handleStreamHeader(packet.value.value, packet.participantIdentity, encryptionType);\n                case \"streamChunk\":\n                    return this.handleStreamChunk(packet.value.value, encryptionType);\n                case \"streamTrailer\":\n                    return this.handleStreamTrailer(packet.value.value, encryptionType);\n                default:\n                    throw new Error('DataPacket of value \"'.concat(packet.value.case, '\" is not data stream related!'));\n            }\n        });\n    }\n    handleStreamHeader(streamHeader, participantIdentity, encryptionType) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (streamHeader.contentHeader.case === \"byteHeader\") {\n                const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);\n                if (!streamHandlerCallback) {\n                    this.log.debug(\"ignoring incoming byte stream due to no handler for topic\", streamHeader.topic);\n                    return;\n                }\n                let streamController;\n                const outOfBandFailureRejectingFuture = new Future();\n                outOfBandFailureRejectingFuture.promise.catch((err)=>{\n                    this.log.error(err);\n                });\n                const info = {\n                    id: streamHeader.streamId,\n                    name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : \"unknown\",\n                    mimeType: streamHeader.mimeType,\n                    size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n                    topic: streamHeader.topic,\n                    timestamp: bigIntToNumber(streamHeader.timestamp),\n                    attributes: streamHeader.attributes,\n                    encryptionType\n                };\n                const stream = new ReadableStream({\n                    start: (controller)=>{\n                        streamController = controller;\n                        if (this.textStreamControllers.has(streamHeader.streamId)) {\n                            throw new DataStreamError(\"A data stream read is already in progress for a stream with id \".concat(streamHeader.streamId, \".\"), DataStreamErrorReason.AlreadyOpened);\n                        }\n                        this.byteStreamControllers.set(streamHeader.streamId, {\n                            info,\n                            controller: streamController,\n                            startTime: Date.now(),\n                            sendingParticipantIdentity: participantIdentity,\n                            outOfBandFailureRejectingFuture\n                        });\n                    }\n                });\n                streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength), outOfBandFailureRejectingFuture), {\n                    identity: participantIdentity\n                });\n            } else if (streamHeader.contentHeader.case === \"textHeader\") {\n                const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);\n                if (!streamHandlerCallback) {\n                    this.log.debug(\"ignoring incoming text stream due to no handler for topic\", streamHeader.topic);\n                    return;\n                }\n                let streamController;\n                const outOfBandFailureRejectingFuture = new Future();\n                outOfBandFailureRejectingFuture.promise.catch((err)=>{\n                    this.log.error(err);\n                });\n                const info = {\n                    id: streamHeader.streamId,\n                    mimeType: streamHeader.mimeType,\n                    size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n                    topic: streamHeader.topic,\n                    timestamp: Number(streamHeader.timestamp),\n                    attributes: streamHeader.attributes,\n                    encryptionType\n                };\n                const stream = new ReadableStream({\n                    start: (controller)=>{\n                        streamController = controller;\n                        if (this.textStreamControllers.has(streamHeader.streamId)) {\n                            throw new DataStreamError(\"A data stream read is already in progress for a stream with id \".concat(streamHeader.streamId, \".\"), DataStreamErrorReason.AlreadyOpened);\n                        }\n                        this.textStreamControllers.set(streamHeader.streamId, {\n                            info,\n                            controller: streamController,\n                            startTime: Date.now(),\n                            sendingParticipantIdentity: participantIdentity,\n                            outOfBandFailureRejectingFuture\n                        });\n                    }\n                });\n                streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength), outOfBandFailureRejectingFuture), {\n                    identity: participantIdentity\n                });\n            }\n        });\n    }\n    handleStreamChunk(chunk, encryptionType) {\n        const fileBuffer = this.byteStreamControllers.get(chunk.streamId);\n        if (fileBuffer) {\n            if (fileBuffer.info.encryptionType !== encryptionType) {\n                fileBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(chunk.streamId, \". Expected \").concat(encryptionType, \", got \").concat(fileBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n                this.byteStreamControllers.delete(chunk.streamId);\n            } else if (chunk.content.length > 0) {\n                fileBuffer.controller.enqueue(chunk);\n            }\n        }\n        const textBuffer = this.textStreamControllers.get(chunk.streamId);\n        if (textBuffer) {\n            if (textBuffer.info.encryptionType !== encryptionType) {\n                textBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(chunk.streamId, \". Expected \").concat(encryptionType, \", got \").concat(textBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n                this.textStreamControllers.delete(chunk.streamId);\n            } else if (chunk.content.length > 0) {\n                textBuffer.controller.enqueue(chunk);\n            }\n        }\n    }\n    handleStreamTrailer(trailer, encryptionType) {\n        const textBuffer = this.textStreamControllers.get(trailer.streamId);\n        if (textBuffer) {\n            if (textBuffer.info.encryptionType !== encryptionType) {\n                textBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(trailer.streamId, \". Expected \").concat(encryptionType, \", got \").concat(textBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n            } else {\n                textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);\n                textBuffer.controller.close();\n                this.textStreamControllers.delete(trailer.streamId);\n            }\n        }\n        const fileBuffer = this.byteStreamControllers.get(trailer.streamId);\n        if (fileBuffer) {\n            if (fileBuffer.info.encryptionType !== encryptionType) {\n                fileBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(trailer.streamId, \". Expected \").concat(encryptionType, \", got \").concat(fileBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n            } else {\n                fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);\n                fileBuffer.controller.close();\n            }\n            this.byteStreamControllers.delete(trailer.streamId);\n        }\n    }\n}\nclass BaseStreamWriter {\n    constructor(writableStream, info, onClose){\n        this.writableStream = writableStream;\n        this.defaultWriter = writableStream.getWriter();\n        this.onClose = onClose;\n        this.info = info;\n    }\n    write(chunk) {\n        return this.defaultWriter.write(chunk);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield this.defaultWriter.close();\n            this.defaultWriter.releaseLock();\n            (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\nclass TextStreamWriter extends BaseStreamWriter {\n}\nclass ByteStreamWriter extends BaseStreamWriter {\n}\nconst STREAM_CHUNK_SIZE = 15000;\n/**\n * Manages sending custom user data via data channels.\n * @internal\n */ class OutgoingDataStreamManager {\n    constructor(engine, log){\n        this.engine = engine;\n        this.log = log;\n    }\n    setupEngine(engine) {\n        this.engine = engine;\n    }\n    /** {@inheritDoc LocalParticipant.sendText} */ sendText(text, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const streamId = crypto.randomUUID();\n            const textInBytes = new TextEncoder().encode(text);\n            const totalTextLength = textInBytes.byteLength;\n            const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(()=>crypto.randomUUID());\n            const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);\n            const handleProgress = (progress, idx)=>{\n                var _a;\n                progresses[idx] = progress;\n                const totalProgress = progresses.reduce((acc, val)=>acc + val, 0);\n                (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, totalProgress);\n            };\n            const writer = yield this.streamText({\n                streamId,\n                totalSize: totalTextLength,\n                destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,\n                topic: options === null || options === void 0 ? void 0 : options.topic,\n                attachedStreamIds: fileIds,\n                attributes: options === null || options === void 0 ? void 0 : options.attributes\n            });\n            yield writer.write(text);\n            // set text part of progress to 1\n            handleProgress(1, 0);\n            yield writer.close();\n            if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {\n                yield Promise.all(options.attachments.map((file, idx)=>__awaiter(this, void 0, void 0, function*() {\n                        return this._sendFile(fileIds[idx], file, {\n                            topic: options.topic,\n                            mimeType: file.type,\n                            onProgress: (progress)=>{\n                                handleProgress(progress, idx + 1);\n                            }\n                        });\n                    })));\n            }\n            return writer.info;\n        });\n    }\n    /**\n   * @internal\n   * @experimental CAUTION, might get removed in a minor release\n   */ streamText(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            const info = {\n                id: streamId,\n                mimeType: \"text/plain\",\n                timestamp: Date.now(),\n                topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : \"\",\n                size: options === null || options === void 0 ? void 0 : options.totalSize,\n                attributes: options === null || options === void 0 ? void 0 : options.attributes,\n                encryptionType: ((_c = this.engine.e2eeManager) === null || _c === void 0 ? void 0 : _c.isDataChannelEncryptionEnabled) ? Encryption_Type.GCM : Encryption_Type.NONE\n            };\n            const header = new DataStream_Header({\n                streamId,\n                mimeType: info.mimeType,\n                topic: info.topic,\n                timestamp: numberToBigInt(info.timestamp),\n                totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),\n                attributes: info.attributes,\n                contentHeader: {\n                    case: \"textHeader\",\n                    value: new DataStream_TextHeader({\n                        version: options === null || options === void 0 ? void 0 : options.version,\n                        attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,\n                        replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,\n                        operationType: (options === null || options === void 0 ? void 0 : options.type) === \"update\" ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE\n                    })\n                }\n            });\n            const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n            const packet = new DataPacket({\n                destinationIdentities,\n                value: {\n                    case: \"streamHeader\",\n                    value: header\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            let chunkId = 0;\n            const engine = this.engine;\n            const writableStream = new WritableStream({\n                // Implement the sink\n                write (text) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)){\n                            const chunk = new DataStream_Chunk({\n                                content: textByteChunk,\n                                streamId,\n                                chunkIndex: numberToBigInt(chunkId)\n                            });\n                            const chunkPacket = new DataPacket({\n                                destinationIdentities,\n                                value: {\n                                    case: \"streamChunk\",\n                                    value: chunk\n                                }\n                            });\n                            yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                            chunkId += 1;\n                        }\n                    });\n                },\n                close () {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const trailer = new DataStream_Trailer({\n                            streamId\n                        });\n                        const trailerPacket = new DataPacket({\n                            destinationIdentities,\n                            value: {\n                                case: \"streamTrailer\",\n                                value: trailer\n                            }\n                        });\n                        yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n                    });\n                },\n                abort (err) {\n                    console.log(\"Sink error:\", err);\n                // TODO handle aborts to signal something to receiver side\n                }\n            });\n            let onEngineClose = ()=>__awaiter(this, void 0, void 0, function*() {\n                    yield writer.close();\n                });\n            engine.once(EngineEvent.Closing, onEngineClose);\n            const writer = new TextStreamWriter(writableStream, info, ()=>this.engine.off(EngineEvent.Closing, onEngineClose));\n            return writer;\n        });\n    }\n    sendFile(file, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const streamId = crypto.randomUUID();\n            yield this._sendFile(streamId, file, options);\n            return {\n                id: streamId\n            };\n        });\n    }\n    _sendFile(streamId, file, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const writer = yield this.streamBytes({\n                streamId,\n                totalSize: file.size,\n                name: file.name,\n                mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,\n                topic: options === null || options === void 0 ? void 0 : options.topic,\n                destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities\n            });\n            const reader = file.stream().getReader();\n            while(true){\n                const { done, value } = yield reader.read();\n                if (done) {\n                    break;\n                }\n                yield writer.write(value);\n            }\n            yield writer.close();\n            return writer.info;\n        });\n    }\n    streamBytes(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c, _d, _e, _f;\n            const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n            const info = {\n                id: streamId,\n                mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : \"application/octet-stream\",\n                topic: (_c = options === null || options === void 0 ? void 0 : options.topic) !== null && _c !== void 0 ? _c : \"\",\n                timestamp: Date.now(),\n                attributes: options === null || options === void 0 ? void 0 : options.attributes,\n                size: options === null || options === void 0 ? void 0 : options.totalSize,\n                name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : \"unknown\",\n                encryptionType: ((_e = this.engine.e2eeManager) === null || _e === void 0 ? void 0 : _e.isDataChannelEncryptionEnabled) ? Encryption_Type.GCM : Encryption_Type.NONE\n            };\n            const header = new DataStream_Header({\n                totalLength: numberToBigInt((_f = info.size) !== null && _f !== void 0 ? _f : 0),\n                mimeType: info.mimeType,\n                streamId,\n                topic: info.topic,\n                timestamp: numberToBigInt(Date.now()),\n                attributes: info.attributes,\n                contentHeader: {\n                    case: \"byteHeader\",\n                    value: new DataStream_ByteHeader({\n                        name: info.name\n                    })\n                }\n            });\n            const packet = new DataPacket({\n                destinationIdentities,\n                value: {\n                    case: \"streamHeader\",\n                    value: header\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            let chunkId = 0;\n            const writeMutex = new _();\n            const engine = this.engine;\n            const logLocal = this.log;\n            const writableStream = new WritableStream({\n                write (chunk) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const unlock = yield writeMutex.lock();\n                        let byteOffset = 0;\n                        try {\n                            while(byteOffset < chunk.byteLength){\n                                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);\n                                const chunkPacket = new DataPacket({\n                                    destinationIdentities,\n                                    value: {\n                                        case: \"streamChunk\",\n                                        value: new DataStream_Chunk({\n                                            content: subChunk,\n                                            streamId,\n                                            chunkIndex: numberToBigInt(chunkId)\n                                        })\n                                    }\n                                });\n                                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                                chunkId += 1;\n                                byteOffset += subChunk.byteLength;\n                            }\n                        } finally{\n                            unlock();\n                        }\n                    });\n                },\n                close () {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const trailer = new DataStream_Trailer({\n                            streamId\n                        });\n                        const trailerPacket = new DataPacket({\n                            destinationIdentities,\n                            value: {\n                                case: \"streamTrailer\",\n                                value: trailer\n                            }\n                        });\n                        yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n                    });\n                },\n                abort (err) {\n                    logLocal.error(\"Sink error:\", err);\n                }\n            });\n            const byteWriter = new ByteStreamWriter(writableStream, info);\n            return byteWriter;\n        });\n    }\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver, loggerOptions){\n        super(mediaTrack, kind, loggerOptions);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener(\"removetrack\", onRemoveTrack);\n                if (this.receiver && \"playoutDelayHint\" in this.receiver) {\n                    this.receiver.playoutDelayHint = undefined;\n                }\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener(\"removetrack\", onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Allows to set a playout delay (in seconds) for this track.\n   * A higher value allows for more buffering of the track in the browser\n   * and will result in a delay of media being played back of `delayInSeconds`\n   */ setPlayoutDelay(delayInSeconds) {\n        if (this.receiver) {\n            if (\"playoutDelayHint\" in this.receiver) {\n                this.receiver.playoutDelayHint = delayInSeconds;\n            } else {\n                this.log.warn(\"Playout delay not supported in this browser\");\n            }\n        } else {\n            this.log.warn(\"Cannot set playout delay, track already ended\");\n        }\n    }\n    /**\n   * Returns the current playout delay (in seconds) of this track.\n   */ getPlayoutDelay() {\n        if (this.receiver) {\n            if (\"playoutDelayHint\" in this.receiver) {\n                return this.receiver.playoutDelayHint;\n            } else {\n                this.log.warn(\"Playout delay not supported in this browser\");\n            }\n        } else {\n            this.log.warn(\"Cannot get playout delay, track already ended\");\n        }\n        return 0;\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n        if (supportsSynchronizationSources()) {\n            this.registerTimeSyncUpdate();\n        }\n    }\n    registerTimeSyncUpdate() {\n        const loop = ()=>{\n            var _a;\n            this.timeSyncHandle = requestAnimationFrame(()=>loop());\n            const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];\n            if (sources) {\n                const { timestamp, rtpTimestamp } = sources;\n                if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {\n                    this.emit(TrackEvent.TimeSyncUpdate, {\n                        timestamp,\n                        rtpTimestamp\n                    });\n                    this.rtpTimestamp = rtpTimestamp;\n                }\n            }\n        };\n        loop();\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn't been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            element.setSinkId(this.sinkId).catch((e)=>{\n                this.log.error(\"Failed to set sink id on remote audio track\", e, this.logContext);\n            });\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            this.log.debug(\"using audio context mapping\", this.logContext);\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn't running already\n        if (context.state !== \"running\") {\n            context.resume().then(()=>{\n                if (context.state !== \"running\") {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    receiverStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    setStreamState(value) {\n        super.setStreamState(value);\n        this.log.debug(\"setStreamState\", value);\n        if (this.isAdaptiveStream && value === Track.StreamState.Active) {\n            // update visibility for adaptive stream tracks when stream state received from server is active\n            // this is needed to ensure the track is stopped when there's no element attached to it at all\n            this.updateVisibility();\n        }\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It's possible attach is called multiple times on an element. When that's\n        // the case, we'd want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            this.log.warn(\"visibility resize observer not triggered\", this.logContext);\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            this.log.warn(\"stopObservingElementInfo ignored\", this.logContext);\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = \"\";\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: \"video\",\n                        streamId: v.id,\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === \"codec\") {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== \"\" && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility(forceEmit) {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible && !forceEmit) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === \"screen\") {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we'll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we'll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.isPiP = isElementInPiP(this.element);\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a, _b, _c;\n            (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener(\"pagehide\", this.onLeavePiP);\n            this.isPiP = isElementInPiP(this.element);\n            (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = isElementInPiP(this.element);\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && isElementInPiP(element);\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        var _a, _b, _c;\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = isElementInPiP(this.element);\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n        (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener(\"enter\", this.onEnterPiP);\n        (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener(\"pagehide\", this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b, _c, _d, _e;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n        (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener(\"enter\", this.onEnterPiP);\n        (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener(\"pagehide\", this.onLeavePiP);\n    }\n}\nfunction isElementInPiP(el) {\n    var _a, _b;\n    // Simple video PiP\n    if (document.pictureInPictureElement === el) return true;\n    // Document PiP\n    if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);\n    return false;\n}\n// does not account for occlusion by other elements or opacity property\nfunction isElementInViewport(el, win) {\n    const viewportWindow = win || window;\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== \"none\";\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name, loggerOptions){\n        var _a;\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.log = livekitLogger;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n        this.loggerContextCb = this.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (isAudioTrack(this.track)) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (isVideoTrack(this.track)) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        this.log.debug(\"update publication info\", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus[\"Desired\"] = \"desired\";\n        SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n        SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus[\"Allowed\"] = \"allowed\";\n        PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.handleCpuConstrained = ()=>{\n            if (this.track && isVideoTrack(this.track)) {\n                this.emit(TrackEvent.CpuConstrained, this.track);\n            }\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n            this.track.off(TrackEvent.CpuConstrained, this.handleCpuConstrained);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.CpuConstrained, this.handleCpuConstrained);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    get isLocal() {\n        return true;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n    getTrackFeatures() {\n        var _a;\n        if (isAudioTrack(this.track)) {\n            const settings = this.track.getSourceTrackSettings();\n            const features = new Set();\n            if (settings.autoGainControl) {\n                features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\n            }\n            if (settings.echoCancellation) {\n                features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);\n            }\n            if (settings.noiseSuppression) {\n                features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);\n            }\n            if (settings.channelCount && settings.channelCount > 1) {\n                features.add(AudioTrackFeature.TF_STEREO);\n            }\n            if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {\n                features.add(AudioTrackFeature.TF_NO_DTX);\n            }\n            if (this.track.enhancedNoiseCancellation) {\n                features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);\n            }\n            return Array.from(features.values());\n        } else return [];\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options, loggerOptions) {\n    return __awaiter(this, void 0, void 0, function*() {\n        options !== null && options !== void 0 ? options : options = {};\n        let attemptExactMatch = false;\n        const { audioProcessor, videoProcessor, optionsWithoutProcessor: internalOptions } = extractProcessorsFromOptions(options);\n        let retryAudioOptions = internalOptions.audio;\n        let retryVideoOptions = internalOptions.video;\n        if (audioProcessor && typeof internalOptions.audio === \"object\") {\n            internalOptions.audio.processor = audioProcessor;\n        }\n        if (videoProcessor && typeof internalOptions.video === \"object\") {\n            internalOptions.video.processor = videoProcessor;\n        }\n        // if the user passes a device id as a string, we default to exact match\n        if (options.audio && typeof internalOptions.audio === \"object\" && typeof internalOptions.audio.deviceId === \"string\") {\n            const deviceId = internalOptions.audio.deviceId;\n            internalOptions.audio.deviceId = {\n                exact: deviceId\n            };\n            attemptExactMatch = true;\n            retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {\n                deviceId: {\n                    ideal: deviceId\n                }\n            });\n        }\n        if (internalOptions.video && typeof internalOptions.video === \"object\" && typeof internalOptions.video.deviceId === \"string\") {\n            const deviceId = internalOptions.video.deviceId;\n            internalOptions.video.deviceId = {\n                exact: deviceId\n            };\n            attemptExactMatch = true;\n            retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {\n                deviceId: {\n                    ideal: deviceId\n                }\n            });\n        }\n        if (internalOptions.audio === true) {\n            internalOptions.audio = {\n                deviceId: \"default\"\n            };\n        } else if (typeof internalOptions.audio === \"object\" && internalOptions.audio !== null) {\n            internalOptions.audio = Object.assign(Object.assign({}, internalOptions.audio), {\n                deviceId: internalOptions.audio.deviceId || \"default\"\n            });\n        }\n        if (internalOptions.video === true) {\n            internalOptions.video = {\n                deviceId: \"default\"\n            };\n        } else if (typeof internalOptions.video === \"object\" && !internalOptions.video.deviceId) {\n            internalOptions.video.deviceId = \"default\";\n        }\n        const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (internalOptions.audio) {\n            DeviceManager.userMediaPromiseMap.set(\"audioinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"audioinput\"));\n        }\n        if (internalOptions.video) {\n            DeviceManager.userMediaPromiseMap.set(\"videoinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"videoinput\"));\n        }\n        try {\n            const stream = yield mediaPromise;\n            return yield Promise.all(stream.getTracks().map((mediaStreamTrack)=>__awaiter(this, void 0, void 0, function*() {\n                    const isAudio = mediaStreamTrack.kind === \"audio\";\n                    let trackOptions = isAudio ? opts.audio : opts.video;\n                    if (typeof trackOptions === \"boolean\" || !trackOptions) {\n                        trackOptions = {};\n                    }\n                    let trackConstraints;\n                    const conOrBool = isAudio ? constraints.audio : constraints.video;\n                    if (typeof conOrBool !== \"boolean\") {\n                        trackConstraints = conOrBool;\n                    }\n                    // update the constraints with the device id the user gave permissions to in the permission prompt\n                    // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n                    const newDeviceId = mediaStreamTrack.getSettings().deviceId;\n                    if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {\n                        trackConstraints.deviceId = newDeviceId;\n                    } else if (!trackConstraints) {\n                        trackConstraints = {\n                            deviceId: newDeviceId\n                        };\n                    }\n                    const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);\n                    if (track.kind === Track.Kind.Video) {\n                        track.source = Track.Source.Camera;\n                    } else if (track.kind === Track.Kind.Audio) {\n                        track.source = Track.Source.Microphone;\n                    }\n                    track.mediaStream = stream;\n                    if (isAudioTrack(track) && audioProcessor) {\n                        yield track.setProcessor(audioProcessor);\n                    } else if (isVideoTrack(track) && videoProcessor) {\n                        yield track.setProcessor(videoProcessor);\n                    }\n                    return track;\n                })));\n        } catch (e) {\n            if (!attemptExactMatch) {\n                throw e;\n            }\n            return createLocalTracks(Object.assign(Object.assign({}, options), {\n                audio: retryAudioOptions,\n                video: retryVideoOptions\n            }), loggerOptions);\n        }\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options !== null && options !== void 0 ? options : true\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options !== null && options !== void 0 ? options : true,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined && !isSafari17Based()) {\n            options.resolution = ScreenSharePresets.h1080fps30.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError(\"no video track found\");\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality[\"Excellent\"] = \"excellent\";\n    ConnectionQuality[\"Good\"] = \"good\";\n    ConnectionQuality[\"Poor\"] = \"poor\";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality[\"Lost\"] = \"lost\";\n    ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isEncrypted() {\n        return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a;\n        return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;\n    }\n    get isActive() {\n        var _a;\n        return ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) === ParticipantInfo_State.ACTIVE;\n    }\n    get kind() {\n        return this._kind;\n    }\n    /** participant attributes, similar to metadata, but as a key/value map */ get attributes() {\n        return Object.freeze(Object.assign({}, this._attributes));\n    }\n    /** @internal */ constructor(sid, identity, name, metadata, attributes, loggerOptions){\n        let kind = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ParticipantInfo_Kind.STANDARD;\n        var _a;\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.log = livekitLogger;\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n        this.loggerOptions = loggerOptions;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.trackPublications = new Map();\n        this._kind = kind;\n        this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};\n    }\n    getTrackPublications() {\n        return Array.from(this.trackPublications.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   */ getTrackPublication(source) {\n        for (const [, pub] of this.trackPublications){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track's name.\n   */ getTrackPublicationByName(name) {\n        for (const [, pub] of this.trackPublications){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Waits until the participant is active and ready to receive data messages\n   * @returns a promise that resolves when the participant is active\n   */ waitUntilActive() {\n        if (this.isActive) {\n            return Promise.resolve();\n        }\n        if (this.activeFuture) {\n            return this.activeFuture.promise;\n        }\n        this.activeFuture = new Future();\n        this.once(ParticipantEvent.Active, ()=>{\n            var _a, _b;\n            (_b = (_a = this.activeFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.activeFuture = undefined;\n        });\n        return this.activeFuture.promise;\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrackPublication(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrackPublication(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrackPublication(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        var _a;\n        // it's possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it's possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        this._setAttributes(info.attributes);\n        if (info.state === ParticipantInfo_State.ACTIVE && ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) !== ParticipantInfo_State.ACTIVE) {\n            this.emit(ParticipantEvent.Active);\n        }\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /**\n   * Updates metadata from server\n   **/ _setAttributes(attributes) {\n        const diff = diffAttributes(this.attributes, attributes);\n        this._attributes = attributes;\n        if (Object.keys(diff).length > 0) {\n            this.emit(ParticipantEvent.AttributesChanged, diff);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e, _f;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setDisconnected() {\n        var _a, _b;\n        if (this.activeFuture) {\n            (_b = (_a = this.activeFuture).reject) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\"Participant disconnected\"));\n            this.activeFuture = undefined;\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTrackPublications.forEach((track)=>isAudioTrack(track.track) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.trackPublications.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTrackPublications.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTrackPublications.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : \"\",\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : \"\",\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options, roomRpcHandlers, roomOutgoingDataStreamManager){\n        super(sid, identity, undefined, undefined, undefined, {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.engine.logContext\n        });\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.enabledPublishVideoCodecs = [];\n        this.pendingAcks = new Map();\n        this.pendingResponses = new Map();\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleClosing = ()=>{\n            var _a, _b, _c, _d, _e, _f;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>this.log.warn(e.message, this.logContext));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\"Got disconnected during reconnection attempt\"));\n                this.reconnectFuture = undefined;\n            }\n            if (this.signalConnectedFuture) {\n                (_d = (_c = this.signalConnectedFuture).reject) === null || _d === void 0 ? void 0 : _d.call(_c, new Error(\"Got disconnected without signal connected\"));\n                this.signalConnectedFuture = undefined;\n            }\n            (_f = (_e = this.activeAgentFuture) === null || _e === void 0 ? void 0 : _e.reject) === null || _f === void 0 ? void 0 : _f.call(_e, new Error(\"Got disconnected without active agent present\"));\n            this.activeAgentFuture = undefined;\n            this.firstActiveAgent = undefined;\n        };\n        this.handleSignalConnected = (joinResponse)=>{\n            var _a, _b;\n            if (joinResponse.participant) {\n                this.updateInfo(joinResponse.participant);\n            }\n            if (!this.signalConnectedFuture) {\n                this.signalConnectedFuture = new Future();\n            }\n            (_b = (_a = this.signalConnectedFuture).resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n        };\n        this.handleSignalRequestResponse = (response)=>{\n            const { requestId, reason, message } = response;\n            const targetRequest = this.pendingSignalRequests.get(requestId);\n            if (targetRequest) {\n                if (reason !== RequestResponse_Reason.OK) {\n                    targetRequest.reject(new SignalRequestError(message, reason));\n                }\n                this.pendingSignalRequests.delete(requestId);\n            }\n        };\n        this.handleDataPacket = (packet)=>{\n            switch(packet.value.case){\n                case \"rpcResponse\":\n                    let rpcResponse = packet.value.value;\n                    let payload = null;\n                    let error = null;\n                    if (rpcResponse.value.case === \"payload\") {\n                        payload = rpcResponse.value.value;\n                    } else if (rpcResponse.value.case === \"error\") {\n                        error = RpcError.fromProto(rpcResponse.value.value);\n                    }\n                    this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);\n                    break;\n                case \"rpcAck\":\n                    let rpcAck = packet.value.value;\n                    this.handleIncomingRpcAck(rpcAck.requestId);\n                    break;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            this.log.debug(\"updating track subscription permissions\", Object.assign(Object.assign({}, this.logContext), {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            }));\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we'll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                this.log.error(\"could not update mute status for unpublished track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            this.log.debug(\"upstream paused\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            this.log.debug(\"upstream resumed\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.onTrackFeatureUpdate = (track)=>{\n            const pub = this.audioTrackPublications.get(track.sid);\n            if (!pub) {\n                this.log.warn(\"Could not update local audio track settings, missing publication for track \".concat(track.sid), this.logContext);\n                return;\n            }\n            this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());\n        };\n        this.onTrackCpuConstrained = (track, publication)=>{\n            this.log.debug(\"track cpu constrained\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.LocalTrackCpuConstrained, track, publication);\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTrackPublications.get(update.trackSid);\n                if (!pub) {\n                    this.log.warn(\"received subscribed quality update for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                        trackSid: update.trackSid\n                    }));\n                    return;\n                }\n                if (!pub.videoTrack) {\n                    return;\n                }\n                const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                try {\n                    for(var _e = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _e = true){\n                        _c = newCodecs_1_1.value;\n                        _e = false;\n                        const codec = _c;\n                        if (isBackupCodec(codec)) {\n                            this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n                            yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                        }\n                    }\n                } catch (e_1_1) {\n                    e_1 = {\n                        error: e_1_1\n                    };\n                } finally{\n                    try {\n                        if (!_e && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                    } finally{\n                        if (e_1) throw e_1.error;\n                    }\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.trackPublications.get(unpublished.trackSid);\n            if (!track) {\n                this.log.warn(\"received unpublished event for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: unpublished.trackSid\n                }));\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    this.log.debug(\"unpublishing local track due to TrackEnded\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n                                });\n                                if (currentPermissions && currentPermissions.state === \"denied\") {\n                                    this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== \"denied\") {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error(\"GetUserMedia Permission denied\");\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            this.log.debug(\"track ended, attempting to use a different device\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            if (isLocalAudioTrack(track)) {\n                                // fall back to default device if available\n                                yield track.restartTrack({\n                                    deviceId: \"default\"\n                                });\n                            } else {\n                                yield track.restartTrack();\n                            }\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.trackPublications = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map([\n            [\n                \"audioinput\",\n                \"default\"\n            ],\n            [\n                \"videoinput\",\n                \"default\"\n            ],\n            [\n                \"audiooutput\",\n                \"default\"\n            ]\n        ]);\n        this.pendingSignalRequests = new Map();\n        this.rpcHandlers = roomRpcHandlers;\n        this.roomOutgoingDataStreamManager = roomOutgoingDataStreamManager;\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrackPublication(source) {\n        const track = super.getTrackPublication(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackPublicationByName(name) {\n        const track = super.getTrackPublicationByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        var _a;\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.trackPublications.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        if ((_a = this.signalConnectedFuture) === null || _a === void 0 ? void 0 : _a.isResolved) {\n            this.signalConnectedFuture = undefined;\n        }\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalConnected, this.handleSignalConnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Closing, this.handleClosing).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */ setMetadata(metadata) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                metadata\n            });\n        });\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */ setName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                name\n            });\n        });\n    }\n    /**\n   * Set or update participant attributes. It will make updates only to keys that\n   * are present in `attributes`, and will not override others.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param attributes attributes to update\n   */ setAttributes(attributes) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                attributes\n            });\n        });\n    }\n    requestMetadataUpdate(_a) {\n        return __awaiter(this, arguments, void 0, function(_ref) {\n            var _this = this;\n            let { metadata, name, attributes } = _ref;\n            return function*() {\n                return new Promise((resolve, reject)=>__awaiter(_this, void 0, void 0, function*() {\n                        var _a, _b;\n                        try {\n                            let isRejected = false;\n                            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a !== void 0 ? _a : \"\", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : \"\", attributes);\n                            const startTime = performance.now();\n                            this.pendingSignalRequests.set(requestId, {\n                                resolve,\n                                reject: (error)=>{\n                                    reject(error);\n                                    isRejected = true;\n                                },\n                                values: {\n                                    name,\n                                    metadata,\n                                    attributes\n                                }\n                            });\n                            while(performance.now() - startTime < 5000 && !isRejected){\n                                if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every((_ref2)=>{\n                                    let [key, value] = _ref2;\n                                    return this.attributes[key] === value || value === \"\" && !this.attributes[key];\n                                }))) {\n                                    this.pendingSignalRequests.delete(requestId);\n                                    resolve();\n                                    return;\n                                }\n                                yield sleep(50);\n                            }\n                            reject(new SignalRequestError(\"Request to update local metadata timed out\", \"TimeoutError\"));\n                        } catch (e) {\n                            if (e instanceof Error) reject(e);\n                        }\n                    }));\n            }();\n        });\n    }\n    /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            this.log.debug(\"setTrackEnabled\", Object.assign(Object.assign({}, this.logContext), {\n                source,\n                enabled\n            }));\n            if (this.republishPromise) {\n                yield this.republishPromise;\n            }\n            let track = this.getTrackPublication(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        const pendingTrack = yield this.waitForPendingPublicationOfSource(source);\n                        if (!pendingTrack) {\n                            this.log.info(\"waiting for pending publication promise timed out\", Object.assign(Object.assign({}, this.logContext), {\n                                source\n                            }));\n                        }\n                        yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();\n                        return pendingTrack;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e, sourceToKind(source));\n                        }\n                        this.pendingPublishing.delete(source);\n                        throw e;\n                    }\n                    for (const localTrack of localTracks){\n                        const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n                        if (source === Track.Source.Microphone && isAudioTrack(localTrack) && opts.preConnectBuffer) {\n                            this.log.info(\"starting preconnect buffer for microphone\", Object.assign({}, this.logContext));\n                            localTrack.startPreConnectBuffer();\n                        }\n                    }\n                    try {\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            this.log.info(\"publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else {\n                if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {\n                    // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available\n                    track = yield this.waitForPendingPublicationOfSource(source);\n                    if (!track) {\n                        this.log.info(\"waiting for pending publication promise timed out\", Object.assign(Object.assign({}, this.logContext), {\n                            source\n                        }));\n                    }\n                }\n                if (track && track.track) {\n                    // screenshare cannot be muted, unpublish instead\n                    if (source === Track.Source.ScreenShare) {\n                        track = yield this.unpublishTrack(track.track);\n                        const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);\n                        if (screenAudioTrack && screenAudioTrack.track) {\n                            this.unpublishTrack(screenAudioTrack.track);\n                        }\n                    } else {\n                        yield track.mute();\n                    }\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it's already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            options !== null && options !== void 0 ? options : options = {};\n            const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            try {\n                const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                const localTracks = tracks.map((track)=>{\n                    if (isAudioTrack(track)) {\n                        this.microphoneError = undefined;\n                        track.setAudioContext(this.audioContext);\n                        track.source = Track.Source.Microphone;\n                        this.emit(ParticipantEvent.AudioStreamAcquired);\n                    }\n                    if (isVideoTrack(track)) {\n                        this.cameraError = undefined;\n                        track.source = Track.Source.Camera;\n                    }\n                    return track;\n                });\n                return localTracks;\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (options.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (options.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n            }\n            if (options.resolution === undefined && !isSafari17Based()) {\n                // we need to constrain the dimensions, otherwise it could lead to low bitrate\n                // due to encoding a huge video. Encoding such large surfaces is really expensive\n                // unfortunately Safari 17 has a but and cannot be constrained by default\n                options.resolution = ScreenSharePresets.h1080fps30.resolution;\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError(\"no video track found\");\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            screenVideo.source = Track.Source.ScreenShare;\n            if (options.contentHint) {\n                screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n            }\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.publishOrRepublishTrack(track, options);\n        });\n    }\n    publishOrRepublishTrack(track_1, options_1) {\n        return __awaiter(this, arguments, void 0, function(track, options) {\n            var _this2 = this;\n            let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            return function*() {\n                var _a, _b, _c, _d;\n                if (isLocalAudioTrack(track)) {\n                    track.setAudioContext(_this2.audioContext);\n                }\n                yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n                if (_this2.republishPromise && !isRepublish) {\n                    yield _this2.republishPromise;\n                }\n                if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {\n                    yield _this2.pendingPublishPromises.get(track);\n                }\n                let defaultConstraints;\n                if (track instanceof MediaStreamTrack) {\n                    defaultConstraints = track.getConstraints();\n                } else {\n                    // we want to access constraints directly as `track.mediaStreamTrack`\n                    // might be pointing to a non-device track (e.g. processed track) already\n                    defaultConstraints = track.constraints;\n                    let deviceKind = undefined;\n                    switch(track.source){\n                        case Track.Source.Microphone:\n                            deviceKind = \"audioinput\";\n                            break;\n                        case Track.Source.Camera:\n                            deviceKind = \"videoinput\";\n                    }\n                    if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {\n                        defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                            deviceId: _this2.activeDeviceMap.get(deviceKind)\n                        });\n                    }\n                }\n                // convert raw media track into audio or video track\n                if (track instanceof MediaStreamTrack) {\n                    switch(track.kind){\n                        case \"audio\":\n                            track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {\n                                loggerName: _this2.roomOptions.loggerName,\n                                loggerContextCb: ()=>_this2.logContext\n                            });\n                            break;\n                        case \"video\":\n                            track = new LocalVideoTrack(track, defaultConstraints, true, {\n                                loggerName: _this2.roomOptions.loggerName,\n                                loggerContextCb: ()=>_this2.logContext\n                            });\n                            break;\n                        default:\n                            throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n                    }\n                } else {\n                    track.updateLoggerOptions({\n                        loggerName: _this2.roomOptions.loggerName,\n                        loggerContextCb: ()=>_this2.logContext\n                    });\n                }\n                // is it already published? if so skip\n                let existingPublication;\n                _this2.trackPublications.forEach((publication)=>{\n                    if (!publication.track) {\n                        return;\n                    }\n                    if (publication.track === track) {\n                        existingPublication = publication;\n                    }\n                });\n                if (existingPublication) {\n                    _this2.log.warn(\"track has already been published, skipping\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));\n                    return existingPublication;\n                }\n                const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);\n                const isStereoInput = \"channelCount\" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n                track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n                const isStereo = (_b = opts.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n                // disable dtx for stereo track if not enabled explicitly\n                if (isStereo) {\n                    if (opts.dtx === undefined) {\n                        _this2.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));\n                    }\n                    if (opts.red === undefined) {\n                        _this2.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                    }\n                    (_c = opts.dtx) !== null && _c !== void 0 ? _c : opts.dtx = false;\n                    (_d = opts.red) !== null && _d !== void 0 ? _d : opts.red = false;\n                }\n                if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {\n                    _this2.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2\", Object.assign({}, _this2.logContext));\n                    opts.simulcast = false;\n                }\n                if (opts.source) {\n                    track.source = opts.source;\n                }\n                const publishPromise = new Promise((resolve, reject)=>__awaiter(_this2, void 0, void 0, function*() {\n                        try {\n                            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {\n                                this.log.debug(\"deferring track publication until signal is connected\", Object.assign(Object.assign({}, this.logContext), {\n                                    track: getLogContextFromTrack(track)\n                                }));\n                                let publicationTimedOut = false;\n                                const timeout = setTimeout(()=>{\n                                    publicationTimedOut = true;\n                                    track.stop();\n                                    reject(new PublishTrackError(\"publishing rejected as engine not connected within timeout\", 408));\n                                }, 15000);\n                                yield this.waitUntilEngineConnected();\n                                clearTimeout(timeout);\n                                if (publicationTimedOut) {\n                                    return;\n                                }\n                                const publication = yield this.publish(track, opts, isStereo);\n                                resolve(publication);\n                            } else {\n                                try {\n                                    const publication = yield this.publish(track, opts, isStereo);\n                                    resolve(publication);\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            }\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }));\n                _this2.pendingPublishPromises.set(track, publishPromise);\n                try {\n                    const publication = yield publishPromise;\n                    return publication;\n                } catch (e) {\n                    throw e;\n                } finally{\n                    _this2.pendingPublishPromises.delete(track);\n                }\n            }();\n        });\n    }\n    waitUntilEngineConnected() {\n        if (!this.signalConnectedFuture) {\n            this.signalConnectedFuture = new Future();\n        }\n        return this.signalConnectedFuture.promise;\n    }\n    hasPermissionsToPublish(track) {\n        if (!this.permissions) {\n            this.log.warn(\"no permissions present for publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            return false;\n        }\n        const { canPublish, canPublishSources } = this.permissions;\n        if (canPublish && (canPublishSources.length === 0 || canPublishSources.map((source)=>getTrackSourceFromProto(source)).includes(track.source))) {\n            return true;\n        }\n        this.log.warn(\"insufficient permissions to publish\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        return false;\n    }\n    publish(track, opts, isStereo) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n            if (!this.hasPermissionsToPublish(track)) {\n                throw new PublishTrackError(\"failed to publish track, insufficient permissions\", 403);\n            }\n            const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack)=>isLocalTrack(track) && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            }\n            if (opts.stopMicTrackOnMute && isAudioTrack(track)) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === \"av1\" && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === \"vp9\" && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            if (this.enabledPublishVideoCodecs.length > 0) {\n                // fallback to a supported codec if it is not supported\n                if (!this.enabledPublishVideoCodecs.some((c)=>opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {\n                    opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);\n                }\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n            const audioFeatures = [];\n            const disableDtx = !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true);\n            const settings = track.getSourceTrackSettings();\n            if (settings.autoGainControl) {\n                audioFeatures.push(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\n            }\n            if (settings.echoCancellation) {\n                audioFeatures.push(AudioTrackFeature.TF_ECHO_CANCELLATION);\n            }\n            if (settings.noiseSuppression) {\n                audioFeatures.push(AudioTrackFeature.TF_NOISE_SUPPRESSION);\n            }\n            if (settings.channelCount && settings.channelCount > 1) {\n                audioFeatures.push(AudioTrackFeature.TF_STEREO);\n            }\n            if (disableDtx) {\n                audioFeatures.push(AudioTrackFeature.TF_NO_DTX);\n            }\n            if (isLocalAudioTrack(track) && track.hasPreConnectBuffer) {\n                audioFeatures.push(AudioTrackFeature.TF_PRECONNECT_BUFFER);\n            }\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx,\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream,\n                backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy,\n                audioFeatures\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it's quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    this.log.error(\"could not determine track dimensions, using defaults\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        dims\n                    }));\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (isLocalVideoTrack(track)) {\n                    if (isSVCCodec(videoCodec)) {\n                        if (track.source === Track.Source.ScreenShare) {\n                            // vp9 svc with screenshare cannot encode multiple spatial layers\n                            // doing so reduces publish resolution to minimal resolution\n                            opts.scalabilityMode = \"L1T3\";\n                            // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3\n                            // It has a different path for screenshare handling and it seems to be untested/buggy\n                            // As a workaround, we are setting contentHint to force it to go through the same\n                            // path as regular camera video. While this is not optimal, it delivers the performance\n                            // that we need\n                            if (\"contentHint\" in track.mediaStreamTrack) {\n                                track.mediaStreamTrack.contentHint = \"motion\";\n                                this.log.info(\"forcing contentHint to motion for screenshare with SVC codecs\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            }\n                        }\n                        // set scalabilityMode to 'L3T3_KEY' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : \"L3T3_KEY\";\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: \"\"\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,\n                        priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : \"high\",\n                        networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : \"high\"\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const negotiate = ()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b, _c;\n                    if (!this.engine.pcManager) {\n                        throw new UnexpectedConnectionState(\"pcManager is not ready\");\n                    }\n                    track.sender = yield this.engine.createSender(track, opts, encodings);\n                    this.emit(ParticipantEvent.LocalSenderCreated, track.sender, track);\n                    if (isLocalVideoTrack(track)) {\n                        (_a = opts.degradationPreference) !== null && _a !== void 0 ? _a : opts.degradationPreference = getDefaultDegradationPreference(track);\n                        track.setDegradationPreference(opts.degradationPreference);\n                    }\n                    if (encodings) {\n                        if (isFireFox() && track.kind === Track.Kind.Audio) {\n                            /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n               publish high quality audio track. But firefox always uses this value as the actual\n               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n               So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n               fix the issue.\n             */ let trackTransceiver = undefined;\n                            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                                if (transceiver.sender === track.sender) {\n                                    trackTransceiver = transceiver;\n                                    break;\n                                }\n                            }\n                            if (trackTransceiver) {\n                                this.engine.pcManager.publisher.setTrackCodecBitrate({\n                                    transceiver: trackTransceiver,\n                                    codec: \"opus\",\n                                    maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                                });\n                            }\n                        } else if (track.codec && isSVCCodec(track.codec) && ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)) {\n                            this.engine.pcManager.publisher.setTrackCodecBitrate({\n                                cid: req.cid,\n                                codec: track.codec,\n                                maxbr: encodings[0].maxBitrate / 1000\n                            });\n                        }\n                    }\n                    yield this.engine.negotiate();\n                });\n            let ti;\n            const addTrackPromise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    var _a;\n                    try {\n                        ti = yield this.engine.addTrack(req);\n                        resolve(ti);\n                    } catch (err) {\n                        if (track.sender && ((_a = this.engine.pcManager) === null || _a === void 0 ? void 0 : _a.publisher)) {\n                            this.engine.pcManager.publisher.removeTrack(track.sender);\n                            yield this.engine.negotiate().catch((negotiateErr)=>{\n                                this.log.error(\"failed to negotiate after removing track due to failed add track request\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                                    error: negotiateErr\n                                }));\n                            });\n                        }\n                        reject(err);\n                    }\n                }));\n            if (this.enabledPublishVideoCodecs.length > 0) {\n                const rets = yield Promise.all([\n                    addTrackPromise,\n                    negotiate()\n                ]);\n                ti = rets[0];\n            } else {\n                ti = yield addTrackPromise;\n                // server might not support the codec the client has requested, in that case, fallback\n                // to a supported codec\n                let primaryCodecMime;\n                ti.codecs.forEach((codec)=>{\n                    if (primaryCodecMime === undefined) {\n                        primaryCodecMime = codec.mimeType;\n                    }\n                });\n                if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                    const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                    if (updatedCodec !== videoCodec) {\n                        this.log.debug(\"falling back to server selected codec\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                            codec: updatedCodec\n                        }));\n                        opts.videoCodec = updatedCodec;\n                        // recompute encodings since bitrates/etc could have changed\n                        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                    }\n                }\n                yield negotiate();\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            publication.on(TrackEvent.CpuConstrained, (constrainedTrack)=>this.onTrackCpuConstrained(constrainedTrack, publication));\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n            if (isLocalVideoTrack(track)) {\n                track.startMonitor(this.engine.client);\n            } else if (isLocalAudioTrack(track)) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            if (isLocalAudioTrack(track) && ti.audioFeatures.includes(AudioTrackFeature.TF_PRECONNECT_BUFFER)) {\n                const stream = track.getPreConnectBuffer();\n                const mimeType = track.getPreConnectBufferMimeType();\n                // TODO: we're registering the listener after negotiation, so there might be a race\n                this.on(ParticipantEvent.LocalTrackSubscribed, (pub)=>{\n                    if (pub.trackSid === ti.sid) {\n                        if (!track.hasPreConnectBuffer) {\n                            this.log.warn(\"subscribe event came to late, buffer already closed\", this.logContext);\n                            return;\n                        }\n                        this.log.debug(\"finished recording preconnect buffer\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        track.stopPreConnectBuffer();\n                    }\n                });\n                if (stream) {\n                    const bufferStreamPromise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, e_2, _b, _c;\n                            var _d, _e;\n                            try {\n                                this.log.debug(\"waiting for agent\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                const agentActiveTimeout = setTimeout(()=>{\n                                    reject(new Error(\"agent not active within 10 seconds\"));\n                                }, 10000);\n                                const agent = yield this.waitUntilActiveAgentPresent();\n                                clearTimeout(agentActiveTimeout);\n                                this.log.debug(\"sending preconnect buffer\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                const writer = yield this.streamBytes({\n                                    name: \"preconnect-buffer\",\n                                    mimeType,\n                                    topic: \"lk.agent.pre-connect-audio-buffer\",\n                                    destinationIdentities: [\n                                        agent.identity\n                                    ],\n                                    attributes: {\n                                        trackId: publication.trackSid,\n                                        sampleRate: String((_d = settings.sampleRate) !== null && _d !== void 0 ? _d : \"48000\"),\n                                        channels: String((_e = settings.channelCount) !== null && _e !== void 0 ? _e : \"1\")\n                                    }\n                                });\n                                try {\n                                    for(var _f = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), _a = stream_1_1.done, !_a; _f = true){\n                                        _c = stream_1_1.value;\n                                        _f = false;\n                                        const chunk = _c;\n                                        yield writer.write(chunk);\n                                    }\n                                } catch (e_2_1) {\n                                    e_2 = {\n                                        error: e_2_1\n                                    };\n                                } finally{\n                                    try {\n                                        if (!_f && !_a && (_b = stream_1.return)) yield _b.call(stream_1);\n                                    } finally{\n                                        if (e_2) throw e_2.error;\n                                    }\n                                }\n                                yield writer.close();\n                                resolve();\n                            } catch (e) {\n                                reject(e);\n                            }\n                        }));\n                    bufferStreamPromise.then(()=>{\n                        this.log.debug(\"preconnect buffer sent successfully\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    }).catch((e)=>{\n                        this.log.error(\"error sending preconnect buffer\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                            error: e\n                        }));\n                    });\n                }\n            }\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.trackPublications.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError(\"track is not published\");\n            }\n            if (!isLocalVideoTrack(track)) {\n                throw new TrackInvalidError(\"track is not a video track\");\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            if (!simulcastTrack) {\n                return;\n            }\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const negotiate = ()=>__awaiter(this, void 0, void 0, function*() {\n                    yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n                    yield this.engine.negotiate();\n                });\n            const rets = yield Promise.all([\n                this.engine.addTrack(req),\n                negotiate()\n            ]);\n            const ti = rets[0];\n            this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            if (isLocalTrack(track)) {\n                const publishPromise = this.pendingPublishPromises.get(track);\n                if (publishPromise) {\n                    this.log.info(\"awaiting publish promise before attempting to unpublish\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    yield publishPromise;\n                }\n            }\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n            this.log.debug(\"unpublishing track\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n            if (!publication || !publication.track) {\n                this.log.warn(\"track was not unpublished because no publication was found\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            } else {\n                track.stopMonitor();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = \"inactive\";\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (isLocalVideoTrack(track)) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    this.log.warn(\"failed to unpublish track\", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n                        error: e\n                    }));\n                }\n            }\n            // remove from our maps\n            this.trackPublications.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTrackPublications.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTrackPublications.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>!!track);\n        });\n    }\n    republishAllTracks(options_1) {\n        return __awaiter(this, arguments, void 0, function(options) {\n            var _this3 = this;\n            let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                if (_this3.republishPromise) {\n                    yield _this3.republishPromise;\n                }\n                _this3.republishPromise = new Promise((resolve, reject)=>__awaiter(_this3, void 0, void 0, function*() {\n                        try {\n                            const localPubs = [];\n                            this.trackPublications.forEach((pub)=>{\n                                if (pub.track) {\n                                    if (options) {\n                                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                                    }\n                                    localPubs.push(pub);\n                                }\n                            });\n                            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                                    const track = pub.track;\n                                    yield this.unpublishTrack(track, false);\n                                    if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {\n                                        // generally we need to restart the track before publishing, often a full reconnect\n                                        // is necessary because computer had gone to sleep.\n                                        this.log.debug(\"restarting existing track\", Object.assign(Object.assign({}, this.logContext), {\n                                            track: pub.trackSid\n                                        }));\n                                        yield track.restartTrack();\n                                    }\n                                    yield this.publishOrRepublishTrack(track, pub.options, true);\n                                })));\n                            resolve();\n                        } catch (error) {\n                            reject(error);\n                        } finally{\n                            this.republishPromise = undefined;\n                        }\n                    }));\n                yield _this3.republishPromise;\n            }();\n        });\n    }\n    /**\n   * Publish a new data payload to the room. Data will be forwarded to each\n   * participant in the room if the destination field in publishOptions is empty\n   *\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\n   * @param options optionally specify a `reliable`, `topic` and `destination`\n   */ publishData(data_1) {\n        return __awaiter(this, arguments, void 0, function(data) {\n            var _this4 = this;\n            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return function*() {\n                const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;\n                const destinationIdentities = options.destinationIdentities;\n                const topic = options.topic;\n                let userPacket = new UserPacket({\n                    participantIdentity: _this4.identity,\n                    payload: data,\n                    destinationIdentities,\n                    topic\n                });\n                const packet = new DataPacket({\n                    kind: kind,\n                    value: {\n                        case: \"user\",\n                        value: userPacket\n                    }\n                });\n                yield _this4.engine.sendDataPacket(packet, kind);\n            }();\n        });\n    }\n    /**\n   * Publish SIP DTMF message to the room.\n   *\n   * @param code DTMF code\n   * @param digit DTMF digit\n   */ publishDtmf(code, digit) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"sipDtmf\",\n                    value: new SipDTMF({\n                        code: code,\n                        digit: digit\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /** @deprecated Consider migrating to {@link sendText} */ sendChatMessage(text, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = {\n                id: crypto.randomUUID(),\n                message: text,\n                timestamp: Date.now(),\n                attachedFiles: options === null || options === void 0 ? void 0 : options.attachments\n            };\n            const packet = new DataPacket({\n                value: {\n                    case: \"chatMessage\",\n                    value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n                        timestamp: protoInt64.parse(msg.timestamp)\n                    }))\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            this.emit(ParticipantEvent.ChatMessage, msg);\n            return msg;\n        });\n    }\n    /** @deprecated Consider migrating to {@link sendText} */ editChatMessage(editText, originalMessage) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = Object.assign(Object.assign({}, originalMessage), {\n                message: editText,\n                editTimestamp: Date.now()\n            });\n            const packet = new DataPacket({\n                value: {\n                    case: \"chatMessage\",\n                    value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n                        timestamp: protoInt64.parse(msg.timestamp),\n                        editTimestamp: protoInt64.parse(msg.editTimestamp)\n                    }))\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            this.emit(ParticipantEvent.ChatMessage, msg);\n            return msg;\n        });\n    }\n    /**\n   * Sends the given string to participants in the room via the data channel.\n   * For longer messages, consider using {@link streamText} instead.\n   *\n   * @param text The text payload\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   */ sendText(text, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.roomOutgoingDataStreamManager.sendText(text, options);\n        });\n    }\n    /**\n   * Creates a new TextStreamWriter which can be used to stream text incrementally\n   * to participants in the room via the data channel.\n   *\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   *\n   * @internal\n   * @experimental CAUTION, might get removed in a minor release\n   */ streamText(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.roomOutgoingDataStreamManager.streamText(options);\n        });\n    }\n    /** Send a File to all participants in the room via the data channel.\n   * @param file The File object payload\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   * @param options.onProgress A callback function used to monitor the upload progress percentage.\n   */ sendFile(file, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.roomOutgoingDataStreamManager.sendFile(file, options);\n        });\n    }\n    /**\n   * Stream bytes incrementally to participants in the room via the data channel.\n   * For sending files, consider using {@link sendFile} instead.\n   *\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   */ streamBytes(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.roomOutgoingDataStreamManager.streamBytes(options);\n        });\n    }\n    /**\n   * Initiate an RPC call to a remote participant\n   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}\n   * @returns A promise that resolves with the response payload or rejects with an error.\n   * @throws Error on failure. Details in `message`.\n   */ performRpc(_a) {\n        return __awaiter(this, arguments, void 0, function(_ref3) {\n            var _this5 = this;\n            let { destinationIdentity, method, payload, responseTimeout = 15000 } = _ref3;\n            return function*() {\n                const maxRoundTripLatency = 7000;\n                const minEffectiveTimeout = maxRoundTripLatency + 1000;\n                return new Promise((resolve, reject)=>__awaiter(_this5, void 0, void 0, function*() {\n                        var _a, _b, _c, _d;\n                        if (byteLength(payload) > MAX_PAYLOAD_BYTES) {\n                            reject(RpcError.builtIn(\"REQUEST_PAYLOAD_TOO_LARGE\"));\n                            return;\n                        }\n                        if (((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, \"1.8.0\") < 0) {\n                            reject(RpcError.builtIn(\"UNSUPPORTED_SERVER\"));\n                            return;\n                        }\n                        const effectiveTimeout = Math.max(responseTimeout, minEffectiveTimeout);\n                        const id = crypto.randomUUID();\n                        yield this.publishRpcRequest(destinationIdentity, id, method, payload, effectiveTimeout);\n                        const ackTimeoutId = setTimeout(()=>{\n                            this.pendingAcks.delete(id);\n                            reject(RpcError.builtIn(\"CONNECTION_TIMEOUT\"));\n                            this.pendingResponses.delete(id);\n                            clearTimeout(responseTimeoutId);\n                        }, maxRoundTripLatency);\n                        this.pendingAcks.set(id, {\n                            resolve: ()=>{\n                                clearTimeout(ackTimeoutId);\n                            },\n                            participantIdentity: destinationIdentity\n                        });\n                        const responseTimeoutId = setTimeout(()=>{\n                            this.pendingResponses.delete(id);\n                            reject(RpcError.builtIn(\"RESPONSE_TIMEOUT\"));\n                        }, responseTimeout);\n                        this.pendingResponses.set(id, {\n                            resolve: (responsePayload, responseError)=>{\n                                clearTimeout(responseTimeoutId);\n                                if (this.pendingAcks.has(id)) {\n                                    console.warn(\"RPC response received before ack\", id);\n                                    this.pendingAcks.delete(id);\n                                    clearTimeout(ackTimeoutId);\n                                }\n                                if (responseError) {\n                                    reject(responseError);\n                                } else {\n                                    resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : \"\");\n                                }\n                            },\n                            participantIdentity: destinationIdentity\n                        });\n                    }));\n            }();\n        });\n    }\n    /**\n   * @deprecated use `room.registerRpcMethod` instead\n   */ registerRpcMethod(method, handler) {\n        if (this.rpcHandlers.has(method)) {\n            this.log.warn(\"you're overriding the RPC handler for method \".concat(method, \", in the future this will throw an error\"));\n        }\n        this.rpcHandlers.set(method, handler);\n    }\n    /**\n   * @deprecated use `room.unregisterRpcMethod` instead\n   */ unregisterRpcMethod(method) {\n        this.rpcHandlers.delete(method);\n    }\n    /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    handleIncomingRpcAck(requestId) {\n        const handler = this.pendingAcks.get(requestId);\n        if (handler) {\n            handler.resolve();\n            this.pendingAcks.delete(requestId);\n        } else {\n            console.error(\"Ack received for unexpected RPC request\", requestId);\n        }\n    }\n    handleIncomingRpcResponse(requestId, payload, error) {\n        const handler = this.pendingResponses.get(requestId);\n        if (handler) {\n            handler.resolve(payload, error);\n            this.pendingResponses.delete(requestId);\n        } else {\n            console.error(\"Response received for unexpected RPC request\", requestId);\n        }\n    }\n    /** @internal */ publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcRequest\",\n                    value: new RpcRequest({\n                        id: requestId,\n                        method,\n                        payload,\n                        responseTimeoutMs: responseTimeout,\n                        version: 1\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /** @internal */ handleParticipantDisconnected(participantIdentity) {\n        for (const [id, { participantIdentity: pendingIdentity }] of this.pendingAcks){\n            if (pendingIdentity === participantIdentity) {\n                this.pendingAcks.delete(id);\n            }\n        }\n        for (const [id, { participantIdentity: pendingIdentity, resolve }] of this.pendingResponses){\n            if (pendingIdentity === participantIdentity) {\n                resolve(null, RpcError.builtIn(\"RECIPIENT_DISCONNECTED\"));\n                this.pendingResponses.delete(id);\n            }\n        }\n    }\n    /** @internal */ setEnabledPublishCodecs(codecs) {\n        this.enabledPublishVideoCodecs = codecs.filter((c)=>c.mime.split(\"/\")[0].toLowerCase() === \"video\");\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server's track mute status doesn't match actual, we'll have to update\n        // the server's copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.trackPublications.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    this.log.debug(\"updating server mute state after reconcile\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n                        mutedOnServer\n                    }));\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    /** @internal */ setActiveAgent(agent) {\n        var _a, _b, _c, _d;\n        this.firstActiveAgent = agent;\n        if (agent && !this.firstActiveAgent) {\n            this.firstActiveAgent = agent;\n        }\n        if (agent) {\n            (_b = (_a = this.activeAgentFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a, agent);\n        } else {\n            (_d = (_c = this.activeAgentFuture) === null || _c === void 0 ? void 0 : _c.reject) === null || _d === void 0 ? void 0 : _d.call(_c, new Error(\"Agent disconnected\"));\n        }\n        this.activeAgentFuture = undefined;\n    }\n    waitUntilActiveAgentPresent() {\n        if (this.firstActiveAgent) {\n            return Promise.resolve(this.firstActiveAgent);\n        }\n        if (!this.activeAgentFuture) {\n            this.activeAgentFuture = new Future();\n        }\n        return this.activeAgentFuture.promise;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.trackPublications.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n    waitForPendingPublicationOfSource(source) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const waitForPendingTimeout = 10000;\n            const startTime = Date.now();\n            while(Date.now() < startTime + waitForPendingTimeout){\n                const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find((_ref4)=>{\n                    let [pendingTrack] = _ref4;\n                    return pendingTrack.source === source;\n                });\n                if (publishPromiseEntry) {\n                    return publishPromiseEntry[1];\n                }\n                yield sleep(20);\n            }\n        });\n    }\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.requestedDisabled = undefined;\n        this.visible = true;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n            this.visible = visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n            this.videoDimensionsAdaptiveStream = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it's not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn't keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: \"\",\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return this.requestedDisabled !== undefined ? !this.requestedDisabled : this.isAdaptiveStream ? this.visible : true;\n    }\n    get isLocal() {\n        return false;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.requestedDisabled === !enabled) {\n            return;\n        }\n        this.requestedDisabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.requestedMaxQuality === quality) {\n            return;\n        }\n        this.requestedMaxQuality = quality;\n        this.requestedVideoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    /**\n   * Explicitly set the video dimensions for this track.\n   *\n   * This will take precedence over adaptive stream dimensions.\n   *\n   * @param dimensions The video dimensions to set.\n   */ setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.requestedVideoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.requestedVideoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (isRemoteVideoTrack(this.track)) {\n            this.requestedVideoDimensions = dimensions;\n        }\n        this.requestedMaxQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!isRemoteVideoTrack(this.track)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        var _a;\n        return (_a = this.requestedMaxQuality) !== null && _a !== void 0 ? _a : VideoQuality.HIGH;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (!this.isDesired) {\n            this.log.warn(\"cannot update track settings when not subscribed\", this.logContext);\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: !this.isEnabled,\n            fps: this.fps\n        });\n        if (this.kind === Track.Kind.Video) {\n            let minDimensions = this.requestedVideoDimensions;\n            if (this.videoDimensionsAdaptiveStream !== undefined) {\n                if (minDimensions) {\n                    // check whether the adaptive stream dimensions are smaller than the requested dimensions and use smaller one\n                    const smallerAdaptive = areDimensionsSmaller(this.videoDimensionsAdaptiveStream, minDimensions);\n                    if (smallerAdaptive) {\n                        this.log.debug(\"using adaptive stream dimensions instead of requested\", Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));\n                        minDimensions = this.videoDimensionsAdaptiveStream;\n                    }\n                } else if (this.requestedMaxQuality !== undefined && this.trackInfo) {\n                    // check whether adaptive stream dimensions are smaller than the max quality layer and use smaller one\n                    const maxQualityLayer = layerDimensionsFor(this.trackInfo, this.requestedMaxQuality);\n                    if (maxQualityLayer && areDimensionsSmaller(this.videoDimensionsAdaptiveStream, maxQualityLayer)) {\n                        this.log.debug(\"using adaptive stream dimensions instead of max quality layer\", Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));\n                        minDimensions = this.videoDimensionsAdaptiveStream;\n                    }\n                } else {\n                    this.log.debug(\"using adaptive stream dimensions\", Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));\n                    minDimensions = this.videoDimensionsAdaptiveStream;\n                }\n            }\n            if (minDimensions) {\n                settings.width = Math.ceil(minDimensions.width);\n                settings.height = Math.ceil(minDimensions.height);\n            } else if (this.requestedMaxQuality !== undefined) {\n                this.log.debug(\"using requested max quality\", Object.assign(Object.assign({}, this.logContext), {\n                    quality: this.requestedMaxQuality\n                }));\n                settings.quality = this.requestedMaxQuality;\n            } else {\n                this.log.debug(\"using default quality\", Object.assign(Object.assign({}, this.logContext), {\n                    quality: VideoQuality.HIGH\n                }));\n                // defaults to high quality\n                settings.quality = VideoQuality.HIGH;\n            }\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi, loggerOptions) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);\n    }\n    get logContext() {\n        return Object.assign(Object.assign({}, super.logContext), {\n            rpID: this.sid,\n            remoteParticipant: this.identity\n        });\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions){\n        let kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : ParticipantInfo_Kind.STANDARD;\n        super(sid, identity || \"\", name, metadata, attributes, loggerOptions, kind);\n        this.signalClient = signalClient;\n        this.trackPublications = new Map();\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            this.log.debug(\"send update settings\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)), {\n                settings\n            }));\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrackPublication(source) {\n        const track = super.getTrackPublication(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackPublicationByName(name) {\n        const track = super.getTrackPublicationByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrackPublication(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant's microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrackPublication(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it's possible for the media track to arrive before participant info\n        let publication = this.getTrackPublicationBySid(sid);\n        // it's also possible that the browser didn't honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith(\"TR\")) {\n                // find the first track that matches type\n                this.trackPublications.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn't locate the track, it's possible that the metadata hasn't\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                this.log.error(\"could not find published track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: sid\n                }));\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            this.log.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === \"video\";\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication's muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    /**\n   * @internal\n   */ getTrackPublicationBySid(sid) {\n        return this.trackPublications.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            let publication = this.getTrackPublicationBySid(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n                    loggerContextCb: ()=>this.logContext,\n                    loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n                });\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n                        oldTrack: getLogContextFromTrack(existingTrackOfSource),\n                        newTrack: getLogContextFromTrack(publication)\n                    }));\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.trackPublications.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                this.log.trace(\"detected removed track on remote participant, unpublishing\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it's ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.trackPublications.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.trackPublications.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTrackPublications.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTrackPublications.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTrackPublications.forEach((pub)=>{\n                var _a;\n                if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : \"default\"));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        this.log.trace(\"participant event\", Object.assign(Object.assign({}, this.logContext), {\n            event,\n            args\n        }));\n        return super.emit(event, ...args);\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Disconnected\"] = \"disconnected\";\n    ConnectionState[\"Connecting\"] = \"connecting\";\n    ConnectionState[\"Connected\"] = \"connected\";\n    ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n    ConnectionState[\"SignalReconnecting\"] = \"signalReconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst CONNECTION_RECONCILE_FREQUENCY_MS = 4 * 1000;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    get hasE2EESetup() {\n        return this.e2eeManager !== undefined;\n    }\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a, _b, _c;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.log = livekitLogger;\n        this.bufferedEvents = [];\n        this.isResuming = false;\n        this.rpcHandlers = new Map();\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _a;\n                if (!isBrowserSupported()) {\n                    if (isReactNative()) {\n                        throw Error(\"WebRTC isn't detected, have you called registerGlobals?\");\n                    } else {\n                        throw Error(\"LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.\");\n                    }\n                }\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().then((settings)=>{\n                        var _a;\n                        (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.setServerReportedRegions(settings);\n                    }).catch((e)=>{\n                        this.log.warn(\"could not fetch region settings\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _a, _b;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield BackOffStrategy.getInstance().getBackOffPromise(url);\n                            if (abortController.signal.aborted) {\n                                throw new ConnectionError(\"Connection attempt aborted\", ConnectionErrorReason.Cancelled);\n                            }\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (error) {\n                            if (this.regionUrlProvider && error instanceof ConnectionError && error.reason !== ConnectionErrorReason.Cancelled && error.reason !== ConnectionErrorReason.NotAllowed) {\n                                let nextUrl = null;\n                                try {\n                                    this.log.debug(\"Fetching next region\");\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\n                                } catch (regionFetchError) {\n                                    if (regionFetchError instanceof ConnectionError && (regionFetchError.status === 401 || regionFetchError.reason === ConnectionErrorReason.Cancelled)) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(regionFetchError);\n                                        return;\n                                    }\n                                }\n                                if (// making sure we only register failed attempts on things we actually care about\n                                [\n                                    ConnectionErrorReason.InternalError,\n                                    ConnectionErrorReason.ServerUnreachable,\n                                    ConnectionErrorReason.Timeout\n                                ].includes(error.reason)) {\n                                    this.log.debug(\"Adding failed connection attempt to back off\");\n                                    BackOffStrategy.getInstance().addFailedConnectionAttempt(url);\n                                }\n                                if (nextUrl && !((_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.aborted)) {\n                                    this.log.info(\"Initial connection failed with ConnectionError: \".concat(error.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n                                    this.recreateEngine();\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(error));\n                                    reject(error);\n                                }\n                            } else {\n                                let disconnectReason = DisconnectReason.UNKNOWN_REASON;\n                                if (error instanceof ConnectionError) {\n                                    disconnectReason = getDisconnectReasonFromConnectionError(error);\n                                }\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);\n                                reject(error);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c;\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === \"object\" ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout,\n                    singlePeerConnection: roomOptions.singlePeerConnection\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                this.serverInfo = serverInfo;\n                this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return \"\".concat(key, \": \").concat(value);\n                }).join(\", \")), {\n                    room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,\n                    roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,\n                    identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity\n                });\n                if (!serverInfo.version) {\n                    throw new UnsupportedServer(\"unknown server version\");\n                }\n                if (serverInfo.version === \"0.15.1\" && this.options.dynacast) {\n                    this.log.debug(\"disabling dynacast due to server version\", this.logContext);\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);\n            if (this.e2eeManager) {\n                try {\n                    this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n                } catch (e) {\n                    this.log.error(e instanceof Error ? e.message : \"Could not set SifTrailer\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)) {\n                    this.log.info(\"Reconnection attempt replaced by new connection attempt\", this.logContext);\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError(\"could not establish signal connection\", abortController.signal.aborted ? ConnectionErrorReason.Cancelled : ConnectionErrorReason.ServerUnreachable);\n                    if (err instanceof Error) {\n                        resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n                        error: err\n                    }));\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError(\"Connection attempt aborted\", ConnectionErrorReason.Cancelled);\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n                    window.addEventListener(\"pagehide\", this.onPageLeave);\n                    window.addEventListener(\"beforeunload\", this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener(\"freeze\", this.onPageLeave);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                BackOffStrategy.getInstance().resetFailedConnectionAttempts(url);\n                this.registerConnectionReconcile();\n                // Notify region provider about successful connection\n                if (this.regionUrlProvider) {\n                    this.regionUrlProvider.notifyConnected();\n                }\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            for(var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++){\n                args_1[_key] = arguments[_key];\n            }\n            return __awaiter(_this, [\n                ...args_1\n            ], void 0, function() {\n                var _this2 = this;\n                let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                return function*() {\n                    var _a, _b, _c;\n                    const unlock = yield _this2.disconnectLock.lock();\n                    try {\n                        if (_this2.state === ConnectionState.Disconnected) {\n                            _this2.log.debug(\"already disconnected\", _this2.logContext);\n                            return;\n                        }\n                        _this2.log.info(\"disconnect from room\", Object.assign({}, _this2.logContext));\n                        if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {\n                            // try aborting pending connection attempt\n                            const msg = \"Abort connection attempt due to user initiated disconnect\";\n                            _this2.log.warn(msg, _this2.logContext);\n                            (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort(msg);\n                            // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n                            (_c = (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, new ConnectionError(\"Client initiated disconnect\", ConnectionErrorReason.Cancelled));\n                            _this2.connectFuture = undefined;\n                        }\n                        // close engine (also closes client)\n                        if (_this2.engine) {\n                            // send leave\n                            if (!_this2.engine.client.isDisconnected) {\n                                yield _this2.engine.client.sendLeave();\n                            }\n                            yield _this2.engine.close();\n                        }\n                        _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                        /* @ts-ignore */ _this2.engine = undefined;\n                    } finally{\n                        unlock();\n                    }\n                }();\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.log.info(\"Page leave detected, disconnecting\", this.logContext);\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === \"iOS\") {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = \"livekit-dummy-audio-el\";\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement(\"audio\");\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener(\"visibilitychange\", ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                            if (!document.hidden) {\n                                this.log.debug(\"page visible again, triggering startAudio to resume playback and update playback status\", this.logContext);\n                                this.startAudio();\n                            }\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                            dummyAudioEl = null;\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.remoteParticipants.forEach((p)=>{\n                    p.audioTrackPublications.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.remoteParticipants.values()){\n                    p.videoTrackPublications.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === \"NotAllowedError\") {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        this.log.warn(\"Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler\", this.logContext);\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag\n            this.isResuming = false;\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.remoteParticipants.values()){\n                this.handleParticipantDisconnected(p.identity, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n                    region: joinResponse.serverRegion\n                }));\n                this.bufferedEvents = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    yield this.localParticipant.republishAllTracks(undefined, true);\n                } catch (error) {\n                    this.log.error(\"error trying to re-publish tracks after reconnection\", Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n                        region: joinResponse.serverRegion\n                    }));\n                } catch (_a) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                this.emitBufferedEvents();\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                var _a;\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates\n                // so we try to map an empty identity to an already known sID manually\n                if (info.identity === \"\") {\n                    info.identity = (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : \"\";\n                }\n                let remoteParticipant = this.remoteParticipants.get(info.identity);\n                // when it's disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.identity, remoteParticipant);\n                } else {\n                    // create participant if doesn't exist\n                    remoteParticipant = this.getOrCreateParticipant(info.identity, info);\n                }\n            });\n        };\n        // updates are sent only when there's a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.getRemoteParticipantBySid(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.remoteParticipants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                const remoteParticipant = this.remoteParticipants.get(p.identity);\n                if (remoteParticipant && remoteParticipant.sid !== p.sid) {\n                    return;\n                }\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.getRemoteParticipantBySid(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.getRemoteParticipantBySid(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublicationBySid(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                const newStreamState = Track.streamStateFromProto(streamState.state);\n                pub.track.setStreamState(newStreamState);\n                if (newStreamState !== pub.track.streamState) {\n                    participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                    this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n                }\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.getRemoteParticipantBySid(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublicationBySid(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.remoteParticipants.values()).find((p)=>p.trackPublications.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublicationBySid(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (packet, encryptionType)=>{\n            // find the participant\n            const participant = this.remoteParticipants.get(packet.participantIdentity);\n            if (packet.value.case === \"user\") {\n                this.handleUserPacket(participant, packet.value.value, packet.kind, encryptionType);\n            } else if (packet.value.case === \"transcription\") {\n                this.handleTranscription(participant, packet.value.value);\n            } else if (packet.value.case === \"sipDtmf\") {\n                this.handleSipDtmf(participant, packet.value.value);\n            } else if (packet.value.case === \"chatMessage\") {\n                this.handleChatMessage(participant, packet.value.value);\n            } else if (packet.value.case === \"metrics\") {\n                this.handleMetrics(packet.value.value, participant);\n            } else if (packet.value.case === \"streamHeader\" || packet.value.case === \"streamChunk\" || packet.value.case === \"streamTrailer\") {\n                this.handleDataStream(packet, encryptionType);\n            } else if (packet.value.case === \"rpcRequest\") {\n                const rpc = packet.value.value;\n                this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);\n            }\n        };\n        this.handleUserPacket = (participant, userPacket, kind, encryptionType)=>{\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic, encryptionType);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind, encryptionType);\n        };\n        this.handleSipDtmf = (participant, dtmf)=>{\n            this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);\n        };\n        this.handleTranscription = (_remoteParticipant, transcription)=>{\n            // find the participant\n            const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);\n            const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);\n            const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);\n            publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);\n            this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);\n        };\n        this.handleChatMessage = (participant, chatMessage)=>{\n            const msg = extractChatMessage(chatMessage);\n            this.emit(RoomEvent.ChatMessage, msg, participant);\n        };\n        this.handleMetrics = (metrics, participant)=>{\n            this.emit(RoomEvent.MetricsReceived, metrics, participant);\n        };\n        this.handleDataStream = (packet, encryptionType)=>{\n            this.incomingDataStreamManager.handleDataStreamPacket(packet, encryptionType);\n        };\n        this.bufferedSegments = new Map();\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            this.log.warn(\"could not playback audio\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                var _a;\n                if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) !== \"iOS\") {\n                    // default devices are non deterministic on iOS, so we don't attempt to select them here\n                    yield this.selectDefaultDevices();\n                }\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.getRemoteParticipantBySid(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalAttributesChanged = (changedAttributes)=>{\n            this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onTrackProcessorUpdate = (processor)=>{\n            var _a;\n            (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a === void 0 ? void 0 : _a.call(processor, this);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c, _d, _e, _f;\n                (_a = pub.track) === null || _a === void 0 ? void 0 : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n                (_b = pub.track) === null || _b === void 0 ? void 0 : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);\n                (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (isLocalAudioTrack(pub.track)) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            var _a, _b;\n            (_a = pub.track) === null || _a === void 0 ? void 0 : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalTrackRestarted = (track)=>__awaiter(this, void 0, void 0, function*() {\n                const deviceId = yield track.getDeviceId(false);\n                const deviceKind = sourceToKind(track.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.log.debug(\"local track restarted, setting \".concat(deviceKind, \" \").concat(deviceId, \" active\"), this.logContext);\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e, kind)=>{\n            this.emit(RoomEvent.MediaDevicesError, e, kind);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.onLocalChatMessageSent = (msg)=>{\n            this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.remoteParticipants = new Map();\n        this.sidToIdentity = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n        this.transcriptionReceivedTimes = new Map();\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.incomingDataStreamManager = new IncomingDataStreamManager();\n        this.outgoingDataStreamManager = new OutgoingDataStreamManager(this.engine, this.log);\n        this.disconnectLock = new _();\n        this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options, this.rpcHandlers, this.outgoingDataStreamManager);\n        if (this.options.e2ee || this.options.encryption) {\n            this.setupE2EE();\n        }\n        this.engine.e2eeManager = this.e2eeManager;\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"videoinput\", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"audioinput\", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n            this.switchActiveDevice(\"audiooutput\", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        if (isWeb()) {\n            const abortController = new AbortController();\n            // in order to catch device changes prior to room connection we need to register the event in the constructor\n            (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener(\"devicechange\", this.handleDeviceChange, {\n                signal: abortController.signal\n            });\n            if (Room.cleanupRegistry) {\n                Room.cleanupRegistry.register(this, ()=>{\n                    abortController.abort();\n                });\n            }\n        }\n    }\n    registerTextStreamHandler(topic, callback) {\n        return this.incomingDataStreamManager.registerTextStreamHandler(topic, callback);\n    }\n    unregisterTextStreamHandler(topic) {\n        return this.incomingDataStreamManager.unregisterTextStreamHandler(topic);\n    }\n    registerByteStreamHandler(topic, callback) {\n        return this.incomingDataStreamManager.registerByteStreamHandler(topic, callback);\n    }\n    unregisterByteStreamHandler(topic) {\n        return this.incomingDataStreamManager.unregisterByteStreamHandler(topic);\n    }\n    /**\n   * Establishes the participant as a receiver for calls of the specified RPC method.\n   *\n   * @param method - The name of the indicated RPC method\n   * @param handler - Will be invoked when an RPC request for this method is received\n   * @returns A promise that resolves when the method is successfully registered\n   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)\n   *\n   * @example\n   * ```typescript\n   * room.localParticipant?.registerRpcMethod(\n   *   'greet',\n   *   async (data: RpcInvocationData) => {\n   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);\n   *     return `Hello, ${data.callerIdentity}!`;\n   *   }\n   * );\n   * ```\n   *\n   * The handler should return a Promise that resolves to a string.\n   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.\n   *\n   * You may throw errors of type `RpcError` with a string `message` in the handler,\n   * and they will be received on the caller's side with the message intact.\n   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` (\"Application Error\").\n   */ registerRpcMethod(method, handler) {\n        if (this.rpcHandlers.has(method)) {\n            throw Error(\"RPC handler already registered for method \".concat(method, \", unregisterRpcMethod before trying to register again\"));\n        }\n        this.rpcHandlers.set(method, handler);\n    }\n    /**\n   * Unregisters a previously registered RPC method.\n   *\n   * @param method - The name of the RPC method to unregister\n   */ unregisterRpcMethod(method) {\n        this.rpcHandlers.delete(method);\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== \"\") {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error(\"e2ee not configured, please set e2ee settings within the room options\");\n            }\n        });\n    }\n    setupE2EE() {\n        // when encryption is enabled via `options.encryption`, we enable data channel encryption\n        var _a;\n        const dcEncryptionEnabled = !!this.options.encryption;\n        const e2eeOptions = this.options.encryption || this.options.e2ee;\n        if (e2eeOptions) {\n            if (\"e2eeManager\" in e2eeOptions) {\n                this.e2eeManager = e2eeOptions.e2eeManager;\n                this.e2eeManager.isDataChannelEncryptionEnabled = dcEncryptionEnabled;\n            } else {\n                this.e2eeManager = new E2EEManager(e2eeOptions, dcEncryptionEnabled);\n            }\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (isLocalParticipant(participant)) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error, participantIdentity)=>{\n                const participant = participantIdentity ? this.getParticipantByIdentity(participantIdentity) : undefined;\n                this.emit(RoomEvent.EncryptionError, error, participant);\n            });\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    get logContext() {\n        var _a;\n        return {\n            room: this.name,\n            roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,\n            participant: this.localParticipant.identity,\n            pID: this.localParticipant.sid\n        };\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n   * server assigned unique room id.\n   * returns once a sid has been issued by the server.\n   */ getSid() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === ConnectionState.Disconnected) {\n                return \"\";\n            }\n            if (this.roomInfo && this.roomInfo.sid !== \"\") {\n                return this.roomInfo.sid;\n            }\n            return new Promise((resolve, reject)=>{\n                const handleRoomUpdate = (roomInfo)=>{\n                    if (roomInfo.sid !== \"\") {\n                        this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n                        resolve(roomInfo.sid);\n                    }\n                };\n                this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);\n                this.once(RoomEvent.Disconnected, ()=>{\n                    this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n                    reject(\"Room disconnected before room server id was available\");\n                });\n            });\n        });\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.e2eeManager = this.e2eeManager;\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            this.isResuming = true;\n            this.log.info(\"Resuming signal connection\", this.logContext);\n            if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {\n                this.emit(RoomEvent.SignalReconnecting);\n            }\n        }).on(EngineEvent.Resumed, ()=>{\n            this.registerConnectionReconcile();\n            this.isResuming = false;\n            this.log.info(\"Resumed signal connection\", this.logContext);\n            this.updateSubscriptions();\n            this.emitBufferedEvents();\n            if (this.setAndEmitConnectionState(ConnectionState.Connected)) {\n                this.emit(RoomEvent.Reconnected);\n            }\n        }).on(EngineEvent.SignalResumed, ()=>{\n            this.bufferedEvents = [];\n            if (this.state === ConnectionState.Reconnecting || this.isResuming) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, ()=>{\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        }).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        }).on(EngineEvent.LocalTrackSubscribed, (subscribedSid)=>{\n            const trackPublication = this.localParticipant.getTrackPublications().find((_ref2)=>{\n                let { trackSid } = _ref2;\n                return trackSid === subscribedSid;\n            });\n            if (!trackPublication) {\n                this.log.warn(\"could not find local track subscription for subscribed event\", this.logContext);\n                return;\n            }\n            this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);\n            this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);\n        }).on(EngineEvent.RoomMoved, (roomMoved)=>{\n            this.log.debug(\"room moved\", roomMoved);\n            if (roomMoved.room) {\n                this.handleRoomUpdate(roomMoved.room);\n            }\n            this.remoteParticipants.forEach((participant, identity)=>{\n                this.handleParticipantDisconnected(identity, participant);\n            });\n            this.emit(RoomEvent.Moved, roomMoved.room.name);\n            if (roomMoved.participant) {\n                this.handleParticipantUpdates([\n                    roomMoved.participant,\n                    ...roomMoved.otherParticipants\n                ]);\n            } else {\n                this.handleParticipantUpdates(roomMoved.otherParticipants);\n            }\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n        if (this.outgoingDataStreamManager) {\n            this.outgoingDataStreamManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it requests device permissions by default if needed\n   * and makes sure the returned device does not consist of dummy devices\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: \"HEAD\"\n                        });\n                        this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: \"HEAD\"\n                    });\n                }\n            } catch (e) {\n                this.log.warn(\"could not prepare connection\", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        return this.remoteParticipants.get(identity);\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>__awaiter(this, void 0, void 0, function*() {});\n            let req;\n            switch(scenario){\n                case \"signal-reconnect\":\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate disconnect\");\n                    break;\n                case \"speaker\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"speakerUpdate\",\n                            value: 3\n                        }\n                    });\n                    break;\n                case \"node-failure\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"nodeFailure\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"server-leave\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"serverLeave\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"migration\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"migration\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"resume-reconnect\":\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                    break;\n                case \"disconnect-signal-on-resume\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResume\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"disconnect-signal-on-resume-no-messages\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResumeNoMessages\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"full-reconnect\":\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate full-reconnect\");\n                    break;\n                case \"force-tcp\":\n                case \"force-tls\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"switchCandidateProtocol\",\n                            value: scenario === \"force-tls\" ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    action: LeaveRequest_Action.RECONNECT\n                                }));\n                            }\n                        });\n                    break;\n                case \"subscriber-bandwidth\":\n                    if (arg === undefined || typeof arg !== \"number\") {\n                        throw new Error(\"subscriber-bandwidth requires a number as argument\");\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"subscriberBandwidth\",\n                            value: numberToBigInt(arg)\n                        }\n                    });\n                    break;\n                case \"leave-full-reconnect\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"leaveRequestFullReconnect\",\n                            value: true\n                        }\n                    });\n            }\n            if (req) {\n                yield this.engine.client.sendSimulateScenario(req);\n                yield postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind_1, deviceId_1) {\n        return __awaiter(this, arguments, void 0, function(kind, deviceId) {\n            var _this3 = this;\n            let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            return function*() {\n                var _a, _b, _c, _d, _e, _f;\n                var _g;\n                let success = true;\n                let shouldTriggerImmediateDeviceChange = false;\n                const deviceConstraint = exact ? {\n                    exact: deviceId\n                } : deviceId;\n                if (kind === \"audioinput\") {\n                    shouldTriggerImmediateDeviceChange = _this3.localParticipant.audioTrackPublications.size === 0;\n                    const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;\n                    _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                    const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter((track)=>track.source === Track.Source.Microphone);\n                    try {\n                        success = (yield Promise.all(tracks.map((t)=>{\n                            var _a;\n                            return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                        }))).every((val)=>val === true);\n                    } catch (e) {\n                        _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                    const isMuted = tracks.some((t)=>{\n                        var _a, _b;\n                        return (_b = (_a = t.track) === null || _a === void 0 ? void 0 : _a.isMuted) !== null && _b !== void 0 ? _b : false;\n                    });\n                    if (success && isMuted) shouldTriggerImmediateDeviceChange = true;\n                } else if (kind === \"videoinput\") {\n                    shouldTriggerImmediateDeviceChange = _this3.localParticipant.videoTrackPublications.size === 0;\n                    const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;\n                    _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                    const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter((track)=>track.source === Track.Source.Camera);\n                    try {\n                        success = (yield Promise.all(tracks.map((t)=>{\n                            var _a;\n                            return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                        }))).every((val)=>val === true);\n                    } catch (e) {\n                        _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                    const isMuted = tracks.some((t)=>{\n                        var _a, _b;\n                        return (_b = (_a = t.track) === null || _a === void 0 ? void 0 : _a.isMuted) !== null && _b !== void 0 ? _b : false;\n                    });\n                    if (success && isMuted) shouldTriggerImmediateDeviceChange = true;\n                } else if (kind === \"audiooutput\") {\n                    shouldTriggerImmediateDeviceChange = true;\n                    if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !(\"setSinkId\" in _this3.audioContext)) {\n                        throw new Error(\"cannot switch audio output, the current browser does not support it\");\n                    }\n                    if (_this3.options.webAudioMix) {\n                        // setting `default` for web audio output doesn't work, so we need to normalize the id before\n                        deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId(\"audiooutput\", deviceId)) !== null && _c !== void 0 ? _c : \"\";\n                    }\n                    (_d = (_g = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _g.audioOutput = {};\n                    const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;\n                    _this3.options.audioOutput.deviceId = deviceId;\n                    try {\n                        if (_this3.options.webAudioMix) {\n                            // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                            (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);\n                        }\n                        // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices\n                        // see https://issues.chromium.org/issues/40252911#comment7\n                        yield Promise.all(Array.from(_this3.remoteParticipants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    } catch (e) {\n                        _this3.options.audioOutput.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                }\n                if (shouldTriggerImmediateDeviceChange) {\n                    _this3.localParticipant.activeDeviceMap.set(kind, deviceId);\n                    _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n                }\n                return success;\n            }();\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        this.isResuming = false;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.remoteParticipants.clear();\n        this.sidToIdentity.clear();\n        this.bufferedEvents = [];\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don't fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We'll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.log.debug(\"deferring on track for later\", {\n                    mediaTrackId: mediaTrack.id,\n                    mediaStreamId: stream.id,\n                    tracksInStream: stream.getTracks().map((track)=>track.id)\n                });\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            this.log.warn(\"skipping incoming track after Room disconnected\", this.logContext);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            this.log.info(\"skipping incoming track as it already ended\", this.logContext);\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantSid = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith(\"TR\")) trackId = streamId;\n        if (participantSid === this.localParticipant.sid) {\n            this.log.warn(\"tried to create RemoteParticipant for local participant\", this.logContext);\n            return;\n        }\n        const participant = Array.from(this.remoteParticipants.values()).find((p)=>p.sid === participantSid);\n        if (!participant) {\n            this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\n            return;\n        }\n        // in single peer connection case, the trackID is locally generated,\n        // not the TR_ prefixed one generated by the server,\n        // use `mid` to find the appropriate track.\n        if (!trackId.startsWith(\"TR\")) {\n            const id = this.engine.getTrackIdForReceiver(receiver);\n            if (!id) {\n                this.log.error(\"Tried to add a track whose 'sid' could not be found for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\n                return;\n            }\n            trackId = id;\n        }\n        if (!trackId.startsWith(\"TR\")) {\n            this.log.warn(\"Tried to add a track whose 'sid' could not be determined for a participant, that's not present. Sid: \".concat(participantSid, \", streamId: \").concat(streamId, \", trackId: \").concat(trackId), Object.assign(Object.assign({}, this.logContext), {\n                rpID: participantSid,\n                streamId,\n                trackId\n            }));\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === \"object\") {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        const publication = participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n        if ((publication === null || publication === void 0 ? void 0 : publication.isEncrypted) && !this.e2eeManager) {\n            this.emit(RoomEvent.EncryptionError, new Error(\"Encrypted \".concat(publication.source, \" track received from participant \").concat(participant.sid, \", but room does not have encryption enabled!\")));\n        }\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        this.isResuming = false;\n        this.bufferedEvents = [];\n        this.transcriptionReceivedTimes.clear();\n        this.incomingDataStreamManager.clearControllers();\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        // Notify region provider about disconnect to potentially stop auto-refetch\n        if (this.regionUrlProvider) {\n            this.regionUrlProvider.notifyDisconnected();\n        }\n        try {\n            this.remoteParticipants.forEach((p)=>{\n                p.trackPublications.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.trackPublications.forEach((pub)=>{\n                var _a, _b, _c;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                } else {\n                    (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.trackPublications.clear();\n            this.localParticipant.videoTrackPublications.clear();\n            this.localParticipant.audioTrackPublications.clear();\n            this.remoteParticipants.clear();\n            this.sidToIdentity.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.webAudioMix === \"boolean\") {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener(\"beforeunload\", this.onPageLeave);\n                window.removeEventListener(\"pagehide\", this.onPageLeave);\n                window.removeEventListener(\"freeze\", this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"devicechange\", this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(identity, participant) {\n        var _a;\n        // remove and send event\n        this.remoteParticipants.delete(identity);\n        if (!participant) {\n            return;\n        }\n        this.incomingDataStreamManager.validateParticipantHasNoActiveDataStreams(identity);\n        participant.trackPublications.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n        participant.setDisconnected();\n        (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);\n    }\n    handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.engine.publishRpcAck(callerIdentity, requestId);\n            if (version !== 1) {\n                yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn(\"UNSUPPORTED_VERSION\"));\n                return;\n            }\n            const handler = this.rpcHandlers.get(method);\n            if (!handler) {\n                yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn(\"UNSUPPORTED_METHOD\"));\n                return;\n            }\n            let responseError = null;\n            let responsePayload = null;\n            try {\n                const response = yield handler({\n                    requestId,\n                    callerIdentity,\n                    payload,\n                    responseTimeout\n                });\n                if (byteLength(response) > MAX_PAYLOAD_BYTES) {\n                    responseError = RpcError.builtIn(\"RESPONSE_PAYLOAD_TOO_LARGE\");\n                    console.warn(\"RPC Response payload too large for \".concat(method));\n                } else {\n                    responsePayload = response;\n                }\n            } catch (error) {\n                if (error instanceof RpcError) {\n                    responseError = error;\n                } else {\n                    console.warn(\"Uncaught error returned by RPC handler for \".concat(method, \". Returning APPLICATION_ERROR instead.\"), error);\n                    responseError = RpcError.builtIn(\"APPLICATION_ERROR\");\n                }\n            }\n            yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);\n        });\n    }\n    /**\n   * attempt to select the default devices if the previously selected devices are no longer available after a device change event\n   */ selectDefaultDevices() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            const previousDevices = DeviceManager.getInstance().previousDevices;\n            // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before\n            const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);\n            const browser = getBrowser();\n            if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && browser.os !== \"iOS\") {\n                for (let availableDevice of availableDevices){\n                    const previousDevice = previousDevices.find((info)=>info.deviceId === availableDevice.deviceId);\n                    if (previousDevice && previousDevice.label !== \"\" && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {\n                        // label has changed on device the same deviceId, indicating that the default device has changed on the OS level\n                        if (this.getActiveDevice(availableDevice.kind) === \"default\") {\n                            // emit an active device change event only if the selected output device is actually on `default`\n                            this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);\n                        }\n                    }\n                }\n            }\n            const kinds = [\n                \"audiooutput\",\n                \"audioinput\",\n                \"videoinput\"\n            ];\n            for (let kind of kinds){\n                const targetSource = kindToSource(kind);\n                const targetPublication = this.localParticipant.getTrackPublication(targetSource);\n                if (targetPublication && ((_a = targetPublication.track) === null || _a === void 0 ? void 0 : _a.isUserProvided)) {\n                    continue;\n                }\n                const devicesOfKind = availableDevices.filter((d)=>d.kind === kind);\n                const activeDevice = this.getActiveDevice(kind);\n                if (activeDevice === ((_b = previousDevices.filter((info)=>info.kind === kind)[0]) === null || _b === void 0 ? void 0 : _b.deviceId)) {\n                    // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes\n                    // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array\n                    if (devicesOfKind.length > 0 && ((_c = devicesOfKind[0]) === null || _c === void 0 ? void 0 : _c.deviceId) !== activeDevice) {\n                        yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n                        continue;\n                    }\n                }\n                if (kind === \"audioinput\" && !isSafariBased() || kind === \"videoinput\") {\n                    continue;\n                }\n                // switch to first available device if previously active device is not available any more\n                if (devicesOfKind.length > 0 && !devicesOfKind.find((deviceInfo)=>deviceInfo.deviceId === this.getActiveDevice(kind)) && // avoid switching audio output on safari without explicit user action as it leads to slowed down audio playback\n                (kind !== \"audiooutput\" || !isSafariBased())) {\n                    yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n                }\n            }\n        });\n    }\n    acquireAudioContext() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            if (typeof this.options.webAudioMix !== \"boolean\" && this.options.webAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.webAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === \"closed\") {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.options.webAudioMix) {\n                this.remoteParticipants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            if (this.audioContext && this.audioContext.state === \"suspended\") {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n                try {\n                    yield Promise.race([\n                        this.audioContext.resume(),\n                        sleep(200)\n                    ]);\n                } catch (e) {\n                    this.log.warn(\"Could not resume audio context\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === \"running\";\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(identity, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        } else {\n            participant = new RemoteParticipant(this.engine.client, \"\", identity, undefined, undefined, undefined, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        }\n        if (this.options.webAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(identity, info) {\n        if (this.remoteParticipants.has(identity)) {\n            const existingParticipant = this.remoteParticipants.get(identity);\n            if (info) {\n                const wasUpdated = existingParticipant.updateInfo(info);\n                if (wasUpdated) {\n                    this.sidToIdentity.set(info.sid, info.identity);\n                }\n            }\n            return existingParticipant;\n        }\n        const participant = this.createParticipant(identity, info);\n        this.remoteParticipants.set(identity, participant);\n        this.sidToIdentity.set(info.sid, info.identity);\n        // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.AttributesChanged, (changedAttributes)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        }).on(ParticipantEvent.Active, ()=>{\n            this.emitWhenConnected(RoomEvent.ParticipantActive, participant);\n            if (participant.kind === ParticipantInfo_Kind.AGENT) {\n                this.localParticipant.setActiveAgent(participant);\n            }\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.remoteParticipants.values()){\n            for (const pub of p.videoTrackPublications.values()){\n                if (pub.isSubscribed && isRemotePub(pub)) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    getRemoteParticipantBySid(sid) {\n        const identity = this.sidToIdentity.get(sid);\n        if (identity) {\n            return this.remoteParticipants.get(identity);\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn't tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                this.log.warn(\"detected connection state mismatch\", Object.assign(Object.assign({}, this.logContext), {\n                    numFailures: consecutiveFailures,\n                    engine: this.engine ? {\n                        closed: this.engine.isClosed,\n                        transportsConnected: this.engine.verifyTransport()\n                    } : undefined\n                }));\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, CONNECTION_RECONCILE_FREQUENCY_MS);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitBufferedEvents() {\n        this.bufferedEvents.forEach((_ref3)=>{\n            let [ev, args] = _ref3;\n            this.emit(ev, ...args);\n        });\n        this.bufferedEvents = [];\n    }\n    emitWhenConnected(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {\n            // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\n            this.bufferedEvents.push([\n                event,\n                args\n            ]);\n        } else if (this.state === ConnectionState.Connected) {\n            return this.emit(event, ...args);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: \"RM_SIMULATED\",\n                name: \"simulated-room\",\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: \"\",\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: \"\",\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: \"simulated-local\",\n                name: \"local-name\"\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: \"video-dummy\"\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: \"simulated-\".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]), new RTCRtpReceiver());\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]), new RTCRtpReceiver());\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){\n            args[_key3 - 1] = arguments[_key3];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {\n            // only extract logContext from arguments in order to avoid logging the whole object tree\n            const minimizedArgs = mapArgs(args).filter((arg)=>arg !== undefined);\n            if (event === RoomEvent.TrackSubscribed || event === RoomEvent.TrackUnsubscribed) {\n                this.log.trace(\"subscribe trace: \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                    event,\n                    args: minimizedArgs\n                }));\n            }\n            this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                event,\n                args: minimizedArgs\n            }));\n        }\n        return super.emit(event, ...args);\n    }\n}\nRoom.cleanupRegistry = typeof FinalizationRegistry !== \"undefined\" && new FinalizationRegistry((cleanup)=>{\n    cleanup();\n});\nfunction mapArgs(args) {\n    return args.map((arg)=>{\n        if (!arg) {\n            return;\n        }\n        if (Array.isArray(arg)) {\n            return mapArgs(arg);\n        }\n        if (typeof arg === \"object\") {\n            return \"logContext\" in arg ? arg.logContext : undefined;\n        }\n        return arg;\n    });\n}\n// This file was generated from JSON Schema using quicktype, do not modify it directly.\n// The code generation lives at https://github.com/livekit/attribute-definitions\n//\n// To parse this data:\n//\n//   import { Convert, AgentAttributes, TranscriptionAttributes } from \"./file\";\n//\n//   const agentAttributes = Convert.toAgentAttributes(json);\n//   const transcriptionAttributes = Convert.toTranscriptionAttributes(json);\n// Converts JSON strings to/from your types\nclass Convert {\n    static toAgentAttributes(json) {\n        return JSON.parse(json);\n    }\n    static agentAttributesToJson(value) {\n        return JSON.stringify(value);\n    }\n    static toTranscriptionAttributes(json) {\n        return JSON.parse(json);\n    }\n    static transcriptionAttributesToJson(value) {\n        return JSON.stringify(value);\n    }\n}\nvar attributeTypings = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Convert: Convert\n});\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n    CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n    CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.options = {};\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        this.options = options;\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error(\"check is running already\");\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.options.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === \"error\");\n    }\n    connect(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            if (!url) {\n                url = this.url;\n            }\n            yield this.room.connect(url, this.token, this.connectOptions);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    switchProtocol(protocol) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasReconnecting = false;\n            let hasReconnected = false;\n            this.room.on(RoomEvent.Reconnecting, ()=>{\n                hasReconnecting = true;\n            });\n            this.room.once(RoomEvent.Reconnected, ()=>{\n                hasReconnected = true;\n            });\n            this.room.simulateScenario(\"force-\".concat(protocol));\n            yield new Promise((resolve)=>setTimeout(resolve, 1000));\n            if (!hasReconnecting) {\n                // no need to wait for reconnection\n                return;\n            }\n            // wait for 10 seconds for reconnection\n            const timeout = Date.now() + 10000;\n            while(Date.now() < timeout){\n                if (hasReconnected) {\n                    return;\n                }\n                yield sleep(100);\n            }\n            throw new Error(\"Could not reconnect using \".concat(protocol, \" protocol after 10 seconds\"));\n        });\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: \"info\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: \"warning\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: \"error\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit(\"update\", this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Checks for connections quality to closests Cloud regions and determining the best quality\n */ class CloudRegionCheck extends Checker {\n    get description() {\n        return \"Cloud regions\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionProvider = new RegionUrlProvider(this.url, this.token);\n            if (!regionProvider.isCloud()) {\n                this.skip();\n                return;\n            }\n            const regionStats = [];\n            const seenUrls = new Set();\n            for(let i = 0; i < 3; i++){\n                const regionUrl = yield regionProvider.getNextBestRegionUrl();\n                if (!regionUrl) {\n                    break;\n                }\n                if (seenUrls.has(regionUrl)) {\n                    continue;\n                }\n                seenUrls.add(regionUrl);\n                const stats = yield this.checkCloudRegion(regionUrl);\n                this.appendMessage(\"\".concat(stats.region, \" RTT: \").concat(stats.rtt, \"ms, duration: \").concat(stats.duration, \"ms\"));\n                regionStats.push(stats);\n            }\n            regionStats.sort((a, b)=>{\n                return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;\n            });\n            const bestRegion = regionStats[0];\n            this.bestStats = bestRegion;\n            this.appendMessage(\"best Cloud region: \".concat(bestRegion.region));\n        });\n    }\n    getInfo() {\n        const info = super.getInfo();\n        info.data = this.bestStats;\n        return info;\n    }\n    checkCloudRegion(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            yield this.connect(url);\n            if (this.options.protocol === \"tcp\") {\n                yield this.switchProtocol(\"tcp\");\n            }\n            const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;\n            if (!region) {\n                throw new Error(\"Region not found\");\n            }\n            const writer = yield this.room.localParticipant.streamText({\n                topic: \"test\"\n            });\n            const chunkSize = 1000; // each chunk is about 1000 bytes\n            const totalSize = 1000000; // approximately 1MB of data\n            const numChunks = totalSize / chunkSize; // will yield 1000 chunks\n            const chunkData = \"A\".repeat(chunkSize); // create a string of 1000 'A' characters\n            const startTime = Date.now();\n            for(let i = 0; i < numChunks; i++){\n                yield writer.write(chunkData);\n            }\n            yield writer.close();\n            const endTime = Date.now();\n            const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();\n            const regionStats = {\n                region: region,\n                rtt: 10000,\n                duration: endTime - startTime\n            };\n            stats === null || stats === void 0 ? void 0 : stats.forEach((stat)=>{\n                if (stat.type === \"candidate-pair\" && stat.nominated) {\n                    regionStats.rtt = stat.currentRoundTripTime * 1000;\n                }\n            });\n            yield this.disconnect();\n            return regionStats;\n        });\n    }\n}\nconst TEST_DURATION = 10000;\nclass ConnectionProtocolCheck extends Checker {\n    get description() {\n        return \"Connection via UDP vs TCP\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const udpStats = yield this.checkConnectionProtocol(\"udp\");\n            const tcpStats = yield this.checkConnectionProtocol(\"tcp\");\n            this.bestStats = udpStats;\n            // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:\n            // 1. the bandwidth limitation is worse on UDP by 500ms\n            // 2. the packet loss is higher on UDP by 1%\n            if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {\n                this.appendMessage(\"best connection quality via tcp\");\n                this.bestStats = tcpStats;\n            } else {\n                this.appendMessage(\"best connection quality via udp\");\n            }\n            const stats = this.bestStats;\n            this.appendMessage(\"upstream bitrate: \".concat((stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2), \" mbps\"));\n            this.appendMessage(\"RTT: \".concat((stats.rttTotal / stats.count * 1000).toFixed(2), \" ms\"));\n            this.appendMessage(\"jitter: \".concat((stats.jitterTotal / stats.count * 1000).toFixed(2), \" ms\"));\n            if (stats.packetsLost > 0) {\n                this.appendWarning(\"packets lost: \".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), \"%\"));\n            }\n            if (stats.qualityLimitationDurations.bandwidth > 1) {\n                this.appendWarning(\"bandwidth limited \".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n            }\n            if (stats.qualityLimitationDurations.cpu > 0) {\n                this.appendWarning(\"cpu limited \".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n            }\n        });\n    }\n    getInfo() {\n        const info = super.getInfo();\n        info.data = this.bestStats;\n        return info;\n    }\n    checkConnectionProtocol(protocol) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.connect();\n            if (protocol === \"tcp\") {\n                yield this.switchProtocol(\"tcp\");\n            } else {\n                yield this.switchProtocol(\"udp\");\n            }\n            // create a canvas with animated content\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = 1280;\n            canvas.height = 720;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                throw new Error(\"Could not get canvas context\");\n            }\n            let hue = 0;\n            const animate = ()=>{\n                hue = (hue + 1) % 360;\n                ctx.fillStyle = \"hsl(\".concat(hue, \", 100%, 50%)\");\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                requestAnimationFrame(animate);\n            };\n            animate();\n            // create video track from canvas\n            const stream = canvas.captureStream(30); // 30fps\n            const videoTrack = stream.getVideoTracks()[0];\n            // publish to room\n            const pub = yield this.room.localParticipant.publishTrack(videoTrack, {\n                simulcast: false,\n                degradationPreference: \"maintain-resolution\",\n                videoEncoding: {\n                    maxBitrate: 2000000\n                }\n            });\n            const track = pub.track;\n            const protocolStats = {\n                protocol,\n                packetsLost: 0,\n                packetsSent: 0,\n                qualityLimitationDurations: {},\n                rttTotal: 0,\n                jitterTotal: 0,\n                bitrateTotal: 0,\n                count: 0\n            };\n            // gather stats once a second\n            const interval = setInterval(()=>__awaiter(this, void 0, void 0, function*() {\n                    const stats = yield track.getRTCStatsReport();\n                    stats === null || stats === void 0 ? void 0 : stats.forEach((stat)=>{\n                        if (stat.type === \"outbound-rtp\") {\n                            protocolStats.packetsSent = stat.packetsSent;\n                            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;\n                            protocolStats.bitrateTotal += stat.targetBitrate;\n                            protocolStats.count++;\n                        } else if (stat.type === \"remote-inbound-rtp\") {\n                            protocolStats.packetsLost = stat.packetsLost;\n                            protocolStats.rttTotal += stat.roundTripTime;\n                            protocolStats.jitterTotal += stat.jitter;\n                        }\n                    });\n                }), 1000);\n            // wait a bit to gather stats\n            yield new Promise((resolve)=>setTimeout(resolve, TEST_DURATION));\n            clearInterval(interval);\n            videoTrack.stop();\n            canvas.remove();\n            yield this.disconnect();\n            return protocolStats;\n        });\n    }\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return \"Can publish audio\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            const trackIsSilent = yield detectSilence(track, 1000);\n            if (trackIsSilent) {\n                throw new Error(\"unable to detect audio from microphone\");\n            }\n            this.appendMessage(\"detected audio from microphone\");\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && (stat.kind === \"audio\" || !stat.kind && stat.mediaType === \"audio\")) {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return \"Can publish video\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            // check if we have video from camera\n            yield this.checkForVideo(track.mediaStreamTrack);\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 5000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && (stat.kind === \"video\" || !stat.kind && stat.mediaType === \"video\")) {\n                    numPackets += stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n        });\n    }\n    checkForVideo(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const stream = new MediaStream();\n            stream.addTrack(track.clone());\n            // Create video element to check frames\n            const video = document.createElement(\"video\");\n            video.srcObject = stream;\n            video.muted = true;\n            video.autoplay = true;\n            video.playsInline = true;\n            // For iOS Safari\n            video.setAttribute(\"playsinline\", \"true\");\n            document.body.appendChild(video);\n            yield new Promise((resolve)=>{\n                video.onplay = ()=>{\n                    setTimeout(()=>{\n                        var _a, _b, _c, _d;\n                        const canvas = document.createElement(\"canvas\");\n                        const settings = track.getSettings();\n                        const width = (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;\n                        const height = (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !== null && _d !== void 0 ? _d : 720;\n                        canvas.width = width;\n                        canvas.height = height;\n                        const ctx = canvas.getContext(\"2d\");\n                        // Draw video frame to canvas\n                        ctx.drawImage(video, 0, 0);\n                        // Get image data and check if all pixels are black\n                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        const data = imageData.data;\n                        let isAllBlack = true;\n                        for(let i = 0; i < data.length; i += 4){\n                            if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {\n                                isAllBlack = false;\n                                break;\n                            }\n                        }\n                        if (isAllBlack) {\n                            this.appendError(\"camera appears to be producing only black frames\");\n                        } else {\n                            this.appendMessage(\"received video frames\");\n                        }\n                        resolve();\n                    }, 1000);\n                };\n                video.play();\n            });\n            stream.getTracks().forEach((t)=>t.stop());\n            video.remove();\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return \"Resuming connection after interruption\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            const handleReconnecting = ()=>{\n                reconnectingTriggered = true;\n            };\n            room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose(\"\");\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error(\"Did not attempt to reconnect\");\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning(\"reconnection is only possible in Redis-based configurations\");\n                throw new Error(\"Not able to reconnect\");\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return \"Can connect via TURN\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000,\n                singlePeerConnection: false\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith(\"turn:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith(\"turns:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith(\"stun:\")) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning(\"No STUN servers configured on server side.\");\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\");\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: \"relay\"\n                    }\n                });\n            } else {\n                this.appendWarning(\"No TURN servers configured.\");\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return \"Establishing WebRTC connection\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                var _a;\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += \" (private)\";\n                            } else {\n                                if (candidate.protocol === \"tcp\" && candidate.tcpType === \"passive\") {\n                                    hasTcp = true;\n                                    str += \" (passive)\";\n                                } else if (candidate.protocol === \"udp\") {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if ((_a = this.room.engine.pcManager) === null || _a === void 0 ? void 0 : _a.subscriber) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info(\"now the room is connected\");\n            } catch (err) {\n                this.appendWarning(\"ports need to be open on firewall in order to connect.\");\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning(\"Server is not configured for ICE/TCP\");\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning(\"No public IPv4 UDP candidates were found. Your server is likely not configured correctly\");\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split(\".\");\n    if (parts.length === 4) {\n        if (parts[0] === \"10\") {\n            return true;\n        } else if (parts[0] === \"192\" && parts[1] === \"168\") {\n            return true;\n        } else if (parts[0] === \"172\") {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return \"Connecting to signal connection via WebSocket\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            if (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) {\n                this.appendWarning(\"Server is insecure, clients may block connections to it\");\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000,\n                singlePeerConnection: false\n            });\n            this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.options = {};\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n        this.options = options;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: \"\",\n            description: \"\"\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit(\"checkUpdate\", checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token, this.options);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on(\"update\", handleUpdate);\n            const result = yield test.run();\n            test.off(\"update\", handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n    checkConnectionProtocol() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const info = yield this.createAndRunCheck(ConnectionProtocolCheck);\n            if (info.data && \"protocol\" in info.data) {\n                const stats = info.data;\n                this.options.protocol = stats.protocol;\n            }\n            return info;\n        });\n    }\n    checkCloudRegion() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(CloudRegionCheck);\n        });\n    }\n}\n/** A Fixed TokenSource is a token source that takes no parameters and returns a completely\n * independently derived value on each fetch() call.\n *\n * The most common downstream implementer is {@link TokenSourceLiteral}.\n */ class TokenSourceFixed {\n}\n/** A Configurable TokenSource is a token source that takes a\n * {@link TokenSourceFetchOptions} object as input and returns a deterministic\n * {@link TokenSourceResponseObject} output based on the options specified.\n *\n * For example, if options.participantName is set, it should be expected that\n * all tokens that are generated will have participant name field set to the\n * provided value.\n *\n * A few common downstream implementers are {@link TokenSourceEndpoint}\n * and {@link TokenSourceCustom}.\n */ class TokenSourceConfigurable {\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    }) : e[r] = t, e;\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nnew TextEncoder();\nconst decoder = new TextDecoder();\nfunction decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\nfunction decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === \"string\" ? input : decoder.decode(input), {\n            alphabet: \"base64url\"\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\");\n    try {\n        return decodeBase64(encoded);\n    } catch (_unused) {\n        throw new TypeError(\"The input to be decoded is not correctly encoded.\");\n    }\n}\nclass JOSEError extends Error {\n    constructor(message, options){\n        var _Error$captureStackTr;\n        super(message, options);\n        _defineProperty(this, \"code\", \"ERR_JOSE_GENERIC\");\n        this.name = this.constructor.name;\n        (_Error$captureStackTr = Error.captureStackTrace) === null || _Error$captureStackTr === void 0 || _Error$captureStackTr.call(Error, this, this.constructor);\n    }\n}\n_defineProperty(JOSEError, \"code\", \"ERR_JOSE_GENERIC\");\nclass JWTClaimValidationFailed extends JOSEError {\n    constructor(message, payload){\n        let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"unspecified\";\n        let reason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"unspecified\";\n        super(message, {\n            cause: {\n                claim,\n                reason,\n                payload\n            }\n        });\n        _defineProperty(this, \"code\", \"ERR_JWT_CLAIM_VALIDATION_FAILED\");\n        _defineProperty(this, \"claim\", void 0);\n        _defineProperty(this, \"reason\", void 0);\n        _defineProperty(this, \"payload\", void 0);\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\n_defineProperty(JWTClaimValidationFailed, \"code\", \"ERR_JWT_CLAIM_VALIDATION_FAILED\");\nclass JWTExpired extends JOSEError {\n    constructor(message, payload){\n        let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"unspecified\";\n        let reason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"unspecified\";\n        super(message, {\n            cause: {\n                claim,\n                reason,\n                payload\n            }\n        });\n        _defineProperty(this, \"code\", \"ERR_JWT_EXPIRED\");\n        _defineProperty(this, \"claim\", void 0);\n        _defineProperty(this, \"reason\", void 0);\n        _defineProperty(this, \"payload\", void 0);\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\n_defineProperty(JWTExpired, \"code\", \"ERR_JWT_EXPIRED\");\nclass JOSEAlgNotAllowed extends JOSEError {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"code\", \"ERR_JOSE_ALG_NOT_ALLOWED\");\n    }\n}\n_defineProperty(JOSEAlgNotAllowed, \"code\", \"ERR_JOSE_ALG_NOT_ALLOWED\");\nclass JOSENotSupported extends JOSEError {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"code\", \"ERR_JOSE_NOT_SUPPORTED\");\n    }\n}\n_defineProperty(JOSENotSupported, \"code\", \"ERR_JOSE_NOT_SUPPORTED\");\nclass JWEDecryptionFailed extends JOSEError {\n    constructor(){\n        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"decryption operation failed\";\n        let options = arguments.length > 1 ? arguments[1] : undefined;\n        super(message, options);\n        _defineProperty(this, \"code\", \"ERR_JWE_DECRYPTION_FAILED\");\n    }\n}\n_defineProperty(JWEDecryptionFailed, \"code\", \"ERR_JWE_DECRYPTION_FAILED\");\nclass JWEInvalid extends JOSEError {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"code\", \"ERR_JWE_INVALID\");\n    }\n}\n_defineProperty(JWEInvalid, \"code\", \"ERR_JWE_INVALID\");\nclass JWSInvalid extends JOSEError {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"code\", \"ERR_JWS_INVALID\");\n    }\n}\n_defineProperty(JWSInvalid, \"code\", \"ERR_JWS_INVALID\");\nclass JWTInvalid extends JOSEError {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"code\", \"ERR_JWT_INVALID\");\n    }\n}\n_defineProperty(JWTInvalid, \"code\", \"ERR_JWT_INVALID\");\nclass JWKInvalid extends JOSEError {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"code\", \"ERR_JWK_INVALID\");\n    }\n}\n_defineProperty(JWKInvalid, \"code\", \"ERR_JWK_INVALID\");\nclass JWKSInvalid extends JOSEError {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"code\", \"ERR_JWKS_INVALID\");\n    }\n}\n_defineProperty(JWKSInvalid, \"code\", \"ERR_JWKS_INVALID\");\nclass JWKSNoMatchingKey extends JOSEError {\n    constructor(){\n        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"no applicable key found in the JSON Web Key Set\";\n        let options = arguments.length > 1 ? arguments[1] : undefined;\n        super(message, options);\n        _defineProperty(this, \"code\", \"ERR_JWKS_NO_MATCHING_KEY\");\n    }\n}\n_defineProperty(JWKSNoMatchingKey, \"code\", \"ERR_JWKS_NO_MATCHING_KEY\");\nclass JWKSMultipleMatchingKeys extends JOSEError {\n    constructor(){\n        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"multiple matching keys found in the JSON Web Key Set\";\n        let options = arguments.length > 1 ? arguments[1] : undefined;\n        super(message, options);\n        _defineProperty(this, Symbol.asyncIterator, void 0);\n        _defineProperty(this, \"code\", \"ERR_JWKS_MULTIPLE_MATCHING_KEYS\");\n    }\n}\n_defineProperty(JWKSMultipleMatchingKeys, \"code\", \"ERR_JWKS_MULTIPLE_MATCHING_KEYS\");\nclass JWKSTimeout extends JOSEError {\n    constructor(){\n        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"request timed out\";\n        let options = arguments.length > 1 ? arguments[1] : undefined;\n        super(message, options);\n        _defineProperty(this, \"code\", \"ERR_JWKS_TIMEOUT\");\n    }\n}\n_defineProperty(JWKSTimeout, \"code\", \"ERR_JWKS_TIMEOUT\");\nclass JWSSignatureVerificationFailed extends JOSEError {\n    constructor(){\n        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"signature verification failed\";\n        let options = arguments.length > 1 ? arguments[1] : undefined;\n        super(message, options);\n        _defineProperty(this, \"code\", \"ERR_JWS_SIGNATURE_VERIFICATION_FAILED\");\n    }\n}\n_defineProperty(JWSSignatureVerificationFailed, \"code\", \"ERR_JWS_SIGNATURE_VERIFICATION_FAILED\");\nfunction isObjectLike(value) {\n    return typeof value === \"object\" && value !== null;\n}\nvar isObject = (input)=>{\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== \"[object Object]\") {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n};\nfunction decodeJwt(jwt) {\n    if (typeof jwt !== \"string\") throw new JWTInvalid(\"JWTs must use Compact JWS serialization, JWT must be a string\");\n    const { 1: payload, length } = jwt.split(\".\");\n    if (length === 5) throw new JWTInvalid(\"Only JWTs using Compact JWS serialization can be decoded\");\n    if (length !== 3) throw new JWTInvalid(\"Invalid JWT\");\n    if (!payload) throw new JWTInvalid(\"JWTs must contain a payload\");\n    let decoded;\n    try {\n        decoded = decode(payload);\n    } catch (_unused) {\n        throw new JWTInvalid(\"Failed to base64url decode the payload\");\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    } catch (_unused2) {\n        throw new JWTInvalid(\"Failed to parse the decoded payload as JSON\");\n    }\n    if (!isObject(result)) throw new JWTInvalid(\"Invalid JWT Claims Set\");\n    return result;\n}\nconst ONE_SECOND_IN_MILLISECONDS = 1000;\nconst ONE_MINUTE_IN_MILLISECONDS = 60 * ONE_SECOND_IN_MILLISECONDS;\nfunction isResponseTokenValid(response) {\n    const jwtPayload = decodeTokenPayload(response.participantToken);\n    if (!(jwtPayload === null || jwtPayload === void 0 ? void 0 : jwtPayload.nbf) || !(jwtPayload === null || jwtPayload === void 0 ? void 0 : jwtPayload.exp)) {\n        return true;\n    }\n    const now = new Date();\n    const nbfInMilliseconds = jwtPayload.nbf * ONE_SECOND_IN_MILLISECONDS;\n    const nbfDate = new Date(nbfInMilliseconds);\n    const expInMilliseconds = jwtPayload.exp * ONE_SECOND_IN_MILLISECONDS;\n    const expDate = new Date(expInMilliseconds - ONE_MINUTE_IN_MILLISECONDS);\n    return nbfDate <= now && expDate > now;\n}\n/** Given a LiveKit generated participant token, decodes and returns the associated {@link TokenPayload} data. */ function decodeTokenPayload(token) {\n    const payload = decodeJwt(token);\n    const { roomConfig } = payload, rest = __rest(payload, [\n        \"roomConfig\"\n    ]);\n    const mappedPayload = Object.assign(Object.assign({}, rest), {\n        roomConfig: payload.roomConfig ? RoomConfiguration.fromJson(payload.roomConfig) : undefined\n    });\n    return mappedPayload;\n}\n/** Given two TokenSourceFetchOptions values, check to see if they are deep equal. */ function areTokenSourceFetchOptionsEqual(a, b) {\n    const allKeysSet = new Set([\n        ...Object.keys(a),\n        ...Object.keys(b)\n    ]);\n    for (const key of allKeysSet){\n        switch(key){\n            case \"roomName\":\n            case \"participantName\":\n            case \"participantIdentity\":\n            case \"participantMetadata\":\n            case \"participantAttributes\":\n            case \"agentName\":\n            case \"agentMetadata\":\n                if (a[key] !== b[key]) {\n                    return false;\n                }\n                break;\n            default:\n                // ref: https://stackoverflow.com/a/58009992\n                const exhaustiveCheckedKey = key;\n                throw new Error(\"Options key \".concat(exhaustiveCheckedKey, \" not being checked for equality!\"));\n        }\n    }\n    return true;\n}\n/** A TokenSourceCached is a TokenSource which caches the last {@link TokenSourceResponseObject} value and returns it\n * until a) it expires or b) the {@link TokenSourceFetchOptions} provided to .fetch(...) change. */ class TokenSourceCached extends TokenSourceConfigurable {\n    constructor(){\n        super(...arguments);\n        this.cachedFetchOptions = null;\n        this.cachedResponse = null;\n        this.fetchMutex = new _();\n    }\n    isSameAsCachedFetchOptions(options) {\n        if (!this.cachedFetchOptions) {\n            return false;\n        }\n        for (const key of Object.keys(this.cachedFetchOptions)){\n            switch(key){\n                case \"roomName\":\n                case \"participantName\":\n                case \"participantIdentity\":\n                case \"participantMetadata\":\n                case \"participantAttributes\":\n                case \"agentName\":\n                case \"agentMetadata\":\n                    if (this.cachedFetchOptions[key] !== options[key]) {\n                        return false;\n                    }\n                    break;\n                default:\n                    // ref: https://stackoverflow.com/a/58009992\n                    const exhaustiveCheckedKey = key;\n                    throw new Error(\"Options key \".concat(exhaustiveCheckedKey, \" not being checked for equality!\"));\n            }\n        }\n        return true;\n    }\n    shouldReturnCachedValueFromFetch(fetchOptions) {\n        if (!this.cachedResponse) {\n            return false;\n        }\n        if (!isResponseTokenValid(this.cachedResponse)) {\n            return false;\n        }\n        if (this.isSameAsCachedFetchOptions(fetchOptions)) {\n            return false;\n        }\n        return true;\n    }\n    getCachedResponseJwtPayload() {\n        if (!this.cachedResponse) {\n            return null;\n        }\n        return decodeTokenPayload(this.cachedResponse.participantToken);\n    }\n    fetch(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.fetchMutex.lock();\n            try {\n                if (this.shouldReturnCachedValueFromFetch(options)) {\n                    return this.cachedResponse.toJson();\n                }\n                this.cachedFetchOptions = options;\n                const tokenResponse = yield this.update(options);\n                this.cachedResponse = tokenResponse;\n                return tokenResponse.toJson();\n            } finally{\n                unlock();\n            }\n        });\n    }\n}\nclass TokenSourceLiteral extends TokenSourceFixed {\n    constructor(literalOrFn){\n        super();\n        this.literalOrFn = literalOrFn;\n    }\n    fetch() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (typeof this.literalOrFn === \"function\") {\n                return this.literalOrFn();\n            } else {\n                return this.literalOrFn;\n            }\n        });\n    }\n}\nclass TokenSourceCustom extends TokenSourceCached {\n    constructor(customFn){\n        super();\n        this.customFn = customFn;\n    }\n    update(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const resultMaybePromise = this.customFn(options);\n            let result;\n            if (resultMaybePromise instanceof Promise) {\n                result = yield resultMaybePromise;\n            } else {\n                result = resultMaybePromise;\n            }\n            return TokenSourceResponse.fromJson(result, {\n                // NOTE: it could be possible that the response body could contain more fields than just\n                // what's in TokenSourceResponse depending on the implementation\n                ignoreUnknownFields: true\n            });\n        });\n    }\n}\nclass TokenSourceEndpoint extends TokenSourceCached {\n    constructor(url){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        this.url = url;\n        this.endpointOptions = options;\n    }\n    createRequestFromOptions(options) {\n        var _a, _b, _c;\n        const request = new TokenSourceRequest();\n        for (const key of Object.keys(options)){\n            switch(key){\n                case \"roomName\":\n                case \"participantName\":\n                case \"participantIdentity\":\n                case \"participantMetadata\":\n                    request[key] = options[key];\n                    break;\n                case \"participantAttributes\":\n                    request.participantAttributes = (_a = options.participantAttributes) !== null && _a !== void 0 ? _a : {};\n                    break;\n                case \"agentName\":\n                    request.roomConfig = (_b = request.roomConfig) !== null && _b !== void 0 ? _b : new RoomConfiguration();\n                    if (request.roomConfig.agents.length === 0) {\n                        request.roomConfig.agents.push(new RoomAgentDispatch());\n                    }\n                    request.roomConfig.agents[0].agentName = options.agentName;\n                    break;\n                case \"agentMetadata\":\n                    request.roomConfig = (_c = request.roomConfig) !== null && _c !== void 0 ? _c : new RoomConfiguration();\n                    if (request.roomConfig.agents.length === 0) {\n                        request.roomConfig.agents.push(new RoomAgentDispatch());\n                    }\n                    request.roomConfig.agents[0].metadata = options.agentMetadata;\n                    break;\n                default:\n                    // ref: https://stackoverflow.com/a/58009992\n                    const exhaustiveCheckedKey = key;\n                    throw new Error(\"Options key \".concat(exhaustiveCheckedKey, \" not being included in forming request!\"));\n            }\n        }\n        return request;\n    }\n    update(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const request = this.createRequestFromOptions(options);\n            const response = yield fetch(this.url, Object.assign(Object.assign({}, this.endpointOptions), {\n                method: (_a = this.endpointOptions.method) !== null && _a !== void 0 ? _a : \"POST\",\n                headers: Object.assign({\n                    \"Content-Type\": \"application/json\"\n                }, this.endpointOptions.headers),\n                body: request.toJsonString({\n                    useProtoFieldName: true\n                })\n            }));\n            if (!response.ok) {\n                throw new Error(\"Error generating token from endpoint \".concat(this.url, \": received \").concat(response.status, \" / \").concat((yield response.text())));\n            }\n            const body = yield response.json();\n            return TokenSourceResponse.fromJson(body, {\n                // NOTE: it could be possible that the response body could contain more fields than just\n                // what's in TokenSourceResponse depending on the implementation (ie, SandboxTokenServer)\n                ignoreUnknownFields: true\n            });\n        });\n    }\n}\nclass TokenSourceSandboxTokenServer extends TokenSourceEndpoint {\n    constructor(sandboxId, options){\n        const { baseUrl = \"https://cloud-api.livekit.io\" } = options, rest = __rest(options, [\n            \"baseUrl\"\n        ]);\n        super(\"\".concat(baseUrl, \"/api/v2/sandbox/connection-details\"), Object.assign(Object.assign({}, rest), {\n            headers: {\n                \"X-Sandbox-ID\": sandboxId\n            }\n        }));\n    }\n}\nconst TokenSource = {\n    /** TokenSource.literal contains a single, literal set of {@link TokenSourceResponseObject}\n   * credentials, either provided directly or returned from a provided function. */ literal (literalOrFn) {\n        return new TokenSourceLiteral(literalOrFn);\n    },\n    /**\n   * TokenSource.custom allows a user to define a manual function which generates new\n   * {@link TokenSourceResponseObject} values on demand.\n   *\n   * Use this to get credentials from custom backends / etc.\n   */ custom (customFn) {\n        return new TokenSourceCustom(customFn);\n    },\n    /**\n   * TokenSource.endpoint creates a token source that fetches credentials from a given URL using\n   * the standard endpoint format:\n   * FIXME: add docs link here in the future!\n   */ endpoint (url) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new TokenSourceEndpoint(url, options);\n    },\n    /**\n   * TokenSource.sandboxTokenServer queries a sandbox token server for credentials,\n   * which supports quick prototyping / getting started types of use cases.\n   *\n   * This token provider is INSECURE and should NOT be used in production.\n   *\n   * For more info:\n   * @see https://cloud.livekit.io/projects/p_/sandbox/templates/token-server\n   */ sandboxTokenServer (sandboxId) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new TokenSourceSandboxTokenServer(sandboxId, options);\n    }\n};\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : \"user\",\n        confidence: \"low\"\n    };\n    // 1. Try to get facingMode from track settings.\n    if (\"facingMode\" in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.trace(\"rawFacingMode\", {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === \"string\" && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: \"high\"\n            };\n        }\n    }\n    // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n    if ([\n        \"low\",\n        \"medium\"\n    ].includes(result.confidence)) {\n        livekitLogger.trace(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        \"obs virtual camera\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        \"iphone\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ],\n    [\n        \"ipad\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can't infer anything from it.\n    if (label === \"\") {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        \"user\",\n        \"environment\",\n        \"left\",\n        \"right\"\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n //# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTYuMF9AdHlwZXMrZG9tLW1lZGlhY2FwdHVyZS1yZWNvcmRAMS4wLjIyL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2xpdmVraXQtY2xpZW50LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLGlCQUFpQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCQSxFQUFFQyxPQUFPLENBQUMsU0FBVUMsQ0FBQztRQUNuQkEsS0FBSyxPQUFPQSxNQUFNLFlBQVksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixNQUFNRyxPQUFPQyxJQUFJLENBQUNKLEdBQUdELE9BQU8sQ0FBQyxTQUFVTSxDQUFDO1lBQ25GLElBQUlBLE1BQU0sYUFBYSxDQUFFQSxDQUFBQSxLQUFLUixDQUFBQSxHQUFJO2dCQUNoQyxJQUFJUyxJQUFJSCxPQUFPSSx3QkFBd0IsQ0FBQ1AsR0FBR0s7Z0JBQzNDRixPQUFPSyxjQUFjLENBQUNYLEdBQUdRLEdBQUdDLEVBQUVHLEdBQUcsR0FBR0gsSUFBSTtvQkFDdENJLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDSyxFQUFFO29CQUFFO2dCQUNsQztZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9GLE9BQU9RLE1BQU0sQ0FBQ2Q7QUFDdkI7QUFFQSxJQUFJRyxJQUFJRyxPQUFPSyxjQUFjO0FBQzdCLElBQUlJLElBQUksQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBTUQsS0FBS0QsSUFBSWIsRUFBRWEsR0FBR0MsR0FBRztRQUNwQ0osWUFBWTtRQUNaTSxjQUFjO1FBQ2RDLFVBQVU7UUFDVkMsT0FBT0g7SUFDVCxLQUFLRixD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RixZQUFZO1lBQ1pzNUYsWUFBWTtRQUNkO0tBQUU7Q0FBQztBQUNIOzs7O0NBSUMsR0FDRCxTQUFTSSwwQkFBMEJHLFdBQVc7SUFDNUMsSUFBSTd1SDtJQUNKLE1BQU11MUIsUUFBUXM1RixZQUFZdjhHLElBQUksR0FBRzBDLFdBQVc7SUFDNUMsNEVBQTRFO0lBQzVFLElBQUl1Z0IsVUFBVSxJQUFJO1FBQ2hCLE9BQU85cUI7SUFDVDtJQUNBLG1EQUFtRDtJQUNuRCxJQUFJa2tILGtCQUFrQmgzRyxHQUFHLENBQUM0ZCxRQUFRO1FBQ2hDLE9BQU9vNUYsa0JBQWtCNzBILEdBQUcsQ0FBQ3k3QjtJQUMvQjtJQUNBLHFEQUFxRDtJQUNyRCxPQUFPLENBQUN2MUIsS0FBSzFHLE1BQU1nOEMsSUFBSSxDQUFDczVFLHlCQUF5QjMrRyxPQUFPLElBQUkvQixJQUFJLENBQUNncUMsQ0FBQUE7UUFDL0QsSUFBSSxDQUFDNDJFLFFBQVEsR0FBRzUyRTtRQUNoQixPQUFPM2lCLE1BQU1DLFFBQVEsQ0FBQ3M1RjtJQUN4QixFQUFDLE1BQU8sUUFBUTl1SCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFO0FBQ2hEO0FBQ0EsU0FBU3d1SCxrQkFBa0IvNUcsSUFBSTtJQUM3QixNQUFNczZHLGdCQUFnQjtRQUFDO1FBQVE7UUFBZTtRQUFRO0tBQVE7SUFDOUQsT0FBT3Q2RyxTQUFTaEssYUFBYXNrSCxjQUFjdjVGLFFBQVEsQ0FBQy9nQjtBQUN0RDtBQUVxbkUsQ0FDcm5FLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbGEtd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjE2LjBfQHR5cGVzK2RvbS1tZWRpYWNhcHR1cmUtcmVjb3JkQDEuMC4yMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzPzE5ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG4gIG0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIGUgJiYgdHlwZW9mIGUgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIShrIGluIG4pKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBoID0gKGksIHMsIHQpID0+IHMgaW4gaSA/IGUoaSwgcywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogdFxufSkgOiBpW3NdID0gdDtcbnZhciBvID0gKGksIHMsIHQpID0+IGgoaSwgdHlwZW9mIHMgIT0gXCJzeW1ib2xcIiA/IHMgKyBcIlwiIDogcywgdCk7XG5jbGFzcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbyh0aGlzLCBcIl9sb2NraW5nXCIpO1xuICAgIG8odGhpcywgXCJfbG9ja3NcIik7XG4gICAgdGhpcy5fbG9ja2luZyA9IFByb21pc2UucmVzb2x2ZSgpLCB0aGlzLl9sb2NrcyA9IDA7XG4gIH1cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tzID4gMDtcbiAgfVxuICBsb2NrKCkge1xuICAgIHRoaXMuX2xvY2tzICs9IDE7XG4gICAgbGV0IHM7XG4gICAgY29uc3QgdCA9IG5ldyBQcm9taXNlKGwgPT4gcyA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9ja3MgLT0gMSwgbCgpO1xuICAgICAgfSksXG4gICAgICBjID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHMpO1xuICAgIHJldHVybiB0aGlzLl9sb2NraW5nID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHQpLCBjO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnV0aHkgb3IgdGhyb3cgZXJyb3IgKHdpdGggbWVzc2FnZSlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LFxuICBGTE9BVDMyX01JTiA9IC0zNDAyODIzNDY2Mzg1Mjg4NmUyMixcbiAgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmYsXG4gIElOVDMyX01BWCA9IDB4N2ZmZmZmZmYsXG4gIElOVDMyX01JTiA9IC0yMTQ3NDgzNjQ4O1xuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBzaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEludDMyKGFyZykge1xuICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVJbnQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBwcm90b2J1ZiBmbG9hdCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFyZykpIHJldHVybjtcbiAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNvbnN0IGVudW1UeXBlU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2VudW0tdHlwZVwiKTtcbi8qKlxuICogR2V0IHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBhIGdlbmVyYXRlZCBlbnVtLlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gc29tZXRoaW5nIG90aGVyIHRoYW4gYSBnZW5lcmF0ZWRcbiAqIGVudW0sIGl0IHJhaXNlcyBhbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bVR5cGUoZW51bU9iamVjdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IHQgPSBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXTtcbiAgYXNzZXJ0KHQsIFwibWlzc2luZyBlbnVtIHR5cGUgb24gZW51bSBvYmplY3RcIik7XG4gIHJldHVybiB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG59XG4vKipcbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBvbiBhIGdlbmVyYXRlZCBlbnVtLlxuICovXG5mdW5jdGlvbiBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXSA9IG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLm1hcCh2ID0+ICh7XG4gICAgbm86IHYubm8sXG4gICAgbmFtZTogdi5uYW1lLFxuICAgIGxvY2FsTmFtZTogZW51bU9iamVjdFt2Lm5vXVxuICB9KSkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRW51bVR5cGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcyxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9vcHQpIHtcbiAgY29uc3QgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBudW1iZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgbm9ybWFsVmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBjb25zdCB2YWx1ZTogRW51bVZhbHVlSW5mbyA9IHsuLi52LCBvcHRpb25zOiB2Lm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdH07XG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgbm9ybWFsVmFsdWVzLnB1c2gobik7XG4gICAgbmFtZXNbdmFsdWUubmFtZV0gPSBuO1xuICAgIG51bWJlcnNbdmFsdWUubm9dID0gbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGVOYW1lLFxuICAgIHZhbHVlczogbm9ybWFsVmFsdWVzLFxuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgLy8gb3B0aW9uczogb3B0Py5vcHRpb25zID8/IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgZmluZE5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWVzW25hbWVdO1xuICAgIH0sXG4gICAgZmluZE51bWJlcihubykge1xuICAgICAgcmV0dXJuIG51bWJlcnNbbm9dO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVudW0gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFrZUVudW0odHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gIGNvbnN0IGVudW1PYmplY3QgPSB7fTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICBlbnVtT2JqZWN0W24ubG9jYWxOYW1lXSA9IG4ubm87XG4gICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xuICB9XG4gIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMpO1xuICByZXR1cm4gZW51bU9iamVjdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSkge1xuICBpZiAoXCJsb2NhbE5hbWVcIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHtcbiAgICBsb2NhbE5hbWU6IHZhbHVlLm5hbWVcbiAgfSk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIE1lc3NhZ2UgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgZXZlcnkgbWVzc2FnZSwgZ2VuZXJhdGVkLCBvciBjcmVhdGVkIGF0XG4gKiBydW50aW1lLlxuICpcbiAqIEl0IGlzIF9ub3RfIHNhZmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG1lc3NhZ2UgYXRcbiAqIHJ1biB0aW1lLCB1c2UgcHJvdG8zLm1ha2VNZXNzYWdlVHlwZSgpLlxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgLyoqXG4gICAqIENvbXBhcmUgd2l0aCBhIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGlzcmVnYXJkcyBleHRlbnNpb25zIGFuZCB1bmtub3duIGZpZWxkcy5cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuZXF1YWxzKHRoaXMuZ2V0VHlwZSgpLCB0aGlzLCBvdGhlcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRlZXAgY29weS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuY2xvbmUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGZyb20gYmluYXJ5IGRhdGEsIG1lcmdpbmcgZmllbGRzLlxuICAgKlxuICAgKiBSZXBlYXRlZCBmaWVsZHMgYXJlIGFwcGVuZGVkLiBNYXAgZW50cmllcyBhcmUgYWRkZWQsIG92ZXJ3cml0aW5nXG4gICAqIGV4aXN0aW5nIGtleXMuXG4gICAqXG4gICAqIElmIGEgbWVzc2FnZSBmaWVsZCBpcyBhbHJlYWR5IHByZXNlbnQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAqIG5ldyBkYXRhLlxuICAgKi9cbiAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGZvcm1hdCA9IHR5cGUucnVudGltZS5iaW4sXG4gICAgICBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0aGlzLCBvcHQucmVhZGVyRmFjdG9yeShieXRlcyksIGJ5dGVzLmJ5dGVMZW5ndGgsIG9wdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiB2YWx1ZS5cbiAgICovXG4gIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGZvcm1hdCA9IHR5cGUucnVudGltZS5qc29uLFxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UodHlwZSwganNvblZhbHVlLCBvcHQsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIFwiLmNvbmNhdCh0aGlzLmdldFR5cGUoKS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcm9tSnNvbihqc29uLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBkYXRhLlxuICAgKi9cbiAgdG9CaW5hcnkob3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGJpbiA9IHR5cGUucnVudGltZS5iaW4sXG4gICAgICBvcHQgPSBiaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSxcbiAgICAgIHdyaXRlciA9IG9wdC53cml0ZXJGYWN0b3J5KCk7XG4gICAgYmluLndyaXRlTWVzc2FnZSh0aGlzLCB3cml0ZXIsIG9wdCk7XG4gICAgcmV0dXJuIHdyaXRlci5maW5pc2goKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiB2YWx1ZSwgYSBKYXZhU2NyaXB0IHZhbHVlIHRoYXQgY2FuIGJlXG4gICAqIHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSgpLlxuICAgKi9cbiAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBqc29uID0gdHlwZS5ydW50aW1lLmpzb24sXG4gICAgICBvcHQgPSBqc29uLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGpzb24ud3JpdGVNZXNzYWdlKHRoaXMsIG9wdCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgdG9Kc29uU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvSnNvbihvcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV0dHlTcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBmb3Igc2VyaWFsaXphdGlvbiBiZWhhdmlvci4gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbiBjYWxsaW5nXG4gICAqIEpTT04uc3RyaW5naWZ5IG9uIHRoaXMgbWVzc2FnZSAoaS5lLiBKU09OLnN0cmluZ2lmeShtc2cpKS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBub3Qgc2VyaWFsaXplIGdvb2dsZS5wcm90b2J1Zi5Bbnkgd2l0aCBhIHBhY2tlZFxuICAgKiBtZXNzYWdlIGJlY2F1c2UgdGhlIHByb3RvYnVmIEpTT04gZm9ybWF0IHNwZWNpZmllcyB0aGF0IGl0IG5lZWRzIHRvIGJlXG4gICAqIHVucGFja2VkLCBhbmQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggYSB0eXBlIHJlZ2lzdHJ5IHRvIGxvb2sgdXAgdGhlXG4gICAqIG1lc3NhZ2UgdHlwZS4gIEFzIGEgcmVzdWx0LCBhdHRlbXB0aW5nIHRvIHNlcmlhbGl6ZSBhIG1lc3NhZ2Ugd2l0aCB0aGlzXG4gICAqIHR5cGUgd2lsbCB0aHJvdyBhbiBFcnJvci5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcHJvdGVjdGVkIGJlY2F1c2UgeW91IHNob3VsZCBub3QgbmVlZCB0byBpbnZva2UgaXRcbiAgICogZGlyZWN0bHkgLS0gaW5zdGVhZCB1c2UgSlNPTi5zdHJpbmdpZnkgb3IgdG9Kc29uU3RyaW5nIGZvclxuICAgKiBzdHJpbmdpZmllZCBKU09OLiAgQWx0ZXJuYXRpdmVseSwgaWYgYWN0dWFsIEpTT04gaXMgZGVzaXJlZCwgeW91IHNob3VsZFxuICAgKiB1c2UgdG9Kc29uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSnNvbih7XG4gICAgICBlbWl0RGVmYXVsdFZhbHVlczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgTWVzc2FnZVR5cGUgb2YgdGhpcyBtZXNzYWdlIC0gYSBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzXG4gICAqIHRoZSBwcm90b2J1ZiBtZXNzYWdlIGRlY2xhcmF0aW9uIGFuZCBwcm92aWRlcyBtZXRhZGF0YSBmb3IgcmVmbGVjdGlvbi1cbiAgICogYmFzZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgLy8gQW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBNZXNzYWdlIF9tdXN0XyBwcm92aWRlIGEgY29tcGxldGUgc3RhdGljXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgTWVzc2FnZVR5cGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgdHlwZSB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gbWFrZU1lc3NhZ2VUeXBlKHJ1bnRpbWUsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IChfYSA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5sb2NhbE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHR5cGVOYW1lLnN1YnN0cmluZyh0eXBlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgY29uc3QgdHlwZSA9IHtcbiAgICBbbG9jYWxOYW1lXTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0RmllbGRzKHRoaXMpO1xuICAgICAgcnVudGltZS51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgfVtsb2NhbE5hbWVdO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHlwZS5wcm90b3R5cGUsIG5ldyBNZXNzYWdlKCkpO1xuICBPYmplY3QuYXNzaWduKHR5cGUsIHtcbiAgICBydW50aW1lLFxuICAgIHR5cGVOYW1lLFxuICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxuICAgIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUudXRpbC5lcXVhbHModHlwZSwgYSwgYik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbi8vIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIFByb3RvY29sIEJ1ZmZlciBjb21waWxlciBpcyBvd25lZCBieSB0aGUgb3duZXJcbi8vIG9mIHRoZSBpbnB1dCBmaWxlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGl0LiAgVGhpcyBjb2RlIGlzIG5vdFxuLy8gc3RhbmRhbG9uZSBhbmQgcmVxdWlyZXMgYSBzdXBwb3J0IGxpYnJhcnkgdG8gYmUgbGlua2VkIHdpdGggaXQuICBUaGlzXG4vLyBzdXBwb3J0IGxpYnJhcnkgaXMgaXRzZWxmIGNvdmVyZWQgYnkgdGhlIGFib3ZlIGxpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QsQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgKi9cbi8qKlxuICogUmVhZCBhIDY0IGJpdCB2YXJpbnQgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogbG93IGJpdHNcbiAqIFsxXTogaGlnaCBiaXRzXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMTc1XG4gKi9cbmZ1bmN0aW9uIHZhcmludDY0cmVhZCgpIHtcbiAgbGV0IGxvd0JpdHMgPSAwO1xuICBsZXQgaGlnaEJpdHMgPSAwO1xuICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgMjg7IHNoaWZ0ICs9IDcpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGxvd0JpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICB9XG4gIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIC8vIGxhc3QgZm91ciBiaXRzIG9mIHRoZSBmaXJzdCAzMiBiaXQgbnVtYmVyXG4gIGxvd0JpdHMgfD0gKG1pZGRsZUJ5dGUgJiAweDBmKSA8PCAyODtcbiAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcbiAgaGlnaEJpdHMgPSAobWlkZGxlQnl0ZSAmIDB4NzApID4+IDQ7XG4gIGlmICgobWlkZGxlQnl0ZSAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICB9XG4gIGZvciAobGV0IHNoaWZ0ID0gMzsgc2hpZnQgPD0gMzE7IHNoaWZ0ICs9IDcpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGhpZ2hCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbn1cbi8qKlxuICogV3JpdGUgYSA2NCBiaXQgdmFyaW50LCBnaXZlbiBhcyB0d28gSlMgbnVtYmVycywgdG8gdGhlIGdpdmVuIGJ5dGVzIGFycmF5LlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvd3JpdGVyLmpzI0wzNDRcbiAqL1xuZnVuY3Rpb24gdmFyaW50NjR3cml0ZShsbywgaGksIGJ5dGVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjg7IGkgPSBpICsgNykge1xuICAgIGNvbnN0IHNoaWZ0ID0gbG8gPj4+IGk7XG4gICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCAmJiBoaSA9PSAwKTtcbiAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHNwbGl0Qml0cyA9IGxvID4+PiAyOCAmIDB4MGYgfCAoaGkgJiAweDA3KSA8PCA0O1xuICBjb25zdCBoYXNNb3JlQml0cyA9ICEoaGkgPj4gMyA9PSAwKTtcbiAgYnl0ZXMucHVzaCgoaGFzTW9yZUJpdHMgPyBzcGxpdEJpdHMgfCAweDgwIDogc3BsaXRCaXRzKSAmIDB4ZmYpO1xuICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgMzE7IGkgPSBpICsgNykge1xuICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCk7XG4gICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcbiAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBieXRlcy5wdXNoKGhpID4+PiAzMSAmIDB4MDEpO1xufVxuLy8gY29uc3RhbnRzIGZvciBiaW5hcnkgbWF0aFxuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSAweDEwMDAwMDAwMDtcbi8qKlxuICogUGFyc2UgZGVjaW1hbCBzdHJpbmcgb2YgNjQgYml0IGludGVnZXIgdmFsdWUgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIGludDY0RnJvbVN0cmluZyhkZWMpIHtcbiAgLy8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24uXG4gIGNvbnN0IG1pbnVzID0gZGVjWzBdID09PSBcIi1cIjtcbiAgaWYgKG1pbnVzKSB7XG4gICAgZGVjID0gZGVjLnNsaWNlKDEpO1xuICB9XG4gIC8vIFdvcmsgNiBkZWNpbWFsIGRpZ2l0cyBhdCBhIHRpbWUsIGFjdGluZyBsaWtlIHdlJ3JlIGNvbnZlcnRpbmcgYmFzZSAxZTZcbiAgLy8gZGlnaXRzIHRvIGJpbmFyeS4gVGhpcyBpcyBzYWZlIHRvIGRvIHdpdGggZmxvYXRpbmcgcG9pbnQgbWF0aCBiZWNhdXNlXG4gIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxuICBjb25zdCBiYXNlID0gMWU2O1xuICBsZXQgbG93Qml0cyA9IDA7XG4gIGxldCBoaWdoQml0cyA9IDA7XG4gIGZ1bmN0aW9uIGFkZDFlNmRpZ2l0KGJlZ2luLCBlbmQpIHtcbiAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXG4gICAgY29uc3QgZGlnaXQxZTYgPSBOdW1iZXIoZGVjLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgICBoaWdoQml0cyAqPSBiYXNlO1xuICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xuICAgIC8vIENhcnJ5IGJpdHMgZnJvbSBsb3dCaXRzIHRvXG4gICAgaWYgKGxvd0JpdHMgPj0gVFdPX1BXUl8zMl9EQkwpIHtcbiAgICAgIGhpZ2hCaXRzID0gaGlnaEJpdHMgKyAobG93Qml0cyAvIFRXT19QV1JfMzJfREJMIHwgMCk7XG4gICAgICBsb3dCaXRzID0gbG93Qml0cyAlIFRXT19QV1JfMzJfREJMO1xuICAgIH1cbiAgfVxuICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XG4gIGFkZDFlNmRpZ2l0KC0xOCwgLTEyKTtcbiAgYWRkMWU2ZGlnaXQoLTEyLCAtNik7XG4gIGFkZDFlNmRpZ2l0KC02KTtcbiAgcmV0dXJuIG1pbnVzID8gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSA6IG5ld0JpdHMobG93Qml0cywgaGlnaEJpdHMpO1xufVxuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIGludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gIGxldCBiaXRzID0gbmV3Qml0cyhsbywgaGkpO1xuICAvLyBJZiB3ZSdyZSB0cmVhdGluZyB0aGUgaW5wdXQgYXMgYSBzaWduZWQgdmFsdWUgYW5kIHRoZSBoaWdoIGJpdCBpcyBzZXQsIGRvXG4gIC8vIGEgbWFudWFsIHR3bydzIGNvbXBsZW1lbnQgY29udmVyc2lvbiBiZWZvcmUgdGhlIGRlY2ltYWwgY29udmVyc2lvbi5cbiAgY29uc3QgbmVnYXRpdmUgPSBiaXRzLmhpICYgMHg4MDAwMDAwMDtcbiAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgYml0cyA9IG5lZ2F0ZShiaXRzLmxvLCBiaXRzLmhpKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB1SW50NjRUb1N0cmluZyhiaXRzLmxvLCBiaXRzLmhpKTtcbiAgcmV0dXJuIG5lZ2F0aXZlID8gXCItXCIgKyByZXN1bHQgOiByZXN1bHQ7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5mdW5jdGlvbiB1SW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgKHtcbiAgICBsbyxcbiAgICBoaVxuICB9ID0gdG9VbnNpZ25lZChsbywgaGkpKTtcbiAgLy8gU2tpcCB0aGUgZXhwZW5zaXZlIGNvbnZlcnNpb24gaWYgdGhlIG51bWJlciBpcyBzbWFsbCBlbm91Z2ggdG8gdXNlIHRoZVxuICAvLyBidWlsdC1pbiBjb252ZXJzaW9ucy5cbiAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSAweDAwMUZGRkZGIEZGRkZGRkZGLCB0aHVzIGFueSBudW1iZXIgd2l0aFxuICAvLyBoaWdoQml0cyA8PSAweDFGRkZGRiBjYW4gYmUgc2FmZWx5IGV4cHJlc3NlZCB3aXRoIGEgZG91YmxlIGFuZCByZXRhaW5cbiAgLy8gaW50ZWdlciBwcmVjaXNpb24uXG4gIC8vIFByb3ZlbiBieTogTnVtYmVyLmlzU2FmZUludGVnZXIoMHgxRkZGRkYgKiAyKiozMiArIDB4RkZGRkZGRkYpID09IHRydWUuXG4gIGlmIChoaSA8PSAweDFGRkZGRikge1xuICAgIHJldHVybiBTdHJpbmcoVFdPX1BXUl8zMl9EQkwgKiBoaSArIGxvKTtcbiAgfVxuICAvLyBXaGF0IHRoaXMgY29kZSBpcyBkb2luZyBpcyBlc3NlbnRpYWxseSBjb252ZXJ0aW5nIHRoZSBpbnB1dCBudW1iZXIgZnJvbVxuICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gIC8vIG9ubHkgMyAodmVyeSBsYXJnZSkgZGlnaXRzLiBUaG9zZSBkaWdpdHMgYXJlIHRoZW4gdHJpdmlhbCB0byBjb252ZXJ0IHRvXG4gIC8vIGEgYmFzZS0xMCBzdHJpbmcuXG4gIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAvLyAyXjI0ID0gMTY3NzcyMTYgPSAoMSw2Nzc3MjE2KSBpbiBiYXNlLTFlNy5cbiAgLy8gMl40OCA9IDI4MTQ3NDk3NjcxMDY1NiA9ICgyLDgxNDc0OTcsNjcxMDY1NikgaW4gYmFzZS0xZTcuXG4gIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gIC8vIGludGVybWVkaWF0ZSBkaWdpdHMgZG9uJ3Qgb3ZlcmZsb3cuXG4gIGNvbnN0IGxvdyA9IGxvICYgMHhGRkZGRkY7XG4gIGNvbnN0IG1pZCA9IChsbyA+Pj4gMjQgfCBoaSA8PCA4KSAmIDB4RkZGRkZGO1xuICBjb25zdCBoaWdoID0gaGkgPj4gMTYgJiAweEZGRkY7XG4gIC8vIEFzc2VtYmxlIG91ciB0aHJlZSBiYXNlLTFlNyBkaWdpdHMsIGlnbm9yaW5nIGNhcnJpZXMuIFRoZSBtYXhpbXVtXG4gIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgLy8gY2FuIGJlIHN0b3JlZCBpbiBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gIGxldCBkaWdpdEEgPSBsb3cgKyBtaWQgKiA2Nzc3MjE2ICsgaGlnaCAqIDY3MTA2NTY7XG4gIGxldCBkaWdpdEIgPSBtaWQgKyBoaWdoICogODE0NzQ5NztcbiAgbGV0IGRpZ2l0QyA9IGhpZ2ggKiAyO1xuICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgY29uc3QgYmFzZSA9IDEwMDAwMDAwO1xuICBpZiAoZGlnaXRBID49IGJhc2UpIHtcbiAgICBkaWdpdEIgKz0gTWF0aC5mbG9vcihkaWdpdEEgLyBiYXNlKTtcbiAgICBkaWdpdEEgJT0gYmFzZTtcbiAgfVxuICBpZiAoZGlnaXRCID49IGJhc2UpIHtcbiAgICBkaWdpdEMgKz0gTWF0aC5mbG9vcihkaWdpdEIgLyBiYXNlKTtcbiAgICBkaWdpdEIgJT0gYmFzZTtcbiAgfVxuICAvLyBJZiBkaWdpdEMgaXMgMCwgdGhlbiB3ZSBzaG91bGQgaGF2ZSByZXR1cm5lZCBpbiB0aGUgdHJpdmlhbCBjb2RlIHBhdGhcbiAgLy8gYXQgdGhlIHRvcCBmb3Igbm9uLXNhZmUgaW50ZWdlcnMuIEdpdmVuIHRoaXMsIHdlIGNhbiBhc3N1bWUgYm90aCBkaWdpdEJcbiAgLy8gYW5kIGRpZ2l0QSBuZWVkIGxlYWRpbmcgemVyb3MuXG4gIHJldHVybiBkaWdpdEMudG9TdHJpbmcoKSArIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEIpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QSk7XG59XG5mdW5jdGlvbiB0b1Vuc2lnbmVkKGxvLCBoaSkge1xuICByZXR1cm4ge1xuICAgIGxvOiBsbyA+Pj4gMCxcbiAgICBoaTogaGkgPj4+IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIG5ld0JpdHMobG8sIGhpKSB7XG4gIHJldHVybiB7XG4gICAgbG86IGxvIHwgMCxcbiAgICBoaTogaGkgfCAwXG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgdHdvJ3MgY29tcGxpbWVudCBuZWdhdGlvbiBvZiBpbnB1dC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzI1NpZ25lZF8zMi1iaXRfaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gIGhpZ2hCaXRzID0gfmhpZ2hCaXRzO1xuICBpZiAobG93Qml0cykge1xuICAgIGxvd0JpdHMgPSB+bG93Qml0cyArIDE7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbG93Qml0cyBpcyAwLCB0aGVuIGJpdHdpc2Utbm90IGlzIDB4RkZGRkZGRkYsXG4gICAgLy8gYWRkaW5nIDEgdG8gdGhhdCwgcmVzdWx0cyBpbiAweDEwMDAwMDAwMCwgd2hpY2ggbGVhdmVzXG4gICAgLy8gdGhlIGxvdyBiaXRzIDB4MCBhbmQgc2ltcGx5IGFkZHMgb25lIHRvIHRoZSBoaWdoIGJpdHMuXG4gICAgaGlnaEJpdHMgKz0gMTtcbiAgfVxuICByZXR1cm4gbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIFJldHVybnMgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBkaWdpdDFlNyB3aXRoIGxlYWRpbmcgemVyb3MuXG4gKi9cbmNvbnN0IGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyA9IGRpZ2l0MWU3ID0+IHtcbiAgY29uc3QgcGFydGlhbCA9IFN0cmluZyhkaWdpdDFlNyk7XG4gIHJldHVybiBcIjAwMDAwMDBcIi5zbGljZShwYXJ0aWFsLmxlbmd0aCkgKyBwYXJ0aWFsO1xufTtcbi8qKlxuICogV3JpdGUgYSAzMiBiaXQgdmFyaW50LCBzaWduZWQgb3IgdW5zaWduZWQuIFNhbWUgYXMgYHZhcmludDY0d3JpdGUoMCwgdmFsdWUsIGJ5dGVzKWBcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzFiMTg4MzNmNGYyYTJmNjgxZjRlNGEyNWNkZjNiMGE0MzExNWVjMjYvanMvYmluYXJ5L2VuY29kZXIuanMjTDE0NFxuICovXG5mdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMlxuICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAweDdmIHwgMHg4MCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgIH1cbiAgICBieXRlcy5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDEyNyB8IDEyOCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+IDc7XG4gICAgfVxuICAgIGJ5dGVzLnB1c2goMSk7XG4gIH1cbn1cbi8qKlxuICogUmVhZCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDIyMFxuICovXG5mdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XG4gIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIGxldCByZXN1bHQgPSBiICYgMHg3ZjtcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDc7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAxNDtcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDIxO1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4MGYpIDw8IDI4O1xuICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoYiAmIDB4ODApICE9PSAwICYmIHJlYWRCeXRlcyA8IDEwOyByZWFkQnl0ZXMrKykgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICBpZiAoKGIgJiAweDgwKSAhPSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbiAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcbiAgcmV0dXJuIHJlc3VsdCA+Pj4gMDtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmZ1bmN0aW9uIG1ha2VJbnQ2NFN1cHBvcnQoKSB7XG4gIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XG4gIC8vIG5vdGUgdGhhdCBTYWZhcmkgMTQgaW1wbGVtZW50cyBCaWdJbnQsIGJ1dCBub3QgdGhlIERhdGFWaWV3IG1ldGhvZHNcbiAgY29uc3Qgb2sgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LmdldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LmdldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5zZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5zZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiAodHlwZW9mIHByb2Nlc3MgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgIT0gXCJvYmplY3RcIiB8fCBwcm9jZXNzLmVudi5CVUZfQklHSU5UX0RJU0FCTEUgIT09IFwiMVwiKTtcbiAgaWYgKG9rKSB7XG4gICAgY29uc3QgTUlOID0gQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksXG4gICAgICBNQVggPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLFxuICAgICAgVU1JTiA9IEJpZ0ludChcIjBcIiksXG4gICAgICBVTUFYID0gQmlnSW50KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHplcm86IEJpZ0ludCgwKSxcbiAgICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGlmIChiaSA+IE1BWCB8fCBiaSA8IE1JTikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaTtcbiAgICAgIH0sXG4gICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGJpID4gVU1BWCB8fCBiaSA8IFVNSU4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1aW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpO1xuICAgICAgfSxcbiAgICAgIGVuYyh2YWx1ZSkge1xuICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHVFbmModmFsdWUpIHtcbiAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy51UGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVjKGxvLCBoaSkge1xuICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGR2LmdldEJpZ0ludDY0KDAsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIHVEZWMobG8sIGhpKSB7XG4gICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gZHYuZ2V0QmlnVWludDY0KDAsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY29uc3QgYXNzZXJ0SW50NjRTdHJpbmcgPSB2YWx1ZSA9PiBhc3NlcnQoL14tP1swLTldKyQvLnRlc3QodmFsdWUpLCBcImludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICBjb25zdCBhc3NlcnRVSW50NjRTdHJpbmcgPSB2YWx1ZSA9PiBhc3NlcnQoL15bMC05XSskLy50ZXN0KHZhbHVlKSwgXCJ1aW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gIHJldHVybiB7XG4gICAgemVybzogXCIwXCIsXG4gICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBlbmModmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICB9LFxuICAgIHVFbmModmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGludDY0RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICBkZWMobG8sIGhpKSB7XG4gICAgICByZXR1cm4gaW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgIH0sXG4gICAgdURlYyhsbywgaGkpIHtcbiAgICAgIHJldHVybiB1SW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHByb3RvSW50NjQgPSBtYWtlSW50NjRTdXBwb3J0KCk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xudmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxuICAvLyBPcmRlciBpcyB3ZWlyZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gIC8vIE5vdCBaaWdaYWcgZW5jb2RlZC4gIE5lZ2F0aXZlIG51bWJlcnMgdGFrZSAxMCBieXRlcy4gIFVzZSBUWVBFX1NJTlQ2NCBpZlxuICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiVUlOVDY0XCJdID0gNF0gPSBcIlVJTlQ2NFwiO1xuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDMyXCJdID0gNV0gPSBcIklOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQk9PTFwiXSA9IDhdID0gXCJCT09MXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gIC8vIEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCBhbmQgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuIEhvd2V2ZXIsIFByb3RvM1xuICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXG4gIC8vIFRZUEVfR1JPVVAgPSAxMCxcbiAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgLy8gTmV3IGluIHZlcnNpb24gMi5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQllURVNcIl0gPSAxMl0gPSBcIkJZVEVTXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gIC8vIFRZUEVfRU5VTSA9IDE0LFxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTRklYRUQzMlwiXSA9IDE1XSA9IFwiU0ZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQ2NFwiXSA9IDE4XSA9IFwiU0lOVDY0XCI7XG59KShTY2FsYXJUeXBlIHx8IChTY2FsYXJUeXBlID0ge30pKTtcbi8qKlxuICogSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBmaWVsZHMgd2l0aCA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4gKiBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KS5cbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuSlNUeXBlLCB3aGljaCBkZWZpbmVzIEpTX05PUk1BTCxcbiAqIEpTX1NUUklORywgYW5kIEpTX05VTUJFUi4gUHJvdG9idWYtRVMgdXNlcyBCaWdJbnQgYnkgZGVmYXVsdCwgYnV0IHdpbGwgdXNlXG4gKiBTdHJpbmcgaWYgYFtqc3R5cGUgPSBKU19TVFJJTkddYCBpcyBzcGVjaWZpZWQuXG4gKlxuICogYGBgcHJvdG9idWZcbiAqIHVpbnQ2NCBmaWVsZF9hID0gMTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX05PUk1BTF07IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OVU1CRVJdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfU1RSSU5HXTsgLy8gU3RyaW5nXG4gKiBgYGBcbiAqL1xudmFyIExvbmdUeXBlO1xuKGZ1bmN0aW9uIChMb25nVHlwZSkge1xuICAvKipcbiAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gIC8qKlxuICAgKiBVc2UgSmF2YVNjcmlwdCBTdHJpbmcuXG4gICAqXG4gICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJTVFJJTkdcIl0gPSAxXSA9IFwiU1RSSU5HXCI7XG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYm90aCBzY2FsYXIgdmFsdWVzIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2NhbGFyRXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICAvLyBUaGlzIGNvcnJlY3RseSBtYXRjaGVzIGVxdWFsIHZhbHVlcyBleGNlcHQgQllURVMgYW5kIChwb3NzaWJseSkgNjQtYml0IGludGVnZXJzLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFNwZWNpYWwgY2FzZSBCWVRFUyAtIHdlIG5lZWQgdG8gY29tcGFyZSBlYWNoIGJ5dGUgaW5kaXZpZHVhbGx5XG4gIGlmICh0eXBlID09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgVWludDhBcnJheSkgfHwgIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gU3BlY2lhbCBjYXNlIDY0LWJpdCBpbnRlZ2VycyAtIHdlIHN1cHBvcnQgbnVtYmVyLCBzdHJpbmcgYW5kIGJpZ2ludCByZXByZXNlbnRhdGlvbi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAvLyBMb29zZSBjb21wYXJpc29uIHdpbGwgbWF0Y2ggYmV0d2VlbiAwbiwgMCBhbmQgXCIwXCIuXG4gICAgICByZXR1cm4gYSA9PSBiO1xuICB9XG4gIC8vIEFueXRoaW5nIHRoYXQgaGFzbid0IGJlZW4gY2F1Z2h0IGJ5IHN0cmljdCBjb21wYXJpc29uIG9yIHNwZWNpYWwgY2FzZWRcbiAgLy8gQllURVMgYW5kIDY0LWJpdCBpbnRlZ2VycyBpcyBub3QgZXF1YWwuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgemVybyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHNjYWxhciB0eXBlLlxuICovXG5mdW5jdGlvbiBzY2FsYXJaZXJvVmFsdWUodHlwZSwgbG9uZ1R5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgIHJldHVybiBsb25nVHlwZSA9PSAwID8gcHJvdG9JbnQ2NC56ZXJvIDogXCIwXCI7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICByZXR1cm4gMC4wO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEhhbmRsZXMgSU5UMzIsIFVJTlQzMiwgU0lOVDMyLCBGSVhFRDMyLCBTRklYRUQzMi5cbiAgICAgIC8vIFdlIGRvIG5vdCB1c2UgaW5kaXZpZHVhbCBjYXNlcyB0byBzYXZlIGEgZmV3IGJ5dGVzIGNvZGUgc2l6ZS5cbiAgICAgIHJldHVybiAwO1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBmb3IgYSB6ZXJvLXZhbHVlLiBGb3IgZXhhbXBsZSwgYW4gaW50ZWdlciBoYXMgdGhlIHplcm8tdmFsdWUgYDBgLFxuICogYSBib29sZWFuIGlzIGBmYWxzZWAsIGEgc3RyaW5nIGlzIGBcIlwiYCwgYW5kIGJ5dGVzIGlzIGFuIGVtcHR5IFVpbnQ4QXJyYXkuXG4gKlxuICogSW4gcHJvdG8zLCB6ZXJvLXZhbHVlcyBhcmUgbm90IHdyaXR0ZW4gdG8gdGhlIHdpcmUsIHVubGVzcyB0aGUgZmllbGQgaXNcbiAqIG9wdGlvbmFsIG9yIHJlcGVhdGVkLlxuICovXG5mdW5jdGlvbiBpc1NjYWxhclplcm9WYWx1ZSh0eXBlLCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJcIjtcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWUgPT0gMDtcbiAgICAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXG4gKlxuICogQSB3aXJlIHR5cGUgcHJvdmlkZXMganVzdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmluZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogZm9sbG93aW5nIHZhbHVlLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2Rpbmcjc3RydWN0dXJlXG4gKi9cbnZhciBXaXJlVHlwZTtcbihmdW5jdGlvbiAoV2lyZVR5cGUpIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGZpeGVkNjQsIHNmaXhlZDY0LCBkb3VibGUuXG4gICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQ2NFwiXSA9IDFdID0gXCJCaXQ2NFwiO1xuICAvKipcbiAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcbiAgICpcbiAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxuICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcbiAgICogcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGEgdGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUsIHN1Y2ggYXMgYSBwcm90bzIgZ3JvdXAsIG9yIGEgbWVzc2FnZVxuICAgKiBpbiBlZGl0aW9ucyB3aXRoIG1lc3NhZ2VfZW5jb2RpbmcgPSBERUxJTUlURUQuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAvKipcbiAgICogRW5kIG9mIGEgdGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkVuZEdyb3VwXCJdID0gNF0gPSBcIkVuZEdyb3VwXCI7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBmaXhlZDMyLCBzZml4ZWQzMiwgZmxvYXQuXG4gICAqIEFsd2F5cyA0IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQzMlwiXSA9IDVdID0gXCJCaXQzMlwiO1xufSkoV2lyZVR5cGUgfHwgKFdpcmVUeXBlID0ge30pKTtcbmNsYXNzIEJpbmFyeVdyaXRlciB7XG4gIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XG4gICAgLyoqXG4gICAgICogUHJldmlvdXMgZm9yayBzdGF0ZXMuXG4gICAgICovXG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMudGV4dEVuY29kZXIgPSB0ZXh0RW5jb2RlciAhPT0gbnVsbCAmJiB0ZXh0RW5jb2RlciAhPT0gdm9pZCAwID8gdGV4dEVuY29kZXIgOiBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuYnVmID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgYnl0ZXMgd3JpdHRlbiBhbmQgcmVzZXQgdGhpcyB3cml0ZXIuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXG4gICAgbGV0IGxlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBmb3JrIGZvciBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgbGlrZSBhIG1lc3NhZ2VcbiAgICogb3IgYSBwYWNrZWQgcmVwZWF0ZWQgZmllbGQuXG4gICAqXG4gICAqIE11c3QgYmUgam9pbmVkIGxhdGVyIHdpdGggYGpvaW4oKWAuXG4gICAqL1xuICBmb3JrKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICBjaHVua3M6IHRoaXMuY2h1bmtzLFxuICAgICAgYnVmOiB0aGlzLmJ1ZlxuICAgIH0pO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5idWYgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogSm9pbiB0aGUgbGFzdCBmb3JrLiBXcml0ZSBpdHMgbGVuZ3RoIGFuZCBieXRlcywgdGhlblxuICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgKi9cbiAgam9pbigpIHtcbiAgICAvLyBnZXQgY2h1bmsgb2YgZm9ya1xuICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XG4gICAgLy8gcmVzdG9yZSBwcmV2aW91cyBzdGF0ZVxuICAgIGxldCBwcmV2ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICBpZiAoIXByZXYpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdGUsIGZvcmsgc3RhY2sgZW1wdHlcIik7XG4gICAgdGhpcy5jaHVua3MgPSBwcmV2LmNodW5rcztcbiAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgIC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICB0aGlzLnVpbnQzMihjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgdWludDMyKCAoZmllbGRObyA8PCAzIHwgdHlwZSkgPj4+IDAgKWAuXG4gICAqXG4gICAqIEdlbmVyYXRlZCBjb2RlIHNob3VsZCBjb21wdXRlIHRoZSB0YWcgYWhlYWQgb2YgdGltZSBhbmQgY2FsbCBgdWludDMyKClgLlxuICAgKi9cbiAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAqL1xuICByYXcoY2h1bmspIHtcbiAgICBpZiAodGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7XG4gICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgdWludDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIHVpbnQzMih2YWx1ZSkge1xuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyLCBpbmxpbmVkIGZvciBzcGVlZFxuICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUgJiAweDdmIHwgMHg4MCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgIH1cbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgaW50MzJgIHZhbHVlLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgKi9cbiAgaW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxuICAgKi9cbiAgYm9vbCh2YWx1ZSkge1xuICAgIHRoaXMuYnVmLnB1c2godmFsdWUgPyAxIDogMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICovXG4gIGJ5dGVzKHZhbHVlKSB7XG4gICAgdGhpcy51aW50MzIodmFsdWUuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzdHJpbmdgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAqL1xuICBzdHJpbmcodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmbG9hdGAgdmFsdWUsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBmbG9hdCh2YWx1ZSkge1xuICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGRvdWJsZSh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGZpeGVkMzJgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQzMih2YWx1ZSkge1xuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQzMih2YWx1ZSkge1xuICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRJbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ludDMyYCB2YWx1ZSwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgLy8gemlnemFnIGVuY29kZVxuICAgIHZhbHVlID0gKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDA7XG4gICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICovXG4gIHNmaXhlZDY0KHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksXG4gICAgICB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkNjQodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSxcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSxcbiAgICAgIHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQ2NCh2YWx1ZSkge1xuICAgIGxldCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzaW50NjRgIHZhbHVlLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSksXG4gICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICBzaWduID0gdGMuaGkgPj4gMzEsXG4gICAgICBsbyA9IHRjLmxvIDw8IDEgXiBzaWduLFxuICAgICAgaGkgPSAodGMuaGkgPDwgMSB8IHRjLmxvID4+PiAzMSkgXiBzaWduO1xuICAgIHZhcmludDY0d3JpdGUobG8sIGhpLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHVpbnQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xuICAgIHZhcmludDY0d3JpdGUodGMubG8sIHRjLmhpLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmNsYXNzIEJpbmFyeVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKGJ1ZiwgdGV4dERlY29kZXIpIHtcbiAgICB0aGlzLnZhcmludDY0ID0gdmFyaW50NjRyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2BcbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHVpbnQzMmAgZmllbGQsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgdGhpcy51aW50MzIgPSB2YXJpbnQzMnJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYCBhbmQgYWNjZXNzIHRvIHByb3RlY3RlZCBgYnVmYFxuICAgIHRoaXMuYnVmID0gYnVmO1xuICAgIHRoaXMubGVuID0gYnVmLmxlbmd0aDtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy50ZXh0RGVjb2RlciA9IHRleHREZWNvZGVyICE9PSBudWxsICYmIHRleHREZWNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RGVjb2RlciA6IG5ldyBUZXh0RGVjb2RlcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgKi9cbiAgdGFnKCkge1xuICAgIGxldCB0YWcgPSB0aGlzLnVpbnQzMigpLFxuICAgICAgZmllbGRObyA9IHRhZyA+Pj4gMyxcbiAgICAgIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICBpZiAoZmllbGRObyA8PSAwIHx8IHdpcmVUeXBlIDwgMCB8fCB3aXJlVHlwZSA+IDUpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdGFnOiBmaWVsZCBubyBcIiArIGZpZWxkTm8gKyBcIiB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gIH1cbiAgLyoqXG4gICAqIFNraXAgb25lIGVsZW1lbnQgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgKlxuICAgKiBXaGVuIHNraXBwaW5nIFN0YXJ0R3JvdXAsIHByb3ZpZGUgdGhlIHRhZ3MgZmllbGQgbnVtYmVyIHRvIGNoZWNrIGZvclxuICAgKiBtYXRjaGluZyBmaWVsZCBudW1iZXIgaW4gdGhlIEVuZEdyb3VwIHRhZy5cbiAgICovXG4gIHNraXAod2lyZVR5cGUsIGZpZWxkTm8pIHtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMHg4MCkge1xuICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgIGNhc2UgV2lyZVR5cGUuQml0NjQ6XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDpcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdpcmVUeXBlLlN0YXJ0R3JvdXA6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBjb25zdCBbZm4sIHd0XSA9IHRoaXMudGFnKCk7XG4gICAgICAgICAgaWYgKHd0ID09PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkTm8gIT09IHVuZGVmaW5lZCAmJiBmbiAhPT0gZmllbGRObykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuZCBncm91cCB0YWdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5za2lwKHd0LCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgIH1cbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAqL1xuICBhc3NlcnRCb3VuZHMoKSB7XG4gICAgaWYgKHRoaXMucG9zID4gdGhpcy5sZW4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ludDMyYCBmaWVsZCwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50MzIoKSB7XG4gICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XG4gICAgLy8gZGVjb2RlIHppZ3phZ1xuICAgIHJldHVybiB6emUgPj4+IDEgXiAtKHp6ZSAmIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGludDY0YCBmaWVsZCwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIGludDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHVpbnQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50NjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQ2NCgpIHtcbiAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICBsZXQgcyA9IC0obG8gJiAxKTtcbiAgICBsbyA9IChsbyA+Pj4gMSB8IChoaSAmIDEpIDw8IDMxKSBeIHM7XG4gICAgaGkgPSBoaSA+Pj4gMSBeIHM7XG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKGxvLCBoaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgYm9vbGAgZmllbGQsIGEgdmFyaWFudC5cbiAgICovXG4gIGJvb2woKSB7XG4gICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgIHJldHVybiBsbyAhPT0gMCB8fCBoaSAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDMyYCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkNjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGZsb2F0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBkb3VibGVgIGZpZWxkLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBkb3VibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDY0KCh0aGlzLnBvcyArPSA4KSAtIDgsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGJ5dGVzYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICovXG4gIGJ5dGVzKCkge1xuICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLFxuICAgICAgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzdHJpbmdgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAqL1xuICBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV4dGVuc2lvbiB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gbWFrZUV4dGVuc2lvbihydW50aW1lLCB0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKSB7XG4gIGxldCBmaTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlTmFtZSxcbiAgICBleHRlbmRlZSxcbiAgICBnZXQgZmllbGQoKSB7XG4gICAgICBpZiAoIWZpKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0eXBlb2YgZmllbGQgPT0gXCJmdW5jdGlvblwiID8gZmllbGQoKSA6IGZpZWxkO1xuICAgICAgICBpLm5hbWUgPSB0eXBlTmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgICAgIGkuanNvbk5hbWUgPSBcIltcIi5jb25jYXQodHlwZU5hbWUsIFwiXVwiKTtcbiAgICAgICAgZmkgPSBydW50aW1lLnV0aWwubmV3RmllbGRMaXN0KFtpXSkubGlzdCgpWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpO1xuICAgIH0sXG4gICAgcnVudGltZVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb250YWluZXIgdGhhdCBhbGxvd3MgdXMgdG8gcmVhZCBleHRlbnNpb24gZmllbGRzIGludG8gaXQgd2l0aCB0aGVcbiAqIHNhbWUgbG9naWMgYXMgcmVndWxhciBmaWVsZHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lcihleHRlbnNpb24pIHtcbiAgY29uc3QgbG9jYWxOYW1lID0gZXh0ZW5zaW9uLmZpZWxkLmxvY2FsTmFtZTtcbiAgY29uc3QgY29udGFpbmVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29udGFpbmVyW2xvY2FsTmFtZV0gPSBpbml0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uKTtcbiAgcmV0dXJuIFtjb250YWluZXIsICgpID0+IGNvbnRhaW5lcltsb2NhbE5hbWVdXTtcbn1cbmZ1bmN0aW9uIGluaXRFeHRlbnNpb25GaWVsZChleHQpIHtcbiAgY29uc3QgZmllbGQgPSBleHQuZmllbGQ7XG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoZmllbGQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZpZWxkLmRlZmF1bHQ7XG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIHJldHVybiBmaWVsZC5ULnZhbHVlc1swXS5ubztcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlQsIGZpZWxkLkwpO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgIGNvbnN0IFQgPSBmaWVsZC5ULFxuICAgICAgICB2YWx1ZSA9IG5ldyBUKCk7XG4gICAgICByZXR1cm4gVC5maWVsZFdyYXBwZXIgPyBULmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjYXNlIFwibWFwXCI6XG4gICAgICB0aHJvdyBcIm1hcCBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIGV4dGVuc2lvbnNcIjtcbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZmlsdGVyIHVua25vd24gZmllbGRzLCBvcHRpbWl6ZWQgYmFzZWQgb24gZmllbGQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyVW5rbm93bkZpZWxkcyh1bmtub3duRmllbGRzLCBmaWVsZCkge1xuICBpZiAoIWZpZWxkLnJlcGVhdGVkICYmIChmaWVsZC5raW5kID09IFwiZW51bVwiIHx8IGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikpIHtcbiAgICAvLyBzaW5ndWxhciBzY2FsYXIgZmllbGRzIGRvIG5vdCBtZXJnZSwgd2UgcGljayB0aGUgbGFzdFxuICAgIGZvciAobGV0IGkgPSB1bmtub3duRmllbGRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodW5rbm93bkZpZWxkc1tpXS5ubyA9PSBmaWVsZC5ubykge1xuICAgICAgICByZXR1cm4gW3Vua25vd25GaWVsZHNbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVua25vd25GaWVsZHMuZmlsdGVyKHVmID0+IHVmLm5vID09PSBmaWVsZC5ubyk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIHByZWZlci1jb25zdCAqL1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKykgZGVjVGFibGVbZW5jVGFibGVbaV0uY2hhckNvZGVBdCgwKV0gPSBpO1xuLy8gc3VwcG9ydCBiYXNlNjR1cmwgdmFyaWFudHNcbmRlY1RhYmxlW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIitcIik7XG5kZWNUYWJsZVtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIvXCIpO1xuY29uc3QgcHJvdG9CYXNlNjQgPSB7XG4gIC8qKlxuICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXkuXG4gICAqXG4gICAqIC0gaWdub3JlcyB3aGl0ZS1zcGFjZSwgaW5jbHVkaW5nIGxpbmUgYnJlYWtzIGFuZCB0YWJzXG4gICAqIC0gYWxsb3dzIGlubmVyIHBhZGRpbmcgKGNhbiBkZWNvZGUgY29uY2F0ZW5hdGVkIGJhc2U2NCBzdHJpbmdzKVxuICAgKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICAgKiAtIHVuZGVyc3RhbmRzIGJhc2U2NHVybCBlbmNvZGluZzpcbiAgICogICBcIi1cIiBpbnN0ZWFkIG9mIFwiK1wiLFxuICAgKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gICAqICAgbm8gcGFkZGluZ1xuICAgKi9cbiAgZGVjKGJhc2U2NFN0cikge1xuICAgIC8vIGVzdGltYXRlIGJ5dGUgc2l6ZSwgbm90IGFjY291bnRpbmcgZm9yIGlubmVyIHBhZGRpbmcgYW5kIHdoaXRlc3BhY2VcbiAgICBsZXQgZXMgPSBiYXNlNjRTdHIubGVuZ3RoICogMyAvIDQ7XG4gICAgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMl0gPT0gXCI9XCIpIGVzIC09IDI7ZWxzZSBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAxXSA9PSBcIj1cIikgZXMgLT0gMTtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksXG4gICAgICBieXRlUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXlcbiAgICAgIGdyb3VwUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgYixcbiAgICAgIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgcCA9IDA7IC8vIHByZXZpb3VzIGJ5dGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgYiA9IGRlY1RhYmxlW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChiYXNlNjRTdHJbaV0pIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgIC8vIHJlc2V0IHN0YXRlIHdoZW4gcGFkZGluZyBmb3VuZFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgY2FzZSBcIlxcdFwiOlxuICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAvLyBza2lwIHdoaXRlLXNwYWNlLCBhbmQgcGFkZGluZ1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSBwIDw8IDIgfCAoYiAmIDQ4KSA+PiA0O1xuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDE1KSA8PCA0IHwgKGIgJiA2MCkgPj4gMjtcbiAgICAgICAgICBwID0gYjtcbiAgICAgICAgICBncm91cFBvcyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAzKSA8PCA2IHwgYjtcbiAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChncm91cFBvcyA9PSAxKSB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KDAsIGJ5dGVQb3MpO1xuICB9LFxuICAvKipcbiAgICogRW5jb2RlIGEgYnl0ZSBhcnJheSB0byBhIGJhc2U2NCBzdHJpbmcuXG4gICAqL1xuICBlbmMoYnl0ZXMpIHtcbiAgICBsZXQgYmFzZTY0ID0gXCJcIixcbiAgICAgIGdyb3VwUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgYixcbiAgICAgIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgcCA9IDA7IC8vIGNhcnJ5IG92ZXIgZnJvbSBwcmV2aW91cyBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYiA9IGJ5dGVzW2ldO1xuICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgPj4gMl07XG4gICAgICAgICAgcCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNF07XG4gICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCBiID4+IDZdO1xuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiICYgNjNdO1xuICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG91dHB1dCBwYWRkaW5nXG4gICAgaWYgKGdyb3VwUG9zKSB7XG4gICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcF07XG4gICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICBpZiAoZ3JvdXBQb3MgPT0gMSkgYmFzZTY0ICs9IFwiPVwiO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9XG59O1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXRyaWV2ZSBhbiBleHRlbnNpb24gdmFsdWUgZnJvbSBhIG1lc3NhZ2UuXG4gKlxuICogVGhlIGZ1bmN0aW9uIG5ldmVyIHJldHVybnMgdW5kZWZpbmVkLiBVc2UgaGFzRXh0ZW5zaW9uKCkgdG8gY2hlY2sgd2hldGhlciBhblxuICogZXh0ZW5zaW9uIGlzIHNldC4gSWYgdGhlIGV4dGVuc2lvbiBpcyBub3Qgc2V0LCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gKiBkZWZhdWx0IHZhbHVlIChpZiBvbmUgd2FzIHNwZWNpZmllZCBpbiB0aGUgcHJvdG9idWYgc291cmNlKSwgb3IgdGhlIHplcm8gdmFsdWVcbiAqIChmb3IgZXhhbXBsZSBgMGAgZm9yIG51bWVyaWMgdHlwZXMsIGBbXWAgZm9yIHJlcGVhdGVkIGV4dGVuc2lvbiBmaWVsZHMsIGFuZFxuICogYW4gZW1wdHkgbWVzc2FnZSBpbnN0YW5jZSBmb3IgbWVzc2FnZSBmaWVsZHMpLlxuICpcbiAqIEV4dGVuc2lvbnMgYXJlIHN0b3JlZCBhcyB1bmtub3duIGZpZWxkcyBvbiBhIG1lc3NhZ2UuIFRvIG11dGF0ZSBhbiBleHRlbnNpb25cbiAqIHZhbHVlLCBtYWtlIHN1cmUgdG8gc3RvcmUgdGhlIG5ldyB2YWx1ZSB3aXRoIHNldEV4dGVuc2lvbigpIGFmdGVyIG11dGF0aW5nLlxuICpcbiAqIElmIHRoZSBleHRlbnNpb24gZG9lcyBub3QgZXh0ZW5kIHRoZSBnaXZlbiBtZXNzYWdlLCBhbiBlcnJvciBpcyByYWlzZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24sIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RXh0ZW5kZWUoZXh0ZW5zaW9uLCBtZXNzYWdlKTtcbiAgY29uc3Qgb3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgdWZzID0gZmlsdGVyVW5rbm93bkZpZWxkcyhtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSwgZXh0ZW5zaW9uLmZpZWxkKTtcbiAgY29uc3QgW2NvbnRhaW5lciwgZ2V0XSA9IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lcihleHRlbnNpb24pO1xuICBmb3IgKGNvbnN0IHVmIG9mIHVmcykge1xuICAgIGV4dGVuc2lvbi5ydW50aW1lLmJpbi5yZWFkRmllbGQoY29udGFpbmVyLCBvcHQucmVhZGVyRmFjdG9yeSh1Zi5kYXRhKSwgZXh0ZW5zaW9uLmZpZWxkLCB1Zi53aXJlVHlwZSwgb3B0KTtcbiAgfVxuICByZXR1cm4gZ2V0KCk7XG59XG4vKipcbiAqIFNldCBhbiBleHRlbnNpb24gdmFsdWUgb24gYSBtZXNzYWdlLiBJZiB0aGUgbWVzc2FnZSBhbHJlYWR5IGhhcyBhIHZhbHVlIGZvclxuICogdGhpcyBleHRlbnNpb24sIHRoZSB2YWx1ZSBpcyByZXBsYWNlZC5cbiAqXG4gKiBJZiB0aGUgZXh0ZW5zaW9uIGRvZXMgbm90IGV4dGVuZCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICovXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uLCB2YWx1ZSwgb3B0aW9ucykge1xuICBhc3NlcnRFeHRlbmRlZShleHRlbnNpb24sIG1lc3NhZ2UpO1xuICBjb25zdCByZWFkT3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3Qgd3JpdGVPcHQgPSBleHRlbnNpb24ucnVudGltZS5iaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgaWYgKGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24pKSB7XG4gICAgY29uc3QgdWZzID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkuZmlsdGVyKHVmID0+IHVmLm5vICE9IGV4dGVuc2lvbi5maWVsZC5ubyk7XG4gICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4uZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSk7XG4gICAgZm9yIChjb25zdCB1ZiBvZiB1ZnMpIHtcbiAgICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIHVmLm5vLCB1Zi53aXJlVHlwZSwgdWYuZGF0YSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdyaXRlciA9IHdyaXRlT3B0LndyaXRlckZhY3RvcnkoKTtcbiAgbGV0IGYgPSBleHRlbnNpb24uZmllbGQ7XG4gIC8vIEltcGxpY2l0IHByZXNlbmNlIGRvZXMgbm90IGFwcGx5IHRvIGV4dGVuc2lvbnMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2lzc3Vlcy84MjM0XG4gIC8vIFdlIHBhdGNoIHRoZSBmaWVsZCBpbmZvIHRvIHVzZSBleHBsaWNpdCBwcmVzZW5jZTpcbiAgaWYgKCFmLm9wdCAmJiAhZi5yZXBlYXRlZCAmJiAoZi5raW5kID09IFwiZW51bVwiIHx8IGYua2luZCA9PSBcInNjYWxhclwiKSkge1xuICAgIGYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbi5maWVsZCksIHtcbiAgICAgIG9wdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGV4dGVuc2lvbi5ydW50aW1lLmJpbi53cml0ZUZpZWxkKGYsIHZhbHVlLCB3cml0ZXIsIHdyaXRlT3B0KTtcbiAgY29uc3QgcmVhZGVyID0gcmVhZE9wdC5yZWFkZXJGYWN0b3J5KHdyaXRlci5maW5pc2goKSk7XG4gIHdoaWxlIChyZWFkZXIucG9zIDwgcmVhZGVyLmxlbikge1xuICAgIGNvbnN0IFtubywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSwgbm8pO1xuICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSk7XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBleHRlbnNpb24gaXMgc2V0IG9uIGEgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikge1xuICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICByZXR1cm4gZXh0ZW5zaW9uLmV4dGVuZGVlLnR5cGVOYW1lID09PSBtZXNzYWdlVHlwZS50eXBlTmFtZSAmJiAhIW1lc3NhZ2VUeXBlLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpLmZpbmQodWYgPT4gdWYubm8gPT0gZXh0ZW5zaW9uLmZpZWxkLm5vKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSkge1xuICBhc3NlcnQoZXh0ZW5zaW9uLmV4dGVuZGVlLnR5cGVOYW1lID09IG1lc3NhZ2UuZ2V0VHlwZSgpLnR5cGVOYW1lLCBcImV4dGVuc2lvbiBcIi5jb25jYXQoZXh0ZW5zaW9uLnR5cGVOYW1lLCBcIiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIG1lc3NhZ2UgXCIpLmNvbmNhdChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUpKTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWVsZCBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGlzRmllbGRTZXQoZmllbGQsIHRhcmdldCkge1xuICBjb25zdCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXS5sZW5ndGggPiAwO1xuICB9XG4gIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHJldHVybiB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXS5jYXNlID09PSBsb2NhbE5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICBpZiAoZmllbGQub3B0IHx8IGZpZWxkLnJlcSkge1xuICAgICAgICAvLyBleHBsaWNpdCBwcmVzZW5jZVxuICAgICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIC8vIGltcGxpY2l0IHByZXNlbmNlXG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcImVudW1cIikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IGZpZWxkLlQudmFsdWVzWzBdLm5vO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFpc1NjYWxhclplcm9WYWx1ZShmaWVsZC5ULCB0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xuICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXRbbG9jYWxOYW1lXSkubGVuZ3RoID4gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgfVxufVxuLyoqXG4gKiBSZXNldHMgdGhlIGZpZWxkLCBzbyB0aGF0IGlzRmllbGRTZXQoKSB3aWxsIHJldHVybiBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJGaWVsZChmaWVsZCwgdGFyZ2V0KSB7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgY29uc3QgaW1wbGljaXRQcmVzZW5jZSA9ICFmaWVsZC5vcHQgJiYgIWZpZWxkLnJlcTtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBbXTtcbiAgfSBlbHNlIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ge1xuICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2UgPyBmaWVsZC5ULnZhbHVlc1swXS5ubyA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gaW1wbGljaXRQcmVzZW5jZSA/IHNjYWxhclplcm9WYWx1ZShmaWVsZC5ULCBmaWVsZC5MKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhbnkgc3VidHlwZSBvZiBNZXNzYWdlIG9yIGlzIGEgc3BlY2lmaWNcbiAqIE1lc3NhZ2UgYnkgcGFzc2luZyB0aGUgdHlwZS5cbiAqXG4gKiBKdXN0IGxpa2UgYGluc3RhbmNlb2ZgLCBgaXNNZXNzYWdlYCBuYXJyb3dzIHRoZSB0eXBlLiBUaGUgYWR2YW50YWdlIG9mXG4gKiBgaXNNZXNzYWdlYCBpcyB0aGF0IGl0IGNvbXBhcmVzIGlkZW50aXR5IGJ5IHRoZSBtZXNzYWdlIHR5cGUgbmFtZSwgbm90IGJ5XG4gKiBjbGFzcyBpZGVudGl0eS4gVGhpcyBtYWtlcyBpdCByb2J1c3QgYWdhaW5zdCB0aGUgZHVhbCBwYWNrYWdlIGhhemFyZCBhbmRcbiAqIHNpbWlsYXIgc2l0dWF0aW9ucywgd2hlcmUgdGhlIHNhbWUgbWVzc2FnZSBpcyBkdXBsaWNhdGVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgX21vc3RseV8gZXF1aXZhbGVudCB0byB0aGUgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLiBGb3JcbiAqIGV4YW1wbGUsIGBpc01lc3NhZ2UoZm9vLCBNeU1lc3NhZ2UpYCBpcyB0aGUgc2FtZSBhcyBgZm9vIGluc3RhbmNlb2YgTXlNZXNzYWdlYCxcbiAqIGFuZCBgaXNNZXNzYWdlKGZvbylgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNZXNzYWdlYC4gSW4gbW9zdCBjYXNlcyxcbiAqIGBpc01lc3NhZ2VgIHNob3VsZCBiZSBwcmVmZXJyZWQgb3ZlciBgaW5zdGFuY2VvZmAuXG4gKlxuICogSG93ZXZlciwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgYGlzTWVzc2FnZWAgZG9lcyBub3QgdXNlIGNsYXNzIGlkZW50aXR5LCB0aGVyZVxuICogYXJlIHN1YnRsZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgZnVuY3Rpb24gYW5kIGBpbnN0YW5jZW9mYC4gTm90YWJseSxcbiAqIGNhbGxpbmcgYGlzTWVzc2FnZWAgb24gYW4gZXhwbGljaXQgdHlwZSBvZiBNZXNzYWdlIHdpbGwgcmV0dXJuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBpc01lc3NhZ2UoYXJnLCB0eXBlKSB7XG4gIGlmIChhcmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZyAhPSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWVzc2FnZS5wcm90b3R5cGUpLmV2ZXJ5KG0gPT4gbSBpbiBhcmcgJiYgdHlwZW9mIGFyZ1ttXSA9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFjdHVhbFR5cGUgPSBhcmcuZ2V0VHlwZSgpO1xuICBpZiAoYWN0dWFsVHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsVHlwZSAhPSBcImZ1bmN0aW9uXCIgfHwgIShcInR5cGVOYW1lXCIgaW4gYWN0dWFsVHlwZSkgfHwgdHlwZW9mIGFjdHVhbFR5cGUudHlwZU5hbWUgIT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFjdHVhbFR5cGUudHlwZU5hbWUgPT0gdHlwZS50eXBlTmFtZTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZnVuY3Rpb24gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gIGlmIChpc01lc3NhZ2UodmFsdWUpIHx8ICF0eXBlLmZpZWxkV3JhcHBlcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdHlwZS5maWVsZFdyYXBwZXIud3JhcEZpZWxkKHZhbHVlKTtcbn1cbih7XG4gIFwiZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlXCI6IFNjYWxhclR5cGUuRE9VQkxFLFxuICBcImdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlXCI6IFNjYWxhclR5cGUuRkxPQVQsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5JTlQ2NCxcbiAgXCJnb29nbGUucHJvdG9idWYuVUludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UNjQsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5JTlQzMixcbiAgXCJnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UMzIsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZVwiOiBTY2FsYXJUeXBlLkJPT0wsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlXCI6IFNjYWxhclR5cGUuU1RSSU5HLFxuICBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCI6IFNjYWxhclR5cGUuQllURVNcbn0pO1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCAqL1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXG5jb25zdCBqc29uUmVhZERlZmF1bHRzID0ge1xuICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZVxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgdG8gSlNPTi5cbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xuICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gIGVudW1Bc0ludGVnZXI6IGZhbHNlLFxuICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gIHByZXR0eVNwYWNlczogMFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyQxKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25SZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25SZWFkRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zJDEob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuY29uc3QgdG9rZW5OdWxsID0gU3ltYm9sKCk7XG5jb25zdCB0b2tlbklnbm9yZWRVbmtub3duRW51bSA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXQoKSB7XG4gIHJldHVybiB7XG4gICAgbWFrZVJlYWRPcHRpb25zOiBtYWtlUmVhZE9wdGlvbnMkMSxcbiAgICBtYWtlV3JpdGVPcHRpb25zOiBtYWtlV3JpdGVPcHRpb25zJDEsXG4gICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbikpKTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgY29uc3Qgb25lb2ZTZWVuID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcbiAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kSnNvbk5hbWUoanNvbktleSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgICAgLy8gc2VlIGNvbmZvcm1hbmNlIHRlc3QgUmVxdWlyZWQuUHJvdG8zLkpzb25JbnB1dC5PbmVvZkZpZWxkTnVsbHtGaXJzdCxTZWNvbmR9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2Vlbi5nZXQoZmllbGQub25lb2YpO1xuICAgICAgICAgICAgaWYgKHNlZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogbXVsdGlwbGUga2V5cyBmb3Igb25lb2YgXFxcIlwiKS5jb25jYXQoZmllbGQub25lb2YubmFtZSwgXCJcXFwiIHByZXNlbnQ6IFxcXCJcIikuY29uY2F0KHNlZW4sIFwiXFxcIiwgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uZW9mU2Vlbi5zZXQoZmllbGQub25lb2YsIGpzb25LZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWFkRmllbGQkMShtZXNzYWdlLCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCB0eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKSAmJiBqc29uS2V5LnN0YXJ0c1dpdGgoXCJbXCIpICYmIGpzb25LZXkuZW5kc1dpdGgoXCJdXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKGpzb25LZXkuc3Vic3RyaW5nKDEsIGpzb25LZXkubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgaWYgKGV4dCAmJiBleHQuZXh0ZW5kZWUudHlwZU5hbWUgPT0gdHlwZS50eXBlTmFtZSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0KTtcbiAgICAgICAgICAgICAgcmVhZEZpZWxkJDEoY29udGFpbmVyLCBqc29uVmFsdWUsIGV4dC5maWVsZCwgb3B0aW9ucywgZXh0KTtcbiAgICAgICAgICAgICAgLy8gV2UgcGFzcyBvbiB0aGUgb3B0aW9ucyBhcyBCaW5hcnlSZWFkT3B0aW9ucy9CaW5hcnlXcml0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgIC8vIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93biBiaW5hcnkgcmVhZGVyIGFuZCB3cml0ZXIgZmFjdG9yaWVzXG4gICAgICAgICAgICAgIC8vIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgc2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCwgZ2V0KCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBrZXkgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiIGlzIHVua25vd25cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgbGV0IGZpZWxkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XG4gICAgICAgICAgaWYgKCFpc0ZpZWxkU2V0KGZpZWxkLCBtZXNzYWdlKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xuICAgICAgICAgICAgICB0aHJvdyBcInJlcXVpcmVkIGZpZWxkIG5vdCBzZXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuRW1pdEZpZWxkRGVmYXVsdFZhbHVlKGZpZWxkKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5vbmVvZiA/IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXS52YWx1ZSA6IG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXTtcbiAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkJDEoZmllbGQsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy50eXBlUmVnaXN0cnk7XG4gICAgICAgIGlmIChyZWdpc3RyeSA9PT0gbnVsbCB8fCByZWdpc3RyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcikge1xuICAgICAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgY29uc3QgZXh0ID0gcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcih0eXBlLnR5cGVOYW1lLCB1Zi5ubyk7XG4gICAgICAgICAgICBpZiAoZXh0ICYmIGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHQpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHBhc3Mgb24gdGhlIG9wdGlvbnMgYXMgQmluYXJ5UmVhZE9wdGlvbnMsIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93blxuICAgICAgICAgICAgICAvLyBiaW5hcnkgcmVhZGVyIGZhY3RvcnkgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkJDEoZXh0LmZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGpzb25bZXh0LmZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBtID0gZmllbGQgPyBcImNhbm5vdCBlbmNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgdG8gSlNPTlwiKSA6IFwiY2Fubm90IGVuY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiB0byBKU09OXCIpO1xuICAgICAgICBjb25zdCByID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSArIChyLmxlbmd0aCA+IDAgPyBcIjogXCIuY29uY2F0KHIpIDogXCJcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlKSB7XG4gICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZC4gRm9yIGJhY2t3YXJkcy1cbiAgICAgIC8vIGNvbXBhdGliaWxpdHksIHdlIHN1cHBvcnQgdGhlIG9sZCBmb3JtIHRoYXQgaXMgcGFydCBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgLy8gdGhyb3VnaCB0aGUgaW50ZXJmYWNlIEpzb25Gb3JtYXQuXG4gICAgICByZXR1cm4gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlICE9PSBudWxsICYmIGxvbmdUeXBlICE9PSB2b2lkIDAgPyBsb25nVHlwZSA6IExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgfSxcbiAgICB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSwgZW1pdERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLiBGb3IgYmFja3dhcmRzLVxuICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAvLyB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgSnNvbkZvcm1hdC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZW1pdERlZmF1bHRWYWx1ZXMgfHwgaXNTY2FsYXJaZXJvVmFsdWUodHlwZSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVNjYWxhciQxKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBkZWJ1ZzogZGVidWdKc29uVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYnVnSnNvblZhbHVlKGpzb24pIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGpzb24pID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogXCJcXFwiXCIuY29uY2F0KGpzb24uc3BsaXQoJ1wiJykuam9pbignXFxcXFwiJyksIFwiXFxcIlwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFN0cmluZyhqc29uKTtcbiAgfVxufVxuLy8gUmVhZCBhIEpTT04gdmFsdWUgZm9yIGEgZmllbGQuXG4vLyBUaGUgXCJwYXJlbnRUeXBlXCIgYXJndW1lbnQgaXMgb25seSB1c2VkIHRvIHByb3ZpZGUgY29udGV4dCBpbiBlcnJvcnMuXG5mdW5jdGlvbiByZWFkRmllbGQkMSh0YXJnZXQsIGpzb25WYWx1ZSwgZmllbGQsIG9wdGlvbnMsIHBhcmVudFR5cGUpIHtcbiAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgYXNzZXJ0KGZpZWxkLmtpbmQgIT0gXCJtYXBcIik7XG4gICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XG4gICAgICBpZiAoanNvbkl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKGZpZWxkLlQuZnJvbUpzb24oanNvbkl0ZW0sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uSXRlbSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB0b2tlbklnbm9yZWRVbmtub3duRW51bSkge1xuICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChlbnVtVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKHJlYWRTY2FsYXIkMShmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCwgdHJ1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uSXRlbSkpO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uVmFsdWUgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XG4gICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbFwiKSk7XG4gICAgICB9XG4gICAgICBsZXQga2V5O1xuICAgICAgdHJ5IHtcbiAgICAgICAga2V5ID0gcmVhZE1hcEtleShmaWVsZC5LLCBqc29uTWFwS2V5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIGtleSBmb3IgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xuICAgICAgICAgIGlmIChlbnVtVmFsdWUgIT09IHRva2VuSWdub3JlZFVua25vd25FbnVtKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFyZ2V0TWFwW2tleV0gPSByZWFkU2NhbGFyJDEoZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIHZhbHVlIGZvciBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHtcbiAgICAgICAgY2FzZTogbG9jYWxOYW1lXG4gICAgICB9O1xuICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBtZXNzYWdlVHlwZS50eXBlTmFtZSAhPSBcImdvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKGlzTWVzc2FnZShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFZhbHVlLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBjdXJyZW50VmFsdWUgPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25WYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCBmYWxzZSk7XG4gICAgICAgIHN3aXRjaCAoZW51bVZhbHVlKSB7XG4gICAgICAgICAgY2FzZSB0b2tlbk51bGw6XG4gICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0b2tlbklnbm9yZWRVbmtub3duRW51bTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNjYWxhclZhbHVlID0gcmVhZFNjYWxhciQxKGZpZWxkLlQsIGpzb25WYWx1ZSwgZmllbGQuTCwgZmFsc2UpO1xuICAgICAgICAgIHN3aXRjaCAoc2NhbGFyVmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxuICAgICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gc2NhbGFyVmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKTtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZE1hcEtleSh0eXBlLCBqc29uKSB7XG4gIGlmICh0eXBlID09PSBTY2FsYXJUeXBlLkJPT0wpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICAgIHN3aXRjaCAoanNvbikge1xuICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAganNvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgIGpzb24gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWFkU2NhbGFyJDEodHlwZSwganNvbiwgTG9uZ1R5cGUuQklHSU5ULCB0cnVlKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICBpZiAobnVsbEFzWmVyb1ZhbHVlKSB7XG4gICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuTnVsbDtcbiAgfVxuICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgLy8gdGhyb3VnaCBpcyByZWdhcmRlZCBhcyBhIGZhaWx1cmUuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgaWYgKGpzb24gPT09IFwiSW5maW5pdHlcIikgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgIC8vIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuRkxPQVQpIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgIGxldCBpbnQzMjtcbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKSBpbnQzMiA9IGpzb247ZWxzZSBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCA9PT0ganNvbi5sZW5ndGgpIGludDMyID0gTnVtYmVyKGpzb24pO1xuICAgICAgfVxuICAgICAgaWYgKGludDMyID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIgfHwgdHlwZSA9PSBTY2FsYXJUeXBlLkZJWEVEMzIpIGFzc2VydFVJbnQzMihpbnQzMik7ZWxzZSBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICByZXR1cm4gaW50MzI7XG4gICAgLy8gaW50NjQsIGZpeGVkNjQsIHVpbnQ2NDogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpIGJyZWFrO1xuICAgICAgY29uc3QgbG9uZyA9IHByb3RvSW50NjQucGFyc2UoanNvbik7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyBsb25nLnRvU3RyaW5nKCkgOiBsb25nO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIGNvbnN0IHVMb25nID0gcHJvdG9JbnQ2NC51UGFyc2UoanNvbik7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyB1TG9uZy50b1N0cmluZygpIDogdUxvbmc7XG4gICAgLy8gYm9vbDpcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJib29sZWFuXCIpIGJyZWFrO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgLy8gc3RyaW5nOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBBIHN0cmluZyBtdXN0IGFsd2F5cyBjb250YWluIFVURi04IGVuY29kZWQgb3IgNy1iaXQgQVNDSUkuXG4gICAgICAvLyBXZSB2YWxpZGF0ZSB3aXRoIGVuY29kZVVSSUNvbXBvbmVudCwgd2hpY2ggYXBwZWFycyB0byBiZSB0aGUgZmFzdGVzdCB3aWRlbHkgYXZhaWxhYmxlIG9wdGlvbi5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBVVEY4XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICBpZiAoanNvbiA9PT0gXCJcIikgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5kZWMoanNvbik7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiByZWFkRW51bSh0eXBlLCBqc29uLCBpZ25vcmVVbmtub3duRmllbGRzLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgICAgcmV0dXJuIDA7IC8vIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUuTlVMTF9WQUxVRSA9IDBcbiAgICB9XG4gICAgcmV0dXJuIG51bGxBc1plcm9WYWx1ZSA/IHR5cGUudmFsdWVzWzBdLm5vIDogdG9rZW5OdWxsO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5ubztcbiAgICAgIH1cbiAgICAgIGlmIChpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0b2tlbklnbm9yZWRVbmtub3duRW51bTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZW51bSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb24pKSk7XG59XG4vLyBEZWNpZGUgd2hldGhlciBhbiB1bnNldCBmaWVsZCBzaG91bGQgYmUgZW1pdHRlZCB3aXRoIEpTT04gd3JpdGUgb3B0aW9uIGBlbWl0RGVmYXVsdFZhbHVlc2BcbmZ1bmN0aW9uIGNhbkVtaXRGaWVsZERlZmF1bHRWYWx1ZShmaWVsZCkge1xuICBpZiAoZmllbGQucmVwZWF0ZWQgfHwgZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgLy8gbWFwcyBhcmUge30sIHJlcGVhdGVkIGZpZWxkcyBhcmUgW11cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAvLyBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIGVtaXR0ZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpIHtcbiAgICAvLyBzaW5ndWxhciBtZXNzYWdlIGZpZWxkIGFyZSBhbGxvd2VkIHRvIGVtaXQgSlNPTiBudWxsLCBidXQgd2UgZG8gbm90XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgaWYgKGZpZWxkLm9wdCB8fCBmaWVsZC5yZXEpIHtcbiAgICAvLyB0aGUgZmllbGQgdXNlcyBleHBsaWNpdCBwcmVzZW5jZSwgc28gd2UgY2Fubm90IGVtaXQgYSB6ZXJvIHZhbHVlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gd3JpdGVGaWVsZCQxKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xuICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlU2NhbGFyJDEoZmllbGQuVi5ULCBlbnRyeVZhbHVlKTsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgY29uc3QgZW51bVR5cGUgPSBmaWVsZC5WLlQ7XG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB3cml0ZUVudW0oZW51bVR5cGUsIGVudHJ5VmFsdWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGVudHJpZXMubGVuZ3RoID4gMCA/IGpzb25PYmogOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVTY2FsYXIkMShmaWVsZC5ULCB2YWx1ZVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGpzb25BcnIucHVzaCh2YWx1ZVtpXS50b0pzb24ob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDAgPyBqc29uQXJyIDogdW5kZWZpbmVkO1xuICB9XG4gIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIHJldHVybiB3cml0ZVNjYWxhciQxKGZpZWxkLlQsIHZhbHVlKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgcmV0dXJuIHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZSkudG9Kc29uKG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZUVudW0odHlwZSwgdmFsdWUsIGVudW1Bc0ludGVnZXIpIHtcbiAgdmFyIF9hO1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbnVtQXNJbnRlZ2VyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IHZhbCA9IHR5cGUuZmluZE51bWJlcih2YWx1ZSk7XG4gIHJldHVybiAoX2EgPSB2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWwubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWU7IC8vIGlmIHdlIGRvbid0IGtub3cgdGhlIGVudW0gdmFsdWUsIGp1c3QgcmV0dXJuIHRoZSBudW1iZXJcbn1cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyJDEodHlwZSwgdmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgLy8gYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkgcmV0dXJuIFwiTmFOXCI7XG4gICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyBzdHJpbmc6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgLy8gYm9vbDpcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgICAgcmV0dXJuIHByb3RvQmFzZTY0LmVuYyh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gKi9cbmNvbnN0IHVua25vd25GaWVsZHNTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvdW5rbm93bi1maWVsZHNcIik7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XG4gIHJlYWRVbmtub3duRmllbGRzOiB0cnVlLFxuICByZWFkZXJGYWN0b3J5OiBieXRlcyA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKVxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgYmluYXJ5IGRhdGEuXG5jb25zdCB3cml0ZURlZmF1bHRzID0ge1xuICB3cml0ZVVua25vd25GaWVsZHM6IHRydWUsXG4gIHdyaXRlckZhY3Rvcnk6ICgpID0+IG5ldyBCaW5hcnlXcml0ZXIoKVxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IHJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JpdGVEZWZhdWx0cyksIG9wdGlvbnMpIDogd3JpdGVEZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VCaW5hcnlGb3JtYXQoKSB7XG4gIHJldHVybiB7XG4gICAgbWFrZVJlYWRPcHRpb25zLFxuICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgbGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIH0sXG4gICAgZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgZGVsZXRlIG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgfSxcbiAgICB3cml0ZVVua25vd25GaWVsZHMobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBjb25zdCBtID0gbWVzc2FnZTtcbiAgICAgIGNvbnN0IGMgPSBtW3Vua25vd25GaWVsZHNTeW1ib2xdO1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIGMpIHtcbiAgICAgICAgICB3cml0ZXIudGFnKGYubm8sIGYud2lyZVR5cGUpLnJhdyhmLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpIHtcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1bdW5rbm93bkZpZWxkc1N5bWJvbF0pKSB7XG4gICAgICAgIG1bdW5rbm93bkZpZWxkc1N5bWJvbF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIG1bdW5rbm93bkZpZWxkc1N5bWJvbF0ucHVzaCh7XG4gICAgICAgIG5vLFxuICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfSxcbiAgICByZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGxlbmd0aE9yRW5kVGFnRmllbGRObywgb3B0aW9ucywgZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICBjb25zdCBlbmQgPSBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aE9yRW5kVGFnRmllbGRObztcbiAgICAgIGxldCBmaWVsZE5vLCB3aXJlVHlwZTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgIGlmIChkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgPT09IHRydWUgJiYgd2lyZVR5cGUgPT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmQoZmllbGRObyk7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUsIGZpZWxkTm8pO1xuICAgICAgICAgIGlmIChvcHRpb25zLnJlYWRVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZEZpZWxkKG1lc3NhZ2UsIHJlYWRlciwgZmllbGQsIHdpcmVUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgJiYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIHdpcmVUeXBlICE9IFdpcmVUeXBlLkVuZEdyb3VwIHx8IGZpZWxkTm8gIT09IGxlbmd0aE9yRW5kVGFnRmllbGRObykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmQgZ3JvdXAgdGFnXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVhZEZpZWxkLFxuICAgIHdyaXRlTWVzc2FnZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMuYnlOdW1iZXIoKSkge1xuICAgICAgICBpZiAoIWlzRmllbGRTZXQoZmllbGQsIG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiB0byBiaW5hcnk6IHJlcXVpcmVkIGZpZWxkIG5vdCBzZXRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLm9uZW9mID8gbWVzc2FnZVtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdLnZhbHVlIDogbWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdO1xuICAgICAgICB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcykge1xuICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgIC8vIFRoZSBiZWhhdmlvciBvZiBvdXIgaW50ZXJuYWwgZnVuY3Rpb24gaGFzIGNoYW5nZWQsIGl0IGRvZXMgbm8gbG9uZ2VyXG4gICAgICAvLyBhY2NlcHQgYHVuZGVmaW5lZGAgdmFsdWVzIGZvciBzaW5ndWxhciBzY2FsYXIgYW5kIG1hcC5cbiAgICAgIC8vIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mXG4gICAgICAvLyB0aGUgcHVibGljIEFQSSB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgQmluYXJ5Rm9ybWF0LlxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRGaWVsZCh0YXJnZXQsXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gYGFueWAgaXMgdGhlIGJlc3QgY2hvaWNlIGZvciBkeW5hbWljIGFjY2Vzc1xucmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICByZXBlYXRlZCxcbiAgICBsb2NhbE5hbWVcbiAgfSA9IGZpZWxkO1xuICBpZiAoZmllbGQub25lb2YpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICBpZiAodGFyZ2V0LmNhc2UgIT0gbG9jYWxOYW1lKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0LnZhbHVlO1xuICAgIH1cbiAgICB0YXJnZXQuY2FzZSA9IGxvY2FsTmFtZTtcbiAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcInNjYWxhclwiOlxuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICBjb25zdCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgbGV0IHJlYWQgPSByZWFkU2NhbGFyO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLkwgPiAwKSB7XG4gICAgICAgIHJlYWQgPSByZWFkU2NhbGFyTFRTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgbGV0IGFyciA9IHRhcmdldFtsb2NhbE5hbWVdOyAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGlzUGFja2VkID0gd2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTO1xuICAgICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKSB7XG4gICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlQ7XG4gICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5wdXNoKHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc01lc3NhZ2UodGFyZ2V0W2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIHRhcmdldFtsb2NhbE5hbWVdLCBvcHRpb25zLCBmaWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMsIGZpZWxkKTtcbiAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZiAmJiAhZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICB0YXJnZXRbbG9jYWxOYW1lXVttYXBLZXldID0gbWFwVmFsO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbi8vIFJlYWQgYSBtZXNzYWdlLCBhdm9pZGluZyBNZXNzYWdlVHlwZS5mcm9tQmluYXJ5KCkgdG8gcmUtdXNlIHRoZVxuLy8gQmluYXJ5UmVhZE9wdGlvbnMgYW5kIHRoZSBJQmluYXJ5UmVhZGVyLlxuZnVuY3Rpb24gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMsIGZpZWxkKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICBjb25zdCBkZWxpbWl0ZWQgPSBmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGQuZGVsaW1pdGVkO1xuICBmb3JtYXQucmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCBkZWxpbWl0ZWQgPyBmaWVsZC5ubyA6IHJlYWRlci51aW50MzIoKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgb3B0aW9ucywgZGVsaW1pdGVkKTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vLyBSZWFkIGEgbWFwIGZpZWxkLCBleHBlY3Rpbmcga2V5IGZpZWxkID0gMSwgdmFsdWUgZmllbGQgPSAyXG5mdW5jdGlvbiByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucykge1xuICBjb25zdCBsZW5ndGggPSByZWFkZXIudWludDMyKCksXG4gICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgbGV0IGtleSwgdmFsO1xuICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgIGNvbnN0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAga2V5ID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLkspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuVi5UKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IGZpZWxkLlYuVCgpLCBvcHRpb25zLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIGtleSA9IHNjYWxhclplcm9WYWx1ZShmaWVsZC5LLCBMb25nVHlwZS5CSUdJTlQpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPSBcIm51bWJlclwiKSB7XG4gICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgdmFsID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlYuVCwgTG9uZ1R5cGUuQklHSU5UKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICB2YWwgPSBmaWVsZC5WLlQudmFsdWVzWzBdLm5vO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIHZhbCA9IG5ldyBmaWVsZC5WLlQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBba2V5LCB2YWxdO1xufVxuLy8gUmVhZCBhIHNjYWxhciB2YWx1ZSwgYnV0IHJldHVybiA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4vLyBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KSBhcyBzdHJpbmcgaW5zdGVhZCBvZiBiaWdpbnQuXG5mdW5jdGlvbiByZWFkU2NhbGFyTFRTdHJpbmcocmVhZGVyLCB0eXBlKSB7XG4gIGNvbnN0IHYgPSByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSk7XG4gIHJldHVybiB0eXBlb2YgdiA9PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygpIDogdjtcbn1cbi8vIERvZXMgbm90IHVzZSBzY2FsYXJUeXBlSW5mbygpIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5mdW5jdGlvbiByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiByZWFkZXIuYm9vbCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICByZXR1cm4gcmVhZGVyLmRvdWJsZSgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5pbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgcmV0dXJuIHJlYWRlci5ieXRlcygpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkNjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci51aW50MzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50MzIoKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucykge1xuICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gIGNvbnN0IHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQ7XG4gIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgbGV0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCkge1xuICAgICAgICAgIHdyaXRlUGFja2VkKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1hcFwiOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsdWUpIHtcbiAgd3JpdGVyLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKTtcbiAgd3JpdGVyLmZvcmsoKTtcbiAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAvLyB3ZSBjb252ZXJ0IGZyb20gb3VyIHJlcHJlc2VudGF0aW9uIHRvIHRoZSBwcm90b2J1ZiB0eXBlXG4gIGxldCBrZXlWYWx1ZSA9IGtleTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xuICBzd2l0Y2ggKGZpZWxkLkspIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgIGtleVZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGtleSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGFzc2VydChrZXkgPT0gXCJ0cnVlXCIgfHwga2V5ID09IFwiZmFsc2VcIik7XG4gICAgICBrZXlWYWx1ZSA9IGtleSA9PSBcInRydWVcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXG4gIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuSywgMSwga2V5VmFsdWUpO1xuICAvLyB3cml0ZSB2YWx1ZSwgZXhwZWN0aW5nIHZhbHVlIGZpZWxkIG51bWJlciA9IDJcbiAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIGZpZWxkLlYuVCwgMiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgU2NhbGFyVHlwZS5JTlQzMiwgMiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5ieXRlcyh2YWx1ZS50b0JpbmFyeShvcHRpb25zKSk7XG4gICAgICBicmVhaztcbiAgfVxuICB3cml0ZXIuam9pbigpO1xufVxuLy8gVmFsdWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkXG5mdW5jdGlvbiB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCB2YWx1ZSkge1xuICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICBpZiAoZmllbGQuZGVsaW1pdGVkKSB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5TdGFydEdyb3VwKS5yYXcobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSkudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5FbmRHcm91cCk7ZWxzZSB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmJ5dGVzKG1lc3NhZ2UudG9CaW5hcnkob3B0aW9ucykpO1xufVxuZnVuY3Rpb24gd3JpdGVTY2FsYXIod3JpdGVyLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSkge1xuICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gIGxldCBbd2lyZVR5cGUsIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgd3JpdGVyLnRhZyhmaWVsZE5vLCB3aXJlVHlwZSlbbWV0aG9kXSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB3cml0ZVBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gIGxldCBbLCBtZXRob2RdID0gc2NhbGFyVHlwZUluZm8odHlwZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZVtpXSk7XG4gIH1cbiAgd3JpdGVyLmpvaW4oKTtcbn1cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGZvciB3cml0aW5nIGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGFwcHJvcHJpYXRlIFdpcmVUeXBlXG4gKiBbMV06IG5hbWUgb2YgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBvZiBJQmluYXJ5V3JpdGVyXG4gKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvdG8zIHNlbWFudGljc1xuICpcbiAqIElmIGFyZ3VtZW50IGB2YWx1ZWAgaXMgb21pdHRlZCwgWzJdIGlzIGFsd2F5cyBmYWxzZS5cbiAqL1xuLy8gVE9ETyByZXBsYWNlIGNhbGwtc2l0ZXMgd3JpdGVTY2FsYXIoKSBhbmQgd3JpdGVQYWNrZWQoKSwgdGhlbiByZW1vdmVcbmZ1bmN0aW9uIHNjYWxhclR5cGVJbmZvKHR5cGUpIHtcbiAgbGV0IHdpcmVUeXBlID0gV2lyZVR5cGUuVmFyaW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBJTlQzMiwgVUlOVDMyLCBTSU5UMzIgYXJlIGNvdmVyZWQgYnkgdGhlIGRlZmF1bHRzXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IG1ldGhvZCA9IFNjYWxhclR5cGVbdHlwZV0udG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFt3aXJlVHlwZSwgbWV0aG9kXTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG5mdW5jdGlvbiBtYWtlVXRpbENvbW1vbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzZXRFbnVtVHlwZSxcbiAgICBpbml0UGFydGlhbChzb3VyY2UsIHRhcmdldCkge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQuZ2V0VHlwZSgpO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLFxuICAgICAgICAgIHQgPSB0YXJnZXQsXG4gICAgICAgICAgcyA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHNbbG9jYWxOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETyBpZiBzb3VyY2UgaXMgYSBNZXNzYWdlIGluc3RhbmNlLCB3ZSBzaG91bGQgdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgY29uc3Qgc2sgPSBzW2xvY2FsTmFtZV0uY2FzZTtcbiAgICAgICAgICAgIGlmIChzayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlRmllbGQgPSBtZW1iZXIuZmluZEZpZWxkKHNrKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV0udmFsdWU7XG4gICAgICAgICAgICBpZiAoc291cmNlRmllbGQgJiYgc291cmNlRmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIiAmJiAhaXNNZXNzYWdlKHZhbCwgc291cmNlRmllbGQuVCkpIHtcbiAgICAgICAgICAgICAgdmFsID0gbmV3IHNvdXJjZUZpZWxkLlQodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlRmllbGQgJiYgc291cmNlRmllbGQua2luZCA9PT0gXCJzY2FsYXJcIiAmJiBzb3VyY2VGaWVsZC5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIHZhbCA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHtcbiAgICAgICAgICAgICAgY2FzZTogc2ssXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIGNvcHkgPSBtZW1iZXIucmVwZWF0ZWQgPyBjb3B5Lm1hcCh0b1U4QXJyKSA6IHRvVThBcnIoY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlYuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB0b1U4QXJyKHYpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRbbG9jYWxOYW1lXSwgc1tsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZW1iZXIuVi5UO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdW2tdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB0YWtlIHBhcnRpYWwgaW5wdXQgZm9yIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCBhIHdyYXBwZXIgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBtZXNzYWdlVHlwZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBjb25zdCBtdCA9IG1lbWJlci5UO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBzW2xvY2FsTmFtZV0ubWFwKHZhbCA9PiBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgIGlmIChtdC5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIEJ5dGVzVmFsdWUudHlwZU5hbWUgYXMgdGhhdCB3aWxsIGNyZWF0ZSBhIGNpcmN1bGFyIGltcG9ydFxuICAgICAgICAgICAgICAgIG10LnR5cGVOYW1lID09PSBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgZXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpLmV2ZXJ5KG0gPT4ge1xuICAgICAgICBjb25zdCB2YSA9IGFbbS5sb2NhbE5hbWVdO1xuICAgICAgICBjb25zdCB2YiA9IGJbbS5sb2NhbE5hbWVdO1xuICAgICAgICBpZiAobS5yZXBlYXRlZCkge1xuICAgICAgICAgIGlmICh2YS5sZW5ndGggIT09IHZiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSByZXBlYXRlZCBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBtLlQuZXF1YWxzKGEsIHZiW2ldKSk7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKG0uVCwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcGVhdGVkIGNhbm5vdCBjb250YWluIFwiLmNvbmNhdChtLmtpbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBsZXQgYSA9IHZhO1xuICAgICAgICAgICAgbGV0IGIgPSB2YjtcbiAgICAgICAgICAgIGlmIChtLlQuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgIWlzTWVzc2FnZShhKSkge1xuICAgICAgICAgICAgICAgIGEgPSBtLlQuZmllbGRXcmFwcGVyLndyYXBGaWVsZChhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYiAhPT0gdW5kZWZpbmVkICYmICFpc01lc3NhZ2UoYikpIHtcbiAgICAgICAgICAgICAgICBiID0gbS5ULmZpZWxkV3JhcHBlci53cmFwRmllbGQoYik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtLlQuZXF1YWxzKGEsIGIpO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLCB2Yik7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhtLlQsIHZhLCB2Yik7XG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICBpZiAodmEuY2FzZSAhPT0gdmIuY2FzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzID0gbS5maW5kRmllbGQodmEuY2FzZSk7XG4gICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gb25lb2YgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgICBzd2l0Y2ggKHMua2luZCkge1xuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzLlQuZXF1YWxzKHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhzLlQsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbmVvZiBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQocy5raW5kKSk7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhKS5jb25jYXQoT2JqZWN0LmtleXModmIpKTtcbiAgICAgICAgICAgIHN3aXRjaCAobS5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gbWVzc2FnZVR5cGUuZXF1YWxzKHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gc2NhbGFyRXF1YWxzKHNjYWxhclR5cGUsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gVE9ETyB1c2UgaXNGaWVsZFNldCgpIGhlcmUgdG8gc3VwcG9ydCBmdXR1cmUgZmllbGQgcHJlc2VuY2VcbiAgICBjbG9uZShtZXNzYWdlKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCksXG4gICAgICAgIHRhcmdldCA9IG5ldyB0eXBlKCksXG4gICAgICAgIGFueSA9IHRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbWVzc2FnZVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICBjb3B5ID0gc291cmNlLm1hcChjbG9uZVNpbmd1bGFyRmllbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICBjb3B5ID0gYW55W21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVTaW5ndWxhckZpZWxkKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm9uZW9mXCIpIHtcbiAgICAgICAgICBjb25zdCBmID0gbWVtYmVyLmZpbmRGaWVsZChzb3VyY2UuY2FzZSk7XG4gICAgICAgICAgY29weSA9IGYgPyB7XG4gICAgICAgICAgICBjYXNlOiBzb3VyY2UuY2FzZSxcbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlLnZhbHVlKVxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHkgPSBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBhbnlbbWVtYmVyLmxvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB1ZiBvZiB0eXBlLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpKSB7XG4gICAgICAgIHR5cGUucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQoYW55LCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH07XG59XG4vLyBjbG9uZSBhIHNpbmdsZSBmaWVsZCB2YWx1ZSAtIGkuZS4gdGhlIGVsZW1lbnQgdHlwZSBvZiByZXBlYXRlZCBmaWVsZHMsIHRoZSB2YWx1ZSB0eXBlIG9mIG1hcHNcbmZ1bmN0aW9uIGNsb25lU2luZ3VsYXJGaWVsZCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNNZXNzYWdlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5jbG9uZSgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgYy5zZXQodmFsdWUpO1xuICAgIHJldHVybiBjO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIHRvVThBcnIoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGlucHV0IDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIG5ld0ZpZWxkTGlzdCwgaW5pdEZpZWxkcykge1xuICByZXR1cm4ge1xuICAgIHN5bnRheCxcbiAgICBqc29uOiBtYWtlSnNvbkZvcm1hdCgpLFxuICAgIGJpbjogbWFrZUJpbmFyeUZvcm1hdCgpLFxuICAgIHV0aWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZVV0aWxDb21tb24oKSksIHtcbiAgICAgIG5ld0ZpZWxkTGlzdCxcbiAgICAgIGluaXRGaWVsZHNcbiAgICB9KSxcbiAgICBtYWtlTWVzc2FnZVR5cGUodHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XG4gICAgICByZXR1cm4gbWFrZU1lc3NhZ2VUeXBlKHRoaXMsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCk7XG4gICAgfSxcbiAgICBtYWtlRW51bSxcbiAgICBtYWtlRW51bVR5cGUsXG4gICAgZ2V0RW51bVR5cGUsXG4gICAgbWFrZUV4dGVuc2lvbih0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKSB7XG4gICAgICByZXR1cm4gbWFrZUV4dGVuc2lvbih0aGlzLCB0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5jbGFzcyBJbnRlcm5hbEZpZWxkTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkcywgbm9ybWFsaXplcikge1xuICAgIHRoaXMuX2ZpZWxkcyA9IGZpZWxkcztcbiAgICB0aGlzLl9ub3JtYWxpemVyID0gbm9ybWFsaXplcjtcbiAgfVxuICBmaW5kSnNvbk5hbWUoanNvbk5hbWUpIHtcbiAgICBpZiAoIXRoaXMuanNvbk5hbWVzKSB7XG4gICAgICBjb25zdCB0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgdFtmLmpzb25OYW1lXSA9IHRbZi5uYW1lXSA9IGY7XG4gICAgICB9XG4gICAgICB0aGlzLmpzb25OYW1lcyA9IHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmpzb25OYW1lc1tqc29uTmFtZV07XG4gIH1cbiAgZmluZChmaWVsZE5vKSB7XG4gICAgaWYgKCF0aGlzLm51bWJlcnMpIHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICB0W2Yubm9dID0gZjtcbiAgICAgIH1cbiAgICAgIHRoaXMubnVtYmVycyA9IHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm51bWJlcnNbZmllbGROb107XG4gIH1cbiAgbGlzdCgpIHtcbiAgICBpZiAoIXRoaXMuYWxsKSB7XG4gICAgICB0aGlzLmFsbCA9IHRoaXMuX25vcm1hbGl6ZXIodGhpcy5fZmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWxsO1xuICB9XG4gIGJ5TnVtYmVyKCkge1xuICAgIGlmICghdGhpcy5udW1iZXJzQXNjKSB7XG4gICAgICB0aGlzLm51bWJlcnNBc2MgPSB0aGlzLmxpc3QoKS5jb25jYXQoKS5zb3J0KChhLCBiKSA9PiBhLm5vIC0gYi5ubyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm51bWJlcnNBc2M7XG4gIH1cbiAgYnlNZW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm1lbWJlcnMpIHtcbiAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgICAgY29uc3QgYSA9IHRoaXMubWVtYmVycztcbiAgICAgIGxldCBvO1xuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgIGlmIChmLm9uZW9mKSB7XG4gICAgICAgICAgaWYgKGYub25lb2YgIT09IG8pIHtcbiAgICAgICAgICAgIG8gPSBmLm9uZW9mO1xuICAgICAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVtYmVycztcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgcHJvdG9idWYgZWxlbWVudCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBGaWVsZCBuYW1lcyAtIGluY2x1ZGluZyBvbmVvZnMgLSBhcmUgY29udmVydGVkIHRvIGxvd2VyQ2FtZWxDYXNlLiBGb3JcbiAqIG1lc3NhZ2VzLCBlbnVtZXJhdGlvbnMgYW5kIHNlcnZpY2VzLCB0aGUgcGFja2FnZSBuYW1lIGlzIHN0cmlwcGVkIGZyb21cbiAqIHRoZSB0eXBlIG5hbWUuIEZvciBuZXN0ZWQgbWVzc2FnZXMgYW5kIGVudW1lcmF0aW9ucywgdGhlIG5hbWVzIGFyZSBqb2luZWRcbiAqIHdpdGggYW4gdW5kZXJzY29yZS4gRm9yIG1ldGhvZHMsIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbWFkZSBsb3dlcmNhc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZpZWxkIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGluT25lb2YpIHtcbiAgY29uc3QgbmFtZSA9IHByb3RvQ2FtZWxDYXNlKHByb3RvTmFtZSk7XG4gIGlmIChpbk9uZW9mKSB7XG4gICAgLy8gb25lb2YgbWVtYmVyIG5hbWVzIGFyZSBub3QgcHJvcGVydGllcywgYnV0IHZhbHVlcyBvZiB0aGUgYGNhc2VgIHByb3BlcnR5LlxuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkoc2FmZU1lc3NhZ2VQcm9wZXJ0eShuYW1lKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBvbmVvZiBncm91cCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxPbmVvZk5hbWUocHJvdG9OYW1lKSB7XG4gIHJldHVybiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgSlNPTiBuYW1lIGZvciBhIHByb3RvYnVmIGZpZWxkLCBleGFjdGx5IGxpa2UgcHJvdG9jIGRvZXMuXG4gKi9cbmNvbnN0IGZpZWxkSnNvbk5hbWUgPSBwcm90b0NhbWVsQ2FzZTtcbi8qKlxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBwcm90b0NhbWVsQ2FzZSBhY2NvcmRpbmcgdG8gdGhlIGNvbnZlbnRpb25cbiAqIHVzZWQgYnkgcHJvdG9jIHRvIGNvbnZlcnQgYSBmaWVsZCBuYW1lIHRvIGEgSlNPTiBuYW1lLlxuICovXG5mdW5jdGlvbiBwcm90b0NhbWVsQ2FzZShzbmFrZUNhc2UpIHtcbiAgbGV0IGNhcE5leHQgPSBmYWxzZTtcbiAgY29uc3QgYiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYWtlQ2FzZS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjID0gc25ha2VDYXNlLmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgXCJfXCI6XG4gICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6XG4gICAgICBjYXNlIFwiMVwiOlxuICAgICAgY2FzZSBcIjJcIjpcbiAgICAgIGNhc2UgXCIzXCI6XG4gICAgICBjYXNlIFwiNFwiOlxuICAgICAgY2FzZSBcIjVcIjpcbiAgICAgIGNhc2UgXCI2XCI6XG4gICAgICBjYXNlIFwiN1wiOlxuICAgICAgY2FzZSBcIjhcIjpcbiAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjYXBOZXh0KSB7XG4gICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGIuam9pbihcIlwiKTtcbn1cbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCByZXNlcnZlZE9iamVjdFByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IEphdmFTY3JpcHRcblwiY29uc3RydWN0b3JcIiwgXCJ0b1N0cmluZ1wiLCBcInRvSlNPTlwiLCBcInZhbHVlT2ZcIl0pO1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSB0aGUgcnVudGltZS5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcyA9IG5ldyBTZXQoW1xuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWVcblwiZ2V0VHlwZVwiLCBcImNsb25lXCIsIFwiZXF1YWxzXCIsIFwiZnJvbUJpbmFyeVwiLCBcImZyb21Kc29uXCIsIFwiZnJvbUpzb25TdHJpbmdcIiwgXCJ0b0JpbmFyeVwiLCBcInRvSnNvblwiLCBcInRvSnNvblN0cmluZ1wiLFxuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWUgZm9yIHRoZSBmdXR1cmVcblwidG9PYmplY3RcIl0pO1xuY29uc3QgZmFsbGJhY2sgPSBuYW1lID0+IFwiXCIuY29uY2F0KG5hbWUsIFwiJFwiKTtcbi8qKlxuICogV2lsbCB3cmFwIG5hbWVzIHRoYXQgYXJlIE9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllcyBvciBuYW1lcyByZXNlcnZlZFxuICogZm9yIGBNZXNzYWdlYHMuXG4gKi9cbmNvbnN0IHNhZmVNZXNzYWdlUHJvcGVydHkgPSBuYW1lID0+IHtcbiAgaWYgKHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICB9XG4gIHJldHVybiBuYW1lO1xufTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCBzYWZlT2JqZWN0UHJvcGVydHkgPSBuYW1lID0+IHtcbiAgaWYgKHJlc2VydmVkT2JqZWN0UHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY2xhc3MgSW50ZXJuYWxPbmVvZkluZm8ge1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgdGhpcy5raW5kID0gXCJvbmVvZlwiO1xuICAgIHRoaXMucmVwZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0ID0gZmFsc2U7XG4gICAgdGhpcy5yZXEgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxPbmVvZk5hbWUobmFtZSk7XG4gIH1cbiAgYWRkRmllbGQoZmllbGQpIHtcbiAgICBhc3NlcnQoZmllbGQub25lb2YgPT09IHRoaXMsIFwiZmllbGQgXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiIG5vdCBvbmUgb2YgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgfVxuICBmaW5kRmllbGQobG9jYWxOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9sb29rdXApIHtcbiAgICAgIHRoaXMuX2xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2xvb2t1cFt0aGlzLmZpZWxkc1tpXS5sb2NhbE5hbWVdID0gdGhpcy5maWVsZHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBDb252ZXJ0IGEgY29sbGVjdGlvbiBvZiBmaWVsZCBpbmZvIHRvIGFuIGFycmF5IG9mIG5vcm1hbGl6ZWQgRmllbGRJbmZvLlxuICpcbiAqIFRoZSBhcmd1bWVudCBgcGFja2VkQnlEZWZhdWx0YCBzcGVjaWZpZXMgd2hldGhlciBmaWVsZHMgdGhhdCBkbyBub3Qgc3BlY2lmeVxuICogYHBhY2tlZGAgc2hvdWxkIGJlIHBhY2tlZCAocHJvdG8zKSBvciB1bnBhY2tlZCAocHJvdG8yKS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvcyhmaWVsZEluZm9zLCBwYWNrZWRCeURlZmF1bHQpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gIGNvbnN0IHIgPSBbXTtcbiAgbGV0IG87XG4gIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZW9mIGZpZWxkSW5mb3MgPT0gXCJmdW5jdGlvblwiID8gZmllbGRJbmZvcygpIDogZmllbGRJbmZvcykge1xuICAgIGNvbnN0IGYgPSBmaWVsZDtcbiAgICBmLmxvY2FsTmFtZSA9IGxvY2FsRmllbGROYW1lKGZpZWxkLm5hbWUsIGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpO1xuICAgIGYuanNvbk5hbWUgPSAoX2EgPSBmaWVsZC5qc29uTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmllbGRKc29uTmFtZShmaWVsZC5uYW1lKTtcbiAgICBmLnJlcGVhdGVkID0gKF9iID0gZmllbGQucmVwZWF0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgIGYuTCA9IChfYyA9IGZpZWxkLkwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IExvbmdUeXBlLkJJR0lOVDtcbiAgICB9XG4gICAgZi5kZWxpbWl0ZWQgPSAoX2QgPSBmaWVsZC5kZWxpbWl0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgIGYucmVxID0gKF9lID0gZmllbGQucmVxKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmYWxzZTtcbiAgICBmLm9wdCA9IChfZiA9IGZpZWxkLm9wdCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2U7XG4gICAgaWYgKGZpZWxkLnBhY2tlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGYucGFja2VkID0gZmllbGQua2luZCA9PSBcImVudW1cIiB8fCBmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5TVFJJTkc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgLy8gZi5vcHRpb25zID0gZmllbGQub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0O1xuICAgIGlmIChmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBvb25hbWUgPSB0eXBlb2YgZmllbGQub25lb2YgPT0gXCJzdHJpbmdcIiA/IGZpZWxkLm9uZW9mIDogZmllbGQub25lb2YubmFtZTtcbiAgICAgIGlmICghbyB8fCBvLm5hbWUgIT0gb29uYW1lKSB7XG4gICAgICAgIG8gPSBuZXcgSW50ZXJuYWxPbmVvZkluZm8ob29uYW1lKTtcbiAgICAgIH1cbiAgICAgIGYub25lb2YgPSBvO1xuICAgICAgby5hZGRGaWVsZChmKTtcbiAgICB9XG4gICAgci5wdXNoKGYpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtZXNzYWdlcyBkZWZpbmVkIHdpdGggdGhlIHByb3RvMyBzeW50YXguXG4gKi9cbmNvbnN0IHByb3RvMyA9IG1ha2VQcm90b1J1bnRpbWUoXCJwcm90bzNcIiwgZmllbGRzID0+IHtcbiAgcmV0dXJuIG5ldyBJbnRlcm5hbEZpZWxkTGlzdChmaWVsZHMsIHNvdXJjZSA9PiBub3JtYWxpemVGaWVsZEluZm9zKHNvdXJjZSkpO1xufSxcbi8vIFRPRE8gbWVyZ2Ugd2l0aCBwcm90bzIgYW5kIGluaXRFeHRlbnNpb25GaWVsZCwgYWxzbyBzZWUgaW5pdFBhcnRpYWwsIGVxdWFscywgY2xvbmVcbnRhcmdldCA9PiB7XG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIHRhcmdldC5nZXRUeXBlKCkuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICBpZiAobWVtYmVyLm9wdCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLFxuICAgICAgdCA9IHRhcmdldDtcbiAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICB0W25hbWVdID0gW107XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgIHRbbmFtZV0gPSB7XG4gICAgICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgdFtuYW1lXSA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICB0W25hbWVdID0ge307XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB0W25hbWVdID0gc2NhbGFyWmVyb1ZhbHVlKG1lbWJlci5ULCBtZW1iZXIuTCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcbiAqIGNhbGVuZGFyLCBlbmNvZGVkIGFzIGEgY291bnQgb2Ygc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXRcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS5cbiAqXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxuICogc2Vjb25kIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24sIHVzaW5nIGEgWzI0LWhvdXIgbGluZWFyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXG4gKlxuICogVGhlIHJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLiBCeVxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgdGltZSgpYC5cbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModGltZShOVUxMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYGdldHRpbWVvZmRheSgpYC5cbiAqXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XG4gKiAgICAgZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHR2LnR2X3NlYyk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XG4gKlxuICogRXhhbXBsZSAzOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFdpbjMyIGBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgpYC5cbiAqXG4gKiAgICAgRklMRVRJTUUgZnQ7XG4gKiAgICAgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoJmZ0KTtcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XG4gKlxuICogICAgIC8vIEEgV2luZG93cyB0aWNrIGlzIDEwMCBuYW5vc2Vjb25kcy4gV2luZG93cyBlcG9jaCAxNjAxLTAxLTAxVDAwOjAwOjAwWlxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHMoKElOVDY0KSAoKHRpY2tzIC8gMTAwMDAwMDApIC0gMTE2NDQ0NzM2MDBMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XG4gKlxuICogRXhhbXBsZSA0OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpYC5cbiAqXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xuICpcbiAqIEV4YW1wbGUgNTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBJbnN0YW50Lm5vdygpYC5cbiAqXG4gKiAgICAgSW5zdGFudCBub3cgPSBJbnN0YW50Lm5vdygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID1cbiAqICAgICAgICAgVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG5vdy5nZXRFcG9jaFNlY29uZCgpKVxuICogICAgICAgICAgICAgLnNldE5hbm9zKG5vdy5nZXROYW5vKCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA2OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIGN1cnJlbnQgdGltZSBpbiBQeXRob24uXG4gKlxuICogICAgIHRpbWVzdGFtcCA9IFRpbWVzdGFtcCgpXG4gKiAgICAgdGltZXN0YW1wLkdldEN1cnJlbnRUaW1lKClcbiAqXG4gKiAjIEpTT04gTWFwcGluZ1xuICpcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgVGltZXN0YW1wIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZyBpbiB0aGVcbiAqIFtSRkMgMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBmb3JtYXQuIFRoYXQgaXMsIHRoZVxuICogZm9ybWF0IGlzIFwie3llYXJ9LXttb250aH0te2RheX1Ue2hvdXJ9OnttaW59OntzZWN9Wy57ZnJhY19zZWN9XVpcIlxuICogd2hlcmUge3llYXJ9IGlzIGFsd2F5cyBleHByZXNzZWQgdXNpbmcgZm91ciBkaWdpdHMgd2hpbGUge21vbnRofSwge2RheX0sXG4gKiB7aG91cn0sIHttaW59LCBhbmQge3NlY30gYXJlIHplcm8tcGFkZGVkIHRvIHR3byBkaWdpdHMgZWFjaC4gVGhlIGZyYWN0aW9uYWxcbiAqIHNlY29uZHMsIHdoaWNoIGNhbiBnbyB1cCB0byA5IGRpZ2l0cyAoaS5lLiB1cCB0byAxIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiksXG4gKiBhcmUgb3B0aW9uYWwuIFRoZSBcIlpcIiBzdWZmaXggaW5kaWNhdGVzIHRoZSB0aW1lem9uZSAoXCJVVENcIik7IHRoZSB0aW1lem9uZVxuICogaXMgcmVxdWlyZWQuIEEgcHJvdG8zIEpTT04gc2VyaWFsaXplciBzaG91bGQgYWx3YXlzIHVzZSBVVEMgKGFzIGluZGljYXRlZCBieVxuICogXCJaXCIpIHdoZW4gcHJpbnRpbmcgdGhlIFRpbWVzdGFtcCB0eXBlIGFuZCBhIHByb3RvMyBKU09OIHBhcnNlciBzaG91bGQgYmVcbiAqIGFibGUgdG8gYWNjZXB0IGJvdGggVVRDIGFuZCBvdGhlciB0aW1lem9uZXMgKGFzIGluZGljYXRlZCBieSBhbiBvZmZzZXQpLlxuICpcbiAqIEZvciBleGFtcGxlLCBcIjIwMTctMDEtMTVUMDE6MzA6MTUuMDFaXCIgZW5jb2RlcyAxNS4wMSBzZWNvbmRzIHBhc3RcbiAqIDAxOjMwIFVUQyBvbiBKYW51YXJ5IDE1LCAyMDE3LlxuICpcbiAqIEluIEphdmFTY3JpcHQsIG9uZSBjYW4gY29udmVydCBhIERhdGUgb2JqZWN0IHRvIHRoaXMgZm9ybWF0IHVzaW5nIHRoZVxuICogc3RhbmRhcmRcbiAqIFt0b0lTT1N0cmluZygpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nKVxuICogbWV0aG9kLiBJbiBQeXRob24sIGEgc3RhbmRhcmQgYGRhdGV0aW1lLmRhdGV0aW1lYCBvYmplY3QgY2FuIGJlIGNvbnZlcnRlZFxuICogdG8gdGhpcyBmb3JtYXQgdXNpbmdcbiAqIFtgc3RyZnRpbWVgXShodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvdGltZS5odG1sI3RpbWUuc3RyZnRpbWUpIHdpdGhcbiAqIHRoZSB0aW1lIGZvcm1hdCBzcGVjICclWS0lbS0lZFQlSDolTTolUy4lZlonLiBMaWtld2lzZSwgaW4gSmF2YSwgb25lIGNhbiB1c2VcbiAqIHRoZSBKb2RhIFRpbWUncyBbYElTT0RhdGVUaW1lRm9ybWF0LmRhdGVUaW1lKClgXShcbiAqIGh0dHA6Ly9qb2RhLXRpbWUuc291cmNlZm9yZ2UubmV0L2FwaWRvY3Mvb3JnL2pvZGEvdGltZS9mb3JtYXQvSVNPRGF0ZVRpbWVGb3JtYXQuaHRtbCNkYXRlVGltZSgpXG4gKiApIHRvIG9idGFpbiBhIGZvcm1hdHRlciBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGltZXN0YW1wcyBpbiB0aGlzIGZvcm1hdC5cbiAqXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFxuICovXG5jbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogTm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uIE5lZ2F0aXZlXG4gICAgICogc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmUgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlc1xuICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAqIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubmFub3MgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IFwiLmNvbmNhdChwcm90bzMuanNvbi5kZWJ1Zyhqc29uKSkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVcIik7XG4gICAgfVxuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQucGFyc2UobXMgLyAxMDAwKTtcbiAgICB0aGlzLm5hbm9zID0gMDtcbiAgICBpZiAobWF0Y2hlc1s3XSkge1xuICAgICAgdGhpcy5uYW5vcyA9IHBhcnNlSW50KFwiMVwiICsgbWF0Y2hlc1s3XSArIFwiMFwiLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtIDEwMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmFub3MgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIGxldCB6ID0gXCJaXCI7XG4gICAgaWYgKHRoaXMubmFub3MgPiAwKSB7XG4gICAgICBjb25zdCBuYW5vc1N0ciA9ICh0aGlzLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDMpID09PSBcIjAwMDAwMFwiKSB7XG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArIFwiWlwiO1xuICAgICAgfSBlbHNlIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoNikgPT09IFwiMDAwXCIpIHtcbiAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDYpICsgXCJaXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ciArIFwiWlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xuICB9XG4gIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwICsgTWF0aC5jZWlsKHRoaXMubmFub3MgLyAxMDAwMDAwKSk7XG4gIH1cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gVGltZXN0YW1wLmZyb21EYXRlKG5ldyBEYXRlKCkpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7XG4gICAgICBzZWNvbmRzOiBwcm90b0ludDY0LnBhcnNlKE1hdGguZmxvb3IobXMgLyAxMDAwKSksXG4gICAgICBuYW5vczogbXMgJSAxMDAwICogMTAwMDAwMFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRpbWVzdGFtcCwgYSwgYik7XG4gIH1cbn1cblRpbWVzdGFtcC5ydW50aW1lID0gcHJvdG8zO1xuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNlY29uZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuXG5jb25zdCBNZXRyaWNzQmF0Y2ggPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5NZXRyaWNzQmF0Y2hcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJub3JtYWxpemVkX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN0cl9kYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRpbWVfc2VyaWVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lU2VyaWVzTWV0cmljLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJldmVudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEV2ZW50TWV0cmljLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVGltZVNlcmllc01ldHJpYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRpbWVTZXJpZXNNZXRyaWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibGFiZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNhbXBsZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE1ldHJpY1NhbXBsZSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicmlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBNZXRyaWNTYW1wbGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5NZXRyaWNTYW1wbGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJub3JtYWxpemVkX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInZhbHVlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufV0pO1xuY29uc3QgRXZlbnRNZXRyaWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5FdmVudE1ldHJpY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYWJlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic3RhcnRfdGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJlbmRfdGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJub3JtYWxpemVkX3N0YXJ0X3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfZW5kX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wLFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJyaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IEF1ZGlvQ29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkF1ZGlvQ29kZWNcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiREVGQVVMVF9BQ1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk9QVVNcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJBQUNcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJBQ19NUDNcIlxufV0pO1xuY29uc3QgVmlkZW9Db2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVmlkZW9Db2RlY1wiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJERUZBVUxUX1ZDXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSDI2NF9CQVNFTElORVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkgyNjRfTUFJTlwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIkgyNjRfSElHSFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlZQOFwiXG59XSk7XG5jb25zdCBJbWFnZUNvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5JbWFnZUNvZGVjXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIklDX0RFRkFVTFRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJJQ19KUEVHXCJcbn1dKTtcbmNvbnN0IEJhY2t1cENvZGVjUG9saWN5JDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkJhY2t1cENvZGVjUG9saWN5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBSRUZFUl9SRUdSRVNTSU9OXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiU0lNVUxDQVNUXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiUkVHUkVTU0lPTlwiXG59XSk7XG5jb25zdCBUcmFja1R5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlRyYWNrVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJBVURJT1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlZJREVPXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiREFUQVwiXG59XSk7XG5jb25zdCBUcmFja1NvdXJjZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVHJhY2tTb3VyY2VcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNBTUVSQVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk1JQ1JPUEhPTkVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVfQVVESU9cIlxufV0pO1xuY29uc3QgVmlkZW9RdWFsaXR5JDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlZpZGVvUXVhbGl0eVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJMT1dcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJNRURJVU1cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJISUdIXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiT0ZGXCJcbn1dKTtcbmNvbnN0IENvbm5lY3Rpb25RdWFsaXR5JDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBPT1JcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJHT09EXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRVhDRUxMRU5UXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiTE9TVFwiXG59XSk7XG5jb25zdCBDbGllbnRDb25maWdTZXR0aW5nID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVOU0VUXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiRElTQUJMRURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJFTkFCTEVEXCJcbn1dKTtcbmNvbnN0IERpc2Nvbm5lY3RSZWFzb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTl9SRUFTT05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJDTElFTlRfSU5JVElBVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRFVQTElDQVRFX0lERU5USVRZXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiU0VSVkVSX1NIVVRET1dOXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiUEFSVElDSVBBTlRfUkVNT1ZFRFwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIlJPT01fREVMRVRFRFwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlNUQVRFX01JU01BVENIXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiSk9JTl9GQUlMVVJFXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiTUlHUkFUSU9OXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiU0lHTkFMX0NMT1NFXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcIlJPT01fQ0xPU0VEXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIlVTRVJfVU5BVkFJTEFCTEVcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwiVVNFUl9SRUpFQ1RFRFwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJTSVBfVFJVTktfRkFJTFVSRVwiXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJDT05ORUNUSU9OX1RJTUVPVVRcIlxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiTUVESUFfRkFJTFVSRVwiXG59XSk7XG5jb25zdCBSZWNvbm5lY3RSZWFzb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlJlY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJSUl9VTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlJSX1BVQkxJU0hFUl9GQUlMRURcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIlxufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uRXJyb3IgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlNFX1VOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlNFX1RSQUNLX05PVEZPVU5EXCJcbn1dKTtcbmNvbnN0IEF1ZGlvVHJhY2tGZWF0dXJlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5BdWRpb1RyYWNrRmVhdHVyZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJURl9TVEVSRU9cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJURl9OT19EVFhcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJURl9BVVRPX0dBSU5fQ09OVFJPTFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlRGX0VDSE9fQ0FOQ0VMTEFUSU9OXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiVEZfTk9JU0VfU1VQUFJFU1NJT05cIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJURl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT05cIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJURl9QUkVDT05ORUNUX0JVRkZFUlwiXG59XSk7XG5jb25zdCBSb29tJDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJlbXB0eV90aW1lb3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJkZXBhcnR1cmVfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtYXhfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImNyZWF0aW9uX3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJjcmVhdGlvbl90aW1lX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJ0dXJuX3Bhc3N3b3JkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZW5hYmxlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIm51bV9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm51bV9wdWJsaXNoZXJzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJhY3RpdmVfcmVjb3JkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lZFZlcnNpb25cbn1dKTtcbmNvbnN0IENvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29kZWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibWltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImZtdHBfbGluZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBQYXJ0aWNpcGFudFBlcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFBlcm1pc3Npb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2FuX3N1YnNjcmliZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJjYW5fcHVibGlzaFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9kYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNhbl9wdWJsaXNoX3NvdXJjZXNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImhpZGRlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJyZWNvcmRlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiY2FuX3VwZGF0ZV9tZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiYWdlbnRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcImNhbl9zdWJzY3JpYmVfbWV0cmljc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImlkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhdGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fU3RhdGUpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImpvaW5lZF9hdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcImpvaW5lZF9hdF9tc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwZXJtaXNzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFBlcm1pc3Npb25cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJpc19wdWJsaXNoZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImtpbmRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fS2luZClcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcImRpc2Nvbm5lY3RfcmVhc29uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGlzY29ubmVjdFJlYXNvbilcbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcImtpbmRfZGV0YWlsc1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19LaW5kRGV0YWlsKSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50SW5mb19TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkpPSU5JTkdcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJKT0lORURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJBQ1RJVkVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJESVNDT05ORUNURURcIlxufV0pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvX0tpbmQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5LaW5kXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlNUQU5EQVJEXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSU5HUkVTU1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkVHUkVTU1wiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlNJUFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIkFHRU5UXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiQ09OTkVDVE9SXCJcbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50SW5mb19LaW5kRGV0YWlsID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uS2luZERldGFpbFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJDTE9VRF9BR0VOVFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkZPUldBUkRFRFwiXG59XSk7XG5jb25zdCBFbmNyeXB0aW9uX1R5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkVuY3J5cHRpb24uVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJOT05FXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiR0NNXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQ1VTVE9NXCJcbn1dKTtcbmNvbnN0IFNpbXVsY2FzdENvZGVjSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInZpZGVvX2xheWVyX21vZGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb0xheWVyX01vZGUpXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInNkcF9jaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgVHJhY2tJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInR5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtdXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwic2ltdWxjYXN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImRpc2FibGVfZHR4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInNvdXJjZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcIm1pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJjb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpbXVsY2FzdENvZGVjSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInN0ZXJlb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcImVuY3J5cHRpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJzdHJlYW1cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTgsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZWRWZXJzaW9uXG59LCB7XG4gIG5vOiAxOSxcbiAgbmFtZTogXCJhdWRpb19mZWF0dXJlc1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIwLFxuICBuYW1lOiBcImJhY2t1cF9jb2RlY19wb2xpY3lcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShCYWNrdXBDb2RlY1BvbGljeSQxKVxufV0pO1xuY29uc3QgVmlkZW9MYXllciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlZpZGVvTGF5ZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYml0cmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJzc3JjXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInNwYXRpYWxfbGF5ZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBWaWRlb0xheWVyX01vZGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlZpZGVvTGF5ZXIuTW9kZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJNT0RFX1VOVVNFRFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk9ORV9TUEFUSUFMX0xBWUVSX1BFUl9TVFJFQU1cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJNVUxUSVBMRV9TUEFUSUFMX0xBWUVSU19QRVJfU1RSRUFNXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiT05FX1NQQVRJQUxfTEFZRVJfUEVSX1NUUkVBTV9JTkNPTVBMRVRFX1JUQ1BfU1JcIlxufV0pO1xuY29uc3QgRGF0YVBhY2tldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFQYWNrZXRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwia2luZFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZClcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVzZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVzZXJQYWNrZXQsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3BlYWtlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQWN0aXZlU3BlYWtlclVwZGF0ZSxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzaXBfZHRtZlwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2lwRFRNRixcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJ0cmFuc2NyaXB0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFuc2NyaXB0aW9uLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcIm1ldHJpY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE1ldHJpY3NCYXRjaCxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJjaGF0X21lc3NhZ2VcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENoYXRNZXNzYWdlLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJycGNfcmVxdWVzdFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUnBjUmVxdWVzdCxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwicnBjX2Fja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUnBjQWNrLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJycGNfcmVzcG9uc2VcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY1Jlc3BvbnNlLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJzdHJlYW1faGVhZGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX0hlYWRlcixcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwic3RyZWFtX2NodW5rXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX0NodW5rLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJzdHJlYW1fdHJhaWxlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YVN0cmVhbV9UcmFpbGVyLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJlbmNyeXB0ZWRfcGFja2V0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBFbmNyeXB0ZWRQYWNrZXQsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcInNlcXVlbmNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgRGF0YVBhY2tldF9LaW5kID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5EYXRhUGFja2V0LktpbmRcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUkVMSUFCTEVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJMT1NTWVwiXG59XSk7XG5jb25zdCBFbmNyeXB0ZWRQYWNrZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5FbmNyeXB0ZWRQYWNrZXRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiZW5jcnlwdGlvbl90eXBlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJpdlwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImtleV9pbmRleFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJlbmNyeXB0ZWRfdmFsdWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xufV0pO1xuY29uc3QgRW5jcnlwdGVkUGFja2V0UGF5bG9hZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkVuY3J5cHRlZFBhY2tldFBheWxvYWRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXNlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXNlclBhY2tldCxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjaGF0X21lc3NhZ2VcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENoYXRNZXNzYWdlLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInJwY19yZXF1ZXN0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBScGNSZXF1ZXN0LFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInJwY19hY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY0FjayxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJycGNfcmVzcG9uc2VcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY1Jlc3BvbnNlLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInN0cmVhbV9oZWFkZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fSGVhZGVyLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInN0cmVhbV9jaHVua1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YVN0cmVhbV9DaHVuayxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJzdHJlYW1fdHJhaWxlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YVN0cmVhbV9UcmFpbGVyLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59XSk7XG5jb25zdCBBY3RpdmVTcGVha2VyVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzcGVha2Vyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3BlYWtlckluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTcGVha2VySW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNwZWFrZXJJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImxldmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhY3RpdmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFVzZXJQYWNrZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Vc2VyUGFja2V0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGF5bG9hZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRlc3RpbmF0aW9uX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGVzdGluYXRpb25faWRlbnRpdGllc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ0b3BpY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInN0YXJ0X3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJlbmRfdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm5vbmNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn1dKTtcbmNvbnN0IFNpcERUTUYgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaXBEVE1GXCIsICgpID0+IFt7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNvZGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZGlnaXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgVHJhbnNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYW5zY3JpcHRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhbnNjcmliZWRfcGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNlZ21lbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFuc2NyaXB0aW9uU2VnbWVudCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFRyYW5zY3JpcHRpb25TZWdtZW50ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhbnNjcmlwdGlvblNlZ21lbnRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhcnRfdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0XG4gIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImVuZF90aW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDRcbiAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZmluYWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwibGFuZ3VhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgQ2hhdE1lc3NhZ2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5DaGF0TWVzc2FnZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZWRpdF90aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJkZWxldGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImdlbmVyYXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgUnBjUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY1JlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtZXRob2RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXlsb2FkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicmVzcG9uc2VfdGltZW91dF9tc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBScGNBY2sgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNBY2tcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBScGNSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY1Jlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlcXVlc3RfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXlsb2FkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZXJyb3JcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY0Vycm9yJDEsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn1dKTtcbmNvbnN0IFJwY0Vycm9yJDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNFcnJvclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50VHJhY2tzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGFydGljaXBhbnRUcmFja3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU2VydmVySW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNlcnZlckluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiZWRpdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbilcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInByb3RvY29sXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJub2RlX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGVidWdfaW5mb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImFnZW50X3Byb3RvY29sXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuY29uc3QgU2VydmVySW5mb19FZGl0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5TZXJ2ZXJJbmZvLkVkaXRpb25cIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiU3RhbmRhcmRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJDbG91ZFwiXG59XSk7XG5jb25zdCBDbGllbnRJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ2xpZW50SW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzZGtcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRJbmZvX1NESylcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInByb3RvY29sXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJvc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm9zX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJkZXZpY2VfbW9kZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJicm93c2VyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiYnJvd3Nlcl92ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiYWRkcmVzc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJuZXR3b3JrXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm90aGVyX3Nka3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgQ2xpZW50SW5mb19TREsgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNsaWVudEluZm8uU0RLXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJKU1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlNXSUZUXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiQU5EUk9JRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIkZMVVRURVJcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJHT1wiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlVOSVRZXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiUkVBQ1RfTkFUSVZFXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiUlVTVFwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIlBZVEhPTlwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJDUFBcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiVU5JVFlfV0VCXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcIk5PREVcIlxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwiVU5SRUFMXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcIkVTUDMyXCJcbn1dKTtcbmNvbnN0IENsaWVudENvbmZpZ3VyYXRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5DbGllbnRDb25maWd1cmF0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInZpZGVvXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0NvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic2NyZWVuXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0NvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicmVzdW1lX2Nvbm5lY3Rpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkaXNhYmxlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERpc2FibGVkQ29kZWNzXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImZvcmNlX3JlbGF5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbn1dKTtcbmNvbnN0IFZpZGVvQ29uZmlndXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJoYXJkd2FyZV9lbmNvZGVyXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbn1dKTtcbmNvbnN0IERpc2FibGVkQ29kZWNzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGlzYWJsZWRDb2RlY3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicHVibGlzaFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUaW1lZFZlcnNpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UaW1lZFZlcnNpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidW5peF9taWNyb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGlja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59XSk7XG5jb25zdCBEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkRhdGFTdHJlYW0uT3BlcmF0aW9uVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJDUkVBVEVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJVUERBVEVcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJERUxFVEVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJSRUFDVElPTlwiXG59XSk7XG5jb25zdCBEYXRhU3RyZWFtX1RleHRIZWFkZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLlRleHRIZWFkZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwib3BlcmF0aW9uX3R5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInJlcGx5X3RvX3N0cmVhbV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImF0dGFjaGVkX3N0cmVhbV9pZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZ2VuZXJhdGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSwge1xuICBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9UZXh0SGVhZGVyXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9CeXRlSGVhZGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5CeXRlSGVhZGVyXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fQnl0ZUhlYWRlclwiXG59KTtcbmNvbnN0IERhdGFTdHJlYW1fSGVhZGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5IZWFkZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0b3BpY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1pbWVfdHlwZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInRvdGFsX2xlbmd0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZW5jcnlwdGlvbl90eXBlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXG4gIGtpbmQ6IFwibWFwXCIsXG4gIEs6IDksXG4gIFY6IHtcbiAgICBraW5kOiBcInNjYWxhclwiLFxuICAgIFQ6IDlcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICB9XG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInRleHRfaGVhZGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX1RleHRIZWFkZXIsXG4gIG9uZW9mOiBcImNvbnRlbnRfaGVhZGVyXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImJ5dGVfaGVhZGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX0J5dGVIZWFkZXIsXG4gIG9uZW9mOiBcImNvbnRlbnRfaGVhZGVyXCJcbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX0hlYWRlclwiXG59KTtcbmNvbnN0IERhdGFTdHJlYW1fQ2h1bmsgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLkNodW5rXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0cmVhbV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNodW5rX2luZGV4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDRcbiAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY29udGVudFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIml2XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyLFxuICBvcHQ6IHRydWVcbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX0NodW5rXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9UcmFpbGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5UcmFpbGVyXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0cmVhbV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJlYXNvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX1RyYWlsZXJcIlxufSk7XG5jb25zdCBGaWx0ZXJQYXJhbXMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5GaWx0ZXJQYXJhbXNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaW5jbHVkZV9ldmVudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZXhjbHVkZV9ldmVudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFdlYmhvb2tDb25maWcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5XZWJob29rQ29uZmlnXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInVybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInNpZ25pbmdfa2V5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZmlsdGVyX3BhcmFtc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRmlsdGVyUGFyYW1zXG59XSk7XG5jb25zdCBTdWJzY3JpYmVkQXVkaW9Db2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRBdWRpb0NvZGVjXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNvZGVjXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZW5hYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgUm9vbUFnZW50RGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tQWdlbnREaXNwYXRjaFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJhZ2VudF9uYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgRW5jb2RlZEZpbGVUeXBlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5FbmNvZGVkRmlsZVR5cGVcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiREVGQVVMVF9GSUxFVFlQRVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk1QNFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk9HR1wiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIk1QM1wiXG59XSk7XG5jb25zdCBTZWdtZW50ZWRGaWxlUHJvdG9jb2wgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlNlZ21lbnRlZEZpbGVQcm90b2NvbFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJERUZBVUxUX1NFR01FTlRFRF9GSUxFX1BST1RPQ09MXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSExTX1BST1RPQ09MXCJcbn1dKTtcbmNvbnN0IFNlZ21lbnRlZEZpbGVTdWZmaXggPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlNlZ21lbnRlZEZpbGVTdWZmaXhcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiSU5ERVhcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJUSU1FU1RBTVBcIlxufV0pO1xuY29uc3QgSW1hZ2VGaWxlU3VmZml4ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5JbWFnZUZpbGVTdWZmaXhcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiSU1BR0VfU1VGRklYX0lOREVYXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSU1BR0VfU1VGRklYX1RJTUVTVEFNUFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIklNQUdFX1NVRkZJWF9OT05FX09WRVJXUklURVwiXG59XSk7XG5jb25zdCBTdHJlYW1Qcm90b2NvbCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU3RyZWFtUHJvdG9jb2xcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiREVGQVVMVF9QUk9UT0NPTFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlJUTVBcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJTUlRcIlxufV0pO1xuY29uc3QgQXVkaW9NaXhpbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkF1ZGlvTWl4aW5nXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkRFRkFVTFRfTUlYSU5HXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiRFVBTF9DSEFOTkVMX0FHRU5UXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRFVBTF9DSEFOTkVMX0FMVEVSTkFURVwiXG59XSk7XG5jb25zdCBFbmNvZGluZ09wdGlvbnNQcmVzZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkVuY29kaW5nT3B0aW9uc1ByZXNldFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJIMjY0XzcyMFBfMzBcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJIMjY0XzcyMFBfNjBcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJIMjY0XzEwODBQXzMwXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiSDI2NF8xMDgwUF82MFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlBPUlRSQUlUX0gyNjRfNzIwUF8zMFwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIlBPUlRSQUlUX0gyNjRfNzIwUF82MFwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlBPUlRSQUlUX0gyNjRfMTA4MFBfMzBcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJQT1JUUkFJVF9IMjY0XzEwODBQXzYwXCJcbn1dKTtcbmNvbnN0IFJvb21Db21wb3NpdGVFZ3Jlc3NSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUm9vbUNvbXBvc2l0ZUVncmVzc1JlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicm9vbV9uYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibGF5b3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYXVkaW9fb25seVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiYXVkaW9fbWl4aW5nXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9NaXhpbmcpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInZpZGVvX29ubHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiY3VzdG9tX2Jhc2VfdXJsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZmlsZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRW5jb2RlZEZpbGVPdXRwdXQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInN0cmVhbVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3RyZWFtT3V0cHV0LFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwic2VnbWVudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlZ21lbnRlZEZpbGVPdXRwdXQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInByZXNldFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY29kaW5nT3B0aW9uc1ByZXNldCksXG4gIG9uZW9mOiBcIm9wdGlvbnNcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJhZHZhbmNlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRW5jb2RpbmdPcHRpb25zLFxuICBvbmVvZjogXCJvcHRpb25zXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcImZpbGVfb3V0cHV0c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRW5jb2RlZEZpbGVPdXRwdXQsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzdHJlYW1fb3V0cHV0c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3RyZWFtT3V0cHV0LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic2VnbWVudF9vdXRwdXRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiaW1hZ2Vfb3V0cHV0c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogSW1hZ2VPdXRwdXQsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJ3ZWJob29rc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogV2ViaG9va0NvbmZpZyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IEVuY29kZWRGaWxlT3V0cHV0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRW5jb2RlZEZpbGVPdXRwdXRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiZmlsZV90eXBlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jb2RlZEZpbGVUeXBlKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJmaWxlcGF0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRpc2FibGVfbWFuaWZlc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiczNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFMzVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJnY3BcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEdDUFVwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiYXp1cmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEF6dXJlQmxvYlVwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYWxpT1NTXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBbGlPU1NVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59XSk7XG5jb25zdCBTZWdtZW50ZWRGaWxlT3V0cHV0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2VnbWVudGVkRmlsZU91dHB1dFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlZ21lbnRlZEZpbGVQcm90b2NvbClcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZmlsZW5hbWVfcHJlZml4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicGxheWxpc3RfbmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJsaXZlX3BsYXlsaXN0X25hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZWdtZW50X2R1cmF0aW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJmaWxlbmFtZV9zdWZmaXhcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTZWdtZW50ZWRGaWxlU3VmZml4KVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJkaXNhYmxlX21hbmlmZXN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInMzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTM1VwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZ2NwXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBHQ1BVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImF6dXJlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBenVyZUJsb2JVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImFsaU9TU1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQWxpT1NTVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufV0pO1xuY29uc3QgSW1hZ2VPdXRwdXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5JbWFnZU91dHB1dFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYXB0dXJlX2ludGVydmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImZpbGVuYW1lX3ByZWZpeFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImZpbGVuYW1lX3N1ZmZpeFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEltYWdlRmlsZVN1ZmZpeClcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiaW1hZ2VfY29kZWNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShJbWFnZUNvZGVjKVxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkaXNhYmxlX21hbmlmZXN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInMzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTM1VwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiZ2NwXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBHQ1BVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJhenVyZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQXp1cmVCbG9iVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiYWxpT1NTXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBbGlPU1NVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59XSk7XG5jb25zdCBTM1VwbG9hZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlMzVXBsb2FkXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFjY2Vzc19rZXlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzZWNyZXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwic2Vzc2lvbl90b2tlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJhc3N1bWVfcm9sZV9hcm5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwiYXNzdW1lX3JvbGVfZXh0ZXJuYWxfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJlbmRwb2ludFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImJ1Y2tldFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImZvcmNlX3BhdGhfc3R5bGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwidGFnZ2luZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNvbnRlbnRfZGlzcG9zaXRpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwicHJveHlcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFByb3h5Q29uZmlnXG59XSk7XG5jb25zdCBHQ1BVcGxvYWQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5HQ1BVcGxvYWRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY3JlZGVudGlhbHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJidWNrZXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwcm94eVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUHJveHlDb25maWdcbn1dKTtcbmNvbnN0IEF6dXJlQmxvYlVwbG9hZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkF6dXJlQmxvYlVwbG9hZFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJhY2NvdW50X25hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhY2NvdW50X2tleVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNvbnRhaW5lcl9uYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IEFsaU9TU1VwbG9hZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkFsaU9TU1VwbG9hZFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJhY2Nlc3Nfa2V5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic2VjcmV0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZW5kcG9pbnRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJidWNrZXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgUHJveHlDb25maWcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Qcm94eUNvbmZpZ1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1c2VybmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInBhc3N3b3JkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFN0cmVhbU91dHB1dCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN0cmVhbU91dHB1dFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFN0cmVhbVByb3RvY29sKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1cmxzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBFbmNvZGluZ09wdGlvbnMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5FbmNvZGluZ09wdGlvbnNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGVwdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImZyYW1lcmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiYXVkaW9fY29kZWNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb0NvZGVjKVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJhdWRpb19iaXRyYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiYXVkaW9fcXVhbGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYXVkaW9fZnJlcXVlbmN5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJ2aWRlb19jb2RlY1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvQ29kZWMpXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInZpZGVvX2JpdHJhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJ2aWRlb19xdWFsaXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwia2V5X2ZyYW1lX2ludGVydmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDFcbiAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn1dKTtcbmNvbnN0IEF1dG9QYXJ0aWNpcGFudEVncmVzcyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkF1dG9QYXJ0aWNpcGFudEVncmVzc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwcmVzZXRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNvZGluZ09wdGlvbnNQcmVzZXQpLFxuICBvbmVvZjogXCJvcHRpb25zXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYWR2YW5jZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEVuY29kaW5nT3B0aW9ucyxcbiAgb25lb2Y6IFwib3B0aW9uc1wiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImZpbGVfb3V0cHV0c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRW5jb2RlZEZpbGVPdXRwdXQsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNlZ21lbnRfb3V0cHV0c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2VnbWVudGVkRmlsZU91dHB1dCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IEF1dG9UcmFja0VncmVzcyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkF1dG9UcmFja0VncmVzc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJmaWxlcGF0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImRpc2FibGVfbWFuaWZlc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiczNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFMzVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJnY3BcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEdDUFVwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYXp1cmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEF6dXJlQmxvYlVwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiYWxpT1NTXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBbGlPU1NVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59XSk7XG5jb25zdCBSb29tRWdyZXNzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUm9vbUVncmVzc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tQ29tcG9zaXRlRWdyZXNzUmVxdWVzdFxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQXV0b1BhcnRpY2lwYW50RWdyZXNzXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQXV0b1RyYWNrRWdyZXNzXG59XSk7XG5jb25zdCBSb29tQ29uZmlndXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21Db25maWd1cmF0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlbXB0eV90aW1lb3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRlcGFydHVyZV90aW1lb3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1heF9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZWdyZXNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tRWdyZXNzXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcIm1pbl9wbGF5b3V0X2RlbGF5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcIm1heF9wbGF5b3V0X2RlbGF5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInN5bmNfc3RyZWFtc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiYWdlbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tQWdlbnREaXNwYXRjaCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFNpZ25hbFRhcmdldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU2lnbmFsVGFyZ2V0XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBVQkxJU0hFUlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlNVQlNDUklCRVJcIlxufV0pO1xuY29uc3QgU3RyZWFtU3RhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlN0cmVhbVN0YXRlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkFDVElWRVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlBBVVNFRFwiXG59XSk7XG5jb25zdCBDYW5kaWRhdGVQcm90b2NvbCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQ2FuZGlkYXRlUHJvdG9jb2xcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVURQXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiVENQXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiVExTXCJcbn1dKTtcbmNvbnN0IFNpZ25hbFJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaWduYWxSZXF1ZXN0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbnN3ZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyaWNrbGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYWRkX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBZGRUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJtdXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVTdWJzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJ0cmFja19zZXR0aW5nXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVUcmFja1NldHRpbmdzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibGVhdmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IExlYXZlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJ1cGRhdGVfbGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVWaWRlb0xheWVycyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzeW5jX3N0YXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTeW5jU3RhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic2ltdWxhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpbXVsYXRlU2NlbmFyaW8sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwicGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInVwZGF0ZV9tZXRhZGF0YVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJwaW5nX3JlcVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGluZyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJ1cGRhdGVfYXVkaW9fdHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJ1cGRhdGVfdmlkZW9fdHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZUxvY2FsVmlkZW9UcmFjayxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59XSk7XG5jb25zdCBTaWduYWxSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpZ25hbFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImpvaW5cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEpvaW5SZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwib2ZmZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyaWNrbGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInRyYWNrX3B1Ymxpc2hlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImxlYXZlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBMZWF2ZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJtdXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInNwZWFrZXJzX2NoYW5nZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJzQ2hhbmdlZCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJyb29tX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJjb25uZWN0aW9uX3F1YWxpdHlcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN0cmVhbVN0YXRlVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0eV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJyZWZyZXNoX3Rva2VuXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTcsXG4gIG5hbWU6IFwidHJhY2tfdW5wdWJsaXNoZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJwb25nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTksXG4gIG5hbWU6IFwicmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWNvbm5lY3RSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMCxcbiAgbmFtZTogXCJwb25nX3Jlc3BcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBvbmcsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjEsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Jlc3BvbnNlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpcHRpb25SZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMixcbiAgbmFtZTogXCJyZXF1ZXN0X3Jlc3BvbnNlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZXF1ZXN0UmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjMsXG4gIG5hbWU6IFwidHJhY2tfc3Vic2NyaWJlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tTdWJzY3JpYmVkLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDI0LFxuICBuYW1lOiBcInJvb21fbW92ZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb21Nb3ZlZFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDI1LFxuICBuYW1lOiBcIm1lZGlhX3NlY3Rpb25zX3JlcXVpcmVtZW50XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNZWRpYVNlY3Rpb25zUmVxdWlyZW1lbnQsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjYsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9hdWRpb19jb2RlY191cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRBdWRpb0NvZGVjVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn1dKTtcbmNvbnN0IFNpbXVsY2FzdENvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInZpZGVvX2xheWVyX21vZGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb0xheWVyX01vZGUpXG59XSk7XG5jb25zdCBBZGRUcmFja1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5BZGRUcmFja1JlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInR5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJtdXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkaXNhYmxlX2R0eFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJzb3VyY2VcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSlcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwic2ltdWxjYXN0X2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxjYXN0Q29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwic3RlcmVvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJkaXNhYmxlX3JlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiZW5jcnlwdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInN0cmVhbVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJiYWNrdXBfY29kZWNfcG9saWN5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQmFja3VwQ29kZWNQb2xpY3kkMSlcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcImF1ZGlvX2ZlYXR1cmVzXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9UcmFja0ZlYXR1cmUpLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVHJpY2tsZVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Ucmlja2xlUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYW5kaWRhdGVJbml0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGFyZ2V0XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJmaW5hbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgTXV0ZVRyYWNrUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibXV0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IEpvaW5SZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkpvaW5SZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tJDFcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGFydGljaXBhbnRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mb1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJvdGhlcl9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2VydmVyX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJpY2Vfc2VydmVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogSUNFU2VydmVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzdWJzY3JpYmVyX3ByaW1hcnlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYWx0ZXJuYXRpdmVfdXJsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENsaWVudENvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic2VydmVyX3JlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJwaW5nX3RpbWVvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwaW5nX2ludGVydmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwic2VydmVyX2luZm9cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlcnZlckluZm9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInNpZl90cmFpbGVyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImVuYWJsZWRfcHVibGlzaF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiZmFzdF9wdWJsaXNoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBSZWNvbm5lY3RSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImljZV9zZXJ2ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBJQ0VTZXJ2ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDbGllbnRDb25maWd1cmF0aW9uXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInNlcnZlcl9pbmZvXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXJ2ZXJJbmZvXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImxhc3RfbWVzc2FnZV9zZXFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja0luZm9cbn1dKTtcbmNvbnN0IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgU2Vzc2lvbkRlc2NyaXB0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInR5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzZHBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtaWRfdG9fdHJhY2tfaWRcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50VXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGFydGljaXBhbnRVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBVcGRhdGVTdWJzY3JpcHRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVTdWJzY3JpcHRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpYmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfdHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFRyYWNrcyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFVwZGF0ZVRyYWNrU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVUcmFja1NldHRpbmdzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGlzYWJsZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZnBzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInByaW9yaXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBVcGRhdGVMb2NhbEF1ZGlvVHJhY2sgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVMb2NhbEF1ZGlvVHJhY2tcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZmVhdHVyZXNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb1RyYWNrRmVhdHVyZSksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBVcGRhdGVMb2NhbFZpZGVvVHJhY2sgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVMb2NhbFZpZGVvVHJhY2tcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBMZWF2ZVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2FuX3JlY29ubmVjdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJyZWFzb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhY3Rpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShMZWF2ZVJlcXVlc3RfQWN0aW9uKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZWdpb25zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWdpb25TZXR0aW5nc1xufV0pO1xuY29uc3QgTGVhdmVSZXF1ZXN0X0FjdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuTGVhdmVSZXF1ZXN0LkFjdGlvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJESVNDT05ORUNUXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUkVTVU1FXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiUkVDT05ORUNUXCJcbn1dKTtcbmNvbnN0IFVwZGF0ZVZpZGVvTGF5ZXJzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXBkYXRlVmlkZW9MYXllcnNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGFcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYXR0cmlidXRlc1wiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBJQ0VTZXJ2ZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5JQ0VTZXJ2ZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXJsc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1c2VybmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNyZWRlbnRpYWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgU3BlYWtlcnNDaGFuZ2VkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3BlYWtlcnNDaGFuZ2VkXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNwZWFrZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTcGVha2VySW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFJvb21VcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tVXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb20kMVxufV0pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInF1YWxpdHlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDb25uZWN0aW9uUXVhbGl0eSQxKVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzY29yZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAyXG4gIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cbn1dKTtcbmNvbnN0IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXBkYXRlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29ubmVjdGlvblF1YWxpdHlJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3RyZWFtU3RhdGVJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3RyZWFtU3RhdGVJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN0YXRlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpXG59XSk7XG5jb25zdCBTdHJlYW1TdGF0ZVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN0cmVhbVN0YXRlVXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN0cmVhbVN0YXRlSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFN1YnNjcmliZWRRdWFsaXR5ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlbmFibGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBTdWJzY3JpYmVkQ29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJxdWFsaXRpZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdGllc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN1YnNjcmliZWRfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTdWJzY3JpYmVkQXVkaW9Db2RlY1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRBdWRpb0NvZGVjVXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmliZWRfYXVkaW9fY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkQXVkaW9Db2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFRyYWNrUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrUGVybWlzc2lvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbGxfdHJhY2tzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiYWxsX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja19wZXJtaXNzaW9uc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQZXJtaXNzaW9uLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYWxsb3dlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgUm9vbU1vdmVkUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tTW92ZWRSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tJDFcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidG9rZW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm90aGVyX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3luY1N0YXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3luY1N0YXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmlwdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlU3Vic2NyaXB0aW9uXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInB1Ymxpc2hfdHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkYXRhX2NoYW5uZWxzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhQ2hhbm5lbEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb25cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwidHJhY2tfc2lkc19kaXNhYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkYXRhY2hhbm5lbF9yZWNlaXZlX3N0YXRlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YUNoYW5uZWxSZWNlaXZlU3RhdGUsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBEYXRhQ2hhbm5lbFJlY2VpdmVTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFDaGFubmVsUmVjZWl2ZVN0YXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInB1Ymxpc2hlcl9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJsYXN0X3NlcVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufV0pO1xuY29uc3QgRGF0YUNoYW5uZWxJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YUNoYW5uZWxJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImxhYmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidGFyZ2V0XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxufV0pO1xuY29uc3QgU2ltdWxhdGVTY2VuYXJpbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpbXVsYXRlU2NlbmFyaW9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcl91cGRhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJub2RlX2ZhaWx1cmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJtaWdyYXRpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZXJ2ZXJfbGVhdmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJzd2l0Y2hfY2FuZGlkYXRlX3Byb3RvY29sXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmliZXJfYmFuZHdpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibGVhdmVfcmVxdWVzdF9mdWxsX3JlY29ubmVjdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59XSk7XG5jb25zdCBQaW5nID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGluZ1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJ0dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn1dKTtcbmNvbnN0IFBvbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Qb25nXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImxhc3RfcGluZ190aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn1dKTtcbmNvbnN0IFJlZ2lvblNldHRpbmdzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVnaW9uU2V0dGluZ3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVnaW9uc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUmVnaW9uSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFJlZ2lvbkluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5SZWdpb25JbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRpc3RhbmNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlcnJcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdWJzY3JpcHRpb25FcnJvcilcbn1dKTtcbmNvbnN0IFJlcXVlc3RSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlcXVlc3RSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJlYXNvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFJlcXVlc3RSZXNwb25zZV9SZWFzb24pXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ0cmlja2xlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmlja2xlUmVxdWVzdCxcbiAgb25lb2Y6IFwicmVxdWVzdFwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImFkZF90cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQWRkVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJyZXF1ZXN0XCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwibXV0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTXV0ZVRyYWNrUmVxdWVzdCxcbiAgb25lb2Y6IFwicmVxdWVzdFwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInVwZGF0ZV9tZXRhZGF0YVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSxcbiAgb25lb2Y6IFwicmVxdWVzdFwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInVwZGF0ZV9hdWRpb190cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlTG9jYWxBdWRpb1RyYWNrLFxuICBvbmVvZjogXCJyZXF1ZXN0XCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwidXBkYXRlX3ZpZGVvX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVMb2NhbFZpZGVvVHJhY2ssXG4gIG9uZW9mOiBcInJlcXVlc3RcIlxufV0pO1xuY29uc3QgUmVxdWVzdFJlc3BvbnNlX1JlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUmVxdWVzdFJlc3BvbnNlLlJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJPS1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk5PVF9GT1VORFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk5PVF9BTExPV0VEXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiTElNSVRfRVhDRUVERURcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJRVUVVRURcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJVTlNVUFBPUlRFRF9UWVBFXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiVU5DTEFTU0lGSUVEX0VSUk9SXCJcbn1dKTtcbmNvbnN0IFRyYWNrU3Vic2NyaWJlZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrU3Vic2NyaWJlZFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgQ29ubmVjdGlvblNldHRpbmdzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29ubmVjdGlvblNldHRpbmdzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImF1dG9fc3Vic2NyaWJlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFkYXB0aXZlX3N0cmVhbVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzdWJzY3JpYmVyX2FsbG93X3BhdXNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkaXNhYmxlX2ljZV9saXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBKb2luUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkpvaW5SZXF1ZXN0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNsaWVudF9pbmZvXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDbGllbnRJbmZvXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNvbm5lY3Rpb25fc2V0dGluZ3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvbm5lY3Rpb25TZXR0aW5nc1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2F0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiYWRkX3RyYWNrX3JlcXVlc3RzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBZGRUcmFja1JlcXVlc3QsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInB1Ymxpc2hlcl9vZmZlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInJlY29ubmVjdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJyZWNvbm5lY3RfcmVhc29uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUmVjb25uZWN0UmVhc29uKVxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwic3luY19zdGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3luY1N0YXRlXG59XSk7XG5jb25zdCBXcmFwcGVkSm9pblJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5XcmFwcGVkSm9pblJlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29tcHJlc3Npb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShXcmFwcGVkSm9pblJlcXVlc3RfQ29tcHJlc3Npb24pXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImpvaW5fcmVxdWVzdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59XSk7XG5jb25zdCBXcmFwcGVkSm9pblJlcXVlc3RfQ29tcHJlc3Npb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LldyYXBwZWRKb2luUmVxdWVzdC5Db21wcmVzc2lvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJOT05FXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiR1pJUFwiXG59XSk7XG5jb25zdCBNZWRpYVNlY3Rpb25zUmVxdWlyZW1lbnQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5NZWRpYVNlY3Rpb25zUmVxdWlyZW1lbnRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibnVtX2F1ZGlvc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJudW1fdmlkZW9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBUb2tlblNvdXJjZVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Ub2tlblNvdXJjZVJlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicm9vbV9uYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9uYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfbWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2F0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwicm9vbV9jb25maWdcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb21Db25maWd1cmF0aW9uLFxuICBvcHQ6IHRydWVcbn1dKTtcbmNvbnN0IFRva2VuU291cmNlUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Ub2tlblNvdXJjZVJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNlcnZlcl91cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF90b2tlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBsb2dsZXZlbCQxID0ge2V4cG9ydHM6IHt9fTtcblxuLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xudmFyIGxvZ2xldmVsID0gbG9nbGV2ZWwkMS5leHBvcnRzO1xudmFyIGhhc1JlcXVpcmVkTG9nbGV2ZWw7XG5mdW5jdGlvbiByZXF1aXJlTG9nbGV2ZWwoKSB7XG4gIGlmIChoYXNSZXF1aXJlZExvZ2xldmVsKSByZXR1cm4gbG9nbGV2ZWwkMS5leHBvcnRzO1xuICBoYXNSZXF1aXJlZExvZ2xldmVsID0gMTtcbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAoZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcblxuICAgICAgaWYgKG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgICB9XG4gICAgfSkobG9nbGV2ZWwsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgICAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIHZhciBpc0lFID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJiB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSAmJiAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgbG9nTWV0aG9kcyA9IFtcInRyYWNlXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xuICAgICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG51bGw7XG5cbiAgICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcygpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGFjdHVhbCBtZXRob2RzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IGkgPCBsZXZlbCA/IG5vb3AgOiB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcblxuICAgICAgICAvLyBSZXR1cm4gYW55IGltcG9ydGFudCB3YXJuaW5ncy5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgdGhpcy5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgX2xldmVsLCBfbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fCBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZmFjdG9yeSkge1xuICAgICAgICAvLyBQcml2YXRlIGluc3RhbmNlIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxldmVsIGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IGxvZ2dlciAob3IgYSBnbG9iYWwgZGVmYXVsdCkuIFdlXG4gICAgICAgICAqIGNhY2hlIHRoaXMgaGVyZSByYXRoZXIgdGhhbiBkZWxlZ2F0aW5nIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBzdGF5c1xuICAgICAgICAgKiBpbiBzeW5jIHdpdGggdGhlIGFjdHVhbCBsb2dnaW5nIG1ldGhvZHMgdGhhdCB3ZSBoYXZlIGluc3RhbGxlZCAodGhlXG4gICAgICAgICAqIHBhcmVudCBjb3VsZCBjaGFuZ2UgbGV2ZWxzIGJ1dCB3ZSBtaWdodCBub3QgaGF2ZSByZWJ1aWx0IHRoZSBsb2dnZXJzXG4gICAgICAgICAqIGluIHRoaXMgY2hpbGQgeWV0KS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpbmhlcml0ZWRMZXZlbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGxldmVsIGZvciB0aGlzIGxvZ2dlciwgaWYgYW55LiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgICAqIGBpbmhlcml0ZWRMZXZlbGAuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBkZWZhdWx0TGV2ZWw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVzZXItc3BlY2lmaWMgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgICAqIGBkZWZhdWx0TGV2ZWxgLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdXNlckxldmVsO1xuICAgICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICBzdG9yYWdlS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICB2YXIgY29va2llTmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoY29va2llTmFtZSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbiArIGNvb2tpZU5hbWUubGVuZ3RoICsgMSkpWzFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxldmVsKGlucHV0KSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gaW5wdXQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICAgICAgc2VsZi5uYW1lID0gbmFtZTtcbiAgICAgICAgc2VsZi5sZXZlbHMgPSB7XG4gICAgICAgICAgXCJUUkFDRVwiOiAwLFxuICAgICAgICAgIFwiREVCVUdcIjogMSxcbiAgICAgICAgICBcIklORk9cIjogMixcbiAgICAgICAgICBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsXG4gICAgICAgICAgXCJTSUxFTlRcIjogNVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuICAgICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh1c2VyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJMZXZlbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExldmVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdGVkTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZSh1c2VyTGV2ZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5PVEU6IGluIHYyLCB0aGlzIHNob3VsZCBjYWxsIHJlYnVpbGQoKSwgd2hpY2ggdXBkYXRlcyBjaGlsZHJlbi5cbiAgICAgICAgICByZXR1cm4gcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgZGVmYXVsdExldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG51bGw7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgPT09IHNlbGYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBfbG9nZ2Vyc0J5TmFtZSkge1xuICAgICAgICAgICAgICBfbG9nZ2Vyc0J5TmFtZVtjaGlsZE5hbWVdLnJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgdGhlIGludGVybmFsIGxldmVscy5cbiAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyID8gZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpIDogXCJXQVJOXCIpO1xuICAgICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgICAgaWYgKGluaXRpYWxMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwoaW5pdGlhbExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG4gICAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihuYW1lLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICB9O1xuXG4gICAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICAgIHZhciBfbG9nID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICAgIH07XG4gICAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgICB9O1xuXG4gICAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xuICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfSk7XG4gIH0pKGxvZ2xldmVsJDEpO1xuICByZXR1cm4gbG9nbGV2ZWwkMS5leHBvcnRzO1xufVxuXG52YXIgbG9nbGV2ZWxFeHBvcnRzID0gcmVxdWlyZUxvZ2xldmVsKCk7XG5cbnZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ0cmFjZVwiXSA9IDBdID0gXCJ0cmFjZVwiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImRlYnVnXCJdID0gMV0gPSBcImRlYnVnXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiaW5mb1wiXSA9IDJdID0gXCJpbmZvXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wid2FyblwiXSA9IDNdID0gXCJ3YXJuXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiZXJyb3JcIl0gPSA0XSA9IFwiZXJyb3JcIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJzaWxlbnRcIl0gPSA1XSA9IFwic2lsZW50XCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xudmFyIExvZ2dlck5hbWVzO1xuKGZ1bmN0aW9uIChMb2dnZXJOYW1lcykge1xuICBMb2dnZXJOYW1lc1tcIkRlZmF1bHRcIl0gPSBcImxpdmVraXRcIjtcbiAgTG9nZ2VyTmFtZXNbXCJSb29tXCJdID0gXCJsaXZla2l0LXJvb21cIjtcbiAgTG9nZ2VyTmFtZXNbXCJUb2tlblNvdXJjZVwiXSA9IFwibGl2ZWtpdC10b2tlbi1zb3VyY2VcIjtcbiAgTG9nZ2VyTmFtZXNbXCJQYXJ0aWNpcGFudFwiXSA9IFwibGl2ZWtpdC1wYXJ0aWNpcGFudFwiO1xuICBMb2dnZXJOYW1lc1tcIlRyYWNrXCJdID0gXCJsaXZla2l0LXRyYWNrXCI7XG4gIExvZ2dlck5hbWVzW1wiUHVibGljYXRpb25cIl0gPSBcImxpdmVraXQtdHJhY2stcHVibGljYXRpb25cIjtcbiAgTG9nZ2VyTmFtZXNbXCJFbmdpbmVcIl0gPSBcImxpdmVraXQtZW5naW5lXCI7XG4gIExvZ2dlck5hbWVzW1wiU2lnbmFsXCJdID0gXCJsaXZla2l0LXNpZ25hbFwiO1xuICBMb2dnZXJOYW1lc1tcIlBDTWFuYWdlclwiXSA9IFwibGl2ZWtpdC1wYy1tYW5hZ2VyXCI7XG4gIExvZ2dlck5hbWVzW1wiUENUcmFuc3BvcnRcIl0gPSBcImxpdmVraXQtcGMtdHJhbnNwb3J0XCI7XG4gIExvZ2dlck5hbWVzW1wiRTJFRVwiXSA9IFwibGstZTJlZVwiO1xufSkoTG9nZ2VyTmFtZXMgfHwgKExvZ2dlck5hbWVzID0ge30pKTtcbmxldCBsaXZla2l0TG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcignbGl2ZWtpdCcpO1xuY29uc3QgbGl2ZWtpdExvZ2dlcnMgPSBPYmplY3QudmFsdWVzKExvZ2dlck5hbWVzKS5tYXAobmFtZSA9PiBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKG5hbWUpKTtcbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgY29uc3QgbG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihuYW1lKTtcbiAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsaXZla2l0TG9nZ2VyLmdldExldmVsKCkpO1xuICByZXR1cm4gbG9nZ2VyO1xufVxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgaWYgKGxvZ2dlck5hbWUpIHtcbiAgICBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKGxvZ2dlck5hbWUpLnNldExldmVsKGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGxvZ2dlciBvZiBsaXZla2l0TG9nZ2Vycykge1xuICAgICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogdXNlIHRoaXMgdG8gaG9vayBpbnRvIHRoZSBsb2dnaW5nIGZ1bmN0aW9uIHRvIGFsbG93IHNlbmRpbmcgaW50ZXJuYWwgbGl2ZWtpdCBsb2dzIHRvIHRoaXJkIHBhcnR5IHNlcnZpY2VzXG4gKiBpZiBzZXQsIHRoZSBicm93c2VyIGxvZ3Mgd2lsbCBsb3NlIHRoZWlyIHN0YWNrdHJhY2UgaW5mb3JtYXRpb24gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwjd3JpdGluZy1wbHVnaW5zKVxuICovXG5mdW5jdGlvbiBzZXRMb2dFeHRlbnNpb24oZXh0ZW5zaW9uLCBsb2dnZXIpIHtcbiAgY29uc3QgbG9nZ2VycyA9IGxvZ2dlciA/IFtsb2dnZXJdIDogbGl2ZWtpdExvZ2dlcnM7XG4gIGxvZ2dlcnMuZm9yRWFjaChsb2dSID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEZhY3RvcnkgPSBsb2dSLm1ldGhvZEZhY3Rvcnk7XG4gICAgbG9nUi5tZXRob2RGYWN0b3J5ID0gKG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgY29uc3QgbG9nTGV2ZWwgPSBMb2dMZXZlbFttZXRob2ROYW1lXTtcbiAgICAgIGNvbnN0IG5lZWRMb2cgPSBsb2dMZXZlbCA+PSBjb25maWdMZXZlbCAmJiBsb2dMZXZlbCA8IExvZ0xldmVsLnNpbGVudDtcbiAgICAgIHJldHVybiAobXNnLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0KSByYXdNZXRob2QobXNnLCBjb250ZXh0KTtlbHNlIHJhd01ldGhvZChtc2cpO1xuICAgICAgICBpZiAobmVlZExvZykge1xuICAgICAgICAgIGV4dGVuc2lvbihsb2dMZXZlbCwgbXNnLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGxvZ1Iuc2V0TGV2ZWwobG9nUi5nZXRMZXZlbCgpKTtcbiAgfSk7XG59XG5jb25zdCB3b3JrZXJMb2dnZXIgPSBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKCdsay1lMmVlJyk7XG5cbmNvbnN0IG1heFJldHJ5RGVsYXkgPSA3MDAwO1xuY29uc3QgREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVMgPSBbMCwgMzAwLCAyICogMiAqIDMwMCwgMyAqIDMgKiAzMDAsIDQgKiA0ICogMzAwLCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5XTtcbmNsYXNzIERlZmF1bHRSZWNvbm5lY3RQb2xpY3kge1xuICBjb25zdHJ1Y3RvcihyZXRyeURlbGF5cykge1xuICAgIHRoaXMuX3JldHJ5RGVsYXlzID0gcmV0cnlEZWxheXMgIT09IHVuZGVmaW5lZCA/IFsuLi5yZXRyeURlbGF5c10gOiBERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUztcbiAgfVxuICBuZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LnJldHJ5Q291bnQgPj0gdGhpcy5fcmV0cnlEZWxheXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXRyeURlbGF5ID0gdGhpcy5fcmV0cnlEZWxheXNbY29udGV4dC5yZXRyeUNvdW50XTtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50IDw9IDEpIHJldHVybiByZXRyeURlbGF5O1xuICAgIHJldHVybiByZXRyeURlbGF5ICsgTWF0aC5yYW5kb20oKSAqIDEwMDA7XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGV2ZW50cyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBoYXNSZXF1aXJlZEV2ZW50cztcbmZ1bmN0aW9uIHJlcXVpcmVFdmVudHMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEV2ZW50cykgcmV0dXJuIGV2ZW50cy5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEV2ZW50cyA9IDE7XG4gIHZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGw7XG4gIHZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nID8gUi5hcHBseSA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9O1xuICB2YXIgUmVmbGVjdE93bktleXM7XG4gIGlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5cztcbiAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgfVxuICB2YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9O1xuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbiAgfVxuICBldmVudHMuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgZXZlbnRzLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbiAgLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbiAgLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4gIC8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4gIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG4gIGZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG4gIEV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH1cbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuICAvLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICAgIH1cbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBmdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB2YXIgZG9FcnJvciA9IHR5cGUgPT09ICdlcnJvcic7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO2Vsc2UgaWYgKCFkb0Vycm9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgaWYgKGRvRXJyb3IpIHtcbiAgICAgIHZhciBlcjtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGVyID0gYXJnc1swXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBmdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICAgIHZhciBtO1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIGV4aXN0aW5nO1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgICB9XG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgICB9XG4gICAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgKyAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKyAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gIH07XG4gIGZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICAgIGlmICghdGhpcy5maXJlZCkge1xuICAgICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGZpcmVkOiBmYWxzZSxcbiAgICAgIHdyYXBGbjogdW5kZWZpbmVkLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICAgIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICAgIHJldHVybiB3cmFwcGVkO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcG9zaXRpb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCAwKSByZXR1cm4gdGhpcztcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCkgbGlzdC5zaGlmdCgpO2Vsc2Uge1xuICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG4gICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuICAgIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgICB9XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG4gIGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xuICB9O1xuICBmdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBjb3B5W2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBjb3B5O1xuICB9XG4gIGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICAgIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gICAgbGlzdC5wb3AoKTtcbiAgfVxuICBmdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cy5leHBvcnRzO1xufVxuXG52YXIgZXZlbnRzRXhwb3J0cyA9IHJlcXVpcmVFdmVudHMoKTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxubGV0IGxvZ0Rpc2FibGVkXyA9IHRydWU7XG5sZXQgZGVwcmVjYXRpb25XYXJuaW5nc18gPSB0cnVlO1xuXG4vKipcbiAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSB1YXN0cmluZyB1c2VyQWdlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7IW51bWJlcn0gYnJvd3NlciB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBleHRyYWN0VmVyc2lvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gIGNvbnN0IG1hdGNoID0gdWFzdHJpbmcubWF0Y2goZXhwcik7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gcG9zICYmIHBhcnNlRmxvYXQobWF0Y2hbcG9zXSwgMTApO1xufVxuXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxuLy8gdGhlIGV2ZW50KS5cbmZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3QgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLmFkZEV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEV2ZW50ID0gd3JhcHBlcihlKTtcbiAgICAgIGlmIChtb2RpZmllZEV2ZW50KSB7XG4gICAgICAgIGlmIChjYi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgIGNiLmhhbmRsZUV2ZW50KG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9ldmVudE1hcCA9IHRoaXMuX2V2ZW50TWFwIHx8IHt9O1xuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zZXQoY2IsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgd3JhcHBlZENhbGxiYWNrXSk7XG4gIH07XG4gIGNvbnN0IG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyO1xuICBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXAgfHwgIXRoaXMuX2V2ZW50TWFwIHx8ICF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uaGFzKGNiKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgdW53cmFwcGVkQ2IgPSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmdldChjYik7XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB1bndyYXBwZWRDYl0pO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzYWJsZUxvZyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgcmV0dXJuIGJvb2wgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG59XG5cbi8qKlxuICogRGlzYWJsZSBvciBlbmFibGUgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZVdhcm5pbmdzKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XG59XG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlZChvbGRNZXRob2QsIG5ld01ldGhvZCkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ3NfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihvbGRNZXRob2QgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIG5ld01ldGhvZCArICcgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGRldGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICogICAgIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBicm93c2VyOiBudWxsLFxuICAgIHZlcnNpb246IG51bGxcbiAgfTtcblxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHwgIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hdmlnYXRvclxuICB9ID0gd2luZG93O1xuXG4gIC8vIFByZWZlciBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5cbiAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmJyYW5kcykge1xuICAgIGNvbnN0IGNocm9taXVtID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuYnJhbmRzLmZpbmQoYnJhbmQgPT4ge1xuICAgICAgcmV0dXJuIGJyYW5kLmJyYW5kID09PSAnQ2hyb21pdW0nO1xuICAgIH0pO1xuICAgIGlmIChjaHJvbWl1bSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnJvd3NlcjogJ2Nocm9tZScsXG4gICAgICAgIHZlcnNpb246IHBhcnNlSW50KGNocm9taXVtLnZlcnNpb24sIDEwKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBGaXJlZm94LlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2ZpcmVmb3gnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gcGFyc2VJbnQoZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0ZpcmVmb3hcXC8oXFxkKylcXC4vLCAxKSk7XG4gIH0gZWxzZSBpZiAobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ID09PSBmYWxzZSAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxuICAgIC8vIENocm9tZSA3NCByZW1vdmVkIHdlYmtpdEdldFVzZXJNZWRpYSBvbiBodHRwIGFzIHdlbGwgc28gd2UgbmVlZCB0aGVcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBwYXJzZUludChleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMikpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7XG4gICAgLy8gU2FmYXJpLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBwYXJzZUludChleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKSk7XG4gICAgcmVzdWx0LnN1cHBvcnRzVW5pZmllZFBsYW4gPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgJiYgJ2N1cnJlbnREaXJlY3Rpb24nIGluIHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGU7XG4gICAgLy8gT25seSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgcmVzdWx0Ll9zYWZhcmlWZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL1ZlcnNpb25cXC8oXFxkKyhcXC4/XFxkKykpLywgMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBmYWxsdGhyb3VnaDogbm90IHN1cHBvcnRlZC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBzdXBwb3J0ZWQgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgc29tZXRoaW5nIHlvdSB3YW50IHRvIGNoZWNrLlxuICogQHJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QkMSh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIGZyb20gYSBuZXN0ZWQgb2JqZWN0IC0tIGFuIGVuaGFuY2VkIGFuZCB2YW5pbGxhIHZlcnNpb25cbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QkMShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBrZXkpIHtcbiAgICBjb25zdCBpc09iaiA9IGlzT2JqZWN0JDEoZGF0YVtrZXldKTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzT2JqID8gY29tcGFjdE9iamVjdChkYXRhW2tleV0pIDogZGF0YVtrZXldO1xuICAgIGNvbnN0IGlzRW1wdHlPYmplY3QgPSBpc09iaiAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc0VtcHR5T2JqZWN0KSB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjY3VtdWxhdG9yLCB7XG4gICAgICBba2V5XTogdmFsdWVcbiAgICB9KTtcbiAgfSwge30pO1xufVxuXG4vKiBpdGVyYXRlcyB0aGUgc3RhdHMgZ3JhcGggcmVjdXJzaXZlbHkuICovXG5mdW5jdGlvbiB3YWxrU3RhdHMoc3RhdHMsIGJhc2UsIHJlc3VsdFNldCkge1xuICBpZiAoIWJhc2UgfHwgcmVzdWx0U2V0LmhhcyhiYXNlLmlkKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXN1bHRTZXQuc2V0KGJhc2UuaWQsIGJhc2UpO1xuICBPYmplY3Qua2V5cyhiYXNlKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKCdJZCcpKSB7XG4gICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChiYXNlW25hbWVdKSwgcmVzdWx0U2V0KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkcycpKSB7XG4gICAgICBiYXNlW25hbWVdLmZvckVhY2goaWQgPT4ge1xuICAgICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChpZCksIHJlc3VsdFNldCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBmaWx0ZXIgZ2V0U3RhdHMgZm9yIGEgc2VuZGVyL3JlY2VpdmVyIHRyYWNrLiAqL1xuZnVuY3Rpb24gZmlsdGVyU3RhdHMocmVzdWx0LCB0cmFjaywgb3V0Ym91bmQpIHtcbiAgY29uc3Qgc3RyZWFtU3RhdHNUeXBlID0gb3V0Ym91bmQgPyAnb3V0Ym91bmQtcnRwJyA6ICdpbmJvdW5kLXJ0cCc7XG4gIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gbmV3IE1hcCgpO1xuICBpZiAodHJhY2sgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG4gIH1cbiAgY29uc3QgdHJhY2tTdGF0cyA9IFtdO1xuICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICd0cmFjaycgJiYgdmFsdWUudHJhY2tJZGVudGlmaWVyID09PSB0cmFjay5pZCkge1xuICAgICAgdHJhY2tTdGF0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICB0cmFja1N0YXRzLmZvckVhY2godHJhY2tTdGF0ID0+IHtcbiAgICByZXN1bHQuZm9yRWFjaChzdGF0cyA9PiB7XG4gICAgICBpZiAoc3RhdHMudHlwZSA9PT0gc3RyZWFtU3RhdHNUeXBlICYmIHN0YXRzLnRyYWNrSWQgPT09IHRyYWNrU3RhdC5pZCkge1xuICAgICAgICB3YWxrU3RhdHMocmVzdWx0LCBzdGF0cywgZmlsdGVyZWRSZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuY29uc3QgbG9nZ2luZyA9IGxvZztcbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEkMih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29uc3RyYWludHNUb0Nocm9tZV8gPSBmdW5jdGlvbiAoYykge1xuICAgIGlmICh0eXBlb2YgYyAhPT0gJ29iamVjdCcgfHwgYy5tYW5kYXRvcnkgfHwgYy5vcHRpb25hbCkge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGNvbnN0IGNjID0ge307XG4gICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlcXVpcmUnIHx8IGtleSA9PT0gJ2FkdmFuY2VkJyB8fCBrZXkgPT09ICdtZWRpYVNvdXJjZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgciA9IHR5cGVvZiBjW2tleV0gPT09ICdvYmplY3QnID8gY1trZXldIDoge1xuICAgICAgICBpZGVhbDogY1trZXldXG4gICAgICB9O1xuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgci5taW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRuYW1lXyA9IGZ1bmN0aW9uIChwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2RldmljZUlkJyA/ICdzb3VyY2VJZCcgOiBuYW1lO1xuICAgICAgfTtcbiAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2Mub3B0aW9uYWwgPSBjYy5vcHRpb25hbCB8fCBbXTtcbiAgICAgICAgbGV0IG9jID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygci5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWluJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICAgIG9jID0ge307XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21heCcsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXygnJywga2V5KV0gPSByLmV4YWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWydtaW4nLCAnbWF4J10uZm9yRWFjaChtaXggPT4ge1xuICAgICAgICAgIGlmIChyW21peF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKG1peCwga2V5KV0gPSByW21peF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYy5hZHZhbmNlZCkge1xuICAgICAgY2Mub3B0aW9uYWwgPSAoY2Mub3B0aW9uYWwgfHwgW10pLmNvbmNhdChjLmFkdmFuY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNjO1xuICB9O1xuICBjb25zdCBzaGltQ29uc3RyYWludHNfID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBmdW5jKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjEpIHtcbiAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIHR5cGVvZiBjb25zdHJhaW50cy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24gKG9iaiwgYSwgYikge1xuICAgICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnZ29vZ0F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ2dvb2dOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLmF1ZGlvKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIFNoaW0gZmFjaW5nTW9kZSBmb3IgbW9iaWxlICYgc3VyZmFjZSBwcm8uXG4gICAgICBsZXQgZmFjZSA9IGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICBmYWNlID0gZmFjZSAmJiAodHlwZW9mIGZhY2UgPT09ICdvYmplY3QnID8gZmFjZSA6IHtcbiAgICAgICAgaWRlYWw6IGZhY2VcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjY7XG4gICAgICBpZiAoZmFjZSAmJiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpICYmICEobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZmFjaW5nTW9kZSAmJiAhZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMpKSB7XG4gICAgICAgIGRlbGV0ZSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2JhY2snLCAncmVhciddO1xuICAgICAgICB9IGVsc2UgaWYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydmcm9udCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgLy8gTG9vayBmb3IgbWF0Y2hlcyBpbiBsYWJlbCwgb3IgdXNlIGxhc3QgY2FtIGZvciBiYWNrICh0eXBpY2FsKS5cbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihkZXZpY2VzID0+IHtcbiAgICAgICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkID0+IGQua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKTtcbiAgICAgICAgICAgIGxldCBkZXYgPSBkZXZpY2VzLmZpbmQoZCA9PiBtYXRjaGVzLnNvbWUobWF0Y2ggPT4gZC5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG1hdGNoKSkpO1xuICAgICAgICAgICAgaWYgKCFkZXYgJiYgZGV2aWNlcy5sZW5ndGggJiYgbWF0Y2hlcy5pbmNsdWRlcygnYmFjaycpKSB7XG4gICAgICAgICAgICAgIGRldiA9IGRldmljZXNbZGV2aWNlcy5sZW5ndGggLSAxXTsgLy8gbW9yZSBsaWtlbHkgdGhlIGJhY2sgY2FtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2KSB7XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gZmFjZS5leGFjdCA/IHtcbiAgICAgICAgICAgICAgICBleGFjdDogZGV2LmRldmljZUlkXG4gICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgaWRlYWw6IGRldi5kZXZpY2VJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgICAgICAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICB9XG4gICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gIH07XG4gIGNvbnN0IHNoaW1FcnJvcl8gPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY0KSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgUGVybWlzc2lvbkRpc21pc3NlZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgSW52YWxpZFN0YXRlRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBEZXZpY2VzTm90Rm91bmRFcnJvcjogJ05vdEZvdW5kRXJyb3InLFxuICAgICAgICBDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3I6ICdPdmVyY29uc3RyYWluZWRFcnJvcicsXG4gICAgICAgIFRyYWNrU3RhcnRFcnJvcjogJ05vdFJlYWRhYmxlRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUtpbGxTd2l0Y2hPbjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFRhYkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBTY3JlZW5DYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgRGV2aWNlQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnQgfHwgZS5jb25zdHJhaW50TmFtZSxcbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgKHRoaXMubWVzc2FnZSAmJiAnOiAnKSArIHRoaXMubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBnZXRVc2VyTWVkaWFfID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBjID0+IHtcbiAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoYywgb25TdWNjZXNzLCBlID0+IHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGdldFVzZXJNZWRpYV8uYmluZChuYXZpZ2F0b3IpO1xuXG4gIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcbiAgLy8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGl0IGRvZXMgbm90IGFjY2VwdCBzcGVjLXN0eWxlXG4gIC8vIGNvbnN0cmFpbnRzLlxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBjb25zdCBvcmlnR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjcykge1xuICAgICAgcmV0dXJuIHNoaW1Db25zdHJhaW50c18oY3MsIGMgPT4gb3JpZ0dldFVzZXJNZWRpYShjKS50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgIGlmIChjLmF1ZGlvICYmICFzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggfHwgYy52aWRlbyAmJiAhc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJycsICdOb3RGb3VuZEVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sIGUgPT4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSkpKTtcbiAgICB9O1xuICB9XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5mdW5jdGlvbiBzaGltTWVkaWFTdHJlYW0od2luZG93KSB7XG4gIHdpbmRvdy5NZWRpYVN0cmVhbSA9IHdpbmRvdy5NZWRpYVN0cmVhbSB8fCB3aW5kb3cud2Via2l0TWVkaWFTdHJlYW07XG59XG5mdW5jdGlvbiBzaGltT25UcmFjayQxKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ29udHJhY2snIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb250cmFjaztcbiAgICAgIH0sXG4gICAgICBzZXQoZikge1xuICAgICAgICBpZiAodGhpcy5fb250cmFjaykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fb250cmFja3BvbHkpIHtcbiAgICAgICAgdGhpcy5fb250cmFja3BvbHkgPSBlID0+IHtcbiAgICAgICAgICAvLyBvbmFkZHN0cmVhbSBkb2VzIG5vdCBmaXJlIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhbiBleGlzdGluZ1xuICAgICAgICAgIC8vIHN0cmVhbS4gQnV0IHN0cmVhbS5vbmFkZHRyYWNrIGlzIGltcGxlbWVudGVkIHNvIHdlIHVzZSB0aGF0LlxuICAgICAgICAgIGUuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5nZXRSZWNlaXZlcnMoKS5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0ZS50cmFjay5pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHtcbiAgICAgICAgICAgICAgICB0cmFjazogdGUudHJhY2tcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0ZS50cmFjaztcbiAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpLmZpbmQociA9PiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRyYWNrLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0ge1xuICAgICAgICAgICAgICAgIHRyYWNrXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGV2ZW4gaWYgUlRDUnRwVHJhbnNjZWl2ZXIgaXMgaW4gd2luZG93LCBpdCBpcyBvbmx5IHVzZWQgYW5kXG4gICAgLy8gZW1pdHRlZCBpbiB1bmlmaWVkLXBsYW4uIFVuZm9ydHVuYXRlbHkgdGhpcyBtZWFucyB3ZSBuZWVkXG4gICAgLy8gdG8gdW5jb25kaXRpb25hbGx5IHdyYXAgdGhlIGV2ZW50LlxuICAgIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBpZiAoIWUudHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgcmVjZWl2ZXI6IGUucmVjZWl2ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KSB7XG4gIC8vIE92ZXJyaWRlcyBhZGRUcmFjay9yZW1vdmVUcmFjaywgZGVwZW5kcyBvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjay5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSAmJiAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIGNvbnN0IHNoaW1TZW5kZXJXaXRoRHRtZiA9IGZ1bmN0aW9uIChwYywgdHJhY2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNrLFxuICAgICAgICBnZXQgZHRtZigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gcGMuY3JlYXRlRFRNRlNlbmRlcih0cmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICAgIH0sXG4gICAgICAgIF9wYzogcGNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGF1Z21lbnQgYWRkVHJhY2sgd2hlbiBnZXRTZW5kZXJzIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZGVycy5zbGljZSgpOyAvLyByZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgIH07XG4gICAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICAgICAgbGV0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIXNlbmRlcikge1xuICAgICAgICAgIHNlbmRlciA9IHNoaW1TZW5kZXJXaXRoRHRtZih0aGlzLCB0cmFjayk7XG4gICAgICAgICAgdGhpcy5fc2VuZGVycy5wdXNoKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH07XG4gICAgICBjb25zdCBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgICAgICBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2VuZGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgdGhpcy5fc2VuZGVycy5wdXNoKHNoaW1TZW5kZXJXaXRoRHRtZih0aGlzLCB0cmFjaykpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAvLyByZW1vdmUgc2VuZGVyXG4gICAgICAgICAgdGhpcy5fc2VuZGVycy5zcGxpY2UodGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlciksIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJiAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyICYmICEoJ2R0bWYnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSwgJ2R0bWYnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gdGhpcy5fcGMuY3JlYXRlRFRNRlNlbmRlcih0aGlzLnRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgd2luZG93LlJUQ1J0cFJlY2VpdmVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gc2VuZGVyIHN0YXRzLlxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICAgIGlmIChvcmlnR2V0U2VuZGVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICBjb25zdCBzZW5kZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT5cbiAgICAgIC8qIE5vdGU6IHRoaXMgd2lsbCBpbmNsdWRlIHN0YXRzIG9mIGFsbCBzZW5kZXJzIHRoYXRcbiAgICAgICAqICAgc2VuZCBhIHRyYWNrIHdpdGggdGhlIHNhbWUgaWQgYXMgc2VuZGVyLnRyYWNrIGFzXG4gICAgICAgKiAgIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSB0aGUgUlRDUnRwU2VuZGVyLlxuICAgICAgICovXG4gICAgICBmaWx0ZXJTdGF0cyhyZXN1bHQsIHNlbmRlci50cmFjaywgdHJ1ZSkpO1xuICAgIH07XG4gIH1cblxuICAvLyBzaGltIHJlY2VpdmVyIHN0YXRzLlxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICAgIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgICAgfTtcbiAgICB9XG4gICAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gICAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT4gZmlsdGVyU3RhdHMocmVzdWx0LCByZWNlaXZlci50cmFjaywgZmFsc2UpKTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHModHJhY2spLlxuICBjb25zdCBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGxldCBzZW5kZXI7XG4gICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICBsZXQgZXJyO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzID0+IHtcbiAgICAgICAgaWYgKHMudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZGVyID0gcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKHIgPT4ge1xuICAgICAgICBpZiAoci50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAocmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY2VpdmVyID0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoZXJyIHx8IHNlbmRlciAmJiByZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignVGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VuZGVyKSB7XG4gICAgICAgIHJldHVybiBzZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignVGhlcmUgaXMgbm8gc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdykge1xuICAvLyBzaGltIGFkZFRyYWNrL3JlbW92ZVRyYWNrIHdpdGggbmF0aXZlIHZhcmlhbnRzIGluIG9yZGVyIHRvIG1ha2VcbiAgLy8gdGhlIGludGVyYWN0aW9ucyB3aXRoIGxlZ2FjeSBnZXRMb2NhbFN0cmVhbXMgYmVoYXZlIGFzIGluIG90aGVyIGJyb3dzZXJzLlxuICAvLyBLZWVwcyBhIG1hcHBpbmcgc3RyZWFtLmlkID0+IFtzdHJlYW0sIHJ0cHNlbmRlcnMuLi5dXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5tYXAoc3RyZWFtSWQgPT4gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF1bMF0pO1xuICB9O1xuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICByZXR1cm4gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtLCBzZW5kZXJdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLmluZGV4T2Yoc2VuZGVyKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5wdXNoKHNlbmRlcik7XG4gICAgfVxuICAgIHJldHVybiBzZW5kZXI7XG4gIH07XG4gIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZXhpc3RpbmdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCk7XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGNvbnN0IG5ld1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKS5maWx0ZXIobmV3U2VuZGVyID0+IGV4aXN0aW5nU2VuZGVycy5pbmRleE9mKG5ld1NlbmRlcikgPT09IC0xKTtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtXS5jb25jYXQobmV3U2VuZGVycyk7XG4gIH07XG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICByZXR1cm4gb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBjb25zdCBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgaWYgKHNlbmRlcikge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykuZm9yRWFjaChzdHJlYW1JZCA9PiB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzaGltIGFkZFRyYWNrIGFuZCByZW1vdmVUcmFjay5cbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NSkge1xuICAgIHJldHVybiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KTtcbiAgfVxuXG4gIC8vIGFsc28gc2hpbSBwYy5nZXRMb2NhbFN0cmVhbXMgd2hlbiBhZGRUcmFjayBpcyBzaGltbWVkXG4gIC8vIHRvIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyZWFtcy5cbiAgY29uc3Qgb3JpZ0dldExvY2FsU3RyZWFtcyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICBjb25zdCBuYXRpdmVTdHJlYW1zID0gb3JpZ0dldExvY2FsU3RyZWFtcy5hcHBseSh0aGlzKTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIHJldHVybiBuYXRpdmVTdHJlYW1zLm1hcChzdHJlYW0gPT4gdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gIH07XG4gIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgaWRlbnRpdHkgbWFwcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBhZGRUcmFjay5cbiAgICAvLyBVbmxlc3MgdGhpcyBpcyBiZWluZyB1c2VkIHdpdGggYSBzdHJlYW0gZnJvbSBhZGRUcmFjay5cbiAgICBpZiAoIXRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oc3RyZWFtLmdldFRyYWNrcygpKTtcbiAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgfVxuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICB9O1xuICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdIHx8IHN0cmVhbV0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZXZlcnNlU3RyZWFtc1t0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPyB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0uaWQgOiBzdHJlYW0uaWRdO1xuICAgIGRlbGV0ZSB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF07XG4gIH07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyZWFtcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoc3RyZWFtcy5sZW5ndGggIT09IDEgfHwgIXN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkuZmluZCh0ID0+IHQgPT09IHRyYWNrKSkge1xuICAgICAgLy8gdGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCBidXQgYWxsIHdlIGNhbiBtYW5hZ2Ugd2l0aG91dFxuICAgICAgLy8gW1thc3NvY2lhdGVkIE1lZGlhU3RyZWFtc11dIGludGVybmFsIHNsb3QuXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgYWRhcHRlci5qcyBhZGRUcmFjayBwb2x5ZmlsbCBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlICcgKyAnIHN0cmVhbSB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0cmFjay4nLCAnTm90U3VwcG9ydGVkRXJyb3InKTtcbiAgICB9XG4gICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICB9XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICBjb25zdCBvbGRTdHJlYW0gPSB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgaWYgKG9sZFN0cmVhbSkge1xuICAgICAgLy8gdGhpcyBpcyB1c2luZyBvZGQgQ2hyb21lIGJlaGF2aW91ciwgdXNlIHdpdGggY2F1dGlvbjpcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD03ODE1XG4gICAgICAvLyBOb3RlOiB3ZSByZWx5IG9uIHRoZSBoaWdoLWxldmVsIGFkZFRyYWNrL2R0bWYgc2hpbSB0b1xuICAgICAgLy8gY3JlYXRlIHRoZSBzZW5kZXIgd2l0aCBhIGR0bWYgc2VuZGVyLlxuICAgICAgb2xkU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblxuICAgICAgLy8gVHJpZ2dlciBPTk4gYXN5bmMuXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShbdHJhY2tdKTtcbiAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICB0aGlzLmFkZFN0cmVhbShuZXdTdHJlYW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgfTtcblxuICAvLyByZXBsYWNlIHRoZSBpbnRlcm5hbCBzdHJlYW0gaWQgd2l0aCB0aGUgZXh0ZXJuYWwgb25lIGFuZFxuICAvLyB2aWNlIHZlcnNhLlxuICBmdW5jdGlvbiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcbiAgICAgIGNvbnN0IGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgY29uc3QgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGludGVybmFsU3RyZWFtLmlkLCAnZycpLCBleHRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoZXh0ZXJuYWxTdHJlYW0uaWQsICdnJyksIGludGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwXG4gICAgfSk7XG4gIH1cbiAgWydjcmVhdGVPZmZlcicsICdjcmVhdGVBbnN3ZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgY29uc3QgbWV0aG9kT2JqID0ge1xuICAgICAgW21ldGhvZF0oKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGNvbnN0IGlzTGVnYWN5Q2FsbCA9IGFyZ3VtZW50cy5sZW5ndGggJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgaWYgKGlzTGVnYWN5Q2FsbCkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBhcmdzWzBdLmFwcGx5KG51bGwsIFtkZXNjXSk7XG4gICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChhcmdzWzFdKSB7XG4gICAgICAgICAgICAgIGFyZ3NbMV0uYXBwbHkobnVsbCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBhcmd1bWVudHNbMl1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihkZXNjcmlwdGlvbiA9PiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbikpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gIH0pO1xuICBjb25zdCBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgIWFyZ3VtZW50c1swXS50eXBlKSB7XG4gICAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgYXJndW1lbnRzWzBdID0gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQodGhpcywgYXJndW1lbnRzWzBdKTtcbiAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBUT0RPOiBtYW5nbGUgZ2V0U3RhdHM6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RvbS1ydGNtZWRpYXN0cmVhbXN0YXRzLXN0cmVhbWlkZW50aWZpZXJcblxuICBjb25zdCBvcmlnTG9jYWxEZXNjcmlwdGlvbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJywge1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gb3JpZ0xvY2FsRGVzY3JpcHRpb24uZ2V0LmFwcGx5KHRoaXMpO1xuICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9KTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBub3QgeWV0IGNoZWNrIGZvciBzZW5kZXIgaW5zdGFuY2VvZiBSVENSdHBTZW5kZXJcbiAgICAvLyBzaW5jZSB3ZSBzaGltIFJUUFNlbmRlci4gU28gd2UgY2hlY2sgaWYgc2VuZGVyLl9wYyBpcyBzZXQuXG4gICAgaWYgKCFzZW5kZXIuX3BjKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdBcmd1bWVudCAxIG9mIFJUQ1BlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrICcgKyAnZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBSVENSdHBTZW5kZXIuJywgJ1R5cGVFcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBpc0xvY2FsID0gc2VuZGVyLl9wYyA9PT0gdGhpcztcbiAgICBpZiAoIWlzTG9jYWwpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbmRlciB3YXMgbm90IGNyZWF0ZWQgYnkgdGhpcyBjb25uZWN0aW9uLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuYXRpdmUgc3RyZWFtIHRoZSBzZW5kZXJzIHRyYWNrIGJlbG9uZ3MgdG8uXG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgbGV0IHN0cmVhbTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdHJlYW1zKS5mb3JFYWNoKHN0cmVhbWlkID0+IHtcbiAgICAgIGNvbnN0IGhhc1RyYWNrID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF0uZ2V0VHJhY2tzKCkuZmluZCh0cmFjayA9PiBzZW5kZXIudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChoYXNUcmFjaykge1xuICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICBpZiAoc3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBsYXN0IHRyYWNrIG9mIHRoZSBzdHJlYW0sIHJlbW92ZSB0aGUgc3RyZWFtLiBUaGlzXG4gICAgICAgIC8vIHRha2VzIGNhcmUgb2YgYW55IHNoaW1tZWQgX3NlbmRlcnMuXG4gICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtKHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVseWluZyBvbiB0aGUgc2FtZSBvZGQgY2hyb21lIGJlaGF2aW91ciBhcyBhYm92ZS5cbiAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHNlbmRlci50cmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24kMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gaW1wbGljaXQgY3JlYXRpb24gb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uL1JUQ0ljZUNhbmRpZGF0ZVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1xuICAgICAgICBbbWV0aG9kXSgpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScgPyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBBdHRlbXB0IHRvIGZpeCBPTk4gaW4gcGxhbi1iIG1vZGUuXG5mdW5jdGlvbiBmaXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ25lZ290aWF0aW9ubmVlZGVkJywgZSA9PiB7XG4gICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDcyIHx8IHBjLmdldENvbmZpZ3VyYXRpb24gJiYgcGMuZ2V0Q29uZmlndXJhdGlvbigpLnNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ3N0YWJsZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbnZhciBjaHJvbWVTaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGZpeE5lZ290aWF0aW9uTmVlZGVkOiBmaXhOZWdvdGlhdGlvbk5lZWRlZCxcbiAgc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2s6IHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLFxuICBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmU6IHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSxcbiAgc2hpbUdldFNlbmRlcnNXaXRoRHRtZjogc2hpbUdldFNlbmRlcnNXaXRoRHRtZixcbiAgc2hpbUdldFVzZXJNZWRpYTogc2hpbUdldFVzZXJNZWRpYSQyLFxuICBzaGltTWVkaWFTdHJlYW06IHNoaW1NZWRpYVN0cmVhbSxcbiAgc2hpbU9uVHJhY2s6IHNoaW1PblRyYWNrJDEsXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogc2hpbVBlZXJDb25uZWN0aW9uJDEsXG4gIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzOiBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0c1xufSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhJDEod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgTWVkaWFTdHJlYW1UcmFjayA9IHdpbmRvdyAmJiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaztcbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgLy8gUmVwbGFjZSBGaXJlZm94IDQ0KydzIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2l0aCB1bnByZWZpeGVkIHZlcnNpb24uXG4gICAgZGVwcmVjYXRlZCgnbmF2aWdhdG9yLmdldFVzZXJNZWRpYScsICduYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYScpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH07XG4gIGlmICghKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPiA1NSAmJiAnYXV0b0dhaW5Db250cm9sJyBpbiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkpKSB7XG4gICAgY29uc3QgcmVtYXAgPSBmdW5jdGlvbiAob2JqLCBhLCBiKSB7XG4gICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmF0aXZlR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAodHlwZW9mIGMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVHZXRVc2VyTWVkaWEoYyk7XG4gICAgfTtcbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncykge1xuICAgICAgY29uc3QgbmF0aXZlR2V0U2V0dGluZ3MgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBvYmogPSBuYXRpdmVHZXRTZXR0aW5ncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZW1hcChvYmosICdtb3pBdXRvR2FpbkNvbnRyb2wnLCAnYXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vek5vaXNlU3VwcHJlc3Npb24nLCAnbm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cykge1xuICAgICAgY29uc3QgbmF0aXZlQXBwbHlDb25zdHJhaW50cyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHM7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ2F1ZGlvJyAmJiB0eXBlb2YgYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgICAgICAgcmVtYXAoYywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgICByZW1hcChjLCAnbm9pc2VTdXBwcmVzc2lvbicsICdtb3pOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUFwcGx5Q29uc3RyYWludHMuYXBwbHkodGhpcywgW2NdKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5mdW5jdGlvbiBzaGltR2V0RGlzcGxheU1lZGlhKHdpbmRvdywgcHJlZmVycmVkTWVkaWFTb3VyY2UpIHtcbiAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmICdnZXREaXNwbGF5TWVkaWEnIGluIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID0gZnVuY3Rpb24gZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgaWYgKCEoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8pKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRE9NRXhjZXB0aW9uKCdnZXREaXNwbGF5TWVkaWEgd2l0aG91dCB2aWRlbyAnICsgJ2NvbnN0cmFpbnRzIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgZXJyLm5hbWUgPSAnTm90Rm91bmRFcnJvcic7XG4gICAgICAvLyBmcm9tIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1ET01FeGNlcHRpb24tZXJyb3ItbmFtZXNcbiAgICAgIGVyci5jb2RlID0gODtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMudmlkZW8gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0ge1xuICAgICAgICBtZWRpYVNvdXJjZTogcHJlZmVycmVkTWVkaWFTb3VyY2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1lZGlhU291cmNlID0gcHJlZmVycmVkTWVkaWFTb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICB9O1xufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjsgLy8gcHJvYmFibHkgbWVkaWEucGVlcmNvbm5lY3Rpb24uZW5hYmxlZD1mYWxzZSBpbiBhYm91dDpjb25maWdcbiAgfVxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgICAgW21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbW9kZXJuU3RhdHNUeXBlcyA9IHtcbiAgICBpbmJvdW5kcnRwOiAnaW5ib3VuZC1ydHAnLFxuICAgIG91dGJvdW5kcnRwOiAnb3V0Ym91bmQtcnRwJyxcbiAgICBjYW5kaWRhdGVwYWlyOiAnY2FuZGlkYXRlLXBhaXInLFxuICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICB9O1xuICBjb25zdCBuYXRpdmVHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBjb25zdCBbc2VsZWN0b3IsIG9uU3VjYywgb25FcnJdID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuYXRpdmVHZXRTdGF0cy5hcHBseSh0aGlzLCBbc2VsZWN0b3IgfHwgbnVsbF0pLnRoZW4oc3RhdHMgPT4ge1xuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MyAmJiAhb25TdWNjKSB7XG4gICAgICAgIC8vIFNoaW0gb25seSBwcm9taXNlIGdldFN0YXRzIHdpdGggc3BlYy1oeXBoZW5zIGluIHR5cGUgbmFtZXNcbiAgICAgICAgLy8gTGVhdmUgY2FsbGJhY2sgdmVyc2lvbiBhbG9uZTsgbWlzYyBvbGQgdXNlcyBvZiBmb3JFYWNoIGJlZm9yZSBNYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICAgICAgc3RhdC50eXBlID0gbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLm5hbWUgIT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBdm9pZCBUeXBlRXJyb3I6IFwidHlwZVwiIGlzIHJlYWQtb25seSwgaW4gb2xkIHZlcnNpb25zLiAzNC00M2lzaFxuICAgICAgICAgIHN0YXRzLmZvckVhY2goKHN0YXQsIGkpID0+IHtcbiAgICAgICAgICAgIHN0YXRzLnNldChpLCBPYmplY3QuYXNzaWduKHt9LCBzdGF0LCB7XG4gICAgICAgICAgICAgIHR5cGU6IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH0pLnRoZW4ob25TdWNjLCBvbkVycik7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcbiAgfVxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrID8gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjaykgOiBQcm9taXNlLnJlc29sdmUobmV3IE1hcCgpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgIH07XG4gIH1cbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG4gIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjayk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUmVtb3ZlU3RyZWFtKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCAncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIGRlcHJlY2F0ZWQoJ3JlbW92ZVN0cmVhbScsICdyZW1vdmVUcmFjaycpO1xuICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgIGlmIChzZW5kZXIudHJhY2sgJiYgc3RyZWFtLmdldFRyYWNrcygpLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdykge1xuICAvLyByZW5hbWUgRGF0YUNoYW5uZWwgdG8gUlRDRGF0YUNoYW5uZWwgKG5hdGl2ZSBmaXggaW4gRkY2MCk6XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExNzM4NTFcbiAgaWYgKHdpbmRvdy5EYXRhQ2hhbm5lbCAmJiAhd2luZG93LlJUQ0RhdGFDaGFubmVsKSB7XG4gICAgd2luZG93LlJUQ0RhdGFDaGFubmVsID0gd2luZG93LkRhdGFDaGFubmVsO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0FkZFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlcjtcbiAgaWYgKG9yaWdBZGRUcmFuc2NlaXZlcikge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIgPSBmdW5jdGlvbiBhZGRUcmFuc2NlaXZlcigpIHtcbiAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICAvLyBXZWJJREwgaW5wdXQgY29lcmNpb24gYW5kIHZhbGlkYXRpb25cbiAgICAgIGxldCBzZW5kRW5jb2RpbmdzID0gYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXS5zZW5kRW5jb2RpbmdzO1xuICAgICAgaWYgKHNlbmRFbmNvZGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZW5kRW5jb2RpbmdzID0gW107XG4gICAgICB9XG4gICAgICBzZW5kRW5jb2RpbmdzID0gWy4uLnNlbmRFbmNvZGluZ3NdO1xuICAgICAgY29uc3Qgc2hvdWxkUGVyZm9ybUNoZWNrID0gc2VuZEVuY29kaW5ncy5sZW5ndGggPiAwO1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAvLyBJZiBzZW5kRW5jb2RpbmdzIHBhcmFtcyBhcmUgcHJvdmlkZWQsIHZhbGlkYXRlIGdyYW1tYXJcbiAgICAgICAgc2VuZEVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nUGFyYW0gPT4ge1xuICAgICAgICAgIGlmICgncmlkJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBjb25zdCByaWRSZWdleCA9IC9eW2EtejAtOV17MCwxNn0kL2k7XG4gICAgICAgICAgICBpZiAoIXJpZFJlZ2V4LnRlc3QoZW5jb2RpbmdQYXJhbS5yaWQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgUklEIHZhbHVlIHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3NjYWxlUmVzb2x1dGlvbkRvd25CeScgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgPj0gMS4wKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2NhbGVfcmVzb2x1dGlvbl9kb3duX2J5IG11c3QgYmUgPj0gMS4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnbWF4RnJhbWVyYXRlJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0ubWF4RnJhbWVyYXRlKSA+PSAwKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWF4X2ZyYW1lcmF0ZSBtdXN0IGJlID49IDAuMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IG9yaWdBZGRUcmFuc2NlaXZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5pdCBvcHRpb25zIHdlcmUgYXBwbGllZC4gSWYgbm90IHdlIGRvIHRoaXMgaW4gYW5cbiAgICAgICAgLy8gYXN5bmNocm9ub3VzIHdheSBhbmQgc2F2ZSB0aGUgcHJvbWlzZSByZWZlcmVuY2UgaW4gYSBnbG9iYWwgb2JqZWN0LlxuICAgICAgICAvLyBUaGlzIGlzIGFuIHVnbHkgaGFjaywgYnV0IGF0IHRoZSBzYW1lIHRpbWUgaXMgd2F5IG1vcmUgcm9idXN0IHRoYW5cbiAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHNlbmRlciBwYXJhbWV0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNyZWF0ZU9mZmVyXG4gICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IGFmdGVyIHRoZSBjcmVhdGVvZmZlciB3ZSBhcmUgbm90IDEwMCUgc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBwYXJhbXMgd2VyZSBhc3luY2hyb25vdXNseSBhcHBsaWVkIHNvIHdlIG1pZ2h0IG1pc3MgdGhlXG4gICAgICAgIC8vIG9wcG9ydHVuaXR5IHRvIHJlY3JlYXRlIG9mZmVyLlxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VuZGVyXG4gICAgICAgIH0gPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSB8fFxuICAgICAgICAvLyBBdm9pZCBiZWluZyBmb29sZWQgYnkgcGF0Y2hlZCBnZXRQYXJhbWV0ZXJzKCkgYmVsb3cuXG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MubGVuZ3RoID09PSAxICYmIE9iamVjdC5rZXlzKHBhcmFtcy5lbmNvZGluZ3NbMF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIHNlbmRlci5zZW5kRW5jb2RpbmdzID0gc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5wdXNoKHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1HZXRQYXJhbWV0ZXJzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0UGFyYW1ldGVycyA9IHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFBhcmFtZXRlcnM7XG4gIGlmIChvcmlnR2V0UGFyYW1ldGVycykge1xuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gb3JpZ0dldFBhcmFtZXRlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IFtdLmNvbmNhdCh0aGlzLnNlbmRFbmNvZGluZ3MgfHwgW3t9XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgZmlyZWZveFNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc2hpbUFkZFRyYW5zY2VpdmVyOiBzaGltQWRkVHJhbnNjZWl2ZXIsXG4gIHNoaW1DcmVhdGVBbnN3ZXI6IHNoaW1DcmVhdGVBbnN3ZXIsXG4gIHNoaW1DcmVhdGVPZmZlcjogc2hpbUNyZWF0ZU9mZmVyLFxuICBzaGltR2V0RGlzcGxheU1lZGlhOiBzaGltR2V0RGlzcGxheU1lZGlhLFxuICBzaGltR2V0UGFyYW1ldGVyczogc2hpbUdldFBhcmFtZXRlcnMsXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEkMSxcbiAgc2hpbU9uVHJhY2s6IHNoaW1PblRyYWNrLFxuICBzaGltUGVlckNvbm5lY3Rpb246IHNoaW1QZWVyQ29ubmVjdGlvbixcbiAgc2hpbVJUQ0RhdGFDaGFubmVsOiBzaGltUlRDRGF0YUNoYW5uZWwsXG4gIHNoaW1SZWNlaXZlckdldFN0YXRzOiBzaGltUmVjZWl2ZXJHZXRTdGF0cyxcbiAgc2hpbVJlbW92ZVN0cmVhbTogc2hpbVJlbW92ZVN0cmVhbSxcbiAgc2hpbVNlbmRlckdldFN0YXRzOiBzaGltU2VuZGVyR2V0U3RhdHNcbn0pO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRMb2NhbFN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0cmVhbXM7XG4gICAgfTtcbiAgfVxuICBpZiAoISgnYWRkU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IF9hZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBlbXVsYXRlIENocm9tZSdzIGJlaGF2aW91ciBvZiBhZGRpbmcgaW4gYXVkaW8tdmlkZW8gb3JkZXIuXG4gICAgICAvLyBTYWZhcmkgb3JkZXJzIGJ5IHRyYWNrIGlkLlxuICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjaywgc3RyZWFtKSk7XG4gICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLCBzdHJlYW0pKTtcbiAgICB9O1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzdHJlYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW1zKSB7XG4gICAgICAgIHN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbc3RyZWFtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2NhbFN0cmVhbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgICAgaWYgKHRyYWNrcy5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldFJlbW90ZVN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zID0gZnVuY3Rpb24gZ2V0UmVtb3RlU3RyZWFtcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW1zID8gdGhpcy5fcmVtb3RlU3RyZWFtcyA6IFtdO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ29uYWRkc3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb25hZGRzdHJlYW0nLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbmFkZHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBzZXQoZikge1xuICAgICAgICBpZiAodGhpcy5fb25hZGRzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtID0gZik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBlID0+IHtcbiAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdGVTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgIGNvbnN0IHBjID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5fb25hZGRzdHJlYW1wb2x5KSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBjLl9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGMuX3JlbW90ZVN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseShwYywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSBwcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSBwcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICBjb25zdCBzZXRMb2NhbERlc2NyaXB0aW9uID0gcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIGNvbnN0IHNldFJlbW90ZURlc2NyaXB0aW9uID0gcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICBjb25zdCBhZGRJY2VDYW5kaWRhdGUgPSBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICBwcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgbGV0IHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gc2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBzZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIChjYW5kaWRhdGUsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IGFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBbY2FuZGlkYXRlXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IHdpdGhDYWxsYmFjaztcbn1cbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIC8vIHNoaW0gbm90IG5lZWRlZCBpbiBTYWZhcmkgMTIuMVxuICAgIGNvbnN0IG1lZGlhRGV2aWNlcyA9IG5hdmlnYXRvci5tZWRpYURldmljZXM7XG4gICAgY29uc3QgX2dldFVzZXJNZWRpYSA9IG1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYmluZChtZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gY29uc3RyYWludHMgPT4ge1xuICAgICAgcmV0dXJuIF9nZXRVc2VyTWVkaWEoc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSk7XG4gICAgfTtcbiAgfVxuICBpZiAoIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMsIGNiLCBlcnJjYikge1xuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4oY2IsIGVycmNiKTtcbiAgICB9LmJpbmQobmF2aWdhdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gIGlmIChjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzLCB7XG4gICAgICB2aWRlbzogY29tcGFjdE9iamVjdChjb25zdHJhaW50cy52aWRlbylcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG5mdW5jdGlvbiBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gbWlncmF0ZSBmcm9tIG5vbi1zcGVjIFJUQ0ljZVNlcnZlci51cmwgdG8gUlRDSWNlU2VydmVyLnVybHNcbiAgY29uc3QgT3JpZ1BlZXJDb25uZWN0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbiBSVENQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cykge1xuICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICBjb25zdCBuZXdJY2VTZXJ2ZXJzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBjQ29uZmlnLmljZVNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNlcnZlciA9IHBjQ29uZmlnLmljZVNlcnZlcnNbaV07XG4gICAgICAgIGlmIChzZXJ2ZXIudXJscyA9PT0gdW5kZWZpbmVkICYmIHNlcnZlci51cmwpIHtcbiAgICAgICAgICBkZXByZWNhdGVkKCdSVENJY2VTZXJ2ZXIudXJsJywgJ1JUQ0ljZVNlcnZlci51cmxzJyk7XG4gICAgICAgICAgc2VydmVyID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXJ2ZXIpKTtcbiAgICAgICAgICBzZXJ2ZXIudXJscyA9IHNlcnZlci51cmw7XG4gICAgICAgICAgZGVsZXRlIHNlcnZlci51cmw7XG4gICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHNlcnZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHBjQ29uZmlnLmljZVNlcnZlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwY0NvbmZpZy5pY2VTZXJ2ZXJzID0gbmV3SWNlU2VydmVycztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcmlnUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpO1xuICB9O1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlID0gT3JpZ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgLy8gd3JhcCBzdGF0aWMgbWV0aG9kcy4gQ3VycmVudGx5IGp1c3QgZ2VuZXJhdGVDZXJ0aWZpY2F0ZS5cbiAgaWYgKCdnZW5lcmF0ZUNlcnRpZmljYXRlJyBpbiBPcmlnUGVlckNvbm5lY3Rpb24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLCAnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE9yaWdQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyKHdpbmRvdykge1xuICAvLyBBZGQgZXZlbnQudHJhbnNjZWl2ZXIgbWVtYmVyIG92ZXIgZGVwcmVjYXRlZCBldmVudC5yZWNlaXZlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiYgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiYgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyTGVnYWN5KHdpbmRvdykge1xuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIob2ZmZXJPcHRpb25zKSB7XG4gICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXG4gICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID0gISFvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF1ZGlvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ2F1ZGlvJyk7XG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IGZhbHNlICYmIGF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IHRydWUgJiYgIWF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7XG4gICAgICAgICAgZGlyZWN0aW9uOiAncmVjdm9ubHknXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXG4gICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID0gISFvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZpZGVvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPT09IGZhbHNlICYmIHZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPT09IHRydWUgJiYgIXZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7XG4gICAgICAgICAgZGlyZWN0aW9uOiAncmVjdm9ubHknXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQXVkaW9Db250ZXh0KHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgd2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbn1cblxudmFyIHNhZmFyaVNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc2hpbUF1ZGlvQ29udGV4dDogc2hpbUF1ZGlvQ29udGV4dCxcbiAgc2hpbUNhbGxiYWNrc0FQSTogc2hpbUNhbGxiYWNrc0FQSSxcbiAgc2hpbUNvbnN0cmFpbnRzOiBzaGltQ29uc3RyYWludHMsXG4gIHNoaW1DcmVhdGVPZmZlckxlZ2FjeTogc2hpbUNyZWF0ZU9mZmVyTGVnYWN5LFxuICBzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhLFxuICBzaGltTG9jYWxTdHJlYW1zQVBJOiBzaGltTG9jYWxTdHJlYW1zQVBJLFxuICBzaGltUlRDSWNlU2VydmVyVXJsczogc2hpbVJUQ0ljZVNlcnZlclVybHMsXG4gIHNoaW1SZW1vdGVTdHJlYW1zQVBJOiBzaGltUmVtb3RlU3RyZWFtc0FQSSxcbiAgc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcjogc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlclxufSk7XG5cbnZhciBzZHAkMSA9IHtleHBvcnRzOiB7fX07XG5cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xudmFyIGhhc1JlcXVpcmVkU2RwO1xuZnVuY3Rpb24gcmVxdWlyZVNkcCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkU2RwKSByZXR1cm4gc2RwJDEuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRTZHAgPSAxO1xuICAoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgLy8gU0RQIGhlbHBlcnMuXG4gICAgY29uc3QgU0RQVXRpbHMgPSB7fTtcblxuICAgIC8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuICAgIC8vIFRPRE86IHVzZSBVVUlEcyBpbnN0ZWFkPyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG4gICAgU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG4gICAgfTtcblxuICAgIC8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuICAgIFNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuICAgIC8vIFNwbGl0cyBTRFAgaW50byBsaW5lcywgZGVhbGluZyB3aXRoIGJvdGggQ1JMRiBhbmQgTEYuXG4gICAgU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICByZXR1cm4gYmxvYi50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKTtcbiAgICB9O1xuICAgIC8vIFNwbGl0cyBTRFAgaW50byBzZXNzaW9ucGFydCBhbmQgbWVkaWFzZWN0aW9ucy4gRW5zdXJlcyBDUkxGLlxuICAgIFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgY29uc3QgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCwgaW5kZXgpID0+IChpbmRleCA+IDAgPyAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nKTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbi5cbiAgICBTRFBVdGlscy5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gICAgICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIGluZGl2aWR1YWwgbWVkaWEgc2VjdGlvbnMuXG4gICAgU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gICAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHNlY3Rpb25zO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24gKGJsb2IsIHByZWZpeCkge1xuICAgICAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDApO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYW4gSUNFIGNhbmRpZGF0ZSBsaW5lLiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4gICAgLy8gcnBvcnQgNTU5OTZcIlxuICAgIC8vIElucHV0IGNhbiBiZSBwcmVmaXhlZCB3aXRoIGE9LlxuICAgIFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGxldCBwYXJ0cztcbiAgICAgIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gICAgICBpZiAobGluZS5pbmRleE9mKCdhPWNhbmRpZGF0ZTonKSA9PT0gMCkge1xuICAgICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMCkuc3BsaXQoJyAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHtcbiAgICAgICAgZm91bmRhdGlvbjogcGFydHNbMF0sXG4gICAgICAgIGNvbXBvbmVudDoge1xuICAgICAgICAgIDE6ICdydHAnLFxuICAgICAgICAgIDI6ICdydGNwJ1xuICAgICAgICB9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHByaW9yaXR5OiBwYXJzZUludChwYXJ0c1szXSwgMTApLFxuICAgICAgICBpcDogcGFydHNbNF0sXG4gICAgICAgIGFkZHJlc3M6IHBhcnRzWzRdLFxuICAgICAgICAvLyBhZGRyZXNzIGlzIGFuIGFsaWFzIGZvciBpcC5cbiAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbNV0sIDEwKSxcbiAgICAgICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgICAgICB0eXBlOiBwYXJ0c1s3XVxuICAgICAgfTtcbiAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgc3dpdGNoIChwYXJ0c1tpXSkge1xuICAgICAgICAgIGNhc2UgJ3JhZGRyJzpcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Jwb3J0JzpcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGNwdHlwZSc6XG4gICAgICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3VmcmFnJzpcbiAgICAgICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgICBjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBleHRlbnNpb24gaGFuZGxpbmcsIGluIHBhcnRpY3VsYXIgdWZyYWcuIERvbid0IG92ZXJ3cml0ZS5cbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVbcGFydHNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgIH07XG5cbiAgICAvLyBUcmFuc2xhdGVzIGEgY2FuZGlkYXRlIG9iamVjdCBpbnRvIFNEUCBjYW5kaWRhdGUgYXR0cmlidXRlLlxuICAgIC8vIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgYT0gcHJlZml4IVxuICAgIFNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgICAgY29uc3Qgc2RwID0gW107XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBjYW5kaWRhdGUuY29tcG9uZW50O1xuICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ3J0cCcpIHtcbiAgICAgICAgc2RwLnB1c2goMSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudCA9PT0gJ3J0Y3AnKSB7XG4gICAgICAgIHNkcC5wdXNoKDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2RwLnB1c2goY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcmlvcml0eSk7XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuICAgICAgY29uc3QgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICAgICAgc2RwLnB1c2goJ3R5cCcpO1xuICAgICAgc2RwLnB1c2godHlwZSk7XG4gICAgICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJiBjYW5kaWRhdGUucmVsYXRlZFBvcnQpIHtcbiAgICAgICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7XG4gICAgICAgIHNkcC5wdXNoKCdycG9ydCcpO1xuICAgICAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlICYmIGNhbmRpZGF0ZS5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAndGNwJykge1xuICAgICAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgICAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XG4gICAgICAgIHNkcC5wdXNoKCd1ZnJhZycpO1xuICAgICAgICBzZHAucHVzaChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuICAgIC8vIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcbiAgICBTRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYSBydHBtYXAgbGluZSwgcmV0dXJucyBSVENSdHBDb2RkZWNQYXJhbWV0ZXJzLiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxuICAgIFNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gICAgICBjb25zdCBwYXJzZWQgPSB7XG4gICAgICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCkgLy8gd2FzOiBpZFxuICAgICAgfTtcbiAgICAgIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcbiAgICAgIHBhcnNlZC5uYW1lID0gcGFydHNbMF07XG4gICAgICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgICAgIHBhcnNlZC5jaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICAgICAgLy8gbGVnYWN5IGFsaWFzLCBnb3QgcmVuYW1lZCBiYWNrIHRvIGNoYW5uZWxzIGluIE9SVEMuXG4gICAgICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZXMgYSBydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuICAgIC8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy53cml0ZVJ0cE1hcCA9IGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhbm5lbHMgPSBjb2RlYy5jaGFubmVscyB8fCBjb2RlYy5udW1DaGFubmVscyB8fCAxO1xuICAgICAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICsgKGNoYW5uZWxzICE9PSAxID8gJy8nICsgY2hhbm5lbHMgOiAnJykgKyAnXFxyXFxuJztcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuICAgIC8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuICAgIFNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICAgICAgdXJpOiBwYXJ0c1sxXSxcbiAgICAgICAgYXR0cmlidXRlczogcGFydHMuc2xpY2UoMikuam9pbignICcpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZXMgYW4gZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4gICAgLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxuICAgIFNEUFV0aWxzLndyaXRlRXh0bWFwID0gZnVuY3Rpb24gKGhlYWRlckV4dGVuc2lvbikge1xuICAgICAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICsgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gOiAnJykgKyAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICsgKGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzID8gJyAnICsgaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgOiAnJykgKyAnXFxyXFxuJztcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgZm10cCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuICAgIC8vIEFsc28gZGVhbHMgd2l0aCB2YnI9b247IGNuZz1vblxuICAgIFNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgICAgIGxldCBrdjtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnOycpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgICAgICBwYXJzZWRba3ZbMF0udHJpbSgpXSA9IGt2WzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGVzIGEgZm10cCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIGxldCBsaW5lID0gJyc7XG4gICAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSArICc9JyArIGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgcnRjcC1mYiBsaW5lLCByZXR1cm5zIFJUQ1BSdGNwRmVlZGJhY2sgb2JqZWN0LiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICAgIFNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcGFydHMuc2hpZnQoKSxcbiAgICAgICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlIGE9cnRjcC1mYiBsaW5lcyBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIGxldCBsaW5lcyA9ICcnO1xuICAgICAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIEZJWE1FOiBzcGVjaWFsIGhhbmRsaW5nIGZvciB0cnItaW50P1xuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmYiA9PiB7XG4gICAgICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICsgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICsgJ1xcclxcbic7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYSBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuICAgIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHNwID0gbGluZS5pbmRleE9mKCcgJyk7XG4gICAgICBjb25zdCBwYXJ0cyA9IHtcbiAgICAgICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoNywgc3ApLCAxMClcbiAgICAgIH07XG4gICAgICBjb25zdCBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgICAgIGlmIChjb2xvbiA+IC0xKSB7XG4gICAgICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSwgY29sb24pO1xuICAgICAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGNvbG9uICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZSBhIHNzcmMtZ3JvdXAgbGluZSAoc2VlIFJGQyA1NTc2KS4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9c3NyYy1ncm91cDpzZW1hbnRpY3MgMTIgMzRcbiAgICBTRFBVdGlscy5wYXJzZVNzcmNHcm91cCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEzKS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VtYW50aWNzOiBwYXJ0cy5zaGlmdCgpLFxuICAgICAgICBzc3JjczogcGFydHMubWFwKHNzcmMgPT4gcGFyc2VJbnQoc3NyYywgMTApKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuICAgIC8vIFJldHVybnMgdGhlIE1JRCBvciB1bmRlZmluZWQgaWYgbm8gbWlkIGxpbmUgd2FzIGZvdW5kLlxuICAgIFNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICAgICAgaWYgKG1pZCkge1xuICAgICAgICByZXR1cm4gbWlkLnN1YnN0cmluZyg2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgZmluZ2VycHJpbnQgbGluZSBmb3IgRFRMUy1TUlRQLlxuICAgIFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgICAgIHZhbHVlOiBwYXJ0c1sxXS50b1VwcGVyQ2FzZSgpIC8vIHRoZSBkZWZpbml0aW9uIGlzIHVwcGVyLWNhc2UgaW4gUkZDIDQ1NzIuXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbiAgICAvLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbiAgICAvLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1maW5nZXJwcmludDonKTtcbiAgICAgIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUgaW4gRWRnZS5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdhdXRvJyxcbiAgICAgICAgZmluZ2VycHJpbnRzOiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cbiAgICBTRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcywgc2V0dXBUeXBlKSB7XG4gICAgICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICAgICAgcGFyYW1zLmZpbmdlcnByaW50cy5mb3JFYWNoKGZwID0+IHtcbiAgICAgICAgc2RwICs9ICdhPWZpbmdlcnByaW50OicgKyBmcC5hbGdvcml0aG0gKyAnICcgKyBmcC52YWx1ZSArICdcXHJcXG4nO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYT1jcnlwdG8gbGluZXMgaW50b1xuICAgIC8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNkaWN0aW9uYXJ5LXJ0Y3NydHBzZGVzcGFyYW1ldGVycy1tZW1iZXJzXG4gICAgU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgICAgY3J5cHRvU3VpdGU6IHBhcnRzWzFdLFxuICAgICAgICBrZXlQYXJhbXM6IHBhcnRzWzJdLFxuICAgICAgICBzZXNzaW9uUGFyYW1zOiBwYXJ0cy5zbGljZSgzKVxuICAgICAgfTtcbiAgICB9O1xuICAgIFNEUFV0aWxzLndyaXRlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm4gJ2E9Y3J5cHRvOicgKyBwYXJhbWV0ZXJzLnRhZyArICcgJyArIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgKyAodHlwZW9mIHBhcmFtZXRlcnMua2V5UGFyYW1zID09PSAnb2JqZWN0JyA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKSA6IHBhcmFtZXRlcnMua2V5UGFyYW1zKSArIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICsgJ1xcclxcbic7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyB0aGUgY3J5cHRvIGtleSBwYXJhbWV0ZXJzIGludG9cbiAgICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjcnRjc3J0cGtleXBhcmFtKlxuICAgIFNEUFV0aWxzLnBhcnNlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24gKGtleVBhcmFtcykge1xuICAgICAgaWYgKGtleVBhcmFtcy5pbmRleE9mKCdpbmxpbmU6JykgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJ0cyA9IGtleVBhcmFtcy5zdWJzdHJpbmcoNykuc3BsaXQoJ3wnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleU1ldGhvZDogJ2lubGluZScsXG4gICAgICAgIGtleVNhbHQ6IHBhcnRzWzBdLFxuICAgICAgICBsaWZlVGltZTogcGFydHNbMV0sXG4gICAgICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXG4gICAgICAgIG1raUxlbmd0aDogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzFdIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH07XG4gICAgU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbiAoa2V5UGFyYW1zKSB7XG4gICAgICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6JyArIGtleVBhcmFtcy5rZXlTYWx0ICsgKGtleVBhcmFtcy5saWZlVGltZSA/ICd8JyArIGtleVBhcmFtcy5saWZlVGltZSA6ICcnKSArIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aCA/ICd8JyArIGtleVBhcmFtcy5ta2lWYWx1ZSArICc6JyArIGtleVBhcmFtcy5ta2lMZW5ndGggOiAnJyk7XG4gICAgfTtcblxuICAgIC8vIEV4dHJhY3RzIGFsbCBTREVTIHBhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMuZ2V0Q3J5cHRvUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1jcnlwdG86Jyk7XG4gICAgICByZXR1cm4gbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSk7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBJQ0UgaW5mb3JtYXRpb24gZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbiAgICAvLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbiAgICAvLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuICAgIFNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgICAgY29uc3QgdWZyYWcgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9aWNlLXVmcmFnOicpWzBdO1xuICAgICAgY29uc3QgcHdkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWljZS1wd2Q6JylbMF07XG4gICAgICBpZiAoISh1ZnJhZyAmJiBwd2QpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcm5hbWVGcmFnbWVudDogdWZyYWcuc3Vic3RyaW5nKDEyKSxcbiAgICAgICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHJpbmcoMTApXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cbiAgICBTRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBsZXQgc2RwID0gJ2E9aWNlLXVmcmFnOicgKyBwYXJhbXMudXNlcm5hbWVGcmFnbWVudCArICdcXHJcXG4nICsgJ2E9aWNlLXB3ZDonICsgcGFyYW1zLnBhc3N3b3JkICsgJ1xcclxcbic7XG4gICAgICBpZiAocGFyYW1zLmljZUxpdGUpIHtcbiAgICAgICAgc2RwICs9ICdhPWljZS1saXRlXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZHA7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgUlRDUnRwUGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgIGZlY01lY2hhbmlzbXM6IFtdLFxuICAgICAgICBydGNwOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgICAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICAgICAgZGVzY3JpcHRpb24ucHJvZmlsZSA9IG1saW5lWzJdO1xuICAgICAgZm9yIChsZXQgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgICAgIGNvbnN0IHB0ID0gbWxpbmVbaV07XG4gICAgICAgIGNvbnN0IHJ0cG1hcGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgICAgICBpZiAocnRwbWFwbGluZSkge1xuICAgICAgICAgIGNvbnN0IGNvZGVjID0gU0RQVXRpbHMucGFyc2VSdHBNYXAocnRwbWFwbGluZSk7XG4gICAgICAgICAgY29uc3QgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWZtdHA6JyArIHB0ICsgJyAnKTtcbiAgICAgICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOicgKyBwdCArICcgJykubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgICAgICBkZXNjcmlwdGlvbi5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXG4gICAgICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1JFRCc6XG4gICAgICAgICAgICBjYXNlICdVTFBGRUMnOlxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB3aWxkY2FyZFJ0Y3BGYiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjoqICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICAgIHdpbGRjYXJkUnRjcEZiLmZvckVhY2goZmIgPT4ge1xuICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nRmVlZGJhY2sudHlwZSA9PT0gZmIudHlwZSAmJiBleGlzdGluZ0ZlZWRiYWNrLnBhcmFtZXRlciA9PT0gZmIucGFyYW1ldGVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmYik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbiAgICAvLyBwYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoa2luZCwgY2Fwcykge1xuICAgICAgbGV0IHNkcCA9ICcnO1xuXG4gICAgICAvLyBCdWlsZCB0aGUgbWxpbmUuXG4gICAgICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gICAgICBzZHAgKz0gY2Fwcy5jb2RlY3MubGVuZ3RoID4gMCA/ICc5JyA6ICcwJzsgLy8gcmVqZWN0IGlmIG5vIGNvZGVjcy5cbiAgICAgIHNkcCArPSAnICcgKyAoY2Fwcy5wcm9maWxlIHx8ICdVRFAvVExTL1JUUC9TQVZQRicpICsgJyAnO1xuICAgICAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChjb2RlYyA9PiB7XG4gICAgICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgICAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcbiAgICAgIHNkcCArPSAnYT1ydGNwOjkgSU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuXG4gICAgICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgICAgIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdHBNYXAoY29kZWMpO1xuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRjcEZiKGNvZGVjKTtcbiAgICAgIH0pO1xuICAgICAgbGV0IG1heHB0aW1lID0gMDtcbiAgICAgIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgICBpZiAoY29kZWMubWF4cHRpbWUgPiBtYXhwdGltZSkge1xuICAgICAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgICAgICBzZHAgKz0gJ2E9bWF4cHRpbWU6JyArIG1heHB0aW1lICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gICAgICByZXR1cm4gc2RwO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4gICAgLy8gUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgICAgY29uc3QgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gICAgICBjb25zdCBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcblxuICAgICAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxuICAgICAgY29uc3Qgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihwYXJ0cyA9PiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICAgICAgY29uc3QgcHJpbWFyeVNzcmMgPSBzc3Jjcy5sZW5ndGggPiAwICYmIHNzcmNzWzBdLnNzcmM7XG4gICAgICBsZXQgc2Vjb25kYXJ5U3NyYztcbiAgICAgIGNvbnN0IGZsb3dzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjLWdyb3VwOkZJRCcpLm1hcChsaW5lID0+IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNykuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLm1hcChwYXJ0ID0+IHBhcnNlSW50KHBhcnQsIDEwKSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmbG93cy5sZW5ndGggPiAwICYmIGZsb3dzWzBdLmxlbmd0aCA+IDEgJiYgZmxvd3NbMF1bMF0gPT09IHByaW1hcnlTc3JjKSB7XG4gICAgICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcbiAgICAgICAgICBsZXQgZW5jUGFyYW0gPSB7XG4gICAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChwcmltYXJ5U3NyYyAmJiBzZWNvbmRhcnlTc3JjKSB7XG4gICAgICAgICAgICBlbmNQYXJhbS5ydHggPSB7XG4gICAgICAgICAgICAgIHNzcmM6IHNlY29uZGFyeVNzcmNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgICAgIGVuY1BhcmFtLmZlYyA9IHtcbiAgICAgICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyY1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gd2Ugc3VwcG9ydCBib3RoIGI9QVMgYW5kIGI9VElBUyBidXQgaW50ZXJwcmV0IEFTIGFzIFRJQVMuXG4gICAgICBsZXQgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgICAgIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgICAgIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1USUFTOicpID09PSAwKSB7XG4gICAgICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg3KSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICAgICAgLy8gdXNlIGZvcm11bGEgZnJvbSBKU0VQIHRvIGNvbnZlcnQgYj1BUyB0byBUSUFTIHZhbHVlLlxuICAgICAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNSksIDEwKSAqIDEwMDAgKiAwLjk1IC0gNTAgKiA0MCAqIDg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFuZHdpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKHBhcmFtcyA9PiB7XG4gICAgICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbiAgICB9O1xuXG4gICAgLy8gcGFyc2VzIGh0dHA6Ly9kcmFmdC5vcnRjLm9yZy8jcnRjcnRjcHBhcmFtZXRlcnMqXG4gICAgU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHJ0Y3BQYXJhbWV0ZXJzID0ge307XG5cbiAgICAgIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAgICAgLy8gU1NSQ3MuXG4gICAgICBjb25zdCByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIob2JqID0+IG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZScpWzBdO1xuICAgICAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICAgICAgcnRjcFBhcmFtZXRlcnMuY25hbWUgPSByZW1vdGVTc3JjLnZhbHVlO1xuICAgICAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xuICAgICAgfVxuXG4gICAgICAvLyBFZGdlIHVzZXMgdGhlIGNvbXBvdW5kIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIHJlZHVjZWRTaXplXG4gICAgICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcbiAgICAgIGNvbnN0IHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gICAgICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XG4gICAgICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcblxuICAgICAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAgICAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXG4gICAgICBjb25zdCBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gICAgICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcbiAgICAgIHJldHVybiBydGNwUGFyYW1ldGVycztcbiAgICB9O1xuICAgIFNEUFV0aWxzLndyaXRlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocnRjcFBhcmFtZXRlcnMpIHtcbiAgICAgIGxldCBzZHAgPSAnJztcbiAgICAgIGlmIChydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSkge1xuICAgICAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG4gICAgICB9XG4gICAgICBpZiAocnRjcFBhcmFtZXRlcnMubXV4KSB7XG4gICAgICAgIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG4gICAgICB9XG4gICAgICBpZiAocnRjcFBhcmFtZXRlcnMuc3NyYyAhPT0gdW5kZWZpbmVkICYmIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lKSB7XG4gICAgICAgIHNkcCArPSAnYT1zc3JjOicgKyBydGNwUGFyYW1ldGVycy5zc3JjICsgJyBjbmFtZTonICsgcnRjcFBhcmFtZXRlcnMuY25hbWUgKyAnXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZHA7XG4gICAgfTtcblxuICAgIC8vIHBhcnNlcyBlaXRoZXIgYT1tc2lkOiBvciBhPXNzcmM6Li4uIG1zaWQgbGluZXMgYW5kIHJldHVybnNcbiAgICAvLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxuICAgIFNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGxldCBwYXJ0cztcbiAgICAgIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gICAgICBpZiAoc3BlYy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcGFydHMgPSBzcGVjWzBdLnN1YnN0cmluZyg3KS5zcGxpdCgnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmVhbTogcGFydHNbMF0sXG4gICAgICAgICAgdHJhY2s6IHBhcnRzWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFuQiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKS5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSkuZmlsdGVyKG1zaWRQYXJ0cyA9PiBtc2lkUGFydHMuYXR0cmlidXRlID09PSAnbXNpZCcpO1xuICAgICAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFydHMgPSBwbGFuQlswXS52YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmVhbTogcGFydHNbMF0sXG4gICAgICAgICAgdHJhY2s6IHBhcnRzWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNDVFBcbiAgICAvLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbiAgICAvLyB0byBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNVxuICAgIFNEUFV0aWxzLnBhcnNlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgbWxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gICAgICBjb25zdCBtYXhTaXplTGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF4U2l6ZUxpbmVbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2N0cFBvcnQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHAtcG9ydDonKTtcbiAgICAgIGlmIChzY3RwUG9ydC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9ydDogcGFyc2VJbnQoc2N0cFBvcnRbMF0uc3Vic3RyaW5nKDEyKSwgMTApLFxuICAgICAgICAgIHByb3RvY29sOiBtbGluZS5mbXQsXG4gICAgICAgICAgbWF4TWVzc2FnZVNpemVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjdHBNYXBMaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cG1hcDonKTtcbiAgICAgIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHNjdHBNYXBMaW5lc1swXS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgICAgICBwcm90b2NvbDogcGFydHNbMV0sXG4gICAgICAgICAgbWF4TWVzc2FnZVNpemVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU0NUUFxuICAgIC8vIG91dHB1dHMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IHZlcnNpb24gdGhhdCBhbGwgYnJvd3NlcnNcbiAgICAvLyBzdXBwb3J0IGJ5IG5vdyByZWNlaXZpbmcgaW4gdGhpcyBmb3JtYXQsIHVubGVzcyB3ZSBvcmlnaW5hbGx5IHBhcnNlZFxuICAgIC8vIGFzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNSBmb3JtYXQgKGluZGljYXRlZCBieSB0aGUgbS1saW5lXG4gICAgLy8gcHJvdG9jb2wgb2YgRFRMUy9TQ1RQIC0tIHdpdGhvdXQgVURQLyBvciBUQ1AvKVxuICAgIFNEUFV0aWxzLndyaXRlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG1lZGlhLCBzY3RwKSB7XG4gICAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XG4gICAgICAgIG91dHB1dCA9IFsnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJ1xcclxcbicsICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJywgJ2E9c2N0cC1wb3J0OicgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBbJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJywgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nXTtcbiAgICAgIH1cbiAgICAgIGlmIChzY3RwLm1heE1lc3NhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonICsgc2N0cC5tYXhNZXNzYWdlU2l6ZSArICdcXHJcXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlIGEgc2Vzc2lvbiBJRCBmb3IgU0RQLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLXJ0Y3dlYi1qc2VwLTIwI3NlY3Rpb24tNS4yLjFcbiAgICAvLyByZWNvbW1lbmRzIHVzaW5nIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tICt2ZSA2NC1iaXQgdmFsdWVcbiAgICAvLyBidXQgcmlnaHQgbm93IHRoaXMgc2hvdWxkIGJlIGFjY2VwdGFibGUgYW5kIHdpdGhpbiB0aGUgcmlnaHQgcmFuZ2VcbiAgICBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIyKTtcbiAgICB9O1xuXG4gICAgLy8gV3JpdGUgYm9pbGVyIHBsYXRlIGZvciBzdGFydCBvZiBTRFBcbiAgICAvLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuICAgIC8vIGJlIGdlbmVyYXRlZCByYW5kb21seVxuICAgIC8vIHNlc3NWZXJzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAyXG4gICAgLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcbiAgICBTRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSA9IGZ1bmN0aW9uIChzZXNzSWQsIHNlc3NWZXIsIHNlc3NVc2VyKSB7XG4gICAgICBsZXQgc2Vzc2lvbklkO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHNlc3NWZXIgIT09IHVuZGVmaW5lZCA/IHNlc3NWZXIgOiAyO1xuICAgICAgaWYgKHNlc3NJZCkge1xuICAgICAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXNzaW9uSWQgPSBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXNlciA9IHNlc3NVc2VyIHx8ICd0aGlzaXNhZGFwdGVyb3J0Yyc7XG4gICAgICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cbiAgICAgIHJldHVybiAndj0wXFxyXFxuJyArICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgKyAncz0tXFxyXFxuJyArICd0PTAgMFxcclxcbic7XG4gICAgfTtcblxuICAgIC8vIEdldHMgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBtZWRpYVNlY3Rpb24gb3IgdGhlIHNlc3Npb25wYXJ0LlxuICAgIFNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgICAvLyBMb29rIGZvciBzZW5kcmVjdiwgc2VuZG9ubHksIHJlY3Zvbmx5LCBpbmFjdGl2ZSwgZGVmYXVsdCB0byBzZW5kcmVjdi5cbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XG4gICAgICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XG4gICAgICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICAgICAgY2FzZSAnYT1yZWN2b25seSc6XG4gICAgICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XG4gICAgICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyaW5nKDIpO1xuICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlc3Npb25wYXJ0KSB7XG4gICAgICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdzZW5kcmVjdic7XG4gICAgfTtcbiAgICBTRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyaW5nKDIpO1xuICAgIH07XG4gICAgU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIHJldHVybiBtZWRpYVNlY3Rpb24uc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xuICAgIH07XG4gICAgU0RQVXRpbHMucGFyc2VNTGluZSA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IHBhcnRzWzBdLFxuICAgICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgICBwcm90b2NvbDogcGFydHNbMl0sXG4gICAgICAgIGZtdDogcGFydHMuc2xpY2UoMykuam9pbignICcpXG4gICAgICB9O1xuICAgIH07XG4gICAgU0RQVXRpbHMucGFyc2VPTGluZSA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygyKS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxuICAgICAgICBzZXNzaW9uSWQ6IHBhcnRzWzFdLFxuICAgICAgICBzZXNzaW9uVmVyc2lvbjogcGFyc2VJbnQocGFydHNbMl0sIDEwKSxcbiAgICAgICAgbmV0VHlwZTogcGFydHNbM10sXG4gICAgICAgIGFkZHJlc3NUeXBlOiBwYXJ0c1s0XSxcbiAgICAgICAgYWRkcmVzczogcGFydHNbNV1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGEgdmVyeSBuYWl2ZSBpbnRlcnByZXRhdGlvbiBvZiBhIHZhbGlkIFNEUC5cbiAgICBTRFBVdGlscy5pc1ZhbGlkU0RQID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIGlmICh0eXBlb2YgYmxvYiAhPT0gJ3N0cmluZycgfHwgYmxvYi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG4gICAge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBTRFBVdGlscztcbiAgICB9XG4gIH0pKHNkcCQxKTtcbiAgcmV0dXJuIHNkcCQxLmV4cG9ydHM7XG59XG5cbnZhciBzZHBFeHBvcnRzID0gcmVxdWlyZVNkcCgpO1xudmFyIFNEUFV0aWxzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNkcEV4cG9ydHMpO1xuXG52YXIgc2RwID0gLyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IFNEUFV0aWxzXG59LCBbc2RwRXhwb3J0c10pO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNyBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpIHtcbiAgLy8gZm91bmRhdGlvbiBpcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgYW4gaW5kaWNhdG9yIGZvciBmdWxsIHN1cHBvcnQgZm9yXG4gIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtcGMvI3J0Y2ljZWNhbmRpZGF0ZS1pbnRlcmZhY2VcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ2ZvdW5kYXRpb24nIGluIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBSVENJY2VDYW5kaWRhdGUoYXJncykge1xuICAgIC8vIFJlbW92ZSB0aGUgYT0gd2hpY2ggc2hvdWxkbid0IGJlIHBhcnQgb2YgdGhlIGNhbmRpZGF0ZSBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnb2JqZWN0JyAmJiBhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5pbmRleE9mKCdhPScpID09PSAwKSB7XG4gICAgICBhcmdzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmdzKSk7XG4gICAgICBhcmdzLmNhbmRpZGF0ZSA9IGFyZ3MuY2FuZGlkYXRlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmxlbmd0aCkge1xuICAgICAgLy8gQXVnbWVudCB0aGUgbmF0aXZlIGNhbmRpZGF0ZSB3aXRoIHRoZSBwYXJzZWQgZmllbGRzLlxuICAgICAgY29uc3QgbmF0aXZlQ2FuZGlkYXRlID0gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGFyZ3MuY2FuZGlkYXRlKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcnNlZENhbmRpZGF0ZSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gbmF0aXZlQ2FuZGlkYXRlKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYW5kaWRhdGUsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlZENhbmRpZGF0ZVtrZXldXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3ZlcnJpZGUgc2VyaWFsaXplciB0byBub3Qgc2VyaWFsaXplIHRoZSBleHRyYSBhdHRyaWJ1dGVzLlxuICAgICAgbmF0aXZlQ2FuZGlkYXRlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5kaWRhdGU6IG5hdGl2ZUNhbmRpZGF0ZS5jYW5kaWRhdGUsXG4gICAgICAgICAgc2RwTWlkOiBuYXRpdmVDYW5kaWRhdGUuc2RwTWlkLFxuICAgICAgICAgIHNkcE1MaW5lSW5kZXg6IG5hdGl2ZUNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IG5hdGl2ZUNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5hdGl2ZUNhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gIH07XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlID0gTmF0aXZlUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZTtcblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdjYW5kaWRhdGUnLCB7XG4gICAgICAgIHZhbHVlOiBuZXcgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSksXG4gICAgICAgIHdyaXRhYmxlOiAnZmFsc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdyZWxheVByb3RvY29sJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnaWNlY2FuZGlkYXRlJywgZSA9PiB7XG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZS5jYW5kaWRhdGUpO1xuICAgICAgaWYgKHBhcnNlZENhbmRpZGF0ZS50eXBlID09PSAncmVsYXknKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsaWJ3ZWJydGMtc3BlY2lmaWMgbWFwcGluZyBvZiBsb2NhbCB0eXBlIHByZWZlcmVuY2VcbiAgICAgICAgLy8gdG8gcmVsYXlQcm90b2NvbC5cbiAgICAgICAgZS5jYW5kaWRhdGUucmVsYXlQcm90b2NvbCA9IHtcbiAgICAgICAgICAwOiAndGxzJyxcbiAgICAgICAgICAxOiAndGNwJyxcbiAgICAgICAgICAyOiAndWRwJ1xuICAgICAgICB9W3BhcnNlZENhbmRpZGF0ZS5wcmlvcml0eSA+PiAyNF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdzY3RwJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnc2N0cCcsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNjdHBJbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgIHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHNlY3Rpb25zLnNvbWUobWVkaWFTZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IG1MaW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICAgICAgcmV0dXJuIG1MaW5lICYmIG1MaW5lLmtpbmQgPT09ICdhcHBsaWNhdGlvbicgJiYgbUxpbmUucHJvdG9jb2wuaW5kZXhPZignU0NUUCcpICE9PSAtMTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIGJldHRlciBzb2x1dGlvbiBmb3IgZGV0ZWN0aW5nIEZpcmVmb3g/XG4gICAgY29uc3QgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL21vemlsbGEuLi5USElTX0lTX1NEUEFSVEEtKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgLy8gVGVzdCBmb3IgTmFOICh5ZXMsIHRoaXMgaXMgdWdseSlcbiAgICByZXR1cm4gdmVyc2lvbiAhPT0gdmVyc2lvbiA/IC0xIDogdmVyc2lvbjtcbiAgfTtcbiAgY29uc3QgZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24gKHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIEV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgY2FuIHNlbmQgYXQgbGVhc3QgNjQgS2lCLlxuICAgIC8vIE5vdGU6IEFsdGhvdWdoIENocm9tZSBpcyB0ZWNobmljYWxseSBhYmxlIHRvIHNlbmQgdXAgdG8gMjU2IEtpQiwgdGhlXG4gICAgLy8gICAgICAgZGF0YSBkb2VzIG5vdCByZWFjaCB0aGUgb3RoZXIgcGVlciByZWxpYWJseS5cbiAgICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD04NDE5XG4gICAgbGV0IGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcpIHtcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTcpIHtcbiAgICAgICAgaWYgKHJlbW90ZUlzRmlyZWZveCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBGRiA8IDU3IHdpbGwgc2VuZCBpbiAxNiBLaUIgY2h1bmtzIHVzaW5nIHRoZSBkZXByZWNhdGVkIFBQSURcbiAgICAgICAgICAvLyBmcmFnbWVudGF0aW9uLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDE2Mzg0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIG90aGVyIEZGIChhbmQgUkFXUlRDKSBjYW4gcmVhc3NlbWJsZSBQUElELWZyYWdtZW50ZWRcbiAgICAgICAgICAvLyBtZXNzYWdlcy4gVGh1cywgc3VwcG9ydGluZyB+MiBHaUIgd2hlbiBzZW5kaW5nLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDYwKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSwgYWxsIEZGID49IDU3IHdpbGwgcmVzZXQgdGhlIHJlbW90ZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgICAvLyB0byB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIGEgZGF0YSBjaGFubmVsIGlzIGNyZWF0ZWQgYXQgYSBsYXRlclxuICAgICAgICAvLyBzdGFnZS4gOihcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3ID8gNjU1MzUgOiA2NTUzNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZGID49IDYwIHN1cHBvcnRzIHNlbmRpbmcgfjIgR2lCXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5TZW5kTWF4TWVzc2FnZVNpemU7XG4gIH07XG4gIGNvbnN0IGdldE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uLCByZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBOb3RlOiA2NTUzNiBieXRlcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBTRFAgc3BlYy4gQWxzbyxcbiAgICAvLyAgICAgICBldmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IHN1cHBvcnRzIHJlY2VpdmluZyA2NTUzNiBieXRlcy5cbiAgICBsZXQgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcblxuICAgIC8vIEZGIDU3IGhhcyBhIHNsaWdodGx5IGluY29ycmVjdCBkZWZhdWx0IHJlbW90ZSBtYXggbWVzc2FnZSBzaXplLCBzb1xuICAgIC8vIHdlIG5lZWQgdG8gYWRqdXN0IGl0IGhlcmUgdG8gYXZvaWQgYSBmYWlsdXJlIHdoZW4gc2VuZGluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjU2OTdcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3KSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM1O1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KGRlc2NyaXB0aW9uLnNkcCwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgICBpZiAobWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXRjaFswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgcmVtb3RlSXNGaXJlZm94ICE9PSAtMSkge1xuICAgICAgLy8gSWYgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIGlzIG5vdCBwcmVzZW50IGluIHRoZSByZW1vdGUgU0RQIGFuZFxuICAgICAgLy8gYm90aCBsb2NhbCBhbmQgcmVtb3RlIGFyZSBGaXJlZm94LCB0aGUgcmVtb3RlIHBlZXIgY2FuIHJlY2VpdmVcbiAgICAgIC8vIH4yIEdpQi5cbiAgICAgIG1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICB9XG4gICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICB9O1xuICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgdGhpcy5fc2N0cCA9IG51bGw7XG4gICAgLy8gQ2hyb21lIGRlY2lkZWQgdG8gbm90IGV4cG9zZSAuc2N0cCBpbiBwbGFuLWIgbW9kZS5cbiAgICAvLyBBcyB1c3VhbCwgYWRhcHRlci5qcyBoYXMgdG8gZG8gYW4gJ3VnbHkgd29yYWthcm91bmQnXG4gICAgLy8gdG8gY292ZXIgdXAgdGhlIG1lc3MuXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2RwU2VtYW50aWNzXG4gICAgICB9ID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICBpZiAoc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjdHAnLCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzY3RwSW5EZXNjcmlwdGlvbihhcmd1bWVudHNbMF0pKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVtb3RlIGlzIEZGLlxuICAgICAgY29uc3QgaXNGaXJlZm94ID0gZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24oYXJndW1lbnRzWzBdKTtcblxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSB0aGUgbG9jYWwgcGVlciBpcyBjYXBhYmxlIG9mIHNlbmRpbmdcbiAgICAgIGNvbnN0IGNhblNlbmRNTVMgPSBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUoaXNGaXJlZm94KTtcblxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBvZiB0aGUgcmVtb3RlIHBlZXIuXG4gICAgICBjb25zdCByZW1vdGVNTVMgPSBnZXRNYXhNZXNzYWdlU2l6ZShhcmd1bWVudHNbMF0sIGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIERldGVybWluZSBmaW5hbCBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICAgICAgaWYgKGNhblNlbmRNTVMgPT09IDAgJiYgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgfSBlbHNlIGlmIChjYW5TZW5kTU1TID09PSAwIHx8IHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWF4KGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWluKGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IFJUQ1NjdHBUcmFuc3BvcnQgb2JqZWN0IGFuZCB0aGUgJ21heE1lc3NhZ2VTaXplJ1xuICAgICAgLy8gYXR0cmlidXRlLlxuICAgICAgY29uc3Qgc2N0cCA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjdHAsICdtYXhNZXNzYWdlU2l6ZScsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9zY3RwID0gc2N0cDtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdjcmVhdGVEYXRhQ2hhbm5lbCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlOiBBbHRob3VnaCBGaXJlZm94ID49IDU3IGhhcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgdGhlIG1heGltdW1cbiAgLy8gICAgICAgbWVzc2FnZSBzaXplIGNhbiBiZSByZXNldCBmb3IgYWxsIGRhdGEgY2hhbm5lbHMgYXQgYSBsYXRlciBzdGFnZS5cbiAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG5cbiAgZnVuY3Rpb24gd3JhcERjU2VuZChkYywgcGMpIHtcbiAgICBjb25zdCBvcmlnRGF0YUNoYW5uZWxTZW5kID0gZGMuc2VuZDtcbiAgICBkYy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCB8fCBkYXRhLnNpemUgfHwgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKGRjLnJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJiBwYy5zY3RwICYmIGxlbmd0aCA+IHBjLnNjdHAubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVzc2FnZSB0b28gbGFyZ2UgKGNhbiBzZW5kIGEgbWF4aW11bSBvZiAnICsgcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ0RhdGFDaGFubmVsU2VuZC5hcHBseShkYywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWw7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiBjcmVhdGVEYXRhQ2hhbm5lbCgpIHtcbiAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHdyYXBEY1NlbmQoZGF0YUNoYW5uZWwsIHRoaXMpO1xuICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbiAgfTtcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnZGF0YWNoYW5uZWwnLCBlID0+IHtcbiAgICB3cmFwRGNTZW5kKGUuY2hhbm5lbCwgZS50YXJnZXQpO1xuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuLyogc2hpbXMgUlRDQ29ubmVjdGlvblN0YXRlIGJ5IHByZXRlbmRpbmcgaXQgaXMgdGhlIHNhbWUgYXMgaWNlQ29ubmVjdGlvblN0YXRlLlxuICogU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD02MTQ1I2MxMlxuICogZm9yIHdoeSB0aGlzIGlzIGEgdmFsaWQgaGFjayBpbiBDaHJvbWUuIEluIEZpcmVmb3ggaXQgaXMgc2xpZ2h0bHkgaW5jb3JyZWN0XG4gKiBzaW5jZSBEVExTIGZhaWx1cmVzIHdvdWxkIGJlIGhpZGRlbi4gU2VlXG4gKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjY1ODI3XG4gKiBmb3IgdGhlIEZpcmVmb3ggdHJhY2tpbmcgYnVnLlxuICovXG5mdW5jdGlvbiBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCAnY29ubmVjdGlvblN0YXRlJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnY29ubmVjdGlvblN0YXRlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBsZXRlZDogJ2Nvbm5lY3RlZCcsXG4gICAgICAgIGNoZWNraW5nOiAnY29ubmVjdGluZydcbiAgICAgIH1bdGhpcy5pY2VDb25uZWN0aW9uU3RhdGVdIHx8IHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uY29ubmVjdGlvbnN0YXRlY2hhbmdlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSB8fCBudWxsO1xuICAgIH0sXG4gICAgc2V0KGNiKSB7XG4gICAgICBpZiAodGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbiddLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICBjb25zdCBvcmlnTWV0aG9kID0gcHJvdG9bbWV0aG9kXTtcbiAgICBwcm90b1ttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkgPSBlID0+IHtcbiAgICAgICAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgICAgICAgIGlmIChwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSAhPT0gcGMuY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICBwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSA9IHBjLmNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IEV2ZW50KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBlKTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLyogcmVtb3ZlIGE9ZXh0bWFwLWFsbG93LW1peGVkIGZvciB3ZWJydGMub3JnIDwgTTcxICovXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJyAmJiBicm93c2VyRGV0YWlscy5fc2FmYXJpVmVyc2lvbiA+PSAxMy4xKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZVNSRCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKSB7XG4gICAgaWYgKGRlc2MgJiYgZGVzYy5zZHAgJiYgZGVzYy5zZHAuaW5kZXhPZignXFxuYT1leHRtYXAtYWxsb3ctbWl4ZWQnKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHNkcCA9IGRlc2Muc2RwLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgLy8gU2FmYXJpIGVuZm9yY2VzIHJlYWQtb25seS1uZXNzIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBmaWVsZHMuXG4gICAgICBpZiAod2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAmJiBkZXNjIGluc3RhbmNlb2Ygd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgdHlwZTogZGVzYy50eXBlLFxuICAgICAgICAgIHNkcFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc2Muc2RwID0gc2RwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICAvLyBTdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIC8vIGFzIHdlbGwgYXMgYWRkSWNlQ2FuZGlkYXRlKHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0pXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk3ODU4MlxuICAvLyBOb3RlOiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb3RoZXIgcG9seWZpbGxzIHdoaWNoIGNoYW5nZSB0aGUgc2lnbmF0dXJlLlxuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gIGlmICghbmF0aXZlQWRkSWNlQ2FuZGlkYXRlIHx8IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoKSB7XG4gICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyBGaXJlZm94IDY4KyBlbWl0cyBhbmQgcHJvY2Vzc2VzIHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0sIGlnbm9yZVxuICAgIC8vIGluIG9sZGVyIHZlcnNpb25zLlxuICAgIC8vIE5hdGl2ZSBzdXBwb3J0IGZvciBpZ25vcmluZyBleGlzdHMgZm9yIENocm9tZSBNNzcrLlxuICAgIC8vIFNhZmFyaSBpZ25vcmVzIGFzIHdlbGwsIGV4YWN0IHZlcnNpb24gdW5rbm93biBidXQgd29ya3MgaW4gdGhlIHNhbWVcbiAgICAvLyB2ZXJzaW9uIHRoYXQgYWxzbyBpZ25vcmVzIGFkZEljZUNhbmRpZGF0ZShudWxsKS5cbiAgICBpZiAoKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3OCB8fCBicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY4IHx8IGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknKSAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLmNhbmRpZGF0ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vLyBOb3RlOiBNYWtlIHN1cmUgdG8gY2FsbCB0aGlzIGFoZWFkIG9mIEFQSXMgdGhhdCBtb2RpZnlcbi8vIHNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoXG5mdW5jdGlvbiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgaWYgKCFuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uIHx8IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgbGV0IGRlc2MgPSBhcmd1bWVudHNbMF0gfHwge307XG4gICAgaWYgKHR5cGVvZiBkZXNjICE9PSAnb2JqZWN0JyB8fCBkZXNjLnR5cGUgJiYgZGVzYy5zZHApIHtcbiAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8vIFRoZSByZW1haW5pbmcgc3RlcHMgc2hvdWxkIHRlY2huaWNhbGx5IGhhcHBlbiB3aGVuIFNMRCBjb21lcyBvZmYgdGhlXG4gICAgLy8gUlRDUGVlckNvbm5lY3Rpb24ncyBvcGVyYXRpb25zIGNoYWluIChub3QgYWhlYWQgb2YgZ29pbmcgb24gaXQpLCBidXRcbiAgICAvLyB0aGlzIGlzIHRvbyBkaWZmaWN1bHQgdG8gc2hpbS4gSW5zdGVhZCwgdGhpcyBzaGltIG9ubHkgY292ZXJzIHRoZVxuICAgIC8vIGNvbW1vbiBjYXNlIHdoZXJlIHRoZSBvcGVyYXRpb25zIGNoYWluIGlzIGVtcHR5LiBUaGlzIGlzIGltcGVyZmVjdCwgYnV0XG4gICAgLy8gc2hvdWxkIGNvdmVyIG1hbnkgY2FzZXMuIFJhdGlvbmFsZTogRXZlbiBpZiB3ZSBjYW4ndCByZWR1Y2UgdGhlIGdsYXJlXG4gICAgLy8gd2luZG93IHRvIHplcm8gb24gaW1wZXJmZWN0IGltcGxlbWVudGF0aW9ucywgdGhlcmUncyB2YWx1ZSBpbiB0YXBwaW5nXG4gICAgLy8gaW50byB0aGUgcGVyZmVjdCBuZWdvdGlhdGlvbiBwYXR0ZXJuIHRoYXQgc2V2ZXJhbCBicm93c2VycyBzdXBwb3J0LlxuICAgIGRlc2MgPSB7XG4gICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICBzZHA6IGRlc2Muc2RwXG4gICAgfTtcbiAgICBpZiAoIWRlc2MudHlwZSkge1xuICAgICAgc3dpdGNoICh0aGlzLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgIGNhc2UgJ3N0YWJsZSc6XG4gICAgICAgIGNhc2UgJ2hhdmUtbG9jYWwtb2ZmZXInOlxuICAgICAgICBjYXNlICdoYXZlLXJlbW90ZS1wcmFuc3dlcic6XG4gICAgICAgICAgZGVzYy50eXBlID0gJ29mZmVyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZXNjLnR5cGUgPSAnYW5zd2VyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlc2Muc2RwIHx8IGRlc2MudHlwZSAhPT0gJ29mZmVyJyAmJiBkZXNjLnR5cGUgIT09ICdhbnN3ZXInKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY10pO1xuICAgIH1cbiAgICBjb25zdCBmdW5jID0gZGVzYy50eXBlID09PSAnb2ZmZXInID8gdGhpcy5jcmVhdGVPZmZlciA6IHRoaXMuY3JlYXRlQW5zd2VyO1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMpLnRoZW4oZCA9PiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkXSkpO1xuICB9O1xufVxuXG52YXIgY29tbW9uU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICByZW1vdmVFeHRtYXBBbGxvd01peGVkOiByZW1vdmVFeHRtYXBBbGxvd01peGVkLFxuICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHk6IHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSxcbiAgc2hpbUNvbm5lY3Rpb25TdGF0ZTogc2hpbUNvbm5lY3Rpb25TdGF0ZSxcbiAgc2hpbU1heE1lc3NhZ2VTaXplOiBzaGltTWF4TWVzc2FnZVNpemUsXG4gIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbjogc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uLFxuICBzaGltUlRDSWNlQ2FuZGlkYXRlOiBzaGltUlRDSWNlQ2FuZGlkYXRlLFxuICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbDogc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wsXG4gIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3I6IHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Jcbn0pO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cblxuLy8gU2hpbW1pbmcgc3RhcnRzIGhlcmUuXG5mdW5jdGlvbiBhZGFwdGVyRmFjdG9yeSgpIHtcbiAgbGV0IHtcbiAgICB3aW5kb3dcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgc2hpbUNocm9tZTogdHJ1ZSxcbiAgICBzaGltRmlyZWZveDogdHJ1ZSxcbiAgICBzaGltU2FmYXJpOiB0cnVlXG4gIH07XG4gIC8vIFV0aWxzLlxuICBjb25zdCBsb2dnaW5nID0gbG9nO1xuICBjb25zdCBicm93c2VyRGV0YWlscyA9IGRldGVjdEJyb3dzZXIod2luZG93KTtcbiAgY29uc3QgYWRhcHRlciA9IHtcbiAgICBicm93c2VyRGV0YWlscyxcbiAgICBjb21tb25TaGltLFxuICAgIGV4dHJhY3RWZXJzaW9uOiBleHRyYWN0VmVyc2lvbixcbiAgICBkaXNhYmxlTG9nOiBkaXNhYmxlTG9nLFxuICAgIGRpc2FibGVXYXJuaW5nczogZGlzYWJsZVdhcm5pbmdzLFxuICAgIC8vIEV4cG9zZSBzZHAgYXMgYSBjb252ZW5pZW5jZS4gRm9yIHByb2R1Y3Rpb24gYXBwcyBpbmNsdWRlIGRpcmVjdGx5LlxuICAgIHNkcFxuICB9O1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnY2hyb21lJzpcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhc2hpbVBlZXJDb25uZWN0aW9uJDEgfHwgIW9wdGlvbnMuc2hpbUNocm9tZSkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gY2FuIG5vdCBkZXRlcm1pbmUgdmVyc2lvbiwgbm90IHNoaW1taW5nLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgY2hyb21lLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBjaHJvbWVTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XG4gICAgICBzaGltR2V0VXNlck1lZGlhJDIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltTWVkaWFTdHJlYW0od2luZG93KTtcbiAgICAgIHNoaW1QZWVyQ29ubmVjdGlvbiQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbU9uVHJhY2skMSh3aW5kb3cpO1xuICAgICAgc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdyk7XG4gICAgICBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpO1xuICAgICAgc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpcmVmb3gnOlxuICAgICAgaWYgKCFmaXJlZm94U2hpbSB8fCAhc2hpbVBlZXJDb25uZWN0aW9uIHx8ICFvcHRpb25zLnNoaW1GaXJlZm94KSB7XG4gICAgICAgIGxvZ2dpbmcoJ0ZpcmVmb3ggc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBmaXJlZm94LicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBmaXJlZm94U2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1QZWVyQ29ubmVjdGlvbi5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbU9uVHJhY2sod2luZG93KTtcbiAgICAgIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KTtcbiAgICAgIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpO1xuICAgICAgc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdyk7XG4gICAgICBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdyk7XG4gICAgICBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzYWZhcmknOlxuICAgICAgaWYgKCFzYWZhcmlTaGltIHx8ICFvcHRpb25zLnNoaW1TYWZhcmkpIHtcbiAgICAgICAgbG9nZ2luZygnU2FmYXJpIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgc2FmYXJpLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBzYWZhcmlTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbUNhbGxiYWNrQVBJLlxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZU9mZmVyTGVnYWN5KHdpbmRvdyk7XG4gICAgICBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdyk7XG4gICAgICBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpO1xuICAgICAgc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KTtcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5hZGFwdGVyRmFjdG9yeSh7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3dcbn0pO1xuXG5jb25zdCBFTkNSWVBUSU9OX0FMR09SSVRITSA9ICdBRVMtR0NNJztcbi8vIEhvdyBtYW55IGNvbnNlY3V0aXZlIGZyYW1lcyBjYW4gZmFpbCBkZWNyeXB0aW5nIGJlZm9yZSBhIHBhcnRpY3VsYXIga2V5IGdldHMgbWFya2VkIGFzIGludmFsaWRcbmNvbnN0IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UgPSAxMDtcbi8vIGZsYWcgc2V0IHRvIGluZGljYXRlIHRoYXQgZTJlZSBoYXMgYmVlbiBzZXR1cCBmb3Igc2VuZGVyL3JlY2VpdmVyO1xuY29uc3QgRTJFRV9GTEFHID0gJ2xrX2UyZWUnO1xuY29uc3QgU0FMVCA9ICdMS0ZyYW1lRW5jcnlwdGlvbktleSc7XG5jb25zdCBLRVlfUFJPVklERVJfREVGQVVMVFMgPSB7XG4gIHNoYXJlZEtleTogZmFsc2UsXG4gIHJhdGNoZXRTYWx0OiBTQUxULFxuICByYXRjaGV0V2luZG93U2l6ZTogOCxcbiAgZmFpbHVyZVRvbGVyYW5jZTogREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSxcbiAga2V5cmluZ1NpemU6IDE2XG59O1xuXG52YXIgS2V5UHJvdmlkZXJFdmVudDtcbihmdW5jdGlvbiAoS2V5UHJvdmlkZXJFdmVudCkge1xuICBLZXlQcm92aWRlckV2ZW50W1wiU2V0S2V5XCJdID0gXCJzZXRLZXlcIjtcbiAgLyoqIEV2ZW50IGZvciByZXF1ZXN0aW5nIHRvIHJhdGNoZXQgdGhlIGtleSB1c2VkIHRvIGVuY3J5cHQgdGhlIHN0cmVhbSAqL1xuICBLZXlQcm92aWRlckV2ZW50W1wiUmF0Y2hldFJlcXVlc3RcIl0gPSBcInJhdGNoZXRSZXF1ZXN0XCI7XG4gIC8qKiBFbWl0dGVkIHdoZW4gYSBrZXkgaXMgcmF0Y2hldGVkLiBDb3VsZCBiZSBhZnRlciBhdXRvLXJhdGNoZXRpbmcgb24gZGVjcnlwdGlvbiBmYWlsdXJlIG9yXG4gICAqICBmb2xsb3dpbmcgYSBgUmF0Y2hldFJlcXVlc3RgLCB3aWxsIGNvbnRhaW4gdGhlIHJhdGNoZXRlZCBrZXkgbWF0ZXJpYWwgKi9cbiAgS2V5UHJvdmlkZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XG59KShLZXlQcm92aWRlckV2ZW50IHx8IChLZXlQcm92aWRlckV2ZW50ID0ge30pKTtcbnZhciBLZXlIYW5kbGVyRXZlbnQ7XG4oZnVuY3Rpb24gKEtleUhhbmRsZXJFdmVudCkge1xuICAvKiogRW1pdHRlZCB3aGVuIGEga2V5IGhhcyBiZWVuIHJhdGNoZXRlZC4gSXMgZW1pdHRlZCB3aGVuIGFueSBrZXkgaGFzIGJlZW4gcmF0Y2hldGVkXG4gICAqIGkuZS4gd2hlbiB0aGUgRnJhbWVDcnlwdG9yIHRyaWVkIHRvIHJhdGNoZXQgd2hlbiBkZWNyeXB0aW9uIGlzIGZhaWxpbmcgICovXG4gIEtleUhhbmRsZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XG59KShLZXlIYW5kbGVyRXZlbnQgfHwgKEtleUhhbmRsZXJFdmVudCA9IHt9KSk7XG52YXIgRW5jcnlwdGlvbkV2ZW50O1xuKGZ1bmN0aW9uIChFbmNyeXB0aW9uRXZlbnQpIHtcbiAgRW5jcnlwdGlvbkV2ZW50W1wiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICBFbmNyeXB0aW9uRXZlbnRbXCJFbmNyeXB0aW9uRXJyb3JcIl0gPSBcImVuY3J5cHRpb25FcnJvclwiO1xufSkoRW5jcnlwdGlvbkV2ZW50IHx8IChFbmNyeXB0aW9uRXZlbnQgPSB7fSkpO1xudmFyIENyeXB0b3JFdmVudDtcbihmdW5jdGlvbiAoQ3J5cHRvckV2ZW50KSB7XG4gIENyeXB0b3JFdmVudFtcIkVycm9yXCJdID0gXCJjcnlwdG9yRXJyb3JcIjtcbn0pKENyeXB0b3JFdmVudCB8fCAoQ3J5cHRvckV2ZW50ID0ge30pKTtcblxuZnVuY3Rpb24gaXNFMkVFU3VwcG9ydGVkKCkge1xuICByZXR1cm4gaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkKCkgfHwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKTtcbn1cbmZ1bmN0aW9uIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB0eXBlb2Ygd2luZG93LlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgLy8gQHRzLWlnbm9yZVxuICB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuY3JlYXRlRW5jb2RlZFN0cmVhbXMgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNWaWRlb0ZyYW1lKGZyYW1lKSB7XG4gIHJldHVybiAndHlwZScgaW4gZnJhbWU7XG59XG5mdW5jdGlvbiBpbXBvcnRLZXkoa2V5Qnl0ZXNfMSkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2V5Qnl0ZXMpIHtcbiAgICBsZXQgYWxnb3JpdGhtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITVxuICAgIH07XG4gICAgbGV0IHVzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnZW5jcnlwdCc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2ltcG9ydEtleVxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBrZXlCeXRlcywgYWxnb3JpdGhtLCBmYWxzZSwgdXNhZ2UgPT09ICdkZXJpdmUnID8gWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddIDogWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgfSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhwYXNzd29yZCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGxldCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBlbmMuZW5jb2RlKHBhc3N3b3JkKSwge1xuICAgICAgbmFtZTogJ1BCS0RGMidcbiAgICB9LCBmYWxzZSwgWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddKTtcbiAgICByZXR1cm4ga2V5TWF0ZXJpYWw7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGNyeXB0b0J1ZmZlcikge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGtleU1hdGVyaWFsID0geWllbGQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGNyeXB0b0J1ZmZlciwgJ0hLREYnLCBmYWxzZSwgWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddKTtcbiAgICByZXR1cm4ga2V5TWF0ZXJpYWw7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWxnb09wdGlvbnMoYWxnb3JpdGhtTmFtZSwgc2FsdCkge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBlbmNvZGVkU2FsdCA9IHRleHRFbmNvZGVyLmVuY29kZShzYWx0KTtcbiAgc3dpdGNoIChhbGdvcml0aG1OYW1lKSB7XG4gICAgY2FzZSAnSEtERic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnSEtERicsXG4gICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxuICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgIGluZm86IG5ldyBBcnJheUJ1ZmZlcigxMjgpXG4gICAgICB9O1xuICAgIGNhc2UgJ1BCS0RGMic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbGdvcml0aG0gXCIuY29uY2F0KGFsZ29yaXRobU5hbWUsIFwiIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZFwiKSk7XG4gIH1cbn1cbi8qKlxuICogRGVyaXZlcyBhIHNldCBvZiBrZXlzIGZyb20gdGhlIG1hc3RlciBrZXkuXG4gKiBTZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMy4xXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZUtleXMobWF0ZXJpYWwsIHNhbHQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhbGdvcml0aG1PcHRpb25zID0gZ2V0QWxnb09wdGlvbnMobWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsIHNhbHQpO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlS2V5I0hLREZcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGtkZlBhcmFtc1xuICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShhbGdvcml0aG1PcHRpb25zLCBtYXRlcmlhbCwge1xuICAgICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE0sXG4gICAgICBsZW5ndGg6IDEyOFxuICAgIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0ZXJpYWwsXG4gICAgICBlbmNyeXB0aW9uS2V5XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFMkVFS2V5KCkge1xuICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbn1cbi8qKlxuICogUmF0Y2hldHMgYSBrZXkuIFNlZVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMy41LjFcbiAqL1xuZnVuY3Rpb24gcmF0Y2hldChtYXRlcmlhbCwgc2FsdCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVCaXRzXG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyhhbGdvcml0aG1PcHRpb25zLCBtYXRlcmlhbCwgMjU2KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBuZWVkc1Jic3BVbmVzY2FwaW5nKGZyYW1lRGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lRGF0YS5sZW5ndGggLSAzOyBpKyspIHtcbiAgICBpZiAoZnJhbWVEYXRhW2ldID09IDAgJiYgZnJhbWVEYXRhW2kgKyAxXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMl0gPT0gMykgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VSYnNwKHN0cmVhbSkge1xuICBjb25zdCBkYXRhT3V0ID0gW107XG4gIHZhciBsZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbS5sZW5ndGg7KSB7XG4gICAgLy8gQmUgY2FyZWZ1bCBhYm91dCBvdmVyL3VuZGVyZmxvdyBoZXJlLiBieXRlX2xlbmd0aF8gLSAzIGNhbiB1bmRlcmZsb3csIGFuZFxuICAgIC8vIGkgKyAzIGNhbiBvdmVyZmxvdywgYnV0IGJ5dGVfbGVuZ3RoXyAtIGkgY2FuJ3QsIGJlY2F1c2UgaSA8IGJ5dGVfbGVuZ3RoX1xuICAgIC8vIGFib3ZlLCBhbmQgdGhhdCBleHByZXNzaW9uIHdpbGwgcHJvZHVjZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgaW5cbiAgICAvLyB0aGUgc3RyZWFtIGluY2x1ZGluZyB0aGUgYnl0ZSBhdCBpLlxuICAgIGlmIChsZW5ndGggLSBpID49IDMgJiYgIXN0cmVhbVtpXSAmJiAhc3RyZWFtW2kgKyAxXSAmJiBzdHJlYW1baSArIDJdID09IDMpIHtcbiAgICAgIC8vIFR3byByYnNwIGJ5dGVzLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgICAvLyBTa2lwIHRoZSBlbXVsYXRpb24gYnl0ZS5cbiAgICAgIGkrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2luZ2xlIHJic3AgYnl0ZS5cbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcbn1cbmNvbnN0IGtaZXJvc0luU3RhcnRTZXF1ZW5jZSA9IDI7XG5jb25zdCBrRW11bGF0aW9uQnl0ZSA9IDM7XG5mdW5jdGlvbiB3cml0ZVJic3AoZGF0YV9pbikge1xuICBjb25zdCBkYXRhT3V0ID0gW107XG4gIHZhciBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhX2luLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ5dGUgPSBkYXRhX2luW2ldO1xuICAgIGlmIChieXRlIDw9IGtFbXVsYXRpb25CeXRlICYmIG51bUNvbnNlY3V0aXZlWmVyb3MgPj0ga1plcm9zSW5TdGFydFNlcXVlbmNlKSB7XG4gICAgICAvLyBOZWVkIHRvIGVzY2FwZS5cbiAgICAgIGRhdGFPdXQucHVzaChrRW11bGF0aW9uQnl0ZSk7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gICAgZGF0YU91dC5wdXNoKGJ5dGUpO1xuICAgIGlmIChieXRlID09IDApIHtcbiAgICAgICsrbnVtQ29uc2VjdXRpdmVaZXJvcztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcbn1cbmZ1bmN0aW9uIGFzRW5jcnlwdGFibGVQYWNrZXQocGFja2V0KSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gIGlmICgoKF9hID0gcGFja2V0LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FzZSkgIT09ICdzaXBEdG1mJyAmJiAoKF9iID0gcGFja2V0LnZhbHVlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FzZSkgIT09ICdtZXRyaWNzJyAmJiAoKF9jID0gcGFja2V0LnZhbHVlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FzZSkgIT09ICdzcGVha2VyJyAmJiAoKF9kID0gcGFja2V0LnZhbHVlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FzZSkgIT09ICd0cmFuc2NyaXB0aW9uJyAmJiAoKF9lID0gcGFja2V0LnZhbHVlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FzZSkgIT09ICdlbmNyeXB0ZWRQYWNrZXQnKSB7XG4gICAgcmV0dXJuIG5ldyBFbmNyeXB0ZWRQYWNrZXRQYXlsb2FkKHtcbiAgICAgIHZhbHVlOiBwYWNrZXQudmFsdWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuY2xhc3MgQmFzZUtleVByb3ZpZGVyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBiZWluZyBpbnZva2VkIGFmdGVyIGEga2V5IGhhcyBiZWVuIHJhdGNoZXRlZC5cbiAgICAgKiBDYW4gaGFwcGVuIHdoZW46XG4gICAgICogLSBBIGRlY3J5cHRpb24gZmFpbHVyZSBvY2N1cnMgYW5kIHRoZSBrZXkgaXMgYXV0by1yYXRjaGV0ZWRcbiAgICAgKiAtIEEgcmF0Y2hldCByZXF1ZXN0IGlzIHNlbnQgKHNlZSB7QGxpbmsgcmF0Y2hldEtleSgpfSlcbiAgICAgKiBAcGFyYW0gcmF0Y2hldFJlc3VsdCBDb250YWlucyB0aGUgcmF0Y2hldGVkIGNoYWluIGtleSAoZXhwb3J0YWJsZSB0byBvdGhlciBwYXJ0aWNpcGFudHMpIGFuZCB0aGUgZGVyaXZlZCBuZXcga2V5IG1hdGVyaWFsLlxuICAgICAqIEBwYXJhbSBwYXJ0aWNpcGFudElkXG4gICAgICogQHBhcmFtIGtleUluZGV4XG4gICAgICovXG4gICAgdGhpcy5vbktleVJhdGNoZXRlZCA9IChyYXRjaGV0UmVzdWx0LCBwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygna2V5IHJhdGNoZXRlZCBldmVudCByZWNlaXZlZCcsIHtcbiAgICAgICAgcmF0Y2hldFJlc3VsdCxcbiAgICAgICAgcGFydGljaXBhbnRJZCxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5rZXlJbmZvTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgS0VZX1BST1ZJREVSX0RFRkFVTFRTKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZCwgdGhpcy5vbktleVJhdGNoZXRlZCk7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIGEga2V5IGhhcyBiZWVuIHNldCBmb3IgYSBwYXJ0aWNpcGFudFxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKi9cbiAgb25TZXRFbmNyeXB0aW9uS2V5KGtleSwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcbiAgICBjb25zdCBrZXlJbmZvID0ge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaGFyZWRLZXkgJiYgIXBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGljaXBhbnQgaWRlbnRpdHkgbmVlZHMgdG8gYmUgcGFzc2VkIGZvciBlbmNyeXB0aW9uIGtleSBpZiBzaGFyZWRLZXkgb3B0aW9uIGlzIGZhbHNlJyk7XG4gICAgfVxuICAgIHRoaXMua2V5SW5mb01hcC5zZXQoXCJcIi5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSAhPT0gbnVsbCAmJiBwYXJ0aWNpcGFudElkZW50aXR5ICE9PSB2b2lkIDAgPyBwYXJ0aWNpcGFudElkZW50aXR5IDogJ3NoYXJlZCcsIFwiLVwiKS5jb25jYXQoa2V5SW5kZXggIT09IG51bGwgJiYga2V5SW5kZXggIT09IHZvaWQgMCA/IGtleUluZGV4IDogMCksIGtleUluZm8pO1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyk7XG4gIH1cbiAgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleUluZm9NYXAudmFsdWVzKCkpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuICByYXRjaGV0S2V5KHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgdGhpcy5lbWl0KEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KTtcbiAgfVxufVxuLyoqXG4gKiBBIGJhc2ljIEtleVByb3ZpZGVyIGltcGxlbWVudGF0aW9uIGludGVuZGVkIGZvciBhIHNpbmdsZSBzaGFyZWRcbiAqIHBhc3NwaHJhc2UgYmV0d2VlbiBhbGwgcGFydGljaXBhbnRzXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyIGV4dGVuZHMgQmFzZUtleVByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBzaGFyZWRLZXk6IHRydWUsXG4gICAgICAvLyBmb3IgYSBzaGFyZWQga2V5IHByb3ZpZGVyIGZhaWxpbmcgdG8gZGVjcnlwdCBmb3IgYSBzcGVjaWZpYyBwYXJ0aWNpcGFudFxuICAgICAgLy8gc2hvdWxkIG5vdCBtYXJrIHRoZSBrZXkgYXMgaW52YWxpZCwgc28gd2UgYWNjZXB0IHdyb25nIGtleXMgZm9yZXZlclxuICAgICAgLy8gYW5kIHdvbid0IHRyeSB0byBhdXRvLXJhdGNoZXRcbiAgICAgIHJhdGNoZXRXaW5kb3dTaXplOiAwLFxuICAgICAgZmFpbHVyZVRvbGVyYW5jZTogLTFcbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhIHBhc3NwaHJhc2UgdGhhdCdzIHVzZWQgdG8gY3JlYXRlIHRoZSBjcnlwdG8ga2V5cy5cbiAgICogV2hlbiBwYXNzaW5nIGluIGEgc3RyaW5nLCBQQktERjIgaXMgdXNlZC5cbiAgICogV2hlbiBwYXNzaW5nIGluIGFuIEFycmF5IGJ1ZmZlciBvZiBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gbnVtYmVycywgSEtERiBpcyBiZWluZyB1c2VkLiAocmVjb21tZW5kZWQpXG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIHNldEtleShrZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZGVyaXZlZEtleSA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8geWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKGtleSkgOiB5aWVsZCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIoa2V5KTtcbiAgICAgIHRoaXMub25TZXRFbmNyeXB0aW9uS2V5KGRlcml2ZWRLZXkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIExpdmVraXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ2FuIGVycm9yIGhhcyBvY2N1cmVkJyk7XG4gICAgdGhpcy5uYW1lID0gJ0xpdmVLaXRFcnJvcic7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxudmFyIENvbm5lY3Rpb25FcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkVycm9yUmVhc29uKSB7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJOb3RBbGxvd2VkXCJdID0gMF0gPSBcIk5vdEFsbG93ZWRcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIlNlcnZlclVucmVhY2hhYmxlXCJdID0gMV0gPSBcIlNlcnZlclVucmVhY2hhYmxlXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJJbnRlcm5hbEVycm9yXCJdID0gMl0gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIkNhbmNlbGxlZFwiXSA9IDNdID0gXCJDYW5jZWxsZWRcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIkxlYXZlUmVxdWVzdFwiXSA9IDRdID0gXCJMZWF2ZVJlcXVlc3RcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIlRpbWVvdXRcIl0gPSA1XSA9IFwiVGltZW91dFwiO1xufSkoQ29ubmVjdGlvbkVycm9yUmVhc29uIHx8IChDb25uZWN0aW9uRXJyb3JSZWFzb24gPSB7fSkpO1xuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVhc29uLCBzdGF0dXMsIGNvbnRleHQpIHtcbiAgICBzdXBlcigxLCBtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnQ29ubmVjdGlvbkVycm9yJztcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucmVhc29uTmFtZSA9IENvbm5lY3Rpb25FcnJvclJlYXNvbltyZWFzb25dO1xuICB9XG59XG5jbGFzcyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDIxLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnZGV2aWNlIGlzIHVuc3VwcG9ydGVkJyk7XG4gICAgdGhpcy5uYW1lID0gJ0RldmljZVVuc3VwcG9ydGVkRXJyb3InO1xuICB9XG59XG5jbGFzcyBUcmFja0ludmFsaWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigyMCwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3RyYWNrIGlzIGludmFsaWQnKTtcbiAgICB0aGlzLm5hbWUgPSAnVHJhY2tJbnZhbGlkRXJyb3InO1xuICB9XG59XG5jbGFzcyBVbnN1cHBvcnRlZFNlcnZlciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMCwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3Vuc3VwcG9ydGVkIHNlcnZlcicpO1xuICAgIHRoaXMubmFtZSA9ICdVbnN1cHBvcnRlZFNlcnZlcic7XG4gIH1cbn1cbmNsYXNzIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTIsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmV4cGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUnKTtcbiAgICB0aGlzLm5hbWUgPSAnVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSc7XG4gIH1cbn1cbmNsYXNzIE5lZ290aWF0aW9uRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTMsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmFibGUgdG8gbmVnb3RpYXRlJyk7XG4gICAgdGhpcy5uYW1lID0gJ05lZ290aWF0aW9uRXJyb3InO1xuICB9XG59XG5jbGFzcyBQdWJsaXNoRGF0YUVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDE0LCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5hYmxlIHRvIHB1Ymxpc2ggZGF0YScpO1xuICAgIHRoaXMubmFtZSA9ICdQdWJsaXNoRGF0YUVycm9yJztcbiAgfVxufVxuY2xhc3MgUHVibGlzaFRyYWNrRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMpIHtcbiAgICBzdXBlcigxNSwgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1B1Ymxpc2hUcmFja0Vycm9yJztcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxufVxuY2xhc3MgU2lnbmFsUmVxdWVzdEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVhc29uKSB7XG4gICAgc3VwZXIoMTUsIG1lc3NhZ2UpO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMucmVhc29uTmFtZSA9IHR5cGVvZiByZWFzb24gPT09ICdzdHJpbmcnID8gcmVhc29uIDogUmVxdWVzdFJlc3BvbnNlX1JlYXNvbltyZWFzb25dO1xuICB9XG59XG4vLyBOT1RFOiBtYXRjaGVzIHdpdGggaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvY2xpZW50LXNkay1zd2lmdC9ibG9iL2YzN2JiZDI2MGQ2MWUxNjUwODQ5NjJkYjgyMmM3OWY5OTVmMWExMTMvU291cmNlcy9MaXZlS2l0L0RhdGFTdHJlYW0vU3RyZWFtRXJyb3Iuc3dpZnQjTDE3XG52YXIgRGF0YVN0cmVhbUVycm9yUmVhc29uO1xuKGZ1bmN0aW9uIChEYXRhU3RyZWFtRXJyb3JSZWFzb24pIHtcbiAgLy8gVW5hYmxlIHRvIG9wZW4gYSBzdHJlYW0gd2l0aCB0aGUgc2FtZSBJRCBtb3JlIHRoYW4gb25jZS5cbiAgRGF0YVN0cmVhbUVycm9yUmVhc29uW0RhdGFTdHJlYW1FcnJvclJlYXNvbltcIkFscmVhZHlPcGVuZWRcIl0gPSAwXSA9IFwiQWxyZWFkeU9wZW5lZFwiO1xuICAvLyBTdHJlYW0gY2xvc2VkIGFibm9ybWFsbHkgYnkgcmVtb3RlIHBhcnRpY2lwYW50LlxuICBEYXRhU3RyZWFtRXJyb3JSZWFzb25bRGF0YVN0cmVhbUVycm9yUmVhc29uW1wiQWJub3JtYWxFbmRcIl0gPSAxXSA9IFwiQWJub3JtYWxFbmRcIjtcbiAgLy8gSW5jb21pbmcgY2h1bmsgZGF0YSBjb3VsZCBub3QgYmUgZGVjb2RlZC5cbiAgRGF0YVN0cmVhbUVycm9yUmVhc29uW0RhdGFTdHJlYW1FcnJvclJlYXNvbltcIkRlY29kZUZhaWxlZFwiXSA9IDJdID0gXCJEZWNvZGVGYWlsZWRcIjtcbiAgLy8gUmVhZCBsZW5ndGggZXhjZWVkZWQgdG90YWwgbGVuZ3RoIHNwZWNpZmllZCBpbiBzdHJlYW0gaGVhZGVyLlxuICBEYXRhU3RyZWFtRXJyb3JSZWFzb25bRGF0YVN0cmVhbUVycm9yUmVhc29uW1wiTGVuZ3RoRXhjZWVkZWRcIl0gPSAzXSA9IFwiTGVuZ3RoRXhjZWVkZWRcIjtcbiAgLy8gUmVhZCBsZW5ndGggbGVzcyB0aGFuIHRvdGFsIGxlbmd0aCBzcGVjaWZpZWQgaW4gc3RyZWFtIGhlYWRlci5cbiAgRGF0YVN0cmVhbUVycm9yUmVhc29uW0RhdGFTdHJlYW1FcnJvclJlYXNvbltcIkluY29tcGxldGVcIl0gPSA0XSA9IFwiSW5jb21wbGV0ZVwiO1xuICAvLyBVbmFibGUgdG8gcmVnaXN0ZXIgYSBzdHJlYW0gaGFuZGxlciBtb3JlIHRoYW4gb25jZS5cbiAgRGF0YVN0cmVhbUVycm9yUmVhc29uW0RhdGFTdHJlYW1FcnJvclJlYXNvbltcIkhhbmRsZXJBbHJlYWR5UmVnaXN0ZXJlZFwiXSA9IDddID0gXCJIYW5kbGVyQWxyZWFkeVJlZ2lzdGVyZWRcIjtcbiAgLy8gRW5jcnlwdGlvbiB0eXBlIG1pc21hdGNoLlxuICBEYXRhU3RyZWFtRXJyb3JSZWFzb25bRGF0YVN0cmVhbUVycm9yUmVhc29uW1wiRW5jcnlwdGlvblR5cGVNaXNtYXRjaFwiXSA9IDhdID0gXCJFbmNyeXB0aW9uVHlwZU1pc21hdGNoXCI7XG59KShEYXRhU3RyZWFtRXJyb3JSZWFzb24gfHwgKERhdGFTdHJlYW1FcnJvclJlYXNvbiA9IHt9KSk7XG5jbGFzcyBEYXRhU3RyZWFtRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24pIHtcbiAgICBzdXBlcigxNiwgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0RhdGFTdHJlYW1FcnJvcic7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5yZWFzb25OYW1lID0gRGF0YVN0cmVhbUVycm9yUmVhc29uW3JlYXNvbl07XG4gIH1cbn1cbnZhciBNZWRpYURldmljZUZhaWx1cmU7XG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xuICAvLyB1c2VyIHJlamVjdGVkIHBlcm1pc3Npb25zXG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIlBlcm1pc3Npb25EZW5pZWRcIl0gPSBcIlBlcm1pc3Npb25EZW5pZWRcIjtcbiAgLy8gZGV2aWNlIGlzIG5vdCBhdmFpbGFibGVcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiTm90Rm91bmRcIl0gPSBcIk5vdEZvdW5kXCI7XG4gIC8vIGRldmljZSBpcyBpbiB1c2UuIE9uIFdpbmRvd3MsIG9ubHkgYSBzaW5nbGUgdGFiIG1heSBnZXQgYWNjZXNzIHRvIGEgZGV2aWNlIGF0IGEgdGltZS5cbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiRGV2aWNlSW5Vc2VcIl0gPSBcIkRldmljZUluVXNlXCI7XG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIk90aGVyXCJdID0gXCJPdGhlclwiO1xufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xuKGZ1bmN0aW9uIChNZWRpYURldmljZUZhaWx1cmUpIHtcbiAgZnVuY3Rpb24gZ2V0RmFpbHVyZShlcnJvcikge1xuICAgIGlmIChlcnJvciAmJiAnbmFtZScgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk5vdEZvdW5kO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuUGVybWlzc2lvbkRlbmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5EZXZpY2VJblVzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuT3RoZXI7XG4gICAgfVxuICB9XG4gIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlID0gZ2V0RmFpbHVyZTtcbn0pKE1lZGlhRGV2aWNlRmFpbHVyZSB8fCAoTWVkaWFEZXZpY2VGYWlsdXJlID0ge30pKTtcblxudmFyIENyeXB0b3JFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoQ3J5cHRvckVycm9yUmVhc29uKSB7XG4gIENyeXB0b3JFcnJvclJlYXNvbltDcnlwdG9yRXJyb3JSZWFzb25bXCJJbnZhbGlkS2V5XCJdID0gMF0gPSBcIkludmFsaWRLZXlcIjtcbiAgQ3J5cHRvckVycm9yUmVhc29uW0NyeXB0b3JFcnJvclJlYXNvbltcIk1pc3NpbmdLZXlcIl0gPSAxXSA9IFwiTWlzc2luZ0tleVwiO1xuICBDcnlwdG9yRXJyb3JSZWFzb25bQ3J5cHRvckVycm9yUmVhc29uW1wiSW50ZXJuYWxFcnJvclwiXSA9IDJdID0gXCJJbnRlcm5hbEVycm9yXCI7XG59KShDcnlwdG9yRXJyb3JSZWFzb24gfHwgKENyeXB0b3JFcnJvclJlYXNvbiA9IHt9KSk7XG5jbGFzcyBDcnlwdG9yRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQ3J5cHRvckVycm9yUmVhc29uLkludGVybmFsRXJyb3I7XG4gICAgbGV0IHBhcnRpY2lwYW50SWRlbnRpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcig0MCwgbWVzc2FnZSk7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgfVxufVxuXG4vKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xudmFyIFJvb21FdmVudDtcbihmdW5jdGlvbiAoUm9vbUV2ZW50KSB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWRcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYW5kIGl0J3MgYXR0ZW1wdGluZ1xuICAgKiB0byByZWNvbm5lY3QuXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogV2hlbiB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBpbnRlcnJ1cHRlZC4gVGhpcyBpc24ndCBub3RpY2VhYmxlIHRvIHVzZXJzIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqIEl0IHdpbGwgcmVzb2x2ZSB3aXRoIGEgYFJvb21FdmVudC5SZWNvbm5lY3RlZGAgb25jZSB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmUtZXN0YWJsaXNoZWQuXG4gICAqIElmIG1lZGlhIGZhaWxzIGFkZGl0aW9uYWxseSBpdCBhbiBhZGRpdGlvbmFsIGBSb29tRXZlbnQuUmVjb25uZWN0aW5nYCB3aWxsIGJlIGVtaXR0ZWQuXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaWduYWxSZWNvbm5lY3RpbmdcIl0gPSBcInNpZ25hbFJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogRmlyZXMgd2hlbiBhIHJlY29ubmVjdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb25uZWN0ZWRcIl0gPSBcInJlY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGRpc2Nvbm5lY3RlZCBmcm9tIHJvb20uIFRoaXMgZmlyZXMgd2hlbiByb29tLmRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQgb3JcbiAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWQuXG4gICAqXG4gICAqIERpc2Nvbm5lY3RSZWFzb24gY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoeSB0aGUgcGFydGljaXBhbnQgd2FzIGRpc2Nvbm5lY3RlZC4gTm90YWJsZSByZWFzb25zIGFyZVxuICAgKiAtIERVUExJQ0FURV9JREVOVElUWTogYW5vdGhlciBjbGllbnQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eSBoYXMgam9pbmVkIHRoZSByb29tXG4gICAqIC0gUEFSVElDSVBBTlRfUkVNT1ZFRDogcGFydGljaXBhbnQgd2FzIHJlbW92ZWQgYnkgUmVtb3ZlUGFydGljaXBhbnQgQVBJXG4gICAqIC0gUk9PTV9ERUxFVEVEOiB0aGUgcm9vbSBoYXMgZW5kZWQgdmlhIERlbGV0ZVJvb20gQVBJXG4gICAqXG4gICAqIGFyZ3M6IChbW0Rpc2Nvbm5lY3RSZWFzb25dXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgcm9vbSBjaGFuZ2VzXG4gICAqXG4gICAqIGFyZ3M6IChbW0Nvbm5lY3Rpb25TdGF0ZV1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiO1xuICAvKipcbiAgICogV2hlbiBwYXJ0aWNpcGFudCBoYXMgYmVlbiBtb3ZlZCB0byBhIGRpZmZlcmVudCByb29tIGJ5IHRoZSBzZXJ2aWNlIHJlcXVlc3QuXG4gICAqIFRoZSBiZWhhdmlvciBsb29rcyBsaWtlIHRoZSBwYXJ0aWNpcGFudCBoYXMgYmVlbiBkaXNjb25uZWN0ZWQgYW5kIHJlY29ubmVjdGVkIHRvIGEgZGlmZmVyZW50IHJvb21cbiAgICogc2VhbWxlc3NseSB3aXRob3V0IGNvbm5lY3Rpb24gc3RhdGUgdHJhbnNpdGlvbi5cbiAgICogQSBuZXcgdG9rZW4gd2lsbCBiZSBwcm92aWRlZCBmb3IgcmVjb25uZWN0aW5nIHRvIHRoZSBuZXcgcm9vbSBpZiBuZWVkZWQuXG4gICAqXG4gICAqIGFyZ3M6IChbW3Jvb206IHN0cmluZywgdG9rZW46IHN0cmluZ11dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTW92ZWRcIl0gPSBcIm1vdmVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGlucHV0IG9yIG91dHB1dCBkZXZpY2VzIG9uIHRoZSBtYWNoaW5lIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0NoYW5nZWRcIl0gPSBcIm1lZGlhRGV2aWNlc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gam9pbnMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQuIEl0IHdpbGwgbm90IGVtaXQgZXZlbnRzIGZvciBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWxyZWFkeVxuICAgKiBpbiB0aGUgcm9vbVxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRDb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50Q29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGxlYXZlcyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnREaXNjb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBUaGUgW1tMb2NhbFBhcnRpY2lwYW50XV0gaGFzIHN1YnNjcmliZWQgdG8gYSBuZXcgdHJhY2suIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqXG4gICAqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbm11dGVkXCJdID0gXCJ0cmFja1VubXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XG4gICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBsb2NhbCBhdWRpbyB0cmFjayBpcyBwdWJsaXNoZWQgdGhlIFNESyBjaGVja3Mgd2hldGhlciB0aGVyZSBpcyBjb21wbGV0ZSBzaWxlbmNlXG4gICAqIG9uIHRoYXQgdHJhY2sgYW5kIGVtaXRzIHRoZSBMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIGV2ZW50IGluIHRoYXQgY2FzZS5cbiAgICogVGhpcyBhbGxvd3MgZm9yIGFwcGxpY2F0aW9ucyB0byBzaG93IFVJIGluZm9ybWluZyB1c2VycyB0aGF0IHRoZXkgbWlnaHQgaGF2ZSB0b1xuICAgKiByZXNldCB0aGVpciBhdWRpbyBoYXJkd2FyZSBvciBjaGVjayBmb3IgcHJvcGVyIGRldmljZSBjb25uZWN0aXZpdHkuXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJsb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XG4gIC8qKlxuICAgKiBBY3RpdmUgc3BlYWtlcnMgY2hhbmdlZC4gTGlzdCBvZiBzcGVha2VycyBhcmUgb3JkZXJlZCBieSB0aGVpciBhdWRpbyBsZXZlbC5cbiAgICogbG91ZGVzdCBzcGVha2VycyBmaXJzdC4gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIExvY2FsUGFydGljaXBhbnQgdG9vLlxuICAgKlxuICAgKiBTcGVha2VyIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB0byB0aGUgcHVibGlzaGluZyBwYXJ0aWNpcGFudCBhbmQgdGhlaXIgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIGFyZ3M6IChBcnJheTxbW1BhcnRpY2lwYW50XV0+KVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJhY3RpdmVTcGVha2Vyc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcbiAgICpcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQgYXR0cmlidXRlcyBpcyBhbiBhcHAtc3BlY2lmaWMga2V5IHZhbHVlIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gYSBwYXJ0aWNpcGFudCdzIGF0dHJpYnV0ZXMgY2hhbmdlZCwgdGhpcyBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgY2hhbmdlZCBhdHRyaWJ1dGVzIGFuZCB0aGUgcGFydGljaXBhbnRcbiAgICogYXJnczogKGNoYW5nZWRBdHRyaWJ1dGVzOiBbW1JlY29yZDxzdHJpbmcsIHN0cmluZ11dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBwYXJ0aWNpcGFudCdzIHN0YXRlIGNoYW5nZXMgdG8gQUNUSVZFIGFuZCBpcyByZWFkeSB0byBzZW5kL3JlY2VpdmUgZGF0YSBtZXNzYWdlc1xuICAgKlxuICAgKiBhcmdzOiAocGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50QWN0aXZlXCJdID0gXCJwYXJ0aWNpcGFudEFjdGl2ZVwiO1xuICAvKipcbiAgICogUm9vbSBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVJvb21NZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcm9vbSdzIHN0YXRlLFxuICAgKiAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAoc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUm9vbU1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicm9vbU1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0sIHRvcGljPzogc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIFNJUCBEVE1GIHRvbmVzIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGR0bWY6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xuICAvKipcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIGEgcGFydGljaXBhbnQncyB0cmFjay5cbiAgICogQGJldGFcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYW5zY3JpcHRpb25SZWNlaXZlZFwiXSA9IFwidHJhbnNjcmlwdGlvblJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIHF1YWxpdHkgd2FzIGNoYW5nZWQgZm9yIGEgUGFydGljaXBhbnQuIEl0J2xsIHJlY2VpdmUgdXBkYXRlc1xuICAgKiBmcm9tIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCwgYXMgd2VsbCBhcyBhbnkgW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyB0aGF0IHdlIGFyZVxuICAgKiBzdWJzY3JpYmVkIHRvLlxuICAgKlxuICAgKiBhcmdzOiAoY29ubmVjdGlvblF1YWxpdHk6IFtbQ29ubmVjdGlvblF1YWxpdHldXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIChyZW1vdGUpIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiO1xuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgc3RhdHVzIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIGF1ZGlvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhdWRpbyBlbGVtZW50cy4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIGBSb29tLmNhblBsYXliYWNrQXVkaW9gIHdpbGwgaW5kaWNhdGUgaWYgYXVkaW8gcGxheWJhY2sgaXMgcGVybWl0dGVkLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgdmlkZW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXG4gICAqIGEgdmlkZW8gZWxlbWVudC4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIENhbGxpbmcgYHJvb20uc3RhcnRWaWRlbygpYCBpbiBhIHVzZXIgZ2VzdHVyZSBldmVudCBoYW5kbGVyIHdpbGwgcmVzdW1lIHRoZSB2aWRlbyBwbGF5YmFjay5cbiAgICovXG4gIFJvb21FdmVudFtcIlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJ2aWRlb1BsYXliYWNrQ2hhbmdlZFwiO1xuICAvKipcbiAgICogV2hlbiB3ZSBoYXZlIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgdHJhY2suXG4gICAqIFRoZSBlcnJvcnMgdGFrZSBwbGFjZSBpbiBnZXRVc2VyTWVkaWEoKS5cbiAgICogVXNlIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlKGVycm9yKSB0byBnZXQgdGhlIHJlYXNvbiBvZiBmYWlsdXJlLlxuICAgKiBbW0xvY2FsUGFydGljaXBhbnQubGFzdENhbWVyYUVycm9yXV0gYW5kIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0TWljcm9waG9uZUVycm9yXV1cbiAgICogd2lsbCBpbmRpY2F0ZSBpZiBpdCBoYWQgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGF1ZGlvIG9yIHZpZGVvIHRyYWNrIHJlc3BlY3RpdmVseS5cbiAgICpcbiAgICogYXJnczogKGVycm9yOiBFcnJvcilcbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0Vycm9yXCJdID0gXCJtZWRpYURldmljZXNFcnJvclwiO1xuICAvKipcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFNpZ25hbCBjb25uZWN0ZWQsIGNhbiBwdWJsaXNoIHRyYWNrcy5cbiAgICovXG4gIFJvb21FdmVudFtcIlNpZ25hbENvbm5lY3RlZFwiXSA9IFwic2lnbmFsQ29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBSZWNvcmRpbmcgb2YgYSByb29tIGhhcyBzdGFydGVkL3N0b3BwZWQuIFJvb20uaXNSZWNvcmRpbmcgd2lsbCBiZSB1cGRhdGVkIHRvby5cbiAgICogYXJnczogKGlzUmVjb3JkaW5nOiBib29sZWFuKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiXSA9IFwicmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiO1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIFJvb21FdmVudFtcIkVuY3J5cHRpb25FcnJvclwiXSA9IFwiZW5jcnlwdGlvbkVycm9yXCI7XG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGUgY3VycmVudCBidWZmZXIgc3RhdHVzIG9mIGEgZGF0YSBjaGFubmVsIGNoYW5nZXNcbiAgICogYXJnczogKGlzTG93OiBib29sZWFuLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRENCdWZmZXJTdGF0dXNDaGFuZ2VkXCJdID0gXCJkY0J1ZmZlclN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBieSBhIGNhbGwgdG8gcm9vbS5zd2l0Y2hBY3RpdmVEZXZpY2VcbiAgICogYXJnczogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZylcbiAgICovXG4gIFJvb21FdmVudFtcIkFjdGl2ZURldmljZUNoYW5nZWRcIl0gPSBcImFjdGl2ZURldmljZUNoYW5nZWRcIjtcbiAgUm9vbUV2ZW50W1wiQ2hhdE1lc3NhZ2VcIl0gPSBcImNoYXRNZXNzYWdlXCI7XG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIGxvY2FsUGFydGljaXBhbnQncyB0cmFja1xuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgY29ubmVjdGlvbiBtZXRyaWNzIGZyb20gb3RoZXIgcGFydGljaXBhbnRzXG4gICAqL1xuICBSb29tRXZlbnRbXCJNZXRyaWNzUmVjZWl2ZWRcIl0gPSBcIm1ldHJpY3NSZWNlaXZlZFwiO1xufSkoUm9vbUV2ZW50IHx8IChSb29tRXZlbnQgPSB7fSkpO1xudmFyIFBhcnRpY2lwYW50RXZlbnQ7XG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50RXZlbnQpIHtcbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiO1xuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIGhhcyBiZWVuIGNvbnN0cmFpbmVkIGJ5IGNwdS5cbiAgICogVGhpcyBldmVudCBpcyB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIHJlZHVjZSB0aGUgY2FwdHVyZSByZXNvbHV0aW9uIG9mIHRoZSB0cmFjay5cbiAgICpcbiAgICogVGhpcyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxWaWRlb1RyYWNrXV0sIFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja0NwdUNvbnN0cmFpbmVkXCJdID0gXCJsb2NhbFRyYWNrQ3B1Q29uc3RyYWluZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsU2VuZGVyQ3JlYXRlZFwiXSA9IFwibG9jYWxTZW5kZXJDcmVhdGVkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqIFRvIGFjY2VzcyB0aGUgY3VycmVudCBtZXRhZGF0YSwgc2VlIFtbUGFydGljaXBhbnQubWV0YWRhdGFdXS5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBTSVAgRFRNRiB0b25lcyByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKlxuICAgKiBhcmdzOiAoZHRtZjogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xuICAvKipcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgZGF0YSBzb3VyY2UuXG4gICAqIEBiZXRhXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhbnNjcmlwdGlvblJlY2VpdmVkXCJdID0gXCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIEhhcyBzcGVha2luZyBzdGF0dXMgY2hhbmdlZCBmb3IgdGhlIGN1cnJlbnQgcGFydGljaXBhbnRcbiAgICpcbiAgICogYXJnczogKHNwZWFraW5nOiBib29sZWFuKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIklzU3BlYWtpbmdDaGFuZ2VkXCJdID0gXCJpc1NwZWFraW5nQ2hhbmdlZFwiO1xuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiB0aGUgcmVtb3RlIHBhcnRpY2lwYW50cyBwdWJsaWNhdGlvbnMgaGFzIGNoYW5nZWQgaXRzIHN1YnNjcmlwdGlvbiBzdGF0dXMuXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIGEgbG9jYWwgdHJhY2sgaGFzIGJlZW4gY29uc3RyYWluZWQgYnkgY3B1XG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tDcHVDb25zdHJhaW5lZFwiXSA9IFwidHJhY2tDcHVDb25zdHJhaW5lZFwiO1xuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTWVkaWFEZXZpY2VzRXJyb3JcIl0gPSBcIm1lZGlhRGV2aWNlc0Vycm9yXCI7XG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJBdWRpb1N0cmVhbUFjcXVpcmVkXCJdID0gXCJhdWRpb1N0cmVhbUFjcXVpcmVkXCI7XG4gIC8qKlxuICAgKiBBIHBhcnRpY2lwYW50J3MgcGVybWlzc2lvbiBoYXMgY2hhbmdlZC5cbiAgICogYXJnczogKHByZXZQZXJtaXNzaW9uczogW1tQYXJ0aWNpcGFudFBlcm1pc3Npb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUENUcmFja0FkZGVkXCJdID0gXCJwY1RyYWNrQWRkZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IGF0dHJpYnV0ZXMgaXMgYW4gYXBwLXNwZWNpZmljIGtleSB2YWx1ZSBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIGEgcGFydGljaXBhbnQncyBhdHRyaWJ1dGVzIGNoYW5nZWQsIHRoaXMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgKiBhcmdzOiAoY2hhbmdlZEF0dHJpYnV0ZXM6IFtbUmVjb3JkPHN0cmluZywgc3RyaW5nXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQXR0cmlidXRlc0NoYW5nZWRcIl0gPSBcImF0dHJpYnV0ZXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBmaXJlZCBvbiBsb2NhbCBwYXJ0aWNpcGFudCBvbmx5LCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIHRyYWNrIHNwZWNpZmllZCBpbiB0aGUgcGF5bG9hZFxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJsb2NhbFRyYWNrU3Vic2NyaWJlZFwiO1xuICAvKiogb25seSBlbWl0dGVkIG9uIGxvY2FsIHBhcnRpY2lwYW50ICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJDaGF0TWVzc2FnZVwiXSA9IFwiY2hhdE1lc3NhZ2VcIjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgcGFydGljaXBhbnQncyBzdGF0ZSBjaGFuZ2VzIHRvIEFDVElWRSBhbmQgaXMgcmVhZHkgdG8gc2VuZC9yZWNlaXZlIGRhdGEgbWVzc2FnZXNcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJBY3RpdmVcIl0gPSBcImFjdGl2ZVwiO1xufSkoUGFydGljaXBhbnRFdmVudCB8fCAoUGFydGljaXBhbnRFdmVudCA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG52YXIgRW5naW5lRXZlbnQ7XG4oZnVuY3Rpb24gKEVuZ2luZUV2ZW50KSB7XG4gIEVuZ2luZUV2ZW50W1wiVHJhbnNwb3J0c0NyZWF0ZWRcIl0gPSBcInRyYW5zcG9ydHNDcmVhdGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtaW5nXCJdID0gXCJyZXN1bWluZ1wiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtZWRcIl0gPSBcInJlc3VtZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0aW5nXCJdID0gXCJyZXN0YXJ0aW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN1bWVkXCJdID0gXCJzaWduYWxSZXN1bWVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVzdGFydGVkXCJdID0gXCJzaWduYWxSZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiTWVkaWFUcmFja0FkZGVkXCJdID0gXCJtZWRpYVRyYWNrQWRkZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJBY3RpdmVTcGVha2Vyc1VwZGF0ZVwiXSA9IFwiYWN0aXZlU3BlYWtlcnNVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJEYXRhUGFja2V0UmVjZWl2ZWRcIl0gPSBcImRhdGFQYWNrZXRSZWNlaXZlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJUUFZpZGVvTWFwVXBkYXRlXCJdID0gXCJydHBWaWRlb01hcFVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUGFydGljaXBhbnRVcGRhdGVcIl0gPSBcInBhcnRpY2lwYW50VXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUm9vbVVwZGF0ZVwiXSA9IFwicm9vbVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwic3BlYWtlcnNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJzdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25FcnJvclwiXSA9IFwic3Vic2NyaXB0aW9uRXJyb3JcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCJdID0gXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVtb3RlTXV0ZVwiXSA9IFwicmVtb3RlTXV0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCJdID0gXCJzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiT2ZmbGluZVwiXSA9IFwib2ZmbGluZVwiO1xuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlcXVlc3RSZXNwb25zZVwiXSA9IFwic2lnbmFsUmVxdWVzdFJlc3BvbnNlXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsQ29ubmVjdGVkXCJdID0gXCJzaWduYWxDb25uZWN0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJSb29tTW92ZWRcIl0gPSBcInJvb21Nb3ZlZFwiO1xufSkoRW5naW5lRXZlbnQgfHwgKEVuZ2luZUV2ZW50ID0ge30pKTtcbnZhciBUcmFja0V2ZW50O1xuKGZ1bmN0aW9uIChUcmFja0V2ZW50KSB7XG4gIFRyYWNrRXZlbnRbXCJNZXNzYWdlXCJdID0gXCJtZXNzYWdlXCI7XG4gIFRyYWNrRXZlbnRbXCJNdXRlZFwiXSA9IFwibXV0ZWRcIjtcbiAgVHJhY2tFdmVudFtcIlVubXV0ZWRcIl0gPSBcInVubXV0ZWRcIjtcbiAgLyoqXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJSZXN0YXJ0ZWRcIl0gPSBcInJlc3RhcnRlZFwiO1xuICBUcmFja0V2ZW50W1wiRW5kZWRcIl0gPSBcImVuZGVkXCI7XG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XG4gIFRyYWNrRXZlbnRbXCJVbnN1YnNjcmliZWRcIl0gPSBcInVuc3Vic2NyaWJlZFwiO1xuICBUcmFja0V2ZW50W1wiQ3B1Q29uc3RyYWluZWRcIl0gPSBcImNwdUNvbnN0cmFpbmVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlVwZGF0ZVNldHRpbmdzXCJdID0gXCJ1cGRhdGVTZXR0aW5nc1wiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJVcGRhdGVTdWJzY3JpcHRpb25cIl0gPSBcInVwZGF0ZVN1YnNjcmlwdGlvblwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwiYXVkaW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwiYXVkaW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxBdWRpb1RyYWNrIGluc3RhbmNlc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJhdWRpb1NpbGVuY2VEZXRlY3RlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaXNpYmlsaXR5Q2hhbmdlZFwiXSA9IFwidmlzaWJpbGl0eUNoYW5nZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiXSA9IFwidmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwidmlkZW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwidmlkZW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50QXR0YWNoZWRcIl0gPSBcImVsZW1lbnRBdHRhY2hlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50RGV0YWNoZWRcIl0gPSBcImVsZW1lbnREZXRhY2hlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVBhdXNlZFwiXSA9IFwidXBzdHJlYW1QYXVzZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVXBzdHJlYW1SZXN1bWVkXCJdID0gXCJ1cHN0cmVhbVJlc3VtZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwic3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwic3Vic2NyaXB0aW9uRmFpbGVkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJUcmFja1Byb2Nlc3NvclVwZGF0ZVwiXSA9IFwidHJhY2tQcm9jZXNzb3JVcGRhdGVcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlXCJdID0gXCJhdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZVwiO1xuICAvKipcbiAgICogQGJldGFcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJUcmFuc2NyaXB0aW9uUmVjZWl2ZWRcIl0gPSBcInRyYW5zY3JpcHRpb25SZWNlaXZlZFwiO1xuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlRpbWVTeW5jVXBkYXRlXCJdID0gXCJ0aW1lU3luY1VwZGF0ZVwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBUcmFja0V2ZW50W1wiUHJlQ29ubmVjdEJ1ZmZlckZsdXNoZWRcIl0gPSBcInByZUNvbm5lY3RCdWZmZXJGbHVzaGVkXCI7XG59KShUcmFja0V2ZW50IHx8IChUcmFja0V2ZW50ID0ge30pKTtcblxuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlZENsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBub3QgYSBwcm94eSBieSBzcHJlYWRpbmcgaXRcbiAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgfVxufVxuXG4vLyB0aW55LCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2xhbmNlZGlrc29uL2Jvd3Nlci9ibG9iL21hc3Rlci9zcmMvcGFyc2VyLWJyb3dzZXJzLmpzXG4vLyByZWR1Y2VkIHRvIG9ubHkgZGlmZmVyZW50aWF0ZSBDaHJvbWUoaXVtKSBiYXNlZCBicm93c2VycyAvIEZpcmVmb3ggLyBTYWZhcmlcbmNvbnN0IGNvbW1vblZlcnNpb25JZGVudGlmaWVyID0gL3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2k7XG5sZXQgYnJvd3NlckRldGFpbHM7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRCcm93c2VyKHVzZXJBZ2VudCkge1xuICBsZXQgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1YSA9ICh1c2VyQWdlbnQgIT09IG51bGwgJiYgdXNlckFnZW50ICE9PSB2b2lkIDAgPyB1c2VyQWdlbnQgOiBuYXZpZ2F0b3IudXNlckFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYnJvd3NlckRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBmb3JjZSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBicm93c2Vyc0xpc3QuZmluZChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHRlc3RcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHRlc3QudGVzdCh1YSk7XG4gICAgfSk7XG4gICAgYnJvd3NlckRldGFpbHMgPSBicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIuZGVzY3JpYmUodWEpO1xuICB9XG4gIHJldHVybiBicm93c2VyRGV0YWlscztcbn1cbmNvbnN0IGJyb3dzZXJzTGlzdCA9IFt7XG4gIHRlc3Q6IC9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pLFxuICBkZXNjcmliZSh1YSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSB7XG4gICAgICBuYW1lOiAnRmlyZWZveCcsXG4gICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXG4gICAgICBvczogdWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZnhpb3MnKSA/ICdpT1MnIDogdW5kZWZpbmVkLFxuICAgICAgb3NWZXJzaW9uOiBnZXRPU1ZlcnNpb24odWEpXG4gICAgfTtcbiAgICByZXR1cm4gYnJvd3NlcjtcbiAgfVxufSwge1xuICB0ZXN0OiAvY2hyb218Y3Jpb3N8Y3Jtby9pLFxuICBkZXNjcmliZSh1YSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSB7XG4gICAgICBuYW1lOiAnQ2hyb21lJyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpjaHJvbWV8Y2hyb21pdW18Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjcmlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICBvc1ZlcnNpb246IGdldE9TVmVyc2lvbih1YSlcbiAgICB9O1xuICAgIHJldHVybiBicm93c2VyO1xuICB9XG59LCAvKiBTYWZhcmkgKi9cbntcbiAgdGVzdDogL3NhZmFyaXxhcHBsZXdlYmtpdC9pLFxuICBkZXNjcmliZSh1YSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSB7XG4gICAgICBuYW1lOiAnU2FmYXJpJyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKGNvbW1vblZlcnNpb25JZGVudGlmaWVyLCB1YSksXG4gICAgICBvczogdWEuaW5jbHVkZXMoJ21vYmlsZS8nKSA/ICdpT1MnIDogJ21hY09TJyxcbiAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKVxuICAgIH07XG4gICAgcmV0dXJuIGJyb3dzZXI7XG4gIH1cbn1dO1xuZnVuY3Rpb24gZ2V0TWF0Y2goZXhwLCB1YSkge1xuICBsZXQgaWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIGNvbnN0IG1hdGNoID0gdWEubWF0Y2goZXhwKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBpZCAmJiBtYXRjaFtpZF0gfHwgJyc7XG59XG5mdW5jdGlvbiBnZXRPU1ZlcnNpb24odWEpIHtcbiAgcmV0dXJuIHVhLmluY2x1ZGVzKCdtYWMgb3MnKSA/IGdldE1hdGNoKC9cXCguKz8oXFxkK19cXGQrKDo/X1xcZCspPykvLCB1YSwgMSkucmVwbGFjZSgvXy9nLCAnLicpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgdmVyc2lvbiQxID0gXCIyLjE2LjBcIjtcblxuY29uc3QgdmVyc2lvbiA9IHZlcnNpb24kMTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbiA9IDE2O1xuXG4vKipcbiAqIFRpbWVycyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zXG4gKiB0aGF0IGVuc3VyZSB0aGF0IHRoZXkgYXJlIGZpcmVkLiBUaGVzZSBzaG91bGQgYmUgdXNlZCB3aGVuIGl0IGlzIGNyaXRpY2FsXG4gKiB0aGF0IHRoZSB0aW1lciBmaXJlcyBvbiB0aW1lLlxuICovXG5jbGFzcyBDcml0aWNhbFRpbWVycyB7fVxuQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2V0SW50ZXJ2YWwoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2xlYXJJbnRlcnZhbCguLi5hcmd1bWVudHMpO1xufTtcblxuY29uc3QgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSA9IDUwMDA7XG4vLyBrZWVwIG9sZCBhdWRpbyBlbGVtZW50cyB3aGVuIGRldGFjaGVkLCB3ZSB3b3VsZCByZS11c2UgdGhlbSBzaW5jZSBvbiBpT1Ncbi8vIFNhZmFyaSB0cmFja3Mgd2hpY2ggYXVkaW8gZWxlbWVudHMgaGF2ZSBiZWVuIFwiYmxlc3NlZFwiIGJ5IHRoZSB1c2VyLlxuY29uc3QgcmVjeWNsZWRFbGVtZW50cyA9IFtdO1xudmFyIFZpZGVvUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9RdWFsaXR5KSB7XG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJMT1dcIl0gPSAwXSA9IFwiTE9XXCI7XG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJNRURJVU1cIl0gPSAxXSA9IFwiTUVESVVNXCI7XG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJISUdIXCJdID0gMl0gPSBcIkhJR0hcIjtcbn0pKFZpZGVvUXVhbGl0eSB8fCAoVmlkZW9RdWFsaXR5ID0ge30pKTtcbmNsYXNzIFRyYWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogaW5kaWNhdGVzIGN1cnJlbnQgc3RhdGUgb2Ygc3RyZWFtLCBpdCdsbCBpbmRpY2F0ZSBgcGF1c2VkYCBpZiB0aGUgdHJhY2tcbiAgICogaGFzIGJlZW4gcGF1c2VkIGJ5IGNvbmdlc3Rpb24gY29udHJvbGxlclxuICAgKi9cbiAgZ2V0IHN0cmVhbVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW1TdGF0ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFN0cmVhbVN0YXRlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3RyZWFtU3RhdGUgPSB2YWx1ZTtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBraW5kKSB7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0cmVhbVN0YXRlID0gVHJhY2suU3RyZWFtU3RhdGUuQWN0aXZlO1xuICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmJhY2tncm91bmRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIC8vIGRlbGF5IGFwcCB2aXNpYmlsaXR5IHVwZGF0ZSBpZiBpdCBnb2VzIHRvIGhpZGRlblxuICAgICAgLy8gdXBkYXRlIGltbWVkaWF0ZWx5IGlmIGl0IGNvbWVzIGJhY2sgdG8gZm9jdXNcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSwgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlRyYWNrKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrID0gbWVkaWFUcmFjaztcbiAgICB0aGlzLl9tZWRpYVN0cmVhbUlEID0gbWVkaWFUcmFjay5pZDtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRoaXMpKTtcbiAgfVxuICAvKiogY3VycmVudCByZWNlaXZlIGJpdHMgcGVyIHNlY29uZCAqL1xuICBnZXQgY3VycmVudEJpdHJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCaXRyYXRlO1xuICB9XG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogdXNlZCBmb3Iga2VlcCBtZWRpYVN0cmVhbSdzIGZpcnN0IGlkLCBzaW5jZSBpdCdzIGlkIG1pZ2h0IGNoYW5nZVxuICAgKiBpZiB3ZSBkaXNhYmxlL2VuYWJsZSBhIHRyYWNrXG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1JRCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1JRDtcbiAgfVxuICBhdHRhY2goZWxlbWVudCkge1xuICAgIGxldCBlbGVtZW50VHlwZSA9ICdhdWRpbyc7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgZWxlbWVudFR5cGUgPSAndmlkZW8nO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHRoaXMuYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgfVxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICBpZiAoZS5wYXJlbnRFbGVtZW50ID09PSBudWxsICYmICFlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHBvb2xcbiAgICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnNwbGljZShyZWN5Y2xlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkge1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIC8vIGV2ZW4gaWYgd2UgYmVsaWV2ZSBpdCdzIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQsIGl0J3MgcG9zc2libGVcbiAgICAvLyB0aGUgZWxlbWVudCdzIHNyY09iamVjdCB3YXMgc2V0IHRvIHNvbWV0aGluZyBlbHNlIG91dCBvZiBiYW5kLlxuICAgIC8vIHdlJ2xsIHdhbnQgdG8gcmUtYXR0YWNoIGl0IGluIHRoYXQgY2FzZVxuICAgIGF0dGFjaFRvRWxlbWVudCh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgIC8vIGhhbmRsZSBhdXRvIHBsYXliYWNrIGZhaWx1cmVzXG4gICAgY29uc3QgYWxsTWVkaWFTdHJlYW1UcmFja3MgPSBlbGVtZW50LnNyY09iamVjdC5nZXRUcmFja3MoKTtcbiAgICBjb25zdCBoYXNBdWRpbyA9IGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUodHIgPT4gdHIua2luZCA9PT0gJ2F1ZGlvJyk7XG4gICAgLy8gbWFudWFsbHkgcGxheSBtZWRpYSB0byBkZXRlY3QgYXV0byBwbGF5YmFjayBzdGF0dXNcbiAgICBlbGVtZW50LnBsYXkoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChoYXNBdWRpbyA/IFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQgOiBUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkKTtcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIHRoaXMuZW1pdChoYXNBdWRpbyA/IFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIC8vIGNvbW1vbmx5IHRyaWdnZXJlZCBieSBhbm90aGVyIGBwbGF5YCByZXF1ZXN0LCBvbmx5IGxvZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJcIi5jb25jYXQoaGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJywgXCIgcGxheWJhY2sgYWJvcnRlZCwgbGlrZWx5IGR1ZSB0byBuZXcgcGxheSByZXF1ZXN0XCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybihcImNvdWxkIG5vdCBwbGF5YmFjayBcIi5jb25jYXQoaGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJyksIGUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgYXVkaW8gcGxheWJhY2sgaXNuJ3QgYWxsb3dlZCBtYWtlIHN1cmUgd2Ugc3RpbGwgcGxheSBiYWNrIHRoZSB2aWRlb1xuICAgICAgaWYgKGhhc0F1ZGlvICYmIGVsZW1lbnQgJiYgYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSh0ciA9PiB0ci5raW5kID09PSAndmlkZW8nKSAmJiBlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gY2F0Y2ggZm9yIFNhZmFyaSwgZXhjZWVkZWQgb3B0aW9ucyBhdCB0aGlzIHBvaW50IHRvIGF1dG9tYXRpY2FsbHkgcGxheSB0aGUgbWVkaWEgZWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50QXR0YWNoZWQsIGVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGRldGFjaChlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgZGV0YWNoZWQgPSBbXTtcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsbSA9PiB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxtKTtcbiAgICAgICAgZGV0YWNoZWQucHVzaChlbG0pO1xuICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsbSk7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxtKTtcbiAgICAgIH0pO1xuICAgICAgLy8gcmVtb3ZlIGFsbCB0cmFja3NcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgICAgcmV0dXJuIGRldGFjaGVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3IoKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdG9wTW9uaXRvcigpIHtcbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9ySW50ZXJ2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy50aW1lU3luY0hhbmRsZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lU3luY0hhbmRsZSk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlTG9nZ2VyT3B0aW9ucyhsb2dnZXJPcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkge1xuICAgICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiKSB7XG4gICAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuICAgIH1cbiAgfVxuICByZWN5Y2xlRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gcmUtdXNlIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGxldCBzaG91bGRDYWNoZSA9IHRydWU7XG4gICAgICBlbGVtZW50LnBhdXNlKCk7XG4gICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgIGlmICghZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgc2hvdWxkQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gICAgICBpZiAoIXRoaXMuaXNJbkJhY2tncm91bmQgJiYgdGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvKiogY2F0Y2ggY2xhdXNlIG5lY2Vzc2FyeSBmb3IgU2FmYXJpICovXG4gICAgICAgIH0pKSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJztcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhdHRhY2hUb0VsZW1lbnQodHJhY2ssIGVsZW1lbnQpIHtcbiAgbGV0IG1lZGlhU3RyZWFtO1xuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgIG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gIH0gZWxzZSB7XG4gICAgbWVkaWFTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgfVxuICAvLyBjaGVjayBpZiB0cmFjayBtYXRjaGVzIGV4aXN0aW5nIHRyYWNrXG4gIGxldCBleGlzdGluZ1RyYWNrcztcbiAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gIH0gZWxzZSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICB9XG4gIGlmICghZXhpc3RpbmdUcmFja3MuaW5jbHVkZXModHJhY2spKSB7XG4gICAgZXhpc3RpbmdUcmFja3MuZm9yRWFjaChldCA9PiB7XG4gICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhldCk7XG4gICAgfSk7XG4gICAgbWVkaWFTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICB9XG4gIGlmICghaXNTYWZhcmkoKSB8fCAhKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xuICAgIC8vIHdoZW4gaW4gbG93IHBvd2VyIG1vZGUgKGFwcGxpZXMgdG8gYm90aCBtYWNPUyBhbmQgaU9TKSwgU2FmYXJpIHdpbGwgc2hvdyBhIHBsYXkvcGF1c2Ugb3ZlcmxheVxuICAgIC8vIHdoZW4gYSB2aWRlbyBzdGFydHMgdGhhdCBoYXMgdGhlIGBhdXRvcGxheWAgYXR0cmlidXRlIGlzIHNldC5cbiAgICAvLyB3ZSB3b3JrIGFyb3VuZCB0aGlzIGJ5IF9ub3RfIHNldHRpbmcgdGhlIGF1dG9wbGF5IGF0dHJpYnV0ZSBvbiBzYWZhcmkgYW5kIGluc3RlYWQgY2FsbCBgc2V0VGltZW91dCgoKSA9PiBlbC5wbGF5KCksMClgIGZ1cnRoZXIgZG93blxuICAgIGVsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICB9XG4gIC8vIEluIGNhc2UgdGhlcmUgYXJlIG5vIGF1ZGlvIHRyYWNrcyBwcmVzZW50IG9uIHRoZSBtZWRpYXN0cmVhbSwgd2Ugc2V0IHRoZSBlbGVtZW50IGFzIG11dGVkIHRvIGVuc3VyZSBhdXRvcGxheSB3b3Jrc1xuICBlbGVtZW50Lm11dGVkID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPT09IDA7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgIGVsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICB9XG4gIC8vIGF2b2lkIGZsaWNrZXJcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0ICE9PSBtZWRpYVN0cmVhbSkge1xuICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgaWYgKChpc1NhZmFyaSgpIHx8IGlzRmlyZUZveCgpKSAmJiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgLy8gRmlyZWZveCBhbHNvIGhhcyBhIHRpbWluZyBpc3N1ZSB3aGVyZSB2aWRlbyBkb2Vzbid0IGFjdHVhbGx5IGdldCBhdHRhY2hlZCB1bmxlc3NcbiAgICAgIC8vIHBlcmZvcm1lZCBvdXQtb2YtYmFuZFxuICAgICAgLy8gU2FmYXJpIDE1IGhhcyBhIGJ1ZyB3aGVyZSBpbiBjZXJ0YWluIGxheW91dHMsIHZpZGVvIGVsZW1lbnQgcmVuZGVyc1xuICAgICAgLy8gYmxhY2sgdW50aWwgdGhlIHBhZ2UgaXMgcmVzaXplZCBvciBvdGhlciBjaGFuZ2VzIHRha2UgcGxhY2UuXG4gICAgICAvLyBSZXNldHRpbmcgdGhlIHNyYyB0cmlnZ2VycyBpdCB0byByZW5kZXIuXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC82OTA1MjNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgICAgICAvLyBTYWZhcmkgMTUgc29tZXRpbWVzIGZhaWxzIHRvIHN0YXJ0IGEgdmlkZW9cbiAgICAgICAgLy8gd2hlbiB0aGUgd2luZG93IGlzIGJhY2tncm91bmRlZCBiZWZvcmUgdGhlIGZpcnN0IGZyYW1lIGlzIGRyYXduXG4gICAgICAgIC8vIG1hbnVhbGx5IGNhbGxpbmcgcGxheSBoZXJlIHNlZW1zIHRvIGZpeCB0aGF0XG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvKiogZG8gbm90aGluZyAqL1xuICAgICAgICB9KTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZGV0YWNoVHJhY2sodHJhY2ssIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICBpZiAobWVkaWFTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuKGZ1bmN0aW9uIChUcmFjaykge1xuICBsZXQgS2luZDtcbiAgKGZ1bmN0aW9uIChLaW5kKSB7XG4gICAgS2luZFtcIkF1ZGlvXCJdID0gXCJhdWRpb1wiO1xuICAgIEtpbmRbXCJWaWRlb1wiXSA9IFwidmlkZW9cIjtcbiAgICBLaW5kW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICB9KShLaW5kID0gVHJhY2suS2luZCB8fCAoVHJhY2suS2luZCA9IHt9KSk7XG4gIGxldCBTb3VyY2U7XG4gIChmdW5jdGlvbiAoU291cmNlKSB7XG4gICAgU291cmNlW1wiQ2FtZXJhXCJdID0gXCJjYW1lcmFcIjtcbiAgICBTb3VyY2VbXCJNaWNyb3Bob25lXCJdID0gXCJtaWNyb3Bob25lXCI7XG4gICAgU291cmNlW1wiU2NyZWVuU2hhcmVcIl0gPSBcInNjcmVlbl9zaGFyZVwiO1xuICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlQXVkaW9cIl0gPSBcInNjcmVlbl9zaGFyZV9hdWRpb1wiO1xuICAgIFNvdXJjZVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgfSkoU291cmNlID0gVHJhY2suU291cmNlIHx8IChUcmFjay5Tb3VyY2UgPSB7fSkpO1xuICBsZXQgU3RyZWFtU3RhdGUkMTtcbiAgKGZ1bmN0aW9uIChTdHJlYW1TdGF0ZSkge1xuICAgIFN0cmVhbVN0YXRlW1wiQWN0aXZlXCJdID0gXCJhY3RpdmVcIjtcbiAgICBTdHJlYW1TdGF0ZVtcIlBhdXNlZFwiXSA9IFwicGF1c2VkXCI7XG4gICAgU3RyZWFtU3RhdGVbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gIH0pKFN0cmVhbVN0YXRlJDEgPSBUcmFjay5TdHJlYW1TdGF0ZSB8fCAoVHJhY2suU3RyZWFtU3RhdGUgPSB7fSkpO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIGtpbmRUb1Byb3RvKGspIHtcbiAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgS2luZC5BdWRpbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5BVURJTztcbiAgICAgIGNhc2UgS2luZC5WaWRlbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5WSURFTztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FIHRoaXMgd2FzIFVOUkVDT0dOSVpFRCBiZWZvcmVcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5EQVRBO1xuICAgIH1cbiAgfVxuICBUcmFjay5raW5kVG9Qcm90byA9IGtpbmRUb1Byb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIGtpbmRGcm9tUHJvdG8odCkge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBUcmFja1R5cGUuQVVESU86XG4gICAgICAgIHJldHVybiBLaW5kLkF1ZGlvO1xuICAgICAgY2FzZSBUcmFja1R5cGUuVklERU86XG4gICAgICAgIHJldHVybiBLaW5kLlZpZGVvO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEtpbmQuVW5rbm93bjtcbiAgICB9XG4gIH1cbiAgVHJhY2sua2luZEZyb21Qcm90byA9IGtpbmRGcm9tUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc291cmNlVG9Qcm90byhzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFNvdXJjZS5DYW1lcmE6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5DQU1FUkE7XG4gICAgICBjYXNlIFNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFO1xuICAgICAgY2FzZSBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5VTktOT1dOO1xuICAgIH1cbiAgfVxuICBUcmFjay5zb3VyY2VUb1Byb3RvID0gc291cmNlVG9Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBzb3VyY2VGcm9tUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5DQU1FUkE6XG4gICAgICAgIHJldHVybiBTb3VyY2UuQ2FtZXJhO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5NSUNST1BIT05FOlxuICAgICAgICByZXR1cm4gU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPOlxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU291cmNlLlVua25vd247XG4gICAgfVxuICB9XG4gIFRyYWNrLnNvdXJjZUZyb21Qcm90byA9IHNvdXJjZUZyb21Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBzdHJlYW1TdGF0ZUZyb21Qcm90byhzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFN0cmVhbVN0YXRlLkFDVElWRTpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlJDEuQWN0aXZlO1xuICAgICAgY2FzZSBTdHJlYW1TdGF0ZS5QQVVTRUQ6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLlBhdXNlZDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLlVua25vd247XG4gICAgfVxuICB9XG4gIFRyYWNrLnN0cmVhbVN0YXRlRnJvbVByb3RvID0gc3RyZWFtU3RhdGVGcm9tUHJvdG87XG59KShUcmFjayB8fCAoVHJhY2sgPSB7fSkpO1xuXG5jbGFzcyBWaWRlb1ByZXNldCB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoT3JPcHRpb25zLCBoZWlnaHQsIG1heEJpdHJhdGUsIG1heEZyYW1lcmF0ZSwgcHJpb3JpdHkpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoT3JPcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoT3JPcHRpb25zLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB3aWR0aE9yT3B0aW9ucy5oZWlnaHQ7XG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gd2lkdGhPck9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgICBtYXhCaXRyYXRlOiB3aWR0aE9yT3B0aW9ucy5tYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGU6IHdpZHRoT3JPcHRpb25zLm1heEZyYW1lcmF0ZSxcbiAgICAgICAgcHJpb3JpdHk6IHdpZHRoT3JPcHRpb25zLnByaW9yaXR5XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgbWF4Qml0cmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGhPck9wdGlvbnM7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSB3aWR0aE9yT3B0aW9ucyAvIGhlaWdodDtcbiAgICAgIHRoaXMuZW5jb2RpbmcgPSB7XG4gICAgICAgIG1heEJpdHJhdGUsXG4gICAgICAgIG1heEZyYW1lcmF0ZSxcbiAgICAgICAgcHJpb3JpdHlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIG9wdGlvbnM6IHByb3ZpZGUgYXQgbGVhc3Qgd2lkdGgsIGhlaWdodCBhbmQgbWF4Qml0cmF0ZScpO1xuICAgIH1cbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZnJhbWVSYXRlOiB0aGlzLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLmFzcGVjdFJhdGlvXG4gICAgfTtcbiAgfVxufVxuLy8gYHJlZGAgaXMgbm90IHRlY2huaWNhbGx5IGEgY29kZWMsIGJ1dCB0cmVhdGVkIGFzIG9uZSBpbiBzaWduYWxsaW5nIHByb3RvY29sXG5jb25zdCBhdWRpb0NvZGVjcyA9IFsnb3B1cycsICdyZWQnXTtcbmNvbnN0IGJhY2t1cFZpZGVvQ29kZWNzID0gWyd2cDgnLCAnaDI2NCddO1xuY29uc3QgdmlkZW9Db2RlY3MgPSBbJ3ZwOCcsICdoMjY0JywgJ3ZwOScsICdhdjEnLCAnaDI2NSddO1xuZnVuY3Rpb24gaXNCYWNrdXBWaWRlb0NvZGVjKGNvZGVjKSB7XG4gIHJldHVybiAhIWJhY2t1cFZpZGVvQ29kZWNzLmZpbmQoYmFja3VwID0+IGJhY2t1cCA9PT0gY29kZWMpO1xufVxuLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgaXNCYWNrdXBWaWRlb0NvZGVjfSBpbnN0ZWFkICovXG5jb25zdCBpc0JhY2t1cENvZGVjID0gaXNCYWNrdXBWaWRlb0NvZGVjO1xudmFyIEJhY2t1cENvZGVjUG9saWN5O1xuKGZ1bmN0aW9uIChCYWNrdXBDb2RlY1BvbGljeSkge1xuICAvLyBjb2RlYyByZWdyZXNzaW9uIGlzIHByZWZlcnJlZCwgdGhlIHNmdSB3aWxsIHRyeSB0byByZWdyZXNzIGNvZGVjIGlmIHBvc3NpYmxlIGJ1dCBub3QgZ3VhcmFudGVlZFxuICBCYWNrdXBDb2RlY1BvbGljeVtCYWNrdXBDb2RlY1BvbGljeVtcIlBSRUZFUl9SRUdSRVNTSU9OXCJdID0gMF0gPSBcIlBSRUZFUl9SRUdSRVNTSU9OXCI7XG4gIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCwgcHVibGlzaCBib3RoIHByaW1hcnkgYW5kIGJhY2t1cCBjb2RlYyBhdCB0aGUgc2FtZSB0aW1lXG4gIEJhY2t1cENvZGVjUG9saWN5W0JhY2t1cENvZGVjUG9saWN5W1wiU0lNVUxDQVNUXCJdID0gMV0gPSBcIlNJTVVMQ0FTVFwiO1xuICAvLyBhbHdheXMgdXNlIGJhY2t1cCBjb2RlYyBvbmx5XG4gIEJhY2t1cENvZGVjUG9saWN5W0JhY2t1cENvZGVjUG9saWN5W1wiUkVHUkVTU0lPTlwiXSA9IDJdID0gXCJSRUdSRVNTSU9OXCI7XG59KShCYWNrdXBDb2RlY1BvbGljeSB8fCAoQmFja3VwQ29kZWNQb2xpY3kgPSB7fSkpO1xudmFyIEF1ZGlvUHJlc2V0cztcbihmdW5jdGlvbiAoQXVkaW9QcmVzZXRzKSB7XG4gIEF1ZGlvUHJlc2V0cy50ZWxlcGhvbmUgPSB7XG4gICAgbWF4Qml0cmF0ZTogMTIwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLnNwZWVjaCA9IHtcbiAgICBtYXhCaXRyYXRlOiAyNDAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWMgPSB7XG4gICAgbWF4Qml0cmF0ZTogNDgwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljU3RlcmVvID0ge1xuICAgIG1heEJpdHJhdGU6IDY0MDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpY0hpZ2hRdWFsaXR5ID0ge1xuICAgIG1heEJpdHJhdGU6IDk2MDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpY0hpZ2hRdWFsaXR5U3RlcmVvID0ge1xuICAgIG1heEJpdHJhdGU6IDEyODAwMFxuICB9O1xufSkoQXVkaW9QcmVzZXRzIHx8IChBdWRpb1ByZXNldHMgPSB7fSkpO1xuLyoqXG4gKiBTYW5lIHByZXNldHMgZm9yIHZpZGVvIHJlc29sdXRpb24vZW5jb2RpbmdcbiAqL1xuY29uc3QgVmlkZW9QcmVzZXRzID0ge1xuICBoOTA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDkwLCA5MDAwMCwgMjApLFxuICBoMTgwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAxODAsIDE2MDAwMCwgMjApLFxuICBoMjE2OiBuZXcgVmlkZW9QcmVzZXQoMzg0LCAyMTYsIDE4MDAwMCwgMjApLFxuICBoMzYwOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDQ1MDAwMCwgMjApLFxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA1NDAsIDgwMDAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxNzAwMDAwLCAzMCksXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgMzAwMDAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDI1NjAsIDE0NDAsIDUwMDAwMDAsIDMwKSxcbiAgaDIxNjA6IG5ldyBWaWRlb1ByZXNldCgzODQwLCAyMTYwLCA4MDAwMDAwLCAzMClcbn07XG4vKipcbiAqIEZvdXIgYnkgdGhyZWUgcHJlc2V0c1xuICovXG5jb25zdCBWaWRlb1ByZXNldHM0MyA9IHtcbiAgaDEyMDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgMTIwLCA3MDAwMCwgMjApLFxuICBoMTgwOiBuZXcgVmlkZW9QcmVzZXQoMjQwLCAxODAsIDEyNTAwMCwgMjApLFxuICBoMjQwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAyNDAsIDE0MDAwMCwgMjApLFxuICBoMzYwOiBuZXcgVmlkZW9QcmVzZXQoNDgwLCAzNjAsIDMzMDAwMCwgMjApLFxuICBoNDgwOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCA0ODAsIDUwMDAwMCwgMjApLFxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoNzIwLCA1NDAsIDYwMDAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA3MjAsIDEzMDAwMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxNDQwLCAxMDgwLCAyMzAwMDAwLCAzMCksXG4gIGgxNDQwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTQ0MCwgMzgwMDAwMCwgMzApXG59O1xuY29uc3QgU2NyZWVuU2hhcmVQcmVzZXRzID0ge1xuICBoMzYwZnBzMzogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCAyMDAwMDAsIDMsICdtZWRpdW0nKSxcbiAgaDM2MGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDQwMDAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczU6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDgwMDAwMCwgNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDE1MDAwMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMjAwMDAwMCwgMzAsICdtZWRpdW0nKSxcbiAgaDEwODBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDI1MDAwMDAsIDE1LCAnbWVkaXVtJyksXG4gIGgxMDgwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCA1MDAwMDAwLCAzMCwgJ21lZGl1bScpLFxuICAvLyBvcmlnaW5hbCByZXNvbHV0aW9uLCB3aXRob3V0IHJlc2l6aW5nXG4gIG9yaWdpbmFsOiBuZXcgVmlkZW9QcmVzZXQoMCwgMCwgNzAwMDAwMCwgMzAsICdtZWRpdW0nKVxufTtcblxuY29uc3Qgc2VwYXJhdG9yID0gJ3wnO1xuY29uc3QgZGRFeHRlbnNpb25VUkkgPSAnaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1ydHAtc3BlYy8jZGVwZW5kZW5jeS1kZXNjcmlwdG9yLXJ0cC1oZWFkZXItZXh0ZW5zaW9uJztcbmZ1bmN0aW9uIHVucGFja1N0cmVhbUlkKHBhY2tlZCkge1xuICBjb25zdCBwYXJ0cyA9IHBhY2tlZC5zcGxpdChzZXBhcmF0b3IpO1xuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBbcGFydHNbMF0sIHBhY2tlZC5zdWJzdHIocGFydHNbMF0ubGVuZ3RoICsgMSldO1xuICB9XG4gIHJldHVybiBbcGFja2VkLCAnJ107XG59XG5mdW5jdGlvbiBzbGVlcChkdXJhdGlvbikge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcbiAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkge1xuICByZXR1cm4gJ2FkZFRyYW5zY2VpdmVyJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzdXBwb3J0c0FkZFRyYWNrKCkge1xuICByZXR1cm4gJ2FkZFRyYWNrJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0FkYXB0aXZlU3RyZWFtKCkge1xuICByZXR1cm4gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0R5bmFjYXN0KCkge1xuICByZXR1cm4gc3VwcG9ydHNUcmFuc2NlaXZlcigpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNBVjEoKSB7XG4gIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FmYXJpKCkgfHwgaXNGaXJlRm94KCkpIHtcbiAgICAvLyBTYWZhcmkgMTcgb24gaVBob25lMTQgcmVwb3J0cyBBVjEgY2FwYWJpbGl0eSwgYnV0IGRvZXMgbm90IGFjdHVhbGx5IHN1cHBvcnQgaXRcbiAgICAvLyBGaXJlZm94IGRvZXMgc3VwcG9ydCBBVjEsIGJ1dCBTVkMgcHVibGlzaGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNBVjEgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby9hdjEnKSB7XG4gICAgICAgIGhhc0FWMSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQVYxO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNWUDkoKSB7XG4gIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRmlyZUZveCgpKSB7XG4gICAgLy8gdGVjaG5pY2FsbHkgc3BlYWtpbmcgRmlyZUZveCBzdXBwb3J0cyBWUDksIGJ1dCBTVkMgcHVibGlzaGluZyBpcyBicm9rZW5cbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjMzODc2XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci52ZXJzaW9uKSAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCAnMTYnKSA8IDApIHtcbiAgICAgIC8vIFNhZmFyaSAxNiBhbmQgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBWUDlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIub3MpID09PSAnaU9TJyAmJiAoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLm9zVmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIub3NWZXJzaW9uLCAnMTYnKSA8IDApIHtcbiAgICAgIC8vIFNhZmFyaSAxNiBhbmQgYmVsb3cgb24gaU9TIGRvZXMgbm90IHN1cHBvcnQgVlA5IHdlIG5lZWQgdGhlIGlPUyBjaGVjayB0byBhY2NvdW50IGZvciBvdGhlciBicm93c2VycyBydW5uaW5nIHdlYmtpdCB1bmRlciB0aGUgaG9vZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xuICBsZXQgaGFzVlA5ID0gZmFsc2U7XG4gIGlmIChjYXBhYmlsaXRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgIGlmIChjb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA5Jykge1xuICAgICAgICBoYXNWUDkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc1ZQOTtcbn1cbmZ1bmN0aW9uIGlzU1ZDQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvZGVjID09PSAnYXYxJyB8fCBjb2RlYyA9PT0gJ3ZwOSc7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1NldFNpbmtJZChlbG0pIHtcbiAgaWYgKCFkb2N1bWVudCB8fCBpc1NhZmFyaUJhc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFlbG0pIHtcbiAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICB9XG4gIHJldHVybiAnc2V0U2lua0lkJyBpbiBlbG07XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBzZXR0aW5nIGFuIGF1ZGlvIG91dHB1dCB2aWEge0BsaW5rIFJvb20jc2V0QWN0aXZlRGV2aWNlfVxuICogaXMgc3VwcG9ydGVkIGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICovXG5mdW5jdGlvbiBzdXBwb3J0c0F1ZGlvT3V0cHV0U2VsZWN0aW9uKCkge1xuICAvLyBOb3RlOiB0aGlzIGlzIG1ldGhvZCBwdWJsaWNseSBleHBvcnRlZCB1bmRlciBhIHVzZXIgZnJpZW5kbHkgbmFtZSBhbmQgY3VycmVudGx5IG9ubHkgcHJveHlpbmcgYHN1cHBvcnRzU2V0U2lua0lkYFxuICByZXR1cm4gc3VwcG9ydHNTZXRTaW5rSWQoKTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB8fCBzdXBwb3J0c0FkZFRyYWNrKCk7XG59XG5mdW5jdGlvbiBpc0ZpcmVGb3goKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0ZpcmVmb3gnO1xufVxuZnVuY3Rpb24gaXNDaHJvbWl1bUJhc2VkKCkge1xuICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICByZXR1cm4gISFicm93c2VyICYmIGJyb3dzZXIubmFtZSA9PT0gJ0Nocm9tZScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUyc7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnU2FmYXJpJztcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpQmFzZWQoKSB7XG4gIGNvbnN0IGIgPSBnZXRCcm93c2VyKCk7XG4gIHJldHVybiAoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLm5hbWUpID09PSAnU2FmYXJpJyB8fCAoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLm9zKSA9PT0gJ2lPUyc7XG59XG5mdW5jdGlvbiBpc1NhZmFyaTE3QmFzZWQoKSB7XG4gIGNvbnN0IGIgPSBnZXRCcm93c2VyKCk7XG4gIHJldHVybiAoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLm5hbWUpID09PSAnU2FmYXJpJyAmJiBiLnZlcnNpb24uc3RhcnRzV2l0aCgnMTcuJykgfHwgKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5vcykgPT09ICdpT1MnICYmICEhKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5vc1ZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucyhiLm9zVmVyc2lvbiwgJzE3JykgPj0gMDtcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpU3ZjQXBpKGJyb3dzZXIpIHtcbiAgaWYgKCFicm93c2VyKSB7XG4gICAgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgfVxuICAvLyBTYWZhcmkgMTguNCByZXF1aXJlcyBsZWdhY3kgc3ZjIGFwaSBhbmQgc2NhbGVSZXNvbHV0aW9uRG93biB0byBiZSBzZXRcbiAgcmV0dXJuIChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxOC4zJykgPiAwIHx8IChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIub3MpID09PSAnaU9TJyAmJiAhIShicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIub3NWZXJzaW9uKSAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci5vc1ZlcnNpb24sICcxOC4zJykgPiAwO1xufVxuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmICghaXNXZWIoKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYHVzZXJBZ2VudERhdGFgIGlzIG5vdCB5ZXQgcGFydCBvZiB0eXBlc2NyaXB0XG4gICAgKF9iID0gKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2JpbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC9UYWJsZXR8aVBhZHxNb2JpbGV8QW5kcm9pZHxCbGFja0JlcnJ5Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICk7XG59XG5mdW5jdGlvbiBpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQoKSB7XG4gIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gIGNvbnN0IHN1cHBvcnRlZFNhZmFyaVZlcnNpb24gPSAnMTcuMic7IC8vIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjU3ODAzXG4gIGlmIChicm93c2VyKSB7XG4gICAgaWYgKGJyb3dzZXIubmFtZSAhPT0gJ1NhZmFyaScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYnJvd3Nlci5vcyA9PT0gJ2lPUycgJiYgYnJvd3Nlci5vc1ZlcnNpb24gJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIub3NWZXJzaW9uLCBzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uKSA+PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXIubmFtZSA9PT0gJ1NhZmFyaScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgc3VwcG9ydGVkU2FmYXJpVmVyc2lvbikgPj0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzV2ViKCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIC8vIG5hdmlnYXRvci5wcm9kdWN0IGlzIGRlcHJlY2F0ZWQgb24gYnJvd3NlcnMsIGJ1dCB3aWxsIGJlIHNldCBhcHByb3ByaWF0ZWx5IGZvciByZWFjdC1uYXRpdmUuXG4gIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdCA9PSAnUmVhY3ROYXRpdmUnO1xufVxuZnVuY3Rpb24gaXNDbG91ZChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQuY2xvdWQnKSB8fCBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LnJ1bicpO1xufVxuZnVuY3Rpb24gZXh0cmFjdFByb2plY3RGcm9tVXJsKHNlcnZlclVybCkge1xuICBpZiAoIWlzQ2xvdWQoc2VydmVyVXJsKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBzZXJ2ZXJVcmwuaG9zdG5hbWUuc3BsaXQoJy4nKVswXTtcbn1cbmZ1bmN0aW9uIGdldExLUmVhY3ROYXRpdmVJbmZvKCkge1xuICAvLyBnbG9iYWwgZGVmaW5lZCBvbmx5IGZvciBSZWFjdE5hdGl2ZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoZ2xvYmFsICYmIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWw7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldFJlYWN0TmF0aXZlT3MoKSB7XG4gIGlmICghaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ucGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gIGlmIChpc1dlYigpKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICB9XG4gIHJldHVybiAxO1xufVxuLyoqXG4gKiBAcGFyYW0gdjEgLSBUaGUgZmlyc3QgdmVyc2lvbiBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB2MiAtIFRoZSBzZWNvbmQgdmVyc2lvbiBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIEEgbnVtYmVyIGluZGljYXRpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJzaW9uczpcbiAqICAgLSAxIGlmIHYxIGlzIGdyZWF0ZXIgdGhhbiB2MlxuICogICAtIC0xIGlmIHYxIGlzIGxlc3MgdGhhbiB2MlxuICogICAtIDAgaWYgdjEgYW5kIHYyIGFyZSBlcXVhbFxuICovXG5mdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjEsIHYyKSB7XG4gIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KCcuJyk7XG4gIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGsgPSBNYXRoLm1pbihwYXJ0czEubGVuZ3RoLCBwYXJ0czIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICBjb25zdCBwMSA9IHBhcnNlSW50KHBhcnRzMVtpXSwgMTApO1xuICAgIGNvbnN0IHAyID0gcGFyc2VJbnQocGFydHMyW2ldLCAxMCk7XG4gICAgaWYgKHAxID4gcDIpIHJldHVybiAxO1xuICAgIGlmIChwMSA8IHAyKSByZXR1cm4gLTE7XG4gICAgaWYgKGkgPT09IGsgLSAxICYmIHAxID09PSBwMikgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHYxID09PSAnJyAmJiB2MiAhPT0gJycpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodjIgPT09ICcnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIHBhcnRzMS5sZW5ndGggPT0gcGFydHMyLmxlbmd0aCA/IDAgOiBwYXJ0czEubGVuZ3RoIDwgcGFydHMyLmxlbmd0aCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHJvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGVudHJ5LnRhcmdldC5oYW5kbGVSZXNpemUoZW50cnkpO1xuICB9XG59XG5mdW5jdGlvbiBpb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBlbnRyeS50YXJnZXQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkpO1xuICB9XG59XG5sZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghcmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJvRGlzcGF0Y2hDYWxsYmFjayk7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn07XG5sZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihpb0Rpc3BhdGNoQ2FsbGJhY2ssIHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICByb290TWFyZ2luOiAnMHB4J1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbn07XG5mdW5jdGlvbiBnZXRDbGllbnRJbmZvKCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGluZm8gPSBuZXcgQ2xpZW50SW5mbyh7XG4gICAgc2RrOiBDbGllbnRJbmZvX1NESy5KUyxcbiAgICBwcm90b2NvbDogcHJvdG9jb2xWZXJzaW9uLFxuICAgIHZlcnNpb25cbiAgfSk7XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBpbmZvLm9zID0gKF9hID0gZ2V0UmVhY3ROYXRpdmVPcygpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cbmxldCBlbXB0eVZpZGVvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlWaWRlb1N0cmVhbVRyYWNrKSB7XG4gICAgZW1wdHlWaWRlb1N0cmVhbVRyYWNrID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGVtcHR5VmlkZW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCkge1xuICBsZXQgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE2O1xuICBsZXQgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgbGV0IGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBsZXQgcGFpbnRDb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIC8vIHRoZSBjYW52YXMgc2l6ZSBpcyBzZXQgdG8gMTYgYnkgZGVmYXVsdCwgYmVjYXVzZSBlbGVjdHJvbiBhcHBzIHNlZW0gdG8gZmFpbCB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGlmIChwYWludENvbnRlbnQgJiYgY3R4KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMod2lkdGggLyAyLCBoZWlnaHQgLyAyLCA1MCwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ2dyZXknO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBkdW1teVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gIGNvbnN0IFtkdW1teVRyYWNrXSA9IGR1bW15U3RyZWFtLmdldFRyYWNrcygpO1xuICBpZiAoIWR1bW15VHJhY2spIHtcbiAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gdmlkZW8gdHJhY2snKTtcbiAgfVxuICBkdW1teVRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xuICByZXR1cm4gZHVtbXlUcmFjaztcbn1cbmxldCBlbXB0eUF1ZGlvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93ZWJydGMvd2FybS11cC13aXRoLXJlcGxhY2V0cmFjay9cbiAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgY29uc3Qgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgY29uc3QgZ2FpbiA9IGN0eC5jcmVhdGVHYWluKCk7XG4gICAgZ2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIDApO1xuICAgIGNvbnN0IGRzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW4pO1xuICAgIGdhaW4uY29ubmVjdChkc3QpO1xuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICBbZW1wdHlBdWRpb1N0cmVhbVRyYWNrXSA9IGRzdC5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIGF1ZGlvIHRyYWNrJyk7XG4gICAgfVxuICAgIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuY2xhc3MgRnV0dXJlIHtcbiAgZ2V0IGlzUmVzb2x2ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmVzb2x2ZWQ7XG4gIH1cbiAgY29uc3RydWN0b3IoZnV0dXJlQmFzZSwgb25GaW5hbGx5KSB7XG4gICAgdGhpcy5faXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHRoaXMub25GaW5hbGx5ID0gb25GaW5hbGx5O1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIGlmIChmdXR1cmVCYXNlKSB7XG4gICAgICAgIHlpZWxkIGZ1dHVyZUJhc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLl9pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIChfYSA9IHRoaXMub25GaW5hbGx5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFuYWx5c2VyIHdlYiBhdWRpbyBub2RlIHRoYXQgaXMgYXR0YWNoZWQgdG8gdGhlIHByb3ZpZGVkIHRyYWNrLlxuICogQWRkaXRpb25hbGx5IHJldHVybnMgYSBjb252ZW5pZW5jZSBtZXRob2QgYGNhbGN1bGF0ZVZvbHVtZWAgdG8gcGVyZm9ybSBpbnN0YW50IHZvbHVtZSByZWFkaW5ncyBvbiB0aGF0IHRyYWNrLlxuICogQ2FsbCB0aGUgcmV0dXJuZWQgYGNsZWFudXBgIGZ1bmN0aW9uIHRvIGNsb3NlIHRoZSBhdWRpb0NvbnRleHQgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIGZvciB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBoZWxwZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXVkaW9BbmFseXNlcih0cmFjaywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgY2xvbmVUcmFjazogZmFsc2UsXG4gICAgZmZ0U2l6ZTogMjA0OCxcbiAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IDAuOCxcbiAgICBtaW5EZWNpYmVsczogLTEwMCxcbiAgICBtYXhEZWNpYmVsczogLTgwXG4gIH0sIG9wdGlvbnMpO1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcbiAgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1ZGlvIENvbnRleHQgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXInKTtcbiAgfVxuICBjb25zdCBzdHJlYW1UcmFjayA9IG9wdHMuY2xvbmVUcmFjayA/IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSA6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2s7XG4gIGNvbnN0IG1lZGlhU3RyZWFtU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbc3RyZWFtVHJhY2tdKSk7XG4gIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gIGFuYWx5c2VyLm1pbkRlY2liZWxzID0gb3B0cy5taW5EZWNpYmVscztcbiAgYW5hbHlzZXIubWF4RGVjaWJlbHMgPSBvcHRzLm1heERlY2liZWxzO1xuICBhbmFseXNlci5mZnRTaXplID0gb3B0cy5mZnRTaXplO1xuICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSBvcHRzLnNtb290aGluZ1RpbWVDb25zdGFudDtcbiAgbWVkaWFTdHJlYW1Tb3VyY2UuY29ubmVjdChhbmFseXNlcik7XG4gIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgdm9sdW1lIG9mIHRoZSB0cmFjayBpbiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDFcbiAgICovXG4gIGNvbnN0IGNhbGN1bGF0ZVZvbHVtZSA9ICgpID0+IHtcbiAgICBhbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhQXJyYXkpO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAoY29uc3QgYW1wbGl0dWRlIG9mIGRhdGFBcnJheSkge1xuICAgICAgc3VtICs9IE1hdGgucG93KGFtcGxpdHVkZSAvIDI1NSwgMik7XG4gICAgfVxuICAgIGNvbnN0IHZvbHVtZSA9IE1hdGguc3FydChzdW0gLyBkYXRhQXJyYXkubGVuZ3RoKTtcbiAgICByZXR1cm4gdm9sdW1lO1xuICB9O1xuICBjb25zdCBjbGVhbnVwID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHlpZWxkIGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgIGlmIChvcHRzLmNsb25lVHJhY2spIHtcbiAgICAgIHN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNhbGN1bGF0ZVZvbHVtZSxcbiAgICBhbmFseXNlcixcbiAgICBjbGVhbnVwXG4gIH07XG59XG5mdW5jdGlvbiBpc0F1ZGlvQ29kZWMobWF5YmVDb2RlYykge1xuICByZXR1cm4gYXVkaW9Db2RlY3MuaW5jbHVkZXMobWF5YmVDb2RlYyk7XG59XG5mdW5jdGlvbiBpc1ZpZGVvQ29kZWMobWF5YmVDb2RlYykge1xuICByZXR1cm4gdmlkZW9Db2RlY3MuaW5jbHVkZXMobWF5YmVDb2RlYyk7XG59XG5mdW5jdGlvbiB1bndyYXBDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29uc3RyYWludCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50KSkge1xuICAgIHJldHVybiBjb25zdHJhaW50WzBdO1xuICB9XG4gIGlmIChjb25zdHJhaW50LmV4YWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmV4YWN0KSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0O1xuICB9XG4gIGlmIChjb25zdHJhaW50LmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmlkZWFsKSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuaWRlYWxbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsO1xuICB9XG4gIHRocm93IEVycm9yKCdjb3VsZCBub3QgdW53cmFwIGNvbnN0cmFpbnQnKTtcbn1cbmZ1bmN0aW9uIHRvV2Vic29ja2V0VXJsKHVybCkge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXihodHRwKS8sICd3cycpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiB0b0h0dHBVcmwodXJsKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnd3MnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXih3cykvLCAnaHR0cCcpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzKHRyYW5zY3JpcHRpb24sIGZpcnN0UmVjZWl2ZWRUaW1lc01hcCkge1xuICByZXR1cm4gdHJhbnNjcmlwdGlvbi5zZWdtZW50cy5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGlkLFxuICAgICAgdGV4dCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgZW5kVGltZSxcbiAgICAgIGZpbmFsXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZpcnN0UmVjZWl2ZWRUaW1lID0gKF9hID0gZmlyc3RSZWNlaXZlZFRpbWVzTWFwLmdldChpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERhdGUubm93KCk7XG4gICAgY29uc3QgbGFzdFJlY2VpdmVkVGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmaXJzdFJlY2VpdmVkVGltZXNNYXAuZGVsZXRlKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RSZWNlaXZlZFRpbWVzTWFwLnNldChpZCwgZmlyc3RSZWNlaXZlZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICB0ZXh0LFxuICAgICAgc3RhcnRUaW1lOiBOdW1iZXIucGFyc2VJbnQoc3RhcnRUaW1lLnRvU3RyaW5nKCkpLFxuICAgICAgZW5kVGltZTogTnVtYmVyLnBhcnNlSW50KGVuZFRpbWUudG9TdHJpbmcoKSksXG4gICAgICBmaW5hbCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgZmlyc3RSZWNlaXZlZFRpbWUsXG4gICAgICBsYXN0UmVjZWl2ZWRUaW1lXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q2hhdE1lc3NhZ2UobXNnKSB7XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICB0aW1lc3RhbXAsXG4gICAgbWVzc2FnZSxcbiAgICBlZGl0VGltZXN0YW1wXG4gIH0gPSBtc2c7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdGltZXN0YW1wOiBOdW1iZXIucGFyc2VJbnQodGltZXN0YW1wLnRvU3RyaW5nKCkpLFxuICAgIGVkaXRUaW1lc3RhbXA6IGVkaXRUaW1lc3RhbXAgPyBOdW1iZXIucGFyc2VJbnQoZWRpdFRpbWVzdGFtcC50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlXG4gIH07XG59XG5mdW5jdGlvbiBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKSB7XG4gIHN3aXRjaCAoZS5yZWFzb24pIHtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3Q6XG4gICAgICByZXR1cm4gZS5jb250ZXh0O1xuICAgIGNhc2UgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZDpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQ7XG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZDpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLlVTRVJfUkVKRUNURUQ7XG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGU6XG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5KT0lOX0ZBSUxVUkU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLlVOS05PV05fUkVBU09OO1xuICB9XG59XG4vKiogY29udmVydCBiaWdpbnRzIHRvIG51bWJlcnMgcHJlc2VydmluZyB1bmRlZmluZWQgdmFsdWVzICovXG5mdW5jdGlvbiBiaWdJbnRUb051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IE51bWJlcih2YWx1ZSkgOiB1bmRlZmluZWQ7XG59XG4vKiogY29udmVydCBudW1iZXJzIHRvIGJpZ2ludHMgcHJlc2VydmluZyB1bmRlZmluZWQgdmFsdWVzICovXG5mdW5jdGlvbiBudW1iZXJUb0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IEJpZ0ludCh2YWx1ZSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0xvY2FsVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuICEhdHJhY2sgJiYgISh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spICYmIHRyYWNrLmlzTG9jYWw7XG59XG5mdW5jdGlvbiBpc0F1ZGlvVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuICEhdHJhY2sgJiYgdHJhY2sua2luZCA9PSBUcmFjay5LaW5kLkF1ZGlvO1xufVxuZnVuY3Rpb24gaXNWaWRlb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiAhIXRyYWNrICYmIHRyYWNrLmtpbmQgPT0gVHJhY2suS2luZC5WaWRlbztcbn1cbmZ1bmN0aW9uIGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiBpc0xvY2FsVHJhY2sodHJhY2spICYmIGlzVmlkZW9UcmFjayh0cmFjayk7XG59XG5mdW5jdGlvbiBpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykge1xuICByZXR1cm4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spO1xufVxuZnVuY3Rpb24gaXNSZW1vdGVUcmFjayh0cmFjaykge1xuICByZXR1cm4gISF0cmFjayAmJiAhdHJhY2suaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIGlzUmVtb3RlUHViKHB1Yikge1xuICByZXR1cm4gISFwdWIgJiYgIXB1Yi5pc0xvY2FsO1xufVxuZnVuY3Rpb24gaXNSZW1vdGVWaWRlb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiBpc1JlbW90ZVRyYWNrKHRyYWNrKSAmJiBpc1ZpZGVvVHJhY2sodHJhY2spO1xufVxuZnVuY3Rpb24gaXNMb2NhbFBhcnRpY2lwYW50KHApIHtcbiAgcmV0dXJuIHAuaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIGlzUmVtb3RlUGFydGljaXBhbnQocCkge1xuICByZXR1cm4gIXAuaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIHNwbGl0VXRmOChzLCBuKSB7XG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjA0Mzc5N1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGVuY29kZWQgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XG4gIHdoaWxlIChlbmNvZGVkLmxlbmd0aCA+IG4pIHtcbiAgICBsZXQgayA9IG47XG4gICAgd2hpbGUgKGsgPiAwKSB7XG4gICAgICBjb25zdCBieXRlID0gZW5jb2RlZFtrXTtcbiAgICAgIGlmIChieXRlICE9PSB1bmRlZmluZWQgJiYgKGJ5dGUgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGstLTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goZW5jb2RlZC5zbGljZSgwLCBrKSk7XG4gICAgZW5jb2RlZCA9IGVuY29kZWQuc2xpY2Uoayk7XG4gIH1cbiAgaWYgKGVuY29kZWQubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wdXNoKGVuY29kZWQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBleHRyYWN0TWF4QWdlRnJvbVJlcXVlc3RIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBjYWNoZUNvbnRyb2wgPSBoZWFkZXJzLmdldCgnQ2FjaGUtQ29udHJvbCcpO1xuICBpZiAoY2FjaGVDb250cm9sKSB7XG4gICAgY29uc3QgbWF4QWdlID0gKF9hID0gY2FjaGVDb250cm9sLm1hdGNoKC8oPzpefFssXFxzXSltYXgtYWdlPShcXGQrKS8pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV07XG4gICAgaWYgKG1heEFnZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KG1heEFnZSwgMTApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgdmFyIF9jLCBfZDtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yLFxuICAgIGF1ZGlvUHJvY2Vzc29yLFxuICAgIHZpZGVvUHJvY2Vzc29yXG4gIH0gPSBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcbiAgY29uc3QgZGVmYXVsdEF1ZGlvUHJvY2Vzc29yID0gYXVkaW9EZWZhdWx0cyA9PT0gbnVsbCB8fCBhdWRpb0RlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdWRpb0RlZmF1bHRzLnByb2Nlc3NvcjtcbiAgY29uc3QgZGVmYXVsdFZpZGVvUHJvY2Vzc29yID0gdmlkZW9EZWZhdWx0cyA9PT0gbnVsbCB8fCB2aWRlb0RlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0RlZmF1bHRzLnByb2Nlc3NvcjtcbiAgY29uc3QgY2xvbmVkT3B0aW9ucyA9IG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yICE9PSBudWxsICYmIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yICE9PSB2b2lkIDAgPyBvcHRpb25zV2l0aG91dFByb2Nlc3NvciA6IHt9O1xuICBpZiAoY2xvbmVkT3B0aW9ucy5hdWRpbyA9PT0gdHJ1ZSkgY2xvbmVkT3B0aW9ucy5hdWRpbyA9IHt9O1xuICBpZiAoY2xvbmVkT3B0aW9ucy52aWRlbyA9PT0gdHJ1ZSkgY2xvbmVkT3B0aW9ucy52aWRlbyA9IHt9O1xuICAvLyB1c2UgZGVmYXVsdHNcbiAgaWYgKGNsb25lZE9wdGlvbnMuYXVkaW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhjbG9uZWRPcHRpb25zLmF1ZGlvLCBhdWRpb0RlZmF1bHRzKTtcbiAgICAoX2EgPSAoX2MgPSBjbG9uZWRPcHRpb25zLmF1ZGlvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX2MuZGV2aWNlSWQgPSB7XG4gICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgfTtcbiAgICBpZiAoYXVkaW9Qcm9jZXNzb3IgfHwgZGVmYXVsdEF1ZGlvUHJvY2Vzc29yKSB7XG4gICAgICBjbG9uZWRPcHRpb25zLmF1ZGlvLnByb2Nlc3NvciA9IGF1ZGlvUHJvY2Vzc29yICE9PSBudWxsICYmIGF1ZGlvUHJvY2Vzc29yICE9PSB2b2lkIDAgPyBhdWRpb1Byb2Nlc3NvciA6IGRlZmF1bHRBdWRpb1Byb2Nlc3NvcjtcbiAgICB9XG4gIH1cbiAgaWYgKGNsb25lZE9wdGlvbnMudmlkZW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhjbG9uZWRPcHRpb25zLnZpZGVvLCB2aWRlb0RlZmF1bHRzKTtcbiAgICAoX2IgPSAoX2QgPSBjbG9uZWRPcHRpb25zLnZpZGVvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX2QuZGV2aWNlSWQgPSB7XG4gICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgfTtcbiAgICBpZiAodmlkZW9Qcm9jZXNzb3IgfHwgZGVmYXVsdFZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICBjbG9uZWRPcHRpb25zLnZpZGVvLnByb2Nlc3NvciA9IHZpZGVvUHJvY2Vzc29yICE9PSBudWxsICYmIHZpZGVvUHJvY2Vzc29yICE9PSB2b2lkIDAgPyB2aWRlb1Byb2Nlc3NvciA6IGRlZmF1bHRWaWRlb1Byb2Nlc3NvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhtYWluT2JqZWN0LCBvYmplY3RUb01lcmdlKSB7XG4gIE9iamVjdC5rZXlzKG9iamVjdFRvTWVyZ2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAobWFpbk9iamVjdFtrZXldID09PSB1bmRlZmluZWQpIG1haW5PYmplY3Rba2V5XSA9IG9iamVjdFRvTWVyZ2Vba2V5XTtcbiAgfSk7XG4gIHJldHVybiBtYWluT2JqZWN0O1xufVxuZnVuY3Rpb24gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgdmFyIF9jLCBfZDtcbiAgY29uc3QgY29uc3RyYWludHMgPSB7fTtcbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAvLyBkZWZhdWx0IHZpZGVvIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCB2aWRlb09wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHZpZGVvT3B0aW9ucztcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMudmlkZW87XG4gICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdyZXNvbHV0aW9uJzpcbiAgICAgICAgICAgIC8vIGZsYXR0ZW4gVmlkZW9SZXNvbHV0aW9uIGZpZWxkc1xuICAgICAgICAgICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcodGFyZ2V0LCBzb3VyY2UucmVzb2x1dGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHZpZGVvT3B0aW9ucztcbiAgICAgIChfYSA9IChfYyA9IGNvbnN0cmFpbnRzLnZpZGVvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX2MuZGV2aWNlSWQgPSB7XG4gICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gb3B0aW9ucy52aWRlbyA/IHtcbiAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgICAgIH1cbiAgICAgIH0gOiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICAgIChfYiA9IChfZCA9IGNvbnN0cmFpbnRzLmF1ZGlvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX2QuZGV2aWNlSWQgPSB7XG4gICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0ge1xuICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyBzaWxlbmNlIG9uIGEgZ2l2ZW4gW1tUcmFja11dIGluc3RhbmNlLlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFjayBzZWVtcyB0byBiZSBlbnRpcmVseSBzaWxlbnQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNpbGVuY2UodHJhY2tfMSkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICBsZXQgdGltZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjAwO1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY3R4ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGNvbnN0IGFuYWx5c2VyID0gY3R4LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgIGFuYWx5c2VyLmZmdFNpemUgPSAyMDQ4O1xuICAgICAgICBjb25zdCBidWZmZXJMZW5ndGggPSBhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudDtcbiAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbdHJhY2subWVkaWFTdHJlYW1UcmFja10pKTtcbiAgICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgICAgICB5aWVsZCBzbGVlcCh0aW1lT2Zmc2V0KTtcbiAgICAgICAgYW5hbHlzZXIuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKGRhdGFBcnJheSk7XG4gICAgICAgIGNvbnN0IHNvbWVOb2lzZSA9IGRhdGFBcnJheS5zb21lKHNhbXBsZSA9PiBzYW1wbGUgIT09IDEyOCAmJiBzYW1wbGUgIT09IDApO1xuICAgICAgICBjdHguY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuICFzb21lTm9pc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSgpO1xuICB9KTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5ld0F1ZGlvQ29udGV4dCgpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBBdWRpb0NvbnRleHQgPVxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuICBpZiAoQXVkaW9Db250ZXh0KSB7XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICBsYXRlbmN5SGludDogJ2ludGVyYWN0aXZlJ1xuICAgIH0pO1xuICAgIC8vIElmIHRoZSBhdWRpbyBjb250ZXh0IGlzIHN1c3BlbmRlZCwgd2UgbmVlZCB0byByZXN1bWUgaXQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIHBhZ2VcbiAgICBpZiAoYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gd2luZG93LmRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm9keSkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZVJlc3VtZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChhdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICB5aWVsZCBhdWRpb0NvbnRleHQucmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciB0cnlpbmcgdG8gYXV0by1yZXN1bWUgYXVkaW8gY29udGV4dCcsIGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChfYSA9IHdpbmRvdy5kb2N1bWVudC5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVSZXN1bWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CYXNlQXVkaW9Db250ZXh0L3N0YXRlY2hhbmdlX2V2ZW50XG4gICAgICBhdWRpb0NvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAoX2EgPSB3aW5kb3cuZG9jdW1lbnQuYm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlUmVzdW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVJlc3VtZSk7XG4gICAgfVxuICAgIHJldHVybiBhdWRpb0NvbnRleHQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGtpbmRUb1NvdXJjZShraW5kKSB7XG4gIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcpIHtcbiAgICByZXR1cm4gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzb3VyY2VUb0tpbmQoc291cmNlKSB7XG4gIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKSB7XG4gICAgcmV0dXJuICdhdWRpb2lucHV0JztcbiAgfSBlbHNlIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpIHtcbiAgICByZXR1cm4gJ3ZpZGVvaW5wdXQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICBsZXQgdmlkZW9Db25zdHJhaW50cyA9IChfYSA9IG9wdGlvbnMudmlkZW8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gIC8vIHRyZWF0IDAgYXMgdW5jYXBwZWRcbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAmJiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGggPiAwICYmIG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQgPiAwKSB7XG4gICAgdmlkZW9Db25zdHJhaW50cyA9IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzID09PSAnYm9vbGVhbicgPyB7fSA6IHZpZGVvQ29uc3RyYWludHM7XG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgbWF4OiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgbWF4OiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGF1ZGlvOiAoX2IgPSBvcHRpb25zLmF1ZGlvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICB2aWRlbzogdmlkZW9Db25zdHJhaW50cyxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHN1cHBvcnQgZm9yIGV4cGVyaW1lbnRhbCBkaXNwbGF5IG1lZGlhIGZlYXR1cmVzXG4gICAgY29udHJvbGxlcjogb3B0aW9ucy5jb250cm9sbGVyLFxuICAgIHNlbGZCcm93c2VyU3VyZmFjZTogb3B0aW9ucy5zZWxmQnJvd3NlclN1cmZhY2UsXG4gICAgc3VyZmFjZVN3aXRjaGluZzogb3B0aW9ucy5zdXJmYWNlU3dpdGNoaW5nLFxuICAgIHN5c3RlbUF1ZGlvOiBvcHRpb25zLnN5c3RlbUF1ZGlvLFxuICAgIHByZWZlckN1cnJlbnRUYWI6IG9wdGlvbnMucHJlZmVyQ3VycmVudFRhYlxuICB9O1xufVxuZnVuY3Rpb24gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcobWltZVR5cGUpIHtcbiAgcmV0dXJuIG1pbWVUeXBlLnNwbGl0KCcvJylbMV0udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGdldFRyYWNrUHVibGljYXRpb25JbmZvKHRyYWNrcykge1xuICBjb25zdCBpbmZvcyA9IFtdO1xuICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgaWYgKHRyYWNrLnRyYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZm9zLnB1c2gobmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2Uoe1xuICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgIHRyYWNrOiB0cmFjay50cmFja0luZm9cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5mb3M7XG59XG5mdW5jdGlvbiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSB7XG4gIGlmICgnbWVkaWFTdHJlYW1UcmFjaycgaW4gdHJhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tJRDogdHJhY2suc2lkLFxuICAgICAgc291cmNlOiB0cmFjay5zb3VyY2UsXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgIGVuYWJsZWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCxcbiAgICAgIGtpbmQ6IHRyYWNrLmtpbmQsXG4gICAgICBzdHJlYW1JRDogdHJhY2subWVkaWFTdHJlYW1JRCxcbiAgICAgIHN0cmVhbVRyYWNrSUQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFja0lEOiB0cmFjay50cmFja1NpZCxcbiAgICAgIGVuYWJsZWQ6IHRyYWNrLmlzRW5hYmxlZCxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgdHJhY2tJbmZvOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbWltZVR5cGU6IHRyYWNrLm1pbWVUeXBlLFxuICAgICAgICBuYW1lOiB0cmFjay50cmFja05hbWUsXG4gICAgICAgIGVuY3J5cHRlZDogdHJhY2suaXNFbmNyeXB0ZWQsXG4gICAgICAgIGtpbmQ6IHRyYWNrLmtpbmQsXG4gICAgICAgIHNvdXJjZTogdHJhY2suc291cmNlXG4gICAgICB9LCB0cmFjay50cmFjayA/IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2sudHJhY2spIDoge30pXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc3VwcG9ydHNTeW5jaHJvbml6YXRpb25Tb3VyY2VzKCkge1xuICByZXR1cm4gdHlwZW9mIFJUQ1J0cFJlY2VpdmVyICE9PSAndW5kZWZpbmVkJyAmJiAnZ2V0U3luY2hyb25pemF0aW9uU291cmNlcycgaW4gUlRDUnRwUmVjZWl2ZXI7XG59XG5mdW5jdGlvbiBkaWZmQXR0cmlidXRlcyhvbGRWYWx1ZXMsIG5ld1ZhbHVlcykge1xuICB2YXIgX2E7XG4gIGlmIChvbGRWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9sZFZhbHVlcyA9IHt9O1xuICB9XG4gIGlmIChuZXdWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5ld1ZhbHVlcyA9IHt9O1xuICB9XG4gIGNvbnN0IGFsbEtleXMgPSBbLi4uT2JqZWN0LmtleXMobmV3VmFsdWVzKSwgLi4uT2JqZWN0LmtleXMob2xkVmFsdWVzKV07XG4gIGNvbnN0IGRpZmYgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgIGlmIChvbGRWYWx1ZXNba2V5XSAhPT0gbmV3VmFsdWVzW2tleV0pIHtcbiAgICAgIGRpZmZba2V5XSA9IChfYSA9IG5ld1ZhbHVlc1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgbmV3T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICBsZXQgYXVkaW9Qcm9jZXNzb3I7XG4gIGxldCB2aWRlb1Byb2Nlc3NvcjtcbiAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0JyAmJiBuZXdPcHRpb25zLmF1ZGlvLnByb2Nlc3Nvcikge1xuICAgIGF1ZGlvUHJvY2Vzc29yID0gbmV3T3B0aW9ucy5hdWRpby5wcm9jZXNzb3I7XG4gICAgbmV3T3B0aW9ucy5hdWRpbyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3T3B0aW9ucy5hdWRpbyksIHtcbiAgICAgIHByb2Nlc3NvcjogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0JyAmJiBuZXdPcHRpb25zLnZpZGVvLnByb2Nlc3Nvcikge1xuICAgIHZpZGVvUHJvY2Vzc29yID0gbmV3T3B0aW9ucy52aWRlby5wcm9jZXNzb3I7XG4gICAgbmV3T3B0aW9ucy52aWRlbyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3T3B0aW9ucy52aWRlbyksIHtcbiAgICAgIHByb2Nlc3NvcjogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhdWRpb1Byb2Nlc3NvcixcbiAgICB2aWRlb1Byb2Nlc3NvcixcbiAgICBvcHRpb25zV2l0aG91dFByb2Nlc3NvcjogY2xvbmVEZWVwKG5ld09wdGlvbnMpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUcmFja1NvdXJjZUZyb21Qcm90byhzb3VyY2UpIHtcbiAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICBjYXNlIFRyYWNrU291cmNlLkNBTUVSQTpcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTpcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxufVxuZnVuY3Rpb24gYXJlRGltZW5zaW9uc1NtYWxsZXIoYSwgYikge1xuICByZXR1cm4gYS53aWR0aCAqIGEuaGVpZ2h0IDwgYi53aWR0aCAqIGIuaGVpZ2h0O1xufVxuZnVuY3Rpb24gbGF5ZXJEaW1lbnNpb25zRm9yKHRyYWNrSW5mbywgcXVhbGl0eSkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSB0cmFja0luZm8ubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZChsID0+IGwucXVhbGl0eSA9PT0gcXVhbGl0eSk7XG59XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBFMkVFTWFuYWdlciBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgZGNFbmNyeXB0aW9uRW5hYmxlZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWNyeXB0RGF0YVJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW5jcnlwdERhdGFSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9uV29ya2VyTWVzc2FnZSA9IGV2ID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtpbmQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSBldi5kYXRhO1xuICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKGRhdGEuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgLy8gSWYgZXJyb3IgaGFzIHV1aWQsIGl0J3MgZnJvbSBhbiBhc3luYyBvcGVyYXRpb24gKGVuY3J5cHQvZGVjcnlwdClcbiAgICAgICAgICAvLyBSZWplY3QgdGhlIGNvcnJlc3BvbmRpbmcgZnV0dXJlXG4gICAgICAgICAgaWYgKGRhdGEudXVpZCkge1xuICAgICAgICAgICAgY29uc3QgZGVjcnlwdEZ1dHVyZSA9IHRoaXMuZGVjcnlwdERhdGFSZXF1ZXN0cy5nZXQoZGF0YS51dWlkKTtcbiAgICAgICAgICAgIGlmIChkZWNyeXB0RnV0dXJlID09PSBudWxsIHx8IGRlY3J5cHRGdXR1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY3J5cHRGdXR1cmUucmVqZWN0KSB7XG4gICAgICAgICAgICAgIGRlY3J5cHRGdXR1cmUucmVqZWN0KGRhdGEuZXJyb3IpO1xuICAgICAgICAgICAgICBicmVhazsgLy8gRG9uJ3QgZW1pdCBnZW5lcmFsIGVycm9yIGlmIGl0J3MgaGFuZGxlZCBieSBmdXR1cmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRGdXR1cmUgPSB0aGlzLmVuY3J5cHREYXRhUmVxdWVzdHMuZ2V0KGRhdGEudXVpZCk7XG4gICAgICAgICAgICBpZiAoZW5jcnlwdEZ1dHVyZSA9PT0gbnVsbCB8fCBlbmNyeXB0RnV0dXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbmNyeXB0RnV0dXJlLnJlamVjdCkge1xuICAgICAgICAgICAgICBlbmNyeXB0RnV0dXJlLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7IC8vIERvbid0IGVtaXQgZ2VuZXJhbCBlcnJvciBpZiBpdCdzIGhhbmRsZWQgYnkgZnV0dXJlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVtaXQgZ2VuZXJhbCBlcnJvciBldmVudCBmb3IgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBkYXRhLmVycm9yLCBkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbml0QWNrJzpcbiAgICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKGtleUluZm8gPT4ge1xuICAgICAgICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICAgICAgaWYgKGRhdGEuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVuY3J5cHRpb25FbmFibGVkICE9PSBkYXRhLmVuYWJsZWQgJiYgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZGF0YS5lbmFibGVkLCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkID0gZGF0YS5lbmFibGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IChfYiA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eShkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJjb3VsZG4ndCBzZXQgZW5jcnlwdGlvbiBzdGF0dXMsIHBhcnRpY2lwYW50IG5vdCBmb3VuZFwiLmNvbmNhdChkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZGF0YS5lbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXRjaGV0S2V5JzpcbiAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWQsIGRhdGEucmF0Y2hldFJlc3VsdCwgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5LCBkYXRhLmtleUluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVjcnlwdERhdGFSZXNwb25zZSc6XG4gICAgICAgICAgY29uc3QgZGVjcnlwdEZ1dHVyZSA9IHRoaXMuZGVjcnlwdERhdGFSZXF1ZXN0cy5nZXQoZGF0YS51dWlkKTtcbiAgICAgICAgICBpZiAoZGVjcnlwdEZ1dHVyZSA9PT0gbnVsbCB8fCBkZWNyeXB0RnV0dXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNyeXB0RnV0dXJlLnJlc29sdmUpIHtcbiAgICAgICAgICAgIGRlY3J5cHRGdXR1cmUucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VuY3J5cHREYXRhUmVzcG9uc2UnOlxuICAgICAgICAgIGNvbnN0IGVuY3J5cHRGdXR1cmUgPSB0aGlzLmVuY3J5cHREYXRhUmVxdWVzdHMuZ2V0KGRhdGEudXVpZCk7XG4gICAgICAgICAgaWYgKGVuY3J5cHRGdXR1cmUgPT09IG51bGwgfHwgZW5jcnlwdEZ1dHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5jcnlwdEZ1dHVyZS5yZXNvbHZlKSB7XG4gICAgICAgICAgICBlbmNyeXB0RnV0dXJlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbldvcmtlckVycm9yID0gZXYgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcignZTJlZSB3b3JrZXIgZW5jb3VudGVyZWQgYW4gZXJyb3I6Jywge1xuICAgICAgICBlcnJvcjogZXYuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGV2LmVycm9yLCB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgdGhpcy5rZXlQcm92aWRlciA9IG9wdGlvbnMua2V5UHJvdmlkZXI7XG4gICAgdGhpcy53b3JrZXIgPSBvcHRpb25zLndvcmtlcjtcbiAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5kYXRhQ2hhbm5lbEVuY3J5cHRpb25FbmFibGVkID0gZGNFbmNyeXB0aW9uRW5hYmxlZDtcbiAgfVxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb25FbmFibGVkO1xuICB9XG4gIGdldCBpc0RhdGFDaGFubmVsRW5jcnlwdGlvbkVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkICYmIHRoaXMuZGF0YUNoYW5uZWxFbmNyeXB0aW9uRW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXR1cChyb29tKSB7XG4gICAgaWYgKCFpc0UyRUVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ3RyaWVkIHRvIHNldHVwIGVuZC10by1lbmQgZW5jcnlwdGlvbiBvbiBhbiB1bnN1cHBvcnRlZCBicm93c2VyJyk7XG4gICAgfVxuICAgIGxpdmVraXRMb2dnZXIuaW5mbygnc2V0dGluZyB1cCBlMmVlJyk7XG4gICAgaWYgKHJvb20gIT09IHRoaXMucm9vbSkge1xuICAgICAgdGhpcy5yb29tID0gcm9vbTtcbiAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycyhyb29tLCB0aGlzLmtleVByb3ZpZGVyKTtcbiAgICAgIC8vIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcignJyk7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGtleVByb3ZpZGVyT3B0aW9uczogdGhpcy5rZXlQcm92aWRlci5nZXRPcHRpb25zKCksXG4gICAgICAgICAgbG9nbGV2ZWw6IHdvcmtlckxvZ2dlci5nZXRMZXZlbCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiaW5pdGlhbGl6aW5nIHdvcmtlclwiLCB7XG4gICAgICAgICAgd29ya2VyOiB0aGlzLndvcmtlclxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbldvcmtlck1lc3NhZ2U7XG4gICAgICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSB0aGlzLm9uV29ya2VyRXJyb3I7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJzZXQgZTJlZSB0byBcIi5jb25jYXQoZW5hYmxlZCwgXCIgZm9yIHBhcnRpY2lwYW50IFwiKS5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSkpO1xuICAgIHRoaXMucG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRTaWZUcmFpbGVyKHRyYWlsZXIpIHtcbiAgICBpZiAoIXRyYWlsZXIgfHwgdHJhaWxlci5sZW5ndGggPT09IDApIHtcbiAgICAgIGxpdmVraXRMb2dnZXIud2FybihcImlnbm9yaW5nIHNlcnZlciBzZW50IHRyYWlsZXIgYXMgaXQncyBlbXB0eVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3N0U2lmVHJhaWxlcih0cmFpbGVyKTtcbiAgICB9XG4gIH1cbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XG4gICAgZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJUUFZpZGVvTWFwVXBkYXRlLCBydHBNYXAgPT4ge1xuICAgICAgdGhpcy5wb3N0UlRQTWFwKHJ0cE1hcCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBFdmVudExpc3RlbmVycyhyb29tLCBrZXlQcm92aWRlcikge1xuICAgIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAocHViLCBwYXJ0aWNpcGFudCkgPT4gdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHB1Yi50cmFja0luZm8uZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsIHBhcnRpY2lwYW50LmlkZW50aXR5KSk7XG4gICAgcm9vbS5vbihSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHJvb20ucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocGFydGljaXBhbnQgPT4ge1xuICAgICAgICAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChwdWIudHJhY2tJbmZvLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLCBwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBfLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBraW5kOiAncmVtb3ZlVHJhbnNmb3JtJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrLm1lZGlhU3RyZWFtSURcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChfYSA9IHRoaXMud29ya2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UobXNnKTtcbiAgICB9KS5vbihSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2ssIHB1YiwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFUmVjZWl2ZXIodHJhY2ssIHBhcnRpY2lwYW50LmlkZW50aXR5LCBwdWIudHJhY2tJbmZvKTtcbiAgICB9KS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucm9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0ZWQgcm9vbSB0byBiZSBwcmVzZW50IG9uIHNpZ25hbCBjb25uZWN0XCIpO1xuICAgICAgfVxuICAgICAga2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlzRTJFRUVuYWJsZWQsIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICB9KTtcbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFNlbmRlckNyZWF0ZWQsIChzZW5kZXIsIHRyYWNrKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNldHVwRTJFRVNlbmRlcih0cmFjaywgc2VuZGVyKTtcbiAgICB9KSk7XG4gICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24gPT4ge1xuICAgICAgLy8gU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCByZXRyaWV2aW5nIHBheWxvYWQgaW5mb3JtYXRpb24gb24gUlRDRW5jb2RlZFZpZGVvRnJhbWUsIHNvIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjb2RlYyBtYW51YWxseSBvbmNlIHdlIGhhdmUgdGhlIHRyYWNrSW5mbyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgIGlmICghaXNWaWRlb1RyYWNrKHB1YmxpY2F0aW9uLnRyYWNrKSB8fCAhaXNTYWZhcmlCYXNlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ3VwZGF0ZUNvZGVjJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRyYWNrSWQ6IHB1YmxpY2F0aW9uLnRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgICAgY29kZWM6IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHB1YmxpY2F0aW9uLnRyYWNrSW5mby5jb2RlY3NbMF0ubWltZVR5cGUpLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH0pO1xuICAgIGtleVByb3ZpZGVyLm9uKEtleVByb3ZpZGVyRXZlbnQuU2V0S2V5LCBrZXlJbmZvID0+IHRoaXMucG9zdEtleShrZXlJbmZvKSkub24oS2V5UHJvdmlkZXJFdmVudC5SYXRjaGV0UmVxdWVzdCwgKHBhcnRpY2lwYW50SWQsIGtleUluZGV4KSA9PiB0aGlzLnBvc3RSYXRjaGV0UmVxdWVzdChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkpO1xuICB9XG4gIGVuY3J5cHREYXRhKGRhdGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IGVuY3J5cHQgZGF0YSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHV1aWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBraW5kOiAnZW5jcnlwdERhdGFSZXF1ZXN0JyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHV1aWQsXG4gICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgZnV0dXJlLm9uRmluYWxseSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5lbmNyeXB0RGF0YVJlcXVlc3RzLmRlbGV0ZSh1dWlkKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmVuY3J5cHREYXRhUmVxdWVzdHMuc2V0KHV1aWQsIGZ1dHVyZSk7XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgcmV0dXJuIGZ1dHVyZS5wcm9taXNlO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZUVuY3J5cHRlZERhdGEocGF5bG9hZCwgaXYsIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBoYW5kbGUgZW5jcnlwdGVkIGRhdGEsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHV1aWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdkZWNyeXB0RGF0YVJlcXVlc3QnLFxuICAgICAgZGF0YToge1xuICAgICAgICB1dWlkLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBpdixcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICBmdXR1cmUub25GaW5hbGx5ID0gKCkgPT4ge1xuICAgICAgdGhpcy5kZWNyeXB0RGF0YVJlcXVlc3RzLmRlbGV0ZSh1dWlkKTtcbiAgICB9O1xuICAgIHRoaXMuZGVjcnlwdERhdGFSZXF1ZXN0cy5zZXQodXVpZCwgZnV0dXJlKTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgIHJldHVybiBmdXR1cmUucHJvbWlzZTtcbiAgfVxuICBwb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHJhdGNoZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBraW5kOiAncmF0Y2hldFJlcXVlc3QnLFxuICAgICAgZGF0YToge1xuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBrZXlJbmRleFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBwb3N0S2V5KF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3Qgc2V0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldEtleScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGlzUHVibGlzaGVyOiBwYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSksXG4gICAgICAgIGtleSxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBjb25zdCBlbmFibGVNc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmFibGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShlbmFibGVNc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ZhaWxlZCB0byBlbmFibGUgZTJlZSwgd29ya2VyIGlzIG5vdCByZWFkeScpO1xuICAgIH1cbiAgfVxuICBwb3N0UlRQTWFwKG1hcCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIGxvY2FsIHBhcnRpY2lwYW50IGlkZW50aXR5IGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFJUUE1hcCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcCxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdFNpZlRyYWlsZXIodHJhaWxlcikge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgcG9zdCBTSUYgdHJhaWxlciwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFNpZlRyYWlsZXInLFxuICAgICAgZGF0YToge1xuICAgICAgICB0cmFpbGVyXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCByZW1vdGVJZCwgdHJhY2tJbmZvKSB7XG4gICAgaWYgKCF0cmFjay5yZWNlaXZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0cmFja0luZm8gPT09IG51bGwgfHwgdHJhY2tJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0luZm8ubWltZVR5cGUpIHx8IHRyYWNrSW5mby5taW1lVHlwZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pbWVUeXBlIG1pc3NpbmcgZnJvbSB0cmFja0luZm8sIGNhbm5vdCBzZXQgdXAgRTJFRSBjcnlwdG9yJyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlUmVjZWl2ZXIodHJhY2sucmVjZWl2ZXIsIHRyYWNrLm1lZGlhU3RyZWFtSUQsIHJlbW90ZUlkLCB0cmFjay5raW5kID09PSAndmlkZW8nID8gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodHJhY2tJbmZvLm1pbWVUeXBlKSA6IHVuZGVmaW5lZCk7XG4gIH1cbiAgc2V0dXBFMkVFU2VuZGVyKHRyYWNrLCBzZW5kZXIpIHtcbiAgICBpZiAoIWlzTG9jYWxUcmFjayh0cmFjaykgfHwgIXNlbmRlcikge1xuICAgICAgaWYgKCFzZW5kZXIpIGxpdmVraXRMb2dnZXIud2FybignZWFybHkgcmV0dXJuIGJlY2F1c2Ugc2VuZGVyIGlzIG5vdCByZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVNlbmRlcihzZW5kZXIsIHRyYWNrLm1lZGlhU3RyZWFtSUQsIHVuZGVmaW5lZCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBSZWNlaXZlcn0gYnkgY3JlYXRpbmcgYSB7QGNvZGUgVHJhbnNmb3JtU3RyZWFtfSB3aGljaCB3aWxsIGluamVjdFxuICAgKiBhIGZyYW1lIGRlY29kZXIuXG4gICAqXG4gICAqL1xuICBoYW5kbGVSZWNlaXZlcihyZWNlaXZlciwgdHJhY2tJZCwgcGFydGljaXBhbnRJZGVudGl0eSwgY29kZWMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSAmJlxuICAgICAgLy8gQ2hyb21lIG9jY2FzaW9uYWxseSB0aHJvd3MgYW4gYEludmFsaWRTdGF0ZWAgZXJyb3Igd2hlbiB1c2luZyBzY3JpcHQgdHJhbnNmb3JtcyBkaXJlY3RseSBhZnRlciBpbnRyb2R1Y2luZyB0aGlzIEFQSSBpbiAxNDEuXG4gICAgICAvLyBEaXNhYmxpbmcgaXQgZm9yIENocm9tZSBiYXNlZCBicm93c2VycyB1bnRpbCB0aGUgQVBJIGhhcyBzdGFiaWxpemVkXG4gICAgICAhaXNDaHJvbWl1bUJhc2VkKCkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgY29kZWNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZWNlaXZlci50cmFuc2Zvcm0gPSBuZXcgUlRDUnRwU2NyaXB0VHJhbnNmb3JtKHRoaXMud29ya2VyLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChFMkVFX0ZMQUcgaW4gcmVjZWl2ZXIgJiYgY29kZWMpIHtcbiAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSBjb2RlY1xuICAgICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICd1cGRhdGVDb2RlYycsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCB3cml0YWJsZSA9IHJlY2VpdmVyLndyaXRhYmxlU3RyZWFtO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCByZWFkYWJsZSA9IHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoIXdyaXRhYmxlIHx8ICFyZWFkYWJsZSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdCByZWNlaXZlclN0cmVhbXMgPSByZWNlaXZlci5jcmVhdGVFbmNvZGVkU3RyZWFtcygpO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByZWNlaXZlci53cml0YWJsZVN0cmVhbSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcbiAgICAgICAgICB3cml0YWJsZSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmVjZWl2ZXIucmVhZGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XG4gICAgICAgICAgcmVhZGFibGUgPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgIGtpbmQ6ICdkZWNvZGUnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiByZWFkYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlU3RyZWFtOiB3cml0YWJsZSxcbiAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWQsXG4gICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgICAgICBpc1JldXNlOiBFMkVFX0ZMQUcgaW4gcmVjZWl2ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3JlYWRhYmxlLCB3cml0YWJsZV0pO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVjZWl2ZXJbRTJFRV9GTEFHXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBTZW5kZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBlbmNvZGVyLlxuICAgKlxuICAgKi9cbiAgaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2tJZCwgY29kZWMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKEUyRUVfRkxBRyBpbiBzZW5kZXIgfHwgIXRoaXMud29ya2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHx8IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSAnJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdsb2NhbCBpZGVudGl0eSBuZWVkcyB0byBiZSBrbm93biBpbiBvcmRlciB0byBzZXQgdXAgZW5jcnlwdGVkIHNlbmRlcicpO1xuICAgIH1cbiAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSAmJlxuICAgIC8vIENocm9tZSBvY2Nhc2lvbmFsbHkgdGhyb3dzIGFuIGBJbnZhbGlkU3RhdGVgIGVycm9yIHdoZW4gdXNpbmcgc2NyaXB0IHRyYW5zZm9ybXMgZGlyZWN0bHkgYWZ0ZXIgaW50cm9kdWNpbmcgdGhpcyBBUEkgaW4gMTQxLlxuICAgIC8vIERpc2FibGluZyBpdCBmb3IgQ2hyb21lIGJhc2VkIGJyb3dzZXJzIHVudGlsIHRoZSBBUEkgaGFzIHN0YWJpbGl6ZWRcbiAgICAhaXNDaHJvbWl1bUJhc2VkKCkpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuaW5mbygnaW5pdGlhbGl6ZSBzY3JpcHQgdHJhbnNmb3JtJyk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBraW5kOiAnZW5jb2RlJyxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgIHRyYWNrSWQsXG4gICAgICAgIGNvZGVjXG4gICAgICB9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2VuZGVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ2luaXRpYWxpemUgZW5jb2RlZCBzdHJlYW1zJyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBzZW5kZXJTdHJlYW1zID0gc2VuZGVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVhZGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMucmVhZGFibGUsXG4gICAgICAgICAgd3JpdGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMud3JpdGFibGUsXG4gICAgICAgICAgY29kZWMsXG4gICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgICBpc1JldXNlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCBbc2VuZGVyU3RyZWFtcy5yZWFkYWJsZSwgc2VuZGVyU3RyZWFtcy53cml0YWJsZV0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2VuZGVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICB9XG59XG5cbmNvbnN0IENPTk5FQ1RJT05fQkFDS09GRl9NSU5fTVMgPSA1MDA7XG5jb25zdCBDT05ORUNUSU9OX0JBQ0tPRkZfTUFYX01TID0gMTUwMDA7XG4vKipcbiAqIEJhY2tPZmZTdHJhdGVneSBpbXBsZW1lbnRzIGV4cG9uZW50aWFsIGJhY2tvZmYgZm9yIGNvbm5lY3Rpb24gZmFpbHVyZXMuXG4gKlxuICogV2hlbiBzZXZlcmUgY29ubmVjdGlvbiBmYWlsdXJlcyBvY2N1ciAoZS5nLiwgbmV0d29yayBpc3N1ZXMsIHNlcnZlciB1bmF2YWlsYWJpbGl0eSksXG4gKiB0aGlzIHN0cmF0ZWd5IGludHJvZHVjZXMgaW5jcmVhc2luZyBkZWxheXMgYmV0d2VlbiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gYXZvaWRcbiAqIG92ZXJ3aGVsbWluZyB0aGUgc2VydmVyIGFuZCB0byBnaXZlIHRyYW5zaWVudCBpc3N1ZXMgdGltZSB0byByZXNvbHZlLlxuICpcbiAqIFRoaXMgc3RyYXRlZ3kgaXMgb25seSBhcHBsaWVkIHRvIExpdmVLaXQgQ2xvdWQgcHJvamVjdHMuIEl0IGlkZW50aWZpZXNcbiAqIHByb2plY3RzIGJ5IGV4dHJhY3RpbmcgdGhlIHByb2plY3QgbmFtZSBmcm9tIHRoZSBjb25uZWN0aW9uIFVSTCBhbmQgdHJhY2tzIGZhaWx1cmVzXG4gKiBwZXIgcHJvamVjdC4gU2VsZi1ob3N0ZWQgZGVwbG95bWVudHMgKFVSTHMgd2l0aG91dCBhIHByb2plY3QgaWRlbnRpZmllcikgYXJlIG5vdFxuICogc3ViamVjdCB0byBiYWNrb2ZmIGRlbGF5cy5cbiAqXG4gKiBUaGUgY2xhc3MgaXMgaW1wbGVtZW50ZWQgYXMgYSBzaW5nbGV0b24gdG8gbWFpbnRhaW4gY29uc2lzdGVudCBiYWNrb2ZmIHN0YXRlIGFjcm9zc1xuICogdGhlIGVudGlyZSBhcHBsaWNhdGlvbiBsaWZlY3ljbGUgaW5zdGVhZCBvZiByb29tIGluc3RhbmNlIGxpZmVjeWNsZS5cbiAqL1xuY2xhc3MgQmFja09mZlN0cmF0ZWd5IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZhaWxlZENvbm5lY3Rpb25BdHRlbXB0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJhY2tPZmZQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgQmFja09mZlN0cmF0ZWd5KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfVxuICBhZGRGYWlsZWRDb25uZWN0aW9uQXR0ZW1wdCh1cmxTdHJpbmcpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gZXh0cmFjdFByb2plY3RGcm9tVXJsKHVybCk7XG4gICAgaWYgKCFwcm9qZWN0TmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmFpbHVyZUNvdW50ID0gKF9hID0gdGhpcy5mYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHMuZ2V0KHByb2plY3ROYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICB0aGlzLmZhaWxlZENvbm5lY3Rpb25BdHRlbXB0cy5zZXQocHJvamVjdE5hbWUsIGZhaWx1cmVDb3VudCArIDEpO1xuICAgIHRoaXMuYmFja09mZlByb21pc2VzLnNldChwcm9qZWN0TmFtZSwgc2xlZXAoTWF0aC5taW4oQ09OTkVDVElPTl9CQUNLT0ZGX01JTl9NUyAqIE1hdGgucG93KDIsIGZhaWx1cmVDb3VudCksIENPTk5FQ1RJT05fQkFDS09GRl9NQVhfTVMpKSk7XG4gIH1cbiAgZ2V0QmFja09mZlByb21pc2UodXJsU3RyaW5nKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gdXJsICYmIGV4dHJhY3RQcm9qZWN0RnJvbVVybCh1cmwpO1xuICAgIGNvbnN0IGJhY2tvZmZQcm9taXNlID0gcHJvamVjdE5hbWUgJiYgdGhpcy5iYWNrT2ZmUHJvbWlzZXMuZ2V0KHByb2plY3ROYW1lKTtcbiAgICByZXR1cm4gYmFja29mZlByb21pc2UgfHwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVzZXRGYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHModXJsU3RyaW5nKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gdXJsICYmIGV4dHJhY3RQcm9qZWN0RnJvbVVybCh1cmwpO1xuICAgIGlmIChwcm9qZWN0TmFtZSkge1xuICAgICAgdGhpcy5mYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHMuc2V0KHByb2plY3ROYW1lLCAwKTtcbiAgICAgIHRoaXMuYmFja09mZlByb21pc2VzLnNldChwcm9qZWN0TmFtZSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgIH1cbiAgfVxuICByZXNldEFsbCgpIHtcbiAgICB0aGlzLmJhY2tPZmZQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmFpbGVkQ29ubmVjdGlvbkF0dGVtcHRzLmNsZWFyKCk7XG4gIH1cbn1cbkJhY2tPZmZTdHJhdGVneS5faW5zdGFuY2UgPSBudWxsO1xuXG5jb25zdCBkZWZhdWx0SWQgPSAnZGVmYXVsdCc7XG5jbGFzcyBEZXZpY2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcHJldmlvdXNEZXZpY2VzID0gW107XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGV2aWNlTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuICBnZXQgcHJldmlvdXNEZXZpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0RldmljZXM7XG4gIH1cbiAgZ2V0RGV2aWNlcyhraW5kXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCByZXF1ZXN0UGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpID4gMCkge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2F3YWl0aW5nIGdldFVzZXJNZWRpYSBwcm9taXNlJyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChraW5kKSB7XG4gICAgICAgICAgICAgIHlpZWxkIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5nZXQoa2luZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAudmFsdWVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpdmVraXRMb2dnZXIud2FybignZXJyb3Igd2FpdGluZyBmb3IgbWVkaWEgcGVybWlzc29ucycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGV2aWNlcyA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICBpZiAocmVxdWVzdFBlcm1pc3Npb25zICYmXG4gICAgICAgIC8vIGZvciBzYWZhcmkgd2UgbmVlZCB0byBza2lwIHRoaXMgY2hlY2ssIGFzIG90aGVyd2lzZSBpdCB3aWxsIHJlLWFjcXVpcmUgdXNlciBtZWRpYSBhbmQgZmFpbCBvbiBpT1MgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICAgICAgICAhKGlzU2FmYXJpKCkgJiYgX3RoaXMuaGFzRGV2aWNlSW5Vc2Uoa2luZCkpKSB7XG4gICAgICAgICAgY29uc3QgaXNEdW1teURldmljZU9yRW1wdHkgPSBkZXZpY2VzLmZpbHRlcihkID0+IGQua2luZCA9PT0ga2luZCkubGVuZ3RoID09PSAwIHx8IGRldmljZXMuc29tZShkZXZpY2UgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9MYWJlbCA9IGRldmljZS5sYWJlbCA9PT0gJyc7XG4gICAgICAgICAgICBjb25zdCBpc1JlbGV2YW50ID0ga2luZCA/IGRldmljZS5raW5kID09PSBraW5kIDogdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBub0xhYmVsICYmIGlzUmVsZXZhbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzRHVtbXlEZXZpY2VPckVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uc1RvQWNxdWlyZSA9IHtcbiAgICAgICAgICAgICAgdmlkZW86IGtpbmQgIT09ICdhdWRpb2lucHV0JyAmJiBraW5kICE9PSAnYXVkaW9vdXRwdXQnLFxuICAgICAgICAgICAgICBhdWRpbzoga2luZCAhPT0gJ3ZpZGVvaW5wdXQnICYmIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgICAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHBlcm1pc3Npb25zVG9BY3F1aXJlKTtcbiAgICAgICAgICAgIGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9wcmV2aW91c0RldmljZXMgPSBkZXZpY2VzO1xuICAgICAgICBpZiAoa2luZCkge1xuICAgICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkZXZpY2UgPT4gZGV2aWNlLmtpbmQgPT09IGtpbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIG5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChkZXZpY2VJZCAhPT0gZGVmYXVsdElkKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VJZDtcbiAgICAgIH1cbiAgICAgIC8vIHJlc29sdmUgYWN0dWFsIGRldmljZSBpZCBpZiBpdCdzICdkZWZhdWx0JzogQ2hyb21lIHJldHVybnMgaXQgd2hlbiBub1xuICAgICAgLy8gZGV2aWNlIGhhcyBiZWVuIGNob3NlblxuICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMuZ2V0RGV2aWNlcyhraW5kKTtcbiAgICAgIGNvbnN0IGRlZmF1bHREZXZpY2UgPSBkZXZpY2VzLmZpbmQoZCA9PiBkLmRldmljZUlkID09PSBkZWZhdWx0SWQpO1xuICAgICAgaWYgKCFkZWZhdWx0RGV2aWNlKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignY291bGQgbm90IHJlbGlhYmx5IGRldGVybWluZSBkZWZhdWx0IGRldmljZScpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKGQgPT4gZC5kZXZpY2VJZCAhPT0gZGVmYXVsdElkICYmIGQuZ3JvdXBJZCA9PT0gKGdyb3VwSWQgIT09IG51bGwgJiYgZ3JvdXBJZCAhPT0gdm9pZCAwID8gZ3JvdXBJZCA6IGRlZmF1bHREZXZpY2UuZ3JvdXBJZCkpO1xuICAgICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdjb3VsZCBub3QgcmVsaWFibHkgZGV0ZXJtaW5lIGRlZmF1bHQgZGV2aWNlJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlID09PSBudWxsIHx8IGRldmljZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2aWNlLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIGhhc0RldmljZUluVXNlKGtpbmQpIHtcbiAgICByZXR1cm4ga2luZCA/IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5oYXMoa2luZCkgOiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2l6ZSA+IDA7XG4gIH1cbn1cbkRldmljZU1hbmFnZXIubWVkaWFEZXZpY2VLaW5kcyA9IFsnYXVkaW9pbnB1dCcsICdhdWRpb291dHB1dCcsICd2aWRlb2lucHV0J107XG5EZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBRdWV1ZVRhc2tTdGF0dXM7XG4oZnVuY3Rpb24gKFF1ZXVlVGFza1N0YXR1cykge1xuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiV0FJVElOR1wiXSA9IDBdID0gXCJXQUlUSU5HXCI7XG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJSVU5OSU5HXCJdID0gMV0gPSBcIlJVTk5JTkdcIjtcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIkNPTVBMRVRFRFwiXSA9IDJdID0gXCJDT01QTEVURURcIjtcbn0pKFF1ZXVlVGFza1N0YXR1cyB8fCAoUXVldWVUYXNrU3RhdHVzID0ge30pKTtcbmNsYXNzIEFzeW5jUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBlbmRpbmdUYXNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRhc2tNdXRleCA9IG5ldyBfKCk7XG4gICAgdGhpcy5uZXh0VGFza0luZGV4ID0gMDtcbiAgfVxuICBydW4odGFzaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0YXNrSW5mbyA9IHtcbiAgICAgICAgaWQ6IHRoaXMubmV4dFRhc2tJbmRleCsrLFxuICAgICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cy5XQUlUSU5HXG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJbmZvLmlkLCB0YXNrSW5mbyk7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnRhc2tNdXRleC5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0YXNrSW5mby5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLlJVTk5JTkc7XG4gICAgICAgIHJldHVybiB5aWVsZCB0YXNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0luZm8uaWQpO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVuKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHt9KSk7XG4gICAgfSk7XG4gIH1cbiAgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpO1xuICB9XG59XG5cbi8qKlxuICogW1dlYlNvY2tldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldCkgd2l0aCBbU3RyZWFtcyBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSSlcbiAqXG4gKiBAc2VlIGh0dHBzOi8vd2ViLmRldi93ZWJzb2NrZXRzdHJlYW0vXG4gKi9cbmNsYXNzIFdlYlNvY2tldFN0cmVhbSB7XG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLndzLnJlYWR5U3RhdGU7XG4gIH1cbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKChfYSA9IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xuICAgIH1cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsLCAoX2IgPSBvcHRpb25zLnByb3RvY29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pO1xuICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHRoaXMud3MgPSB3cztcbiAgICBjb25zdCBjbG9zZVdpdGhJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IHtcbiAgICAgICAgY2xvc2VDb2RlOiBjb2RlLFxuICAgICAgICByZWFzb25cbiAgICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgcmV0dXJuIHdzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgfTtcbiAgICB0aGlzLm9wZW5lZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgcmVhZGFibGU6IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHdzLm9ubWVzc2FnZSA9IF9yZWYgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgd3Mub25lcnJvciA9IGUgPT4gY29udHJvbGxlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWw6IGNsb3NlV2l0aEluZm9cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB3cml0YWJsZTogbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIHdzLnNlbmQoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZVdpdGhJbmZvXG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJvdG9jb2w6IHdzLnByb3RvY29sLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHdzLmV4dGVuc2lvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH07XG4gICAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZWplY3RIYW5kbGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47ZWxzZSB7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGNsb3NlRXYgPT4ge1xuICAgICAgICAgICAgICByZXMoY2xvc2VFdik7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IHlpZWxkIFByb21pc2UucmFjZShbc2xlZXAoMjUwKSwgY2xvc2VQcm9taXNlXSk7XG4gICAgICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRW5jb3VudGVyZWQgdW5zcGVjaWZpZWQgd2Vic29ja2V0IGVycm9yIHdpdGhvdXQgYSB0aW1lbHkgY2xvc2UgZXZlbnQnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuIGluZmVyIHRoZSBjbG9zZSByZWFzb24gZnJvbSB0aGUgY2xvc2UgZXZlbnQgdGhlbiByZXNvbHZlIHRoZSBwcm9taXNlLCB3ZSBkb24ndCBuZWVkIHRvIHRocm93XG4gICAgICAgICAgcmVzb2x2ZShyZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdzLm9uY2xvc2UgPSBfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICByZWFzb25cbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBjbG9zZUNvZGU6IGNvZGUsXG4gICAgICAgICAgcmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdEhhbmRsZXIpO1xuICAgICAgfTtcbiAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0SGFuZGxlcik7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICBvcHRpb25zLnNpZ25hbC5vbmFib3J0ID0gKCkgPT4gd3MuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5jbG9zZSA9IGNsb3NlV2l0aEluZm87XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUnRjVXJsKHVybCwgc2VhcmNoUGFyYW1zKSB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9XZWJzb2NrZXRVcmwodXJsKSk7XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgdXJsT2JqLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gYXBwZW5kVXJsUGF0aCh1cmxPYmosICdydGMnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRlVXJsKHJ0Y1dzVXJsKSB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9IdHRwVXJsKHJ0Y1dzVXJsKSk7XG4gIHJldHVybiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgJ3ZhbGlkYXRlJyk7XG59XG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSA/IHBhdGggOiBcIlwiLmNvbmNhdChwYXRoLCBcIi9cIik7XG59XG5mdW5jdGlvbiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgcGF0aCkge1xuICB1cmxPYmoucGF0aG5hbWUgPSBcIlwiLmNvbmNhdChlbnN1cmVUcmFpbGluZ1NsYXNoKHVybE9iai5wYXRobmFtZSkpLmNvbmNhdChwYXRoKTtcbiAgcmV0dXJuIHVybE9iai50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gcGFyc2VTaWduYWxSZXNwb25zZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBTaWduYWxSZXNwb25zZS5mcm9tSnNvbihKU09OLnBhcnNlKHZhbHVlKSwge1xuICAgICAgaWdub3JlVW5rbm93bkZpZWxkczogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gU2lnbmFsUmVzcG9uc2UuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBkZWNvZGUgd2Vic29ja2V0IG1lc3NhZ2U6IFwiLmNvbmNhdCh0eXBlb2YgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldEFib3J0UmVhc29uQXNTdHJpbmcoc2lnbmFsKSB7XG4gIGxldCBkZWZhdWx0TWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ1Vua25vd24gcmVhc29uJztcbiAgaWYgKCEoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNZXNzYWdlO1xuICB9XG4gIGNvbnN0IHJlYXNvbiA9IHNpZ25hbC5yZWFzb247XG4gIHN3aXRjaCAodHlwZW9mIHJlYXNvbikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gcmVhc29uO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24ubWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ3RvU3RyaW5nJyBpbiByZWFzb24gPyByZWFzb24udG9TdHJpbmcoKSA6IGRlZmF1bHRNZXNzYWdlO1xuICB9XG59XG5cbmNvbnN0IHBhc3NUaHJvdWdoUXVldWVTaWduYWxzID0gWydzeW5jU3RhdGUnLCAndHJpY2tsZScsICdvZmZlcicsICdhbnN3ZXInLCAnc2ltdWxhdGUnLCAnbGVhdmUnXTtcbmZ1bmN0aW9uIGNhblBhc3NUaHJvdWdoUXVldWUocmVxKSB7XG4gIGNvbnN0IGNhblBhc3MgPSBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscy5pbmRleE9mKHJlcS5jYXNlKSA+PSAwO1xuICBsaXZla2l0TG9nZ2VyLnRyYWNlKCdyZXF1ZXN0IGFsbG93ZWQgdG8gYnlwYXNzIHF1ZXVlOicsIHtcbiAgICBjYW5QYXNzLFxuICAgIHJlcVxuICB9KTtcbiAgcmV0dXJuIGNhblBhc3M7XG59XG52YXIgU2lnbmFsQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChTaWduYWxDb25uZWN0aW9uU3RhdGUpIHtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiQ09OTkVDVEVEXCJdID0gMV0gPSBcIkNPTk5FQ1RFRFwiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiUkVDT05ORUNUSU5HXCJdID0gMl0gPSBcIlJFQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVElOR1wiXSA9IDNdID0gXCJESVNDT05ORUNUSU5HXCI7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJESVNDT05ORUNURURcIl0gPSA0XSA9IFwiRElTQ09OTkVDVEVEXCI7XG59KShTaWduYWxDb25uZWN0aW9uU3RhdGUgfHwgKFNpZ25hbENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG4vKiogc3BlY2lmaWVzIGhvdyBtdWNoIHRpbWUgKGluIG1zKSB3ZSBhbGxvdyBmb3IgdGhlIHdzIHRvIGNsb3NlIGl0cyBjb25uZWN0aW9uIGdyYWNlZnVsbHkgYmVmb3JlIGNvbnRpbnVpbmcgKi9cbmNvbnN0IE1BWF9XU19DTE9TRV9USU1FID0gMjUwO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2lnbmFsQ2xpZW50IHtcbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuICBnZXQgaXNEaXNjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HIHx8IHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gIH1cbiAgZ2V0IGlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgfVxuICBnZXROZXh0UmVxdWVzdElkKCkge1xuICAgIHRoaXMuX3JlcXVlc3RJZCArPSAxO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0SWQ7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHVzZUpTT04gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX2E7XG4gICAgLyoqIHNpZ25hbCBydHQgaW4gbWlsbGlzZWNvbmRzICovXG4gICAgdGhpcy5ydHQgPSAwO1xuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLnJlc2V0Q2FsbGJhY2tzID0gKCkgPT4ge1xuICAgICAgdGhpcy5vbkFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25MZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25OZWdvdGlhdGVSZXF1ZXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uT2ZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblRyaWNrbGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uQ2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTWVkaWFTZWN0aW9uc1JlcXVpcmVtZW50ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5TaWduYWwpO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy51c2VKU09OID0gdXNlSlNPTjtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IG5ldyBBc3luY1F1ZXVlKCk7XG4gICAgdGhpcy5xdWV1ZWRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuY2xvc2luZ0xvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gIH1cbiAgam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBkdXJpbmcgYSBmdWxsIHJlY29ubmVjdCwgd2UnZCB3YW50IHRvIHN0YXJ0IHRoZSBzZXF1ZW5jZSBldmVuIGlmIGN1cnJlbnRseVxuICAgICAgLy8gY29ubmVjdGVkXG4gICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbiAgcmVjb25uZWN0KHVybCwgdG9rZW4sIHNpZCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2F0dGVtcHRlZCB0byByZWNvbm5lY3Qgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBiZWluZyBzZXQsIGlnbm9yaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gICAgICAvLyBjbGVhciBwaW5nIGludGVydmFsIGFuZCByZXN0YXJ0IGl0IG9uY2UgcmVjb25uZWN0ZWRcbiAgICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHtcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICBzaWQsXG4gICAgICAgIHJlY29ubmVjdFJlYXNvbjogcmVhc29uXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3QodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0cztcbiAgICAgIGNvbnN0IGNsaWVudEluZm8gPSBnZXRDbGllbnRJbmZvKCk7XG4gICAgICBjb25zdCBwYXJhbXMgPSBvcHRzLnNpbmdsZVBlZXJDb25uZWN0aW9uID8gY3JlYXRlSm9pblJlcXVlc3RDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBjbGllbnRJbmZvLCBvcHRzKSA6IGNyZWF0ZUNvbm5lY3Rpb25QYXJhbXModG9rZW4sIGNsaWVudEluZm8sIG9wdHMpO1xuICAgICAgY29uc3QgcnRjVXJsID0gY3JlYXRlUnRjVXJsKHVybCwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlVXJsID0gY3JlYXRlVmFsaWRhdGVVcmwocnRjVXJsKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGFscmVhZHlBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gZXZlbnRPckVycm9yID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhbHJlYWR5QWJvcnRlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5QWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudE9yRXJyb3IgaW5zdGFuY2VvZiBFdmVudCA/IGV2ZW50T3JFcnJvci5jdXJyZW50VGFyZ2V0IDogZXZlbnRPckVycm9yO1xuICAgICAgICAgICAgY29uc3QgcmVhc29uID0gZ2V0QWJvcnRSZWFzb25Bc1N0cmluZyh0YXJnZXQsICdBYm9ydCBoYW5kbGVyIGNhbGxlZCcpO1xuICAgICAgICAgICAgLy8gc2VuZCBsZWF2ZSBpZiB3ZSBoYXZlIGFuIGFjdGl2ZSBzdHJlYW0gd3JpdGVyIChjb25uZWN0aW9uIGlzIG9wZW4pXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW1Xcml0ZXIgJiYgIXRoaXMuaXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZW5kTGVhdmUoKS50aGVuKCgpID0+IHRoaXMuY2xvc2UocmVhc29uKSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBBYm9ydEhhbmRsZXJzKCk7XG4gICAgICAgICAgICByZWplY3QodGFyZ2V0IGluc3RhbmNlb2YgQWJvcnRTaWduYWwgPyB0YXJnZXQucmVhc29uIDogdGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIGNvbnN0IGNsZWFudXBBYm9ydEhhbmRsZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgd3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydEhhbmRsZXIobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyB0aW1lZCBvdXQgKHNpZ25hbCknLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpKTtcbiAgICAgICAgICB9LCBvcHRzLndlYnNvY2tldFRpbWVvdXQpO1xuICAgICAgICAgIGNvbnN0IGhhbmRsZVNpZ25hbENvbm5lY3RlZCA9IChjb25uZWN0aW9uLCBmaXJzdE1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2lnbmFsQ29ubmVjdGVkKGNvbm5lY3Rpb24sIHdzVGltZW91dCwgZmlyc3RNZXNzYWdlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHJlZGFjdGVkVXJsID0gbmV3IFVSTChydGNVcmwpO1xuICAgICAgICAgIGlmIChyZWRhY3RlZFVybC5zZWFyY2hQYXJhbXMuaGFzKCdhY2Nlc3NfdG9rZW4nKSkge1xuICAgICAgICAgICAgcmVkYWN0ZWRVcmwuc2VhcmNoUGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgJzxyZWRhY3RlZD4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJjb25uZWN0aW5nIHRvIFwiLmNvbmNhdChyZWRhY3RlZFVybCksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgcmVjb25uZWN0OiBvcHRzLnJlY29ubmVjdCxcbiAgICAgICAgICAgIHJlY29ubmVjdFJlYXNvbjogb3B0cy5yZWNvbm5lY3RSZWFzb25cbiAgICAgICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jbG9zZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0U3RyZWFtKHJ0Y1VybCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2VkLnRoZW4oY2xvc2VJbmZvID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihcIldlYnNvY2tldCBnb3QgY2xvc2VkIGR1cmluZyBhIChyZSljb25uZWN0aW9uIGF0dGVtcHQ6IFwiLmNvbmNhdChjbG9zZUluZm8ucmVhc29uKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2xvc2VJbmZvLmNsb3NlQ29kZSAhPT0gMTAwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJ3ZWJzb2NrZXQgY2xvc2VkXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICAgICAgcmVhc29uOiBjbG9zZUluZm8ucmVhc29uLFxuICAgICAgICAgICAgICAgICAgY29kZTogY2xvc2VJbmZvLmNsb3NlQ29kZSxcbiAgICAgICAgICAgICAgICAgIHdhc0NsZWFuOiBjbG9zZUluZm8uY2xvc2VDb2RlID09PSAxMDAwLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT25DbG9zZSgoX2EgPSBjbG9zZUluZm8ucmVhc29uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnVW5leHBlY3RlZCBXUyBlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihcIldlYnNvY2tldCBlcnJvciBkdXJpbmcgYSAocmUpY29ubmVjdGlvbiBhdHRlbXB0OiBcIi5jb25jYXQocmVhc29uKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy53cy5vcGVuZWQuY2F0Y2gocmVhc29uID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHlpZWxkIHRoaXMuaGFuZGxlQ29ubmVjdGlvbkVycm9yKHJlYXNvbiwgdmFsaWRhdGVVcmwpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG90aGVyIGVycm9ycywgaGFuZGxlXG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlV1NFcnJvcihyZWFzb24pO1xuICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsUmVhZGVyID0gY29ubmVjdGlvbi5yZWFkYWJsZS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtV3JpdGVyID0gY29ubmVjdGlvbi53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TWVzc2FnZSA9IHlpZWxkIHNpZ25hbFJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBzaWduYWxSZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIGlmICghZmlyc3RNZXNzYWdlLnZhbHVlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoJ25vIG1lc3NhZ2UgcmVjZWl2ZWQgYXMgZmlyc3QgbWVzc2FnZScsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2lnbmFsUmVzcG9uc2UgPSBwYXJzZVNpZ25hbFJlc3BvbnNlKGZpcnN0TWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZmlyc3QgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVGaXJzdE1lc3NhZ2UoZmlyc3RTaWduYWxSZXNwb25zZSwgKF9hID0gb3B0cy5yZWNvbm5lY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIHJlamVjdCh2YWxpZGF0aW9uLmVycm9yKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIGpvaW4gcmVzcG9uc2UgLSBzZXQgdXAgcGluZyBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICBpZiAoKChfYiA9IGZpcnN0U2lnbmFsUmVzcG9uc2UubWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhc2UpID09PSAnam9pbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID0gZmlyc3RTaWduYWxSZXNwb25zZS5tZXNzYWdlLnZhbHVlLnBpbmdUaW1lb3V0O1xuICAgICAgICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uID0gZmlyc3RTaWduYWxSZXNwb25zZS5tZXNzYWdlLnZhbHVlLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAmJiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3BpbmcgY29uZmlnJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICBpbnRlcnZhbDogdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvblxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICAgICAgICAgICAgY29uc3QgZmlyc3RNZXNzYWdlVG9Qcm9jZXNzID0gdmFsaWRhdGlvbi5zaG91bGRQcm9jZXNzRmlyc3RNZXNzYWdlID8gZmlyc3RTaWduYWxSZXNwb25zZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGhhbmRsZVNpZ25hbENvbm5lY3RlZChjb25uZWN0aW9uLCBmaXJzdE1lc3NhZ2VUb1Byb2Nlc3MpO1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWxpZGF0aW9uLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFudXBBYm9ydEhhbmRsZXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHVubG9jaygpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhcnRSZWFkaW5nTG9vcChzaWduYWxSZWFkZXIsIGZpcnN0TWVzc2FnZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoZmlyc3RNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVzcG9uc2UoZmlyc3RNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgICB5aWVsZCBzbGVlcCh0aGlzLnNpZ25hbExhdGVuY3kpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkb25lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gPSB5aWVsZCBzaWduYWxSZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AgPSBwYXJzZVNpZ25hbFJlc3BvbnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTaWduYWxSZXNwb25zZShyZXNwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHVwZGF0ZVN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ0Nsb3NlIG1ldGhvZCBjYWxsZWQgb24gc2lnbmFsIGNsaWVudCc7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKFtTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORyB8fCBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEXS5pbmNsdWRlcyhfdGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICBfdGhpcy5sb2cuZGVidWcoXCJpZ25vcmluZyBzaWduYWwgY2xvc2UgYXMgaXQncyBhbHJlYWR5IGluIGRpc2Nvbm5lY3Rpbmcgc3RhdGVcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLndzKSB7XG4gICAgICAgICAgICBfdGhpcy53cy5jbG9zZSh7XG4gICAgICAgICAgICAgIGNsb3NlQ29kZTogMTAwMCxcbiAgICAgICAgICAgICAgcmVhc29uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYHdzLmNsb3NlKClgIG9ubHkgc3RhcnRzIHRoZSBjbG9zaW5nIGhhbmRzaGFrZSAoQ0xPU0lORyBzdGF0ZSksIHByZWZlciB0byB3YWl0IHVudGlsIHN0YXRlIGlzIGFjdHVhbGx5IENMT1NFRFxuICAgICAgICAgICAgY29uc3QgY2xvc2VQcm9taXNlID0gX3RoaXMud3MuY2xvc2VkO1xuICAgICAgICAgICAgX3RoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfdGhpcy5zdHJlYW1Xcml0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2UoW2Nsb3NlUHJvbWlzZSwgc2xlZXAoTUFYX1dTX0NMT1NFX1RJTUUpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX3RoaXMubG9nLmRlYnVnKCd3ZWJzb2NrZXQgZXJyb3Igd2hpbGUgY2xvc2luZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIGluaXRpYWwgb2ZmZXIgYWZ0ZXIgam9pbmluZ1xuICBzZW5kT2ZmZXIob2ZmZXIsIG9mZmVySWQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBvZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgb2ZmZXJTZHA6IG9mZmVyLnNkcFxuICAgIH0pKTtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdvZmZlcicsXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihvZmZlciwgb2ZmZXJJZClcbiAgICB9KTtcbiAgfVxuICAvLyBhbnN3ZXIgYSBzZXJ2ZXItaW5pdGlhdGVkIG9mZmVyXG4gIHNlbmRBbnN3ZXIoYW5zd2VyLCBvZmZlcklkKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgYW5zd2VyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBhbnN3ZXJTZHA6IGFuc3dlci5zZHBcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2Fuc3dlcicsXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihhbnN3ZXIsIG9mZmVySWQpXG4gICAgfSk7XG4gIH1cbiAgc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGljZSBjYW5kaWRhdGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGNhbmRpZGF0ZVxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndHJpY2tsZScsXG4gICAgICB2YWx1ZTogbmV3IFRyaWNrbGVSZXF1ZXN0KHtcbiAgICAgICAgY2FuZGlkYXRlSW5pdDogSlNPTi5zdHJpbmdpZnkoY2FuZGlkYXRlKSxcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRNdXRlVHJhY2sodHJhY2tTaWQsIG11dGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ211dGUnLFxuICAgICAgdmFsdWU6IG5ldyBNdXRlVHJhY2tSZXF1ZXN0KHtcbiAgICAgICAgc2lkOiB0cmFja1NpZCxcbiAgICAgICAgbXV0ZWRcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZEFkZFRyYWNrKHJlcSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdhZGRUcmFjaycsXG4gICAgICB2YWx1ZTogcmVxXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEobWV0YWRhdGFfMSwgbmFtZV8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGxldCBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBfdGhpczIuZ2V0TmV4dFJlcXVlc3RJZCgpO1xuICAgICAgICB5aWVsZCBfdGhpczIuc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgIGNhc2U6ICd1cGRhdGVNZXRhZGF0YScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKHtcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RJZDtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyYWNrU2V0dGluZycsXG4gICAgICB2YWx1ZTogc2V0dGluZ3NcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yikge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb24nLFxuICAgICAgdmFsdWU6IHN1YlxuICAgIH0pO1xuICB9XG4gIHNlbmRTeW5jU3RhdGUoc3luYykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzeW5jU3RhdGUnLFxuICAgICAgdmFsdWU6IHN5bmNcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlVmlkZW9MYXllcnModHJhY2tTaWQsIGxheWVycykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd1cGRhdGVMYXllcnMnLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVWaWRlb0xheWVycyh7XG4gICAgICAgIHRyYWNrU2lkLFxuICAgICAgICBsYXllcnNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50cywgdHJhY2tQZXJtaXNzaW9ucykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uJyxcbiAgICAgIHZhbHVlOiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbih7XG4gICAgICAgIGFsbFBhcnRpY2lwYW50cyxcbiAgICAgICAgdHJhY2tQZXJtaXNzaW9uc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kU2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzaW11bGF0ZScsXG4gICAgICB2YWx1ZTogc2NlbmFyaW9cbiAgICB9KTtcbiAgfVxuICBzZW5kUGluZygpIHtcbiAgICAvKiogc2VuZCBib3RoIG9mIHBpbmcgYW5kIHBpbmdSZXEgZm9yIGNvbXBhdGliaWxpdHkgdG8gb2xkIGFuZCBuZXcgc2VydmVyICovXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdwaW5nJyxcbiAgICAgIHZhbHVlOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpXG4gICAgfSksIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3BpbmdSZXEnLFxuICAgICAgdmFsdWU6IG5ldyBQaW5nKHtcbiAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpLFxuICAgICAgICBydHQ6IHByb3RvSW50NjQucGFyc2UodGhpcy5ydHQpXG4gICAgICB9KVxuICAgIH0pXSk7XG4gIH1cbiAgc2VuZFVwZGF0ZUxvY2FsQXVkaW9UcmFjayh0cmFja1NpZCwgZmVhdHVyZXMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlQXVkaW9UcmFjaycsXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayh7XG4gICAgICAgIHRyYWNrU2lkLFxuICAgICAgICBmZWF0dXJlc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kTGVhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2xlYXZlJyxcbiAgICAgIHZhbHVlOiBuZXcgTGVhdmVSZXF1ZXN0KHtcbiAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXG4gICAgICAgIC8vIHNlcnZlciBkb2Vzbid0IHByb2Nlc3MgdGhpcyBmaWVsZCwga2VlcGluZyBpdCBoZXJlIHRvIGluZGljYXRlIHRoZSBpbnRlbnQgb2YgYSBmdWxsIGRpc2Nvbm5lY3RcbiAgICAgICAgYWN0aW9uOiBMZWF2ZVJlcXVlc3RfQWN0aW9uLkRJU0NPTk5FQ1RcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFJlcXVlc3QobWVzc2FnZV8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgbGV0IGZyb21RdWV1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gY2FwdHVyZSBhbGwgcmVxdWVzdHMgd2hpbGUgcmVjb25uZWN0aW5nIGFuZCBwdXQgdGhlbSBpbiBhIHF1ZXVlXG4gICAgICAgIC8vIHVubGVzcyB0aGUgcmVxdWVzdCBvcmlnaW5hdGVzIGZyb20gdGhlIHF1ZXVlLCB0aGVuIGRvbid0IGVucXVldWUgYWdhaW5cbiAgICAgICAgY29uc3QgY2FuUXVldWUgPSAhZnJvbVF1ZXVlICYmICFjYW5QYXNzVGhyb3VnaFF1ZXVlKG1lc3NhZ2UpO1xuICAgICAgICBpZiAoY2FuUXVldWUgJiYgX3RoaXMzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICAgICAgX3RoaXMzLnF1ZXVlZFJlcXVlc3RzLnB1c2goKCkgPT4gX19hd2FpdGVyKF90aGlzMywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRSZXF1ZXN0KG1lc3NhZ2UsIHRydWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIHByZXZpb3VzbHkgcXVldWVkIHJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGZpcnN0XG4gICAgICAgIGlmICghZnJvbVF1ZXVlKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMzLnJlcXVlc3RRdWV1ZS5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgICAgIHlpZWxkIHNsZWVwKF90aGlzMy5zaWduYWxMYXRlbmN5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgLy8gU2tpcCByZXF1ZXN0cyBpZiB0aGUgc2lnbmFsIGxheWVyIGlzIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBhbiBldmVudCBpcyBzZW50IGluIHRoZSBtaXN0IG9mIHJvb20uY29ubmVjdCgpIGluaXRpYWxpemluZ1xuICAgICAgICAgIF90aGlzMy5sb2cuZGVidWcoXCJza2lwcGluZyBzaWduYWwgcmVxdWVzdCAodHlwZTogXCIuY29uY2F0KG1lc3NhZ2UuY2FzZSwgXCIpIC0gU2lnbmFsQ2xpZW50IGRpc2Nvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXMzLnN0cmVhbVdyaXRlcikge1xuICAgICAgICAgIF90aGlzMy5sb2cuZXJyb3IoXCJjYW5ub3Qgc2VuZCBzaWduYWwgcmVxdWVzdCBiZWZvcmUgY29ubmVjdGVkLCB0eXBlOiBcIi5jb25jYXQobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLmNhc2UpLCBfdGhpczMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBTaWduYWxSZXF1ZXN0KHtcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfdGhpczMudXNlSlNPTikge1xuICAgICAgICAgICAgeWllbGQgX3RoaXMzLnN0cmVhbVdyaXRlci53cml0ZShyZXEudG9Kc29uU3RyaW5nKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpczMuc3RyZWFtV3JpdGVyLndyaXRlKHJlcS50b0JpbmFyeSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfdGhpczMubG9nLmVycm9yKCdlcnJvciBzZW5kaW5nIHNpZ25hbCBtZXNzYWdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2lnbmFsUmVzcG9uc2UocmVzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBtc2cgPSByZXMubWVzc2FnZTtcbiAgICBpZiAobXNnID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVuc3VwcG9ydGVkIG1lc3NhZ2UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGluZ0hhbmRsZWQgPSBmYWxzZTtcbiAgICBpZiAobXNnLmNhc2UgPT09ICdhbnN3ZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25BbnN3ZXIpIHtcbiAgICAgICAgdGhpcy5vbkFuc3dlcihzZCwgbXNnLnZhbHVlLmlkLCBtc2cudmFsdWUubWlkVG9UcmFja0lkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnb2ZmZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25PZmZlcikge1xuICAgICAgICB0aGlzLm9uT2ZmZXIoc2QsIG1zZy52YWx1ZS5pZCwgbXNnLnZhbHVlLm1pZFRvVHJhY2tJZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyaWNrbGUnKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBKU09OLnBhcnNlKG1zZy52YWx1ZS5jYW5kaWRhdGVJbml0KTtcbiAgICAgIGlmICh0aGlzLm9uVHJpY2tsZSkge1xuICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy52YWx1ZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd1cGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSgoX2EgPSBtc2cudmFsdWUucGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrUHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3NwZWFrZXJzQ2hhbmdlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25TcGVha2Vyc0NoYW5nZWQoKF9iID0gbXNnLnZhbHVlLnNwZWFrZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgaWYgKHRoaXMub25MZWF2ZSkge1xuICAgICAgICB0aGlzLm9uTGVhdmUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbXV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKG1zZy52YWx1ZS5zaWQsIG1zZy52YWx1ZS5tdXRlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJvb21VcGRhdGUgJiYgbXNnLnZhbHVlLnJvb20pIHtcbiAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnZhbHVlLnJvb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdjb25uZWN0aW9uUXVhbGl0eScpIHtcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N0cmVhbVN0YXRlVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlZnJlc2hUb2tlbicpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25FcnJvcihtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nJykgOyBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmdSZXNwJykge1xuICAgICAgdGhpcy5ydHQgPSBEYXRlLm5vdygpIC0gTnVtYmVyLnBhcnNlSW50KG1zZy52YWx1ZS5sYXN0UGluZ1RpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgcGluZ0hhbmRsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyZXF1ZXN0UmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblJlcXVlc3RSZXNwb25zZSkge1xuICAgICAgICB0aGlzLm9uUmVxdWVzdFJlc3BvbnNlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrU3Vic2NyaWJlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1N1YnNjcmliZWQpIHtcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkKG1zZy52YWx1ZS50cmFja1NpZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21Nb3ZlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlLnRva2VuKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9uUm9vbU1vdmVkKSB7XG4gICAgICAgIHRoaXMub25Sb29tTW92ZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbWVkaWFTZWN0aW9uc1JlcXVpcmVtZW50Jykge1xuICAgICAgaWYgKHRoaXMub25NZWRpYVNlY3Rpb25zUmVxdWlyZW1lbnQpIHtcbiAgICAgICAgdGhpcy5vbk1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5zdXBwb3J0ZWQgbWVzc2FnZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBtc2dDYXNlOiBtc2cuY2FzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXBpbmdIYW5kbGVkKSB7XG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gIH1cbiAgc2V0UmVjb25uZWN0ZWQoKSB7XG4gICAgd2hpbGUgKHRoaXMucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxID0gdGhpcy5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5ydW4ocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlT25DbG9zZShyZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQpIHJldHVybjtcbiAgICAgIGNvbnN0IG9uQ2xvc2VDYWxsYmFjayA9IHRoaXMub25DbG9zZTtcbiAgICAgIHlpZWxkIHRoaXMuY2xvc2UodW5kZWZpbmVkLCByZWFzb24pO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQ6IFwiLmNvbmNhdChyZWFzb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9KSk7XG4gICAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XG4gICAgICAgIG9uQ2xvc2VDYWxsYmFjayhyZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVdTRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmxvZy5lcnJvcignd2Vic29ja2V0IGVycm9yJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBlcnJvclxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBwaW5nIHRpbWVvdXQgYW5kIHN0YXJ0cyBhIG5ldyB0aW1lb3V0LlxuICAgKiBDYWxsIHRoaXMgYWZ0ZXIgcmVjZWl2aW5nIGEgcG9uZyBtZXNzYWdlXG4gICAqL1xuICByZXNldFBpbmdUaW1lb3V0KCkge1xuICAgIHRoaXMuY2xlYXJQaW5nVGltZW91dCgpO1xuICAgIGlmICghdGhpcy5waW5nVGltZW91dER1cmF0aW9uKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIHRpbWVvdXQgZHVyYXRpb24gbm90IHNldCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGluZ1RpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMubG9nLndhcm4oXCJwaW5nIHRpbWVvdXQgdHJpZ2dlcmVkLiBsYXN0IHBvbmcgcmVjZWl2ZWQgYXQ6IFwiLmNvbmNhdChuZXcgRGF0ZShEYXRlLm5vdygpIC0gdGhpcy5waW5nVGltZW91dER1cmF0aW9uICogMTAwMCkudG9VVENTdHJpbmcoKSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICAgIH0sIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAqIDEwMDApO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgcGluZyB0aW1lb3V0IChkb2VzIG5vdCBzdGFydCBhIG5ldyB0aW1lb3V0KVxuICAgKi9cbiAgY2xlYXJQaW5nVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5waW5nVGltZW91dCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBzdGFydFBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG4gICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIGludGVydmFsIGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnQgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnNlbmRQaW5nKCk7XG4gICAgfSwgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiAqIDEwMDApO1xuICB9XG4gIGNsZWFyUGluZ0ludGVydmFsKCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdjbGVhcmluZyBwaW5nIGludGVydmFsJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcbiAgICBpZiAodGhpcy5waW5nSW50ZXJ2YWwpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5waW5nSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uIHRvIHRoZSBzaWduYWwgc2VydmVyXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gdGltZW91dEhhbmRsZSBUaGUgdGltZW91dCBoYW5kbGUgdG8gY2xlYXJcbiAgICogQHBhcmFtIGZpcnN0TWVzc2FnZSBPcHRpb25hbCBmaXJzdCBtZXNzYWdlIHRvIHByb2Nlc3NcbiAgICogQGludGVybmFsXG4gICAqL1xuICBoYW5kbGVTaWduYWxDb25uZWN0ZWQoY29ubmVjdGlvbiwgdGltZW91dEhhbmRsZSwgZmlyc3RNZXNzYWdlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICB0aGlzLnN0YXJ0UmVhZGluZ0xvb3AoY29ubmVjdGlvbi5yZWFkYWJsZS5nZXRSZWFkZXIoKSwgZmlyc3RNZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBmaXJzdCBtZXNzYWdlIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbCBzZXJ2ZXJcbiAgICogQHBhcmFtIGZpcnN0U2lnbmFsUmVzcG9uc2UgVGhlIGZpcnN0IHNpZ25hbCByZXNwb25zZSByZWNlaXZlZFxuICAgKiBAcGFyYW0gaXNSZWNvbm5lY3QgV2hldGhlciB0aGlzIGlzIGEgcmVjb25uZWN0aW9uIGF0dGVtcHRcbiAgICogQHJldHVybnMgVmFsaWRhdGlvbiByZXN1bHQgd2l0aCByZXNwb25zZSBvciBlcnJvclxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhbGlkYXRlRmlyc3RNZXNzYWdlKGZpcnN0U2lnbmFsUmVzcG9uc2UsIGlzUmVjb25uZWN0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoKChfYSA9IGZpcnN0U2lnbmFsUmVzcG9uc2UubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnam9pbicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgIHJlc3BvbnNlOiBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UudmFsdWVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HICYmICgoX2IgPSBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSAhPT0gJ2xlYXZlJykge1xuICAgICAgaWYgKCgoX2MgPSBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXNlKSA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgIHJlc3BvbnNlOiBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UudmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluIHJlY29ubmVjdGluZywgYW55IG1lc3NhZ2UgcmVjZWl2ZWQgbWVhbnMgc2lnbmFsIHJlY29ubmVjdGVkIGFuZCB3ZSBzdGlsbCBuZWVkIHRvIHByb2Nlc3MgaXRcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlY2xhcmluZyBzaWduYWwgcmVjb25uZWN0ZWQgd2l0aG91dCByZWNvbm5lY3QgcmVzcG9uc2UgcmVjZWl2ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICBzaG91bGRQcm9jZXNzRmlyc3RNZXNzYWdlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbiAmJiAoKF9kID0gZmlyc3RTaWduYWxSZXNwb25zZS5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FzZSkgPT09ICdsZWF2ZScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IENvbm5lY3Rpb25FcnJvcignUmVjZWl2ZWQgbGVhdmUgcmVxdWVzdCB3aGlsZSB0cnlpbmcgdG8gKHJlKWNvbm5lY3QnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0LCB1bmRlZmluZWQsIGZpcnN0U2lnbmFsUmVzcG9uc2UubWVzc2FnZS52YWx1ZS5yZWFzb24pXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWlzUmVjb25uZWN0KSB7XG4gICAgICAvLyBub24tcmVjb25uZWN0IGNhc2UsIHNob3VsZCByZWNlaXZlIGpvaW4gcmVzcG9uc2UgZmlyc3RcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IENvbm5lY3Rpb25FcnJvcihcImRpZCBub3QgcmVjZWl2ZSBqb2luIHJlc3BvbnNlLCBnb3QgXCIuY29uY2F0KChfZSA9IGZpcnN0U2lnbmFsUmVzcG9uc2UubWVzc2FnZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhc2UsIFwiIGluc3RlYWRcIiksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBDb25uZWN0aW9uRXJyb3IoJ1VuZXhwZWN0ZWQgZmlyc3QgbWVzc2FnZScsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZXJyb3JzIGJ5IHZhbGlkYXRpbmcgd2l0aCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSByZWFzb24gVGhlIGVycm9yIHRoYXQgb2NjdXJyZWRcbiAgICogQHBhcmFtIHZhbGlkYXRlVXJsIFRoZSBVUkwgdG8gdmFsaWRhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aFxuICAgKiBAcmV0dXJucyBBIENvbm5lY3Rpb25FcnJvciB3aXRoIGFwcHJvcHJpYXRlIHJlYXNvbiBhbmQgc3RhdHVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaGFuZGxlQ29ubmVjdGlvbkVycm9yKHJlYXNvbiwgdmFsaWRhdGVVcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIGZldGNoKHZhbGlkYXRlVXJsKTtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzLnRvRml4ZWQoMCkuc3RhcnRzV2l0aCgnNCcpKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0geWllbGQgcmVzcC50ZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uRXJyb3IobXNnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCwgcmVzcC5zdGF0dXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWFzb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uRXJyb3IoXCJFbmNvdW50ZXJlZCB1bmtub3duIHdlYnNvY2tldCBlcnJvciBkdXJpbmcgY29ubmVjdGlvbjogXCIuY29uY2F0KHJlYXNvbiksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yLCByZXNwLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgPyBlIDogbmV3IENvbm5lY3Rpb25FcnJvcihlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnc2VydmVyIHdhcyBub3QgcmVhY2hhYmxlJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHNkKSB7XG4gIGNvbnN0IHJzZCA9IHtcbiAgICB0eXBlOiAnb2ZmZXInLFxuICAgIHNkcDogc2Quc2RwXG4gIH07XG4gIHN3aXRjaCAoc2QudHlwZSkge1xuICAgIGNhc2UgJ2Fuc3dlcic6XG4gICAgY2FzZSAnb2ZmZXInOlxuICAgIGNhc2UgJ3ByYW5zd2VyJzpcbiAgICBjYXNlICdyb2xsYmFjayc6XG4gICAgICByc2QudHlwZSA9IHNkLnR5cGU7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcnNkO1xufVxuZnVuY3Rpb24gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihyc2QsIGlkKSB7XG4gIGNvbnN0IHNkID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgc2RwOiByc2Quc2RwLFxuICAgIHR5cGU6IHJzZC50eXBlLFxuICAgIGlkXG4gIH0pO1xuICByZXR1cm4gc2Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBpbmZvLCBvcHRzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBwYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCB0b2tlbik7XG4gIC8vIG9wdHNcbiAgaWYgKG9wdHMucmVjb25uZWN0KSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0JywgJzEnKTtcbiAgICBpZiAob3B0cy5zaWQpIHtcbiAgICAgIHBhcmFtcy5zZXQoJ3NpZCcsIG9wdHMuc2lkKTtcbiAgICB9XG4gIH1cbiAgcGFyYW1zLnNldCgnYXV0b19zdWJzY3JpYmUnLCBvcHRzLmF1dG9TdWJzY3JpYmUgPyAnMScgOiAnMCcpO1xuICAvLyBDbGllbnRJbmZvXG4gIHBhcmFtcy5zZXQoJ3NkaycsIGlzUmVhY3ROYXRpdmUoKSA/ICdyZWFjdG5hdGl2ZScgOiAnanMnKTtcbiAgcGFyYW1zLnNldCgndmVyc2lvbicsIGluZm8udmVyc2lvbik7XG4gIHBhcmFtcy5zZXQoJ3Byb3RvY29sJywgaW5mby5wcm90b2NvbC50b1N0cmluZygpKTtcbiAgaWYgKGluZm8uZGV2aWNlTW9kZWwpIHtcbiAgICBwYXJhbXMuc2V0KCdkZXZpY2VfbW9kZWwnLCBpbmZvLmRldmljZU1vZGVsKTtcbiAgfVxuICBpZiAoaW5mby5vcykge1xuICAgIHBhcmFtcy5zZXQoJ29zJywgaW5mby5vcyk7XG4gIH1cbiAgaWYgKGluZm8ub3NWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnb3NfdmVyc2lvbicsIGluZm8ub3NWZXJzaW9uKTtcbiAgfVxuICBpZiAoaW5mby5icm93c2VyKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3NlcicsIGluZm8uYnJvd3Nlcik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3NlclZlcnNpb24pIHtcbiAgICBwYXJhbXMuc2V0KCdicm93c2VyX3ZlcnNpb24nLCBpbmZvLmJyb3dzZXJWZXJzaW9uKTtcbiAgfVxuICBpZiAob3B0cy5hZGFwdGl2ZVN0cmVhbSkge1xuICAgIHBhcmFtcy5zZXQoJ2FkYXB0aXZlX3N0cmVhbScsICcxJyk7XG4gIH1cbiAgaWYgKG9wdHMucmVjb25uZWN0UmVhc29uKSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0X3JlYXNvbicsIG9wdHMucmVjb25uZWN0UmVhc29uLnRvU3RyaW5nKCkpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKChfYSA9IG5hdmlnYXRvci5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwYXJhbXMuc2V0KCduZXR3b3JrJywgbmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUpvaW5SZXF1ZXN0Q29ubmVjdGlvblBhcmFtcyh0b2tlbiwgaW5mbywgb3B0cykge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHBhcmFtcy5zZXQoJ2FjY2Vzc190b2tlbicsIHRva2VuKTtcbiAgY29uc3Qgam9pblJlcXVlc3QgPSBuZXcgSm9pblJlcXVlc3Qoe1xuICAgIGNsaWVudEluZm86IGluZm8sXG4gICAgY29ubmVjdGlvblNldHRpbmdzOiBuZXcgQ29ubmVjdGlvblNldHRpbmdzKHtcbiAgICAgIGF1dG9TdWJzY3JpYmU6ICEhb3B0cy5hdXRvU3Vic2NyaWJlLFxuICAgICAgYWRhcHRpdmVTdHJlYW06ICEhb3B0cy5hZGFwdGl2ZVN0cmVhbVxuICAgIH0pLFxuICAgIHJlY29ubmVjdDogISFvcHRzLnJlY29ubmVjdCxcbiAgICBwYXJ0aWNpcGFudFNpZDogb3B0cy5zaWQgPyBvcHRzLnNpZCA6IHVuZGVmaW5lZFxuICB9KTtcbiAgaWYgKG9wdHMucmVjb25uZWN0UmVhc29uKSB7XG4gICAgam9pblJlcXVlc3QucmVjb25uZWN0UmVhc29uID0gb3B0cy5yZWNvbm5lY3RSZWFzb247XG4gIH1cbiAgY29uc3Qgd3JhcHBlZEpvaW5SZXF1ZXN0ID0gbmV3IFdyYXBwZWRKb2luUmVxdWVzdCh7XG4gICAgam9pblJlcXVlc3Q6IGpvaW5SZXF1ZXN0LnRvQmluYXJ5KClcbiAgfSk7XG4gIHBhcmFtcy5zZXQoJ2pvaW5fcmVxdWVzdCcsIGJ0b2EobmV3IFRleHREZWNvZGVyKCd1dGYtOCcpLmRlY29kZSh3cmFwcGVkSm9pblJlcXVlc3QudG9CaW5hcnkoKSkpKTtcbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuY2xhc3MgRGF0YVBhY2tldEJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5fdG90YWxTaXplID0gMDtcbiAgfVxuICBwdXNoKGl0ZW0pIHtcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuX3RvdGFsU2l6ZSArPSBpdGVtLmRhdGEuYnl0ZUxlbmd0aDtcbiAgfVxuICBwb3AoKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuYnVmZmVyLnNoaWZ0KCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuX3RvdGFsU2l6ZSAtPSBpdGVtLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHBvcFRvU2VxdWVuY2Uoc2VxdWVuY2UpIHtcbiAgICB3aGlsZSAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLmJ1ZmZlclswXTtcbiAgICAgIGlmIChmaXJzdC5zZXF1ZW5jZSA8PSBzZXF1ZW5jZSkge1xuICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFsaWduQnVmZmVyZWRBbW91bnQoYnVmZmVyZWRBbW91bnQpIHtcbiAgICB3aGlsZSAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLmJ1ZmZlclswXTtcbiAgICAgIGlmICh0aGlzLl90b3RhbFNpemUgLSBmaXJzdC5kYXRhLmJ5dGVMZW5ndGggPD0gYnVmZmVyZWRBbW91bnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH1cbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gIH1cbn1cblxuY2xhc3MgVFRMTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0dGwgdHRsIG9mIHRoZSBrZXkgKG1zKVxuICAgKi9cbiAgY29uc3RydWN0b3IodHRsKSB7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2xhc3RDbGVhbnVwID0gMDtcbiAgICB0aGlzLnR0bCA9IHR0bDtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKG5vdyAtIHRoaXMuX2xhc3RDbGVhbnVwID4gdGhpcy50dGwgLyAyKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9XG4gICAgY29uc3QgZXhwaXJlc0F0ID0gbm93ICsgdGhpcy50dGw7XG4gICAgdGhpcy5fbWFwLnNldChrZXksIHtcbiAgICAgIHZhbHVlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmICghZW50cnkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGVudHJ5LmV4cGlyZXNBdCA8IERhdGUubm93KCkpIHtcbiAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPCBEYXRlLm5vdygpKSB7XG4gICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLl9tYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAoZW50cnkuZXhwaXJlc0F0IDwgbm93KSB7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbGFzdENsZWFudXAgPSBub3c7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICB9XG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLl9tYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAoZW50cnkuZXhwaXJlc0F0ID49IERhdGUubm93KCkpIHtcbiAgICAgICAgY2FsbGJhY2soZW50cnkudmFsdWUsIGtleSwgdGhpcy5hc1ZhbHVlTWFwKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBtYXAoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB2YWx1ZU1hcCA9IHRoaXMuYXNWYWx1ZU1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHZhbHVlTWFwLmVudHJpZXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2sodmFsdWUsIGtleSwgdmFsdWVNYXApKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc1ZhbHVlTWFwKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLl9tYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAoZW50cnkuZXhwaXJlc0F0ID49IERhdGUubm93KCkpIHtcbiAgICAgICAgcmVzdWx0LnNldChrZXksIGVudHJ5LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG52YXIgbGliID0ge307XG5cbnZhciBwYXJzZXIgPSB7fTtcblxudmFyIGdyYW1tYXIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGFzUmVxdWlyZWRHcmFtbWFyO1xuZnVuY3Rpb24gcmVxdWlyZUdyYW1tYXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEdyYW1tYXIpIHJldHVybiBncmFtbWFyLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkR3JhbW1hciA9IDE7XG4gIHZhciBncmFtbWFyJDEgPSBncmFtbWFyLmV4cG9ydHMgPSB7XG4gICAgdjogW3tcbiAgICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICAgIHJlZzogL14oXFxkKikkL1xuICAgIH1dLFxuICAgIG86IFt7XG4gICAgICAvLyBvPS0gMjA1MTggMCBJTiBJUDQgMjAzLjAuMTEzLjFcbiAgICAgIC8vIE5COiBzZXNzaW9uSWQgd2lsbCBiZSBhIFN0cmluZyBpbiBtb3N0IGNhc2VzIGJlY2F1c2UgaXQgaXMgaHVnZVxuICAgICAgbmFtZTogJ29yaWdpbicsXG4gICAgICByZWc6IC9eKFxcUyopIChcXGQqKSAoXFxkKikgKFxcUyopIElQKFxcZCkgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3VzZXJuYW1lJywgJ3Nlc3Npb25JZCcsICdzZXNzaW9uVmVyc2lvbicsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICAgIGZvcm1hdDogJyVzICVzICVkICVzIElQJWQgJXMnXG4gICAgfV0sXG4gICAgLy8gZGVmYXVsdCBwYXJzaW5nIG9mIHRoZXNlIG9ubHkgKHRob3VnaCBzb21lIG9mIHRoZXNlIGZlZWwgb3V0ZGF0ZWQpXG4gICAgczogW3tcbiAgICAgIG5hbWU6ICduYW1lJ1xuICAgIH1dLFxuICAgIGk6IFt7XG4gICAgICBuYW1lOiAnZGVzY3JpcHRpb24nXG4gICAgfV0sXG4gICAgdTogW3tcbiAgICAgIG5hbWU6ICd1cmknXG4gICAgfV0sXG4gICAgZTogW3tcbiAgICAgIG5hbWU6ICdlbWFpbCdcbiAgICB9XSxcbiAgICBwOiBbe1xuICAgICAgbmFtZTogJ3Bob25lJ1xuICAgIH1dLFxuICAgIHo6IFt7XG4gICAgICBuYW1lOiAndGltZXpvbmVzJ1xuICAgIH1dLFxuICAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhY3R1YWxseSBiZSBwYXJzZWQgcHJvcGVybHkuLi5cbiAgICByOiBbe1xuICAgICAgbmFtZTogJ3JlcGVhdHMnXG4gICAgfV0sXG4gICAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFsc28gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgLy8gazogW3t9XSwgLy8gb3V0ZGF0ZWQgdGhpbmcgaWdub3JlZFxuICAgIHQ6IFt7XG4gICAgICAvLyB0PTAgMFxuICAgICAgbmFtZTogJ3RpbWluZycsXG4gICAgICByZWc6IC9eKFxcZCopIChcXGQqKS8sXG4gICAgICBuYW1lczogWydzdGFydCcsICdzdG9wJ10sXG4gICAgICBmb3JtYXQ6ICclZCAlZCdcbiAgICB9XSxcbiAgICBjOiBbe1xuICAgICAgLy8gYz1JTiBJUDQgMTAuNDcuMTk3LjI2XG4gICAgICBuYW1lOiAnY29ubmVjdGlvbicsXG4gICAgICByZWc6IC9eSU4gSVAoXFxkKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsndmVyc2lvbicsICdpcCddLFxuICAgICAgZm9ybWF0OiAnSU4gSVAlZCAlcydcbiAgICB9XSxcbiAgICBiOiBbe1xuICAgICAgLy8gYj1BUzo0MDAwXG4gICAgICBwdXNoOiAnYmFuZHdpZHRoJyxcbiAgICAgIHJlZzogL14oVElBU3xBU3xDVHxSUnxSUyk6KFxcZCopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnbGltaXQnXSxcbiAgICAgIGZvcm1hdDogJyVzOiVzJ1xuICAgIH1dLFxuICAgIG06IFt7XG4gICAgICAvLyBtPXZpZGVvIDUxNzQ0IFJUUC9BVlAgMTI2IDk3IDk4IDM0IDMxXG4gICAgICAvLyBOQjogc3BlY2lhbCAtIHB1c2hlcyB0byBzZXNzaW9uXG4gICAgICAvLyBUT0RPOiBydHAvZm10cCBzaG91bGQgYmUgZmlsdGVyZWQgYnkgdGhlIHBheWxvYWRzIGZvdW5kIGhlcmU/XG4gICAgICByZWc6IC9eKFxcdyopIChcXGQqKSAoW1xcdy9dKikoPzogKC4qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAncG9ydCcsICdwcm90b2NvbCcsICdwYXlsb2FkcyddLFxuICAgICAgZm9ybWF0OiAnJXMgJWQgJXMgJXMnXG4gICAgfV0sXG4gICAgYTogW3tcbiAgICAgIC8vIGE9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcbiAgICAgIHB1c2g6ICdydHAnLFxuICAgICAgcmVnOiAvXnJ0cG1hcDooXFxkKikgKFtcXHdcXC0uXSopKD86XFxzKlxcLyhcXGQqKSg/OlxccypcXC8oXFxTKikpPyk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29kZWMnLCAncmF0ZScsICdlbmNvZGluZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5lbmNvZGluZyA/ICdydHBtYXA6JWQgJXMvJXMvJXMnIDogby5yYXRlID8gJ3J0cG1hcDolZCAlcy8lcycgOiAncnRwbWFwOiVkICVzJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPWZtdHA6MTA4IHByb2ZpbGUtbGV2ZWwtaWQ9MjQ7b2JqZWN0PTIzO2JpdHJhdGU9NjQwMDBcbiAgICAgIC8vIGE9Zm10cDoxMTEgbWlucHRpbWU9MTA7IHVzZWluYmFuZGZlYz0xXG4gICAgICBwdXNoOiAnZm10cCcsXG4gICAgICByZWc6IC9eZm10cDooXFxkKikgKFtcXFN8IF0qKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiAnZm10cDolZCAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWNvbnRyb2w6c3RyZWFtaWQ9MFxuICAgICAgbmFtZTogJ2NvbnRyb2wnLFxuICAgICAgcmVnOiAvXmNvbnRyb2w6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdjb250cm9sOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cnRjcDo2NTE3OSBJTiBJUDQgMTkzLjg0Ljc3LjE5NFxuICAgICAgbmFtZTogJ3J0Y3AnLFxuICAgICAgcmVnOiAvXnJ0Y3A6KFxcZCopKD86IChcXFMqKSBJUChcXGQpIChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BvcnQnLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLmFkZHJlc3MgIT0gbnVsbCA/ICdydGNwOiVkICVzIElQJWQgJXMnIDogJ3J0Y3A6JWQnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxuICAgICAgcHVzaDogJ3J0Y3BGYlRyckludCcsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIHRyci1pbnQgKFxcZCopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3J0Y3AtZmI6JXMgdHJyLWludCAlZCdcbiAgICB9LCB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgICBwdXNoOiAncnRjcEZiJyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgKFtcXHctX10qKSg/OiAoW1xcdy1fXSopKT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uc3VidHlwZSAhPSBudWxsID8gJ3J0Y3AtZmI6JXMgJXMgJXMnIDogJ3J0Y3AtZmI6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuICAgICAgLy8gYT1leHRtYXA6MS9yZWN2b25seSBVUkktZ3BzLXN0cmluZ1xuICAgICAgLy8gYT1leHRtYXA6MyB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNtcHRlLXRjIDI1QDYwMC8yNFxuICAgICAgcHVzaDogJ2V4dCcsXG4gICAgICByZWc6IC9eZXh0bWFwOihcXGQrKSg/OlxcLyhcXHcrKSk/KD86ICh1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0KSk/IChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWyd2YWx1ZScsICdkaXJlY3Rpb24nLCAnZW5jcnlwdC11cmknLCAndXJpJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ2V4dG1hcDolZCcgKyAoby5kaXJlY3Rpb24gPyAnLyVzJyA6ICcldicpICsgKG9bJ2VuY3J5cHQtdXJpJ10gPyAnICVzJyA6ICcldicpICsgJyAlcycgKyAoby5jb25maWcgPyAnICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPWV4dG1hcC1hbGxvdy1taXhlZFxuICAgICAgbmFtZTogJ2V4dG1hcEFsbG93TWl4ZWQnLFxuICAgICAgcmVnOiAvXihleHRtYXAtYWxsb3ctbWl4ZWQpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9Y3J5cHRvOjEgQUVTX0NNXzEyOF9ITUFDX1NIQTFfODAgaW5saW5lOlBTMXVRQ1ZlZUNGQ2FuVm1jamtwUHl3ak5XaGNZRDBtWFh0eGFWQlJ8Ml4yMHwxOjMyXG4gICAgICBwdXNoOiAnY3J5cHRvJyxcbiAgICAgIHJlZzogL15jcnlwdG86KFxcZCopIChbXFx3X10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnc3VpdGUnLCAnY29uZmlnJywgJ3Nlc3Npb25Db25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsID8gJ2NyeXB0bzolZCAlcyAlcyAlcycgOiAnY3J5cHRvOiVkICVzICVzJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXNldHVwOmFjdHBhc3NcbiAgICAgIG5hbWU6ICdzZXR1cCcsXG4gICAgICByZWc6IC9ec2V0dXA6KFxcdyopLyxcbiAgICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9Y29ubmVjdGlvbjpuZXdcbiAgICAgIG5hbWU6ICdjb25uZWN0aW9uVHlwZScsXG4gICAgICByZWc6IC9eY29ubmVjdGlvbjoobmV3fGV4aXN0aW5nKS8sXG4gICAgICBmb3JtYXQ6ICdjb25uZWN0aW9uOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9bWlkOjFcbiAgICAgIG5hbWU6ICdtaWQnLFxuICAgICAgcmVnOiAvXm1pZDooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAnbWlkOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXG4gICAgICBuYW1lOiAnbXNpZCcsXG4gICAgICByZWc6IC9ebXNpZDooLiopLyxcbiAgICAgIGZvcm1hdDogJ21zaWQ6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1wdGltZToyMFxuICAgICAgbmFtZTogJ3B0aW1lJyxcbiAgICAgIHJlZzogL15wdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgICAgZm9ybWF0OiAncHRpbWU6JWQnXG4gICAgfSwge1xuICAgICAgLy8gYT1tYXhwdGltZTo2MFxuICAgICAgbmFtZTogJ21heHB0aW1lJyxcbiAgICAgIHJlZzogL15tYXhwdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgICAgZm9ybWF0OiAnbWF4cHRpbWU6JWQnXG4gICAgfSwge1xuICAgICAgLy8gYT1zZW5kcmVjdlxuICAgICAgbmFtZTogJ2RpcmVjdGlvbicsXG4gICAgICByZWc6IC9eKHNlbmRyZWN2fHJlY3Zvbmx5fHNlbmRvbmx5fGluYWN0aXZlKS9cbiAgICB9LCB7XG4gICAgICAvLyBhPWljZS1saXRlXG4gICAgICBuYW1lOiAnaWNlbGl0ZScsXG4gICAgICByZWc6IC9eKGljZS1saXRlKS9cbiAgICB9LCB7XG4gICAgICAvLyBhPWljZS11ZnJhZzpGN2dJXG4gICAgICBuYW1lOiAnaWNlVWZyYWcnLFxuICAgICAgcmVnOiAvXmljZS11ZnJhZzooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXVmcmFnOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9aWNlLXB3ZDp4OWNtbC9ZemljaFYyK1hsaGlNdThnXG4gICAgICBuYW1lOiAnaWNlUHdkJyxcbiAgICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtcHdkOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcbiAgICAgIG5hbWU6ICdmaW5nZXJwcmludCcsXG4gICAgICByZWc6IC9eZmluZ2VycHJpbnQ6KFxcUyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcbiAgICAgIGZvcm1hdDogJ2ZpbmdlcnByaW50OiVzICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjAgMSBVRFAgMjExMzY2NzMyNyAyMDMuMC4xMTMuMSA1NDQwMCB0eXAgaG9zdFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MTE2Mjg3NTA4MSAxIHVkcCAyMTEzOTM3MTUxIDE5Mi4xNjguMzQuNzUgNjAwMTcgdHlwIGhvc3QgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB1ZHAgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZToyMjk4MTU2MjAgMSB0Y3AgMTUxODI4MDQ0NyAxOTIuMTY4LjE1MC4xOSA2MDAxNyB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHRjcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgdGNwdHlwZSBwYXNzaXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICBwdXNoOiAnY2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eY2FuZGlkYXRlOihcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIHR5cCAoXFxTKikoPzogcmFkZHIgKFxcUyopIHJwb3J0IChcXGQqKSk/KD86IHRjcHR5cGUgKFxcUyopKT8oPzogZ2VuZXJhdGlvbiAoXFxkKikpPyg/OiBuZXR3b3JrLWlkIChcXGQqKSk/KD86IG5ldHdvcmstY29zdCAoXFxkKikpPy8sXG4gICAgICBuYW1lczogWydmb3VuZGF0aW9uJywgJ2NvbXBvbmVudCcsICd0cmFuc3BvcnQnLCAncHJpb3JpdHknLCAnaXAnLCAncG9ydCcsICd0eXBlJywgJ3JhZGRyJywgJ3Jwb3J0JywgJ3RjcHR5cGUnLCAnZ2VuZXJhdGlvbicsICduZXR3b3JrLWlkJywgJ25ldHdvcmstY29zdCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ2NhbmRpZGF0ZTolcyAlZCAlcyAlZCAlcyAlZCB0eXAgJXMnO1xuICAgICAgICBzdHIgKz0gby5yYWRkciAhPSBudWxsID8gJyByYWRkciAlcyBycG9ydCAlZCcgOiAnJXYldic7XG5cbiAgICAgICAgLy8gTkI6IGNhbmRpZGF0ZSBoYXMgdGhyZWUgb3B0aW9uYWwgY2h1bmtzLCBzbyAldm9pZCBtaWRkbGVzIG9uZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgc3RyICs9IG8udGNwdHlwZSAhPSBudWxsID8gJyB0Y3B0eXBlICVzJyA6ICcldic7XG4gICAgICAgIGlmIChvLmdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnIGdlbmVyYXRpb24gJWQnO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBvWyduZXR3b3JrLWlkJ10gIT0gbnVsbCA/ICcgbmV0d29yay1pZCAlZCcgOiAnJXYnO1xuICAgICAgICBzdHIgKz0gb1snbmV0d29yay1jb3N0J10gIT0gbnVsbCA/ICcgbmV0d29yay1jb3N0ICVkJyA6ICcldic7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1lbmQtb2YtY2FuZGlkYXRlcyAoa2VlcCBhZnRlciB0aGUgY2FuZGlkYXRlcyBsaW5lIGZvciByZWFkYWJpbGl0eSlcbiAgICAgIG5hbWU6ICdlbmRPZkNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXihlbmQtb2YtY2FuZGlkYXRlcykvXG4gICAgfSwge1xuICAgICAgLy8gYT1yZW1vdGUtY2FuZGlkYXRlczoxIDIwMy4wLjExMy4xIDU0NDAwIDIgMjAzLjAuMTEzLjEgNTQ0MDEgLi4uXG4gICAgICBuYW1lOiAncmVtb3RlQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9ecmVtb3RlLWNhbmRpZGF0ZXM6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdyZW1vdGUtY2FuZGlkYXRlczolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWljZS1vcHRpb25zOmdvb2dsZS1pY2VcbiAgICAgIG5hbWU6ICdpY2VPcHRpb25zJyxcbiAgICAgIHJlZzogL15pY2Utb3B0aW9uczooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLW9wdGlvbnM6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1zc3JjOjI1NjYxMDc1NjkgY25hbWU6dDlZVThNMVV4VEY4WTFBMVxuICAgICAgcHVzaDogJ3NzcmNzJyxcbiAgICAgIHJlZzogL15zc3JjOihcXGQqKSAoW1xcd18tXSopKD86OiguKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdhdHRyaWJ1dGUnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdzc3JjOiVkJztcbiAgICAgICAgaWYgKG8uYXR0cmlidXRlICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyAlcyc7XG4gICAgICAgICAgaWYgKG8udmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9ICc6JXMnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMgMSAyXG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDLUZSIDMwMDQzNjQxOTUgMTA4MDc3MjI0MVxuICAgICAgcHVzaDogJ3NzcmNHcm91cHMnLFxuICAgICAgLy8gdG9rZW4tY2hhciA9ICV4MjEgLyAleDIzLTI3IC8gJXgyQS0yQiAvICV4MkQtMkUgLyAleDMwLTM5IC8gJXg0MS01QSAvICV4NUUtN0VcbiAgICAgIHJlZzogL15zc3JjLWdyb3VwOihbXFx4MjFcXHgyM1xceDI0XFx4MjVcXHgyNlxceDI3XFx4MkFcXHgyQlxceDJEXFx4MkVcXHddKikgKC4qKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpY3MnLCAnc3NyY3MnXSxcbiAgICAgIGZvcm1hdDogJ3NzcmMtZ3JvdXA6JXMgJXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1tc2lkLXNlbWFudGljOiBXTVMgSnZsYW01WDNTWDFPUDZwbjIweldvZ3ZhS0p6NUhqZjlPbmxWXG4gICAgICBuYW1lOiAnbXNpZFNlbWFudGljJyxcbiAgICAgIHJlZzogL15tc2lkLXNlbWFudGljOlxccz8oXFx3KikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljJywgJ3Rva2VuJ10sXG4gICAgICBmb3JtYXQ6ICdtc2lkLXNlbWFudGljOiAlcyAlcycgLy8gc3BhY2UgYWZ0ZXIgJzonIGlzIG5vdCBhY2NpZGVudGFsXG4gICAgfSwge1xuICAgICAgLy8gYT1ncm91cDpCVU5ETEUgYXVkaW8gdmlkZW9cbiAgICAgIHB1c2g6ICdncm91cHMnLFxuICAgICAgcmVnOiAvXmdyb3VwOihcXHcqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnbWlkcyddLFxuICAgICAgZm9ybWF0OiAnZ3JvdXA6JXMgJXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1ydGNwLW11eFxuICAgICAgbmFtZTogJ3J0Y3BNdXgnLFxuICAgICAgcmVnOiAvXihydGNwLW11eCkvXG4gICAgfSwge1xuICAgICAgLy8gYT1ydGNwLXJzaXplXG4gICAgICBuYW1lOiAncnRjcFJzaXplJyxcbiAgICAgIHJlZzogL14ocnRjcC1yc2l6ZSkvXG4gICAgfSwge1xuICAgICAgLy8gYT1zY3RwbWFwOjUwMDAgd2VicnRjLWRhdGFjaGFubmVsIDEwMjRcbiAgICAgIG5hbWU6ICdzY3RwbWFwJyxcbiAgICAgIHJlZzogL15zY3RwbWFwOihbXFx3Xy9dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3NjdHBtYXBOdW1iZXInLCAnYXBwJywgJ21heE1lc3NhZ2VTaXplJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLm1heE1lc3NhZ2VTaXplICE9IG51bGwgPyAnc2N0cG1hcDolcyAlcyAlcycgOiAnc2N0cG1hcDolcyAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT14LWdvb2dsZS1mbGFnOmNvbmZlcmVuY2VcbiAgICAgIG5hbWU6ICd4R29vZ2xlRmxhZycsXG4gICAgICByZWc6IC9eeC1nb29nbGUtZmxhZzooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAneC1nb29nbGUtZmxhZzolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPXJpZDoxIHNlbmQgbWF4LXdpZHRoPTEyODA7bWF4LWhlaWdodD03MjA7bWF4LWZwcz0zMDtkZXBlbmQ9MFxuICAgICAgcHVzaDogJ3JpZHMnLFxuICAgICAgcmVnOiAvXnJpZDooW1xcZFxcd10rKSAoXFx3KykoPzogKFtcXFN8IF0qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2RpcmVjdGlvbicsICdwYXJhbXMnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8ucGFyYW1zID8gJ3JpZDolcyAlcyAlcycgOiAncmlkOiVzICVzJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPWltYWdlYXR0cjo5NyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgLy8gYT1pbWFnZWF0dHI6KiBzZW5kIFt4PTgwMCx5PTY0MF0gcmVjdiAqXG4gICAgICAvLyBhPWltYWdlYXR0cjoxMDAgcmVjdiBbeD0zMjAseT0yNDBdXG4gICAgICBwdXNoOiAnaW1hZ2VhdHRycycsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAvLyBhPWltYWdlYXR0cjo5N1xuICAgICAgJ15pbWFnZWF0dHI6KFxcXFxkK3xcXFxcKiknICtcbiAgICAgIC8vIHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF1cbiAgICAgICdbXFxcXHNcXFxcdF0rKHNlbmR8cmVjdilbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKScgK1xuICAgICAgLy8gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgICAnKD86W1xcXFxzXFxcXHRdKyhyZWN2fHNlbmQpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKikpPycpLFxuICAgICAgbmFtZXM6IFsncHQnLCAnZGlyMScsICdhdHRyczEnLCAnZGlyMicsICdhdHRyczInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdpbWFnZWF0dHI6JXMgJXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnNlbmQgMSwyLDM7fjQsfjUgcmVjdiA2O343LH44XG4gICAgICAvLyBhPXNpbXVsY2FzdDpyZWN2IDE7NCw1IHNlbmQgNjs3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0JyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgIC8vIGE9c2ltdWxjYXN0OlxuICAgICAgJ15zaW11bGNhc3Q6JyArXG4gICAgICAvLyBzZW5kIDEsMiwzO340LH41XG4gICAgICAnKHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKyknICtcbiAgICAgIC8vIHNwYWNlICsgcmVjdiA2O343LH44XG4gICAgICAnKD86XFxcXHM/KHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKykpPycgK1xuICAgICAgLy8gZW5kXG4gICAgICAnJCcpLFxuICAgICAgbmFtZXM6IFsnZGlyMScsICdsaXN0MScsICdkaXIyJywgJ2xpc3QyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnc2ltdWxjYXN0OiVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBvbGQgc2ltdWxjYXN0IGRyYWZ0IDAzIChpbXBsZW1lbnRlZCBieSBGaXJlZm94KVxuICAgICAgLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2RwLXNpbXVsY2FzdC0wM1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHJlY3YgcHQ9OTc7OTggc2VuZCBwdD05N1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHNlbmQgcmlkPTU7Njs3IHBhdXNlZD02LDdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3RfMDMnLFxuICAgICAgcmVnOiAvXnNpbXVsY2FzdDpbXFxzXFx0XSsoW1xcUytcXHNcXHRdKykkLyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdzaW11bGNhc3Q6ICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI1XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyOS45N1xuICAgICAgbmFtZTogJ2ZyYW1lcmF0ZScsXG4gICAgICByZWc6IC9eZnJhbWVyYXRlOihcXGQrKD86JHxcXC5cXGQrKSkvLFxuICAgICAgZm9ybWF0OiAnZnJhbWVyYXRlOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIFJGQzQ1NzBcbiAgICAgIC8vIGE9c291cmNlLWZpbHRlcjogaW5jbCBJTiBJUDQgMjM5LjUuMi4zMSAxMC4xLjE1LjVcbiAgICAgIG5hbWU6ICdzb3VyY2VGaWx0ZXInLFxuICAgICAgcmVnOiAvXnNvdXJjZS1maWx0ZXI6ICooZXhjbHxpbmNsKSAoXFxTKikgKElQNHxJUDZ8XFwqKSAoXFxTKikgKC4qKS8sXG4gICAgICBuYW1lczogWydmaWx0ZXJNb2RlJywgJ25ldFR5cGUnLCAnYWRkcmVzc1R5cGVzJywgJ2Rlc3RBZGRyZXNzJywgJ3NyY0xpc3QnXSxcbiAgICAgIGZvcm1hdDogJ3NvdXJjZS1maWx0ZXI6ICVzICVzICVzICVzICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9YnVuZGxlLW9ubHlcbiAgICAgIG5hbWU6ICdidW5kbGVPbmx5JyxcbiAgICAgIHJlZzogL14oYnVuZGxlLW9ubHkpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9bGFiZWw6MVxuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIHJlZzogL15sYWJlbDooLispLyxcbiAgICAgIGZvcm1hdDogJ2xhYmVsOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNVxuICAgICAgbmFtZTogJ3NjdHBQb3J0JyxcbiAgICAgIHJlZzogL15zY3RwLXBvcnQ6KFxcZCspJC8sXG4gICAgICBmb3JtYXQ6ICdzY3RwLXBvcnQ6JXMnXG4gICAgfSwge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi02XG4gICAgICBuYW1lOiAnbWF4TWVzc2FnZVNpemUnLFxuICAgICAgcmVnOiAvXm1heC1tZXNzYWdlLXNpemU6KFxcZCspJC8sXG4gICAgICBmb3JtYXQ6ICdtYXgtbWVzc2FnZS1zaXplOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIFJGQzcyNzNcbiAgICAgIC8vIGE9dHMtcmVmY2xrOnB0cD1JRUVFMTU4OC0yMDA4OjM5LUE3LTk0LUZGLUZFLTA3LUNCLUQwOjM3XG4gICAgICBwdXNoOiAndHNSZWZDbG9ja3MnLFxuICAgICAgcmVnOiAvXnRzLXJlZmNsazooW15cXHM9XSopKD86PShcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2Nsa3NyYycsICdjbGtzcmNFeHQnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICd0cy1yZWZjbGs6JXMnICsgKG8uY2xrc3JjRXh0ICE9IG51bGwgPyAnPSVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPW1lZGlhY2xrOmRpcmVjdD05NjMyMTQ0MjRcbiAgICAgIG5hbWU6ICdtZWRpYUNsaycsXG4gICAgICByZWc6IC9ebWVkaWFjbGs6KD86aWQ9KFxcUyopKT8gKihbXlxccz1dKikoPzo9KFxcUyopKT8oPzogKnJhdGU9KFxcZCspXFwvKFxcZCspKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbWVkaWFDbG9ja05hbWUnLCAnbWVkaWFDbG9ja1ZhbHVlJywgJ3JhdGVOdW1lcmF0b3InLCAncmF0ZURlbm9taW5hdG9yJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnbWVkaWFjbGs6JztcbiAgICAgICAgc3RyICs9IG8uaWQgIT0gbnVsbCA/ICdpZD0lcyAlcycgOiAnJXYlcyc7XG4gICAgICAgIHN0ciArPSBvLm1lZGlhQ2xvY2tWYWx1ZSAhPSBudWxsID8gJz0lcycgOiAnJztcbiAgICAgICAgc3RyICs9IG8ucmF0ZU51bWVyYXRvciAhPSBudWxsID8gJyByYXRlPSVzJyA6ICcnO1xuICAgICAgICBzdHIgKz0gby5yYXRlRGVub21pbmF0b3IgIT0gbnVsbCA/ICcvJXMnIDogJyc7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1rZXl3ZHM6a2V5d29yZHNcbiAgICAgIG5hbWU6ICdrZXl3b3JkcycsXG4gICAgICByZWc6IC9ea2V5d2RzOiguKykkLyxcbiAgICAgIGZvcm1hdDogJ2tleXdkczolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWNvbnRlbnQ6bWFpblxuICAgICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgICAgcmVnOiAvXmNvbnRlbnQ6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdjb250ZW50OiVzJ1xuICAgIH0sXG4gICAgLy8gQkZDUCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDU4M1xuICAgIHtcbiAgICAgIC8vIGE9Zmxvb3JjdHJsOmMtc1xuICAgICAgbmFtZTogJ2JmY3BGbG9vckN0cmwnLFxuICAgICAgcmVnOiAvXmZsb29yY3RybDooYy1vbmx5fHMtb25seXxjLXMpLyxcbiAgICAgIGZvcm1hdDogJ2Zsb29yY3RybDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWNvbmZpZDoxXG4gICAgICBuYW1lOiAnYmZjcENvbmZJZCcsXG4gICAgICByZWc6IC9eY29uZmlkOihcXGQrKS8sXG4gICAgICBmb3JtYXQ6ICdjb25maWQ6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT11c2VyaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BVc2VySWQnLFxuICAgICAgcmVnOiAvXnVzZXJpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAndXNlcmlkOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9Zmxvb3JpZDoxXG4gICAgICBuYW1lOiAnYmZjcEZsb29ySWQnLFxuICAgICAgcmVnOiAvXmZsb29yaWQ6KC4rKSAoPzptLXN0cmVhbXxtc3RybSk6KC4rKS8sXG4gICAgICBuYW1lczogWydpZCcsICdtU3RyZWFtJ10sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmlkOiVzIG1zdHJtOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGFueSBhPSB0aGF0IHdlIGRvbid0IHVuZGVyc3RhbmQgaXMga2VwdCB2ZXJiYXRpbSBvbiBtZWRpYS5pbnZhbGlkXG4gICAgICBwdXNoOiAnaW52YWxpZCcsXG4gICAgICBuYW1lczogWyd2YWx1ZSddXG4gICAgfV1cbiAgfTtcblxuICAvLyBzZXQgc2Vuc2libGUgZGVmYXVsdHMgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBncmFtbWFyIHdpdGggYm9yaW5nIGRldGFpbHNcbiAgT2JqZWN0LmtleXMoZ3JhbW1hciQxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgb2JqcyA9IGdyYW1tYXIkMVtrZXldO1xuICAgIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAoIW9iai5yZWcpIHtcbiAgICAgICAgb2JqLnJlZyA9IC8oLiopLztcbiAgICAgIH1cbiAgICAgIGlmICghb2JqLmZvcm1hdCkge1xuICAgICAgICBvYmouZm9ybWF0ID0gJyVzJztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBncmFtbWFyLmV4cG9ydHM7XG59XG5cbnZhciBoYXNSZXF1aXJlZFBhcnNlcjtcbmZ1bmN0aW9uIHJlcXVpcmVQYXJzZXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFBhcnNlcikgcmV0dXJuIHBhcnNlcjtcbiAgaGFzUmVxdWlyZWRQYXJzZXIgPSAxO1xuICAoZnVuY3Rpb24gKGV4cG9ydHMkMSkge1xuICAgIHZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKSA9PT0gdiA/IE51bWJlcih2KSA6IHY7XG4gICAgfTtcbiAgICB2YXIgYXR0YWNoUHJvcGVydGllcyA9IGZ1bmN0aW9uIChtYXRjaCwgbG9jYXRpb24sIG5hbWVzLCByYXdOYW1lKSB7XG4gICAgICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICAgICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAobWF0Y2hbaSArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gICAgICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcbiAgICAgIGlmIChvYmoucHVzaCAmJiAhbG9jYXRpb25bb2JqLnB1c2hdKSB7XG4gICAgICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcbiAgICAgICAgbG9jYXRpb25bb2JqLm5hbWVdID0ge307XG4gICAgICB9XG4gICAgICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/IHt9IDpcbiAgICAgIC8vIGJsYW5rIG9iamVjdCB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gICAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gICAgICBhdHRhY2hQcm9wZXJ0aWVzKGNvbnRlbnQubWF0Y2gob2JqLnJlZyksIGtleUxvY2F0aW9uLCBvYmoubmFtZXMsIG9iai5uYW1lKTtcbiAgICAgIGlmIChvYmoucHVzaCkge1xuICAgICAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XG4gICAgdmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG4gICAgZXhwb3J0cyQxLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xuICAgICAgdmFyIHNlc3Npb24gPSB7fSxcbiAgICAgICAgbWVkaWEgPSBbXSxcbiAgICAgICAgbG9jYXRpb24gPSBzZXNzaW9uOyAvLyBwb2ludHMgYXQgd2hlcmUgcHJvcGVydGllcyBnbyB1bmRlciAob25lIG9mIHRoZSBhYm92ZSlcblxuICAgICAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICAgICAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgdHlwZSA9IGxbMF07XG4gICAgICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgICAgIG1lZGlhLnB1c2goe1xuICAgICAgICAgICAgcnRwOiBbXSxcbiAgICAgICAgICAgIGZtdHA6IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGggLSAxXTsgLy8gcG9pbnQgYXQgbGF0ZXN0IG1lZGlhIGxpbmVcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IChncmFtbWFyW3R5cGVdIHx8IFtdKS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJlZyhvYmosIGxvY2F0aW9uLCBjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9O1xuICAgIHZhciBwYXJhbVJlZHVjZXIgPSBmdW5jdGlvbiAoYWNjLCBleHByKSB7XG4gICAgICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgYWNjW3NbMF1dID0gdG9JbnRJZkludChzWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFjY1tzWzBdXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnNwbGl0KC87XFxzPy8pLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbiAgICB9O1xuXG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcbiAgICBleHBvcnRzJDEucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cyQxLnBhcnNlUGFyYW1zO1xuICAgIGV4cG9ydHMkMS5wYXJzZVBheWxvYWRzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxuICAgICAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICAgICAgcG9ydDogcGFydHNbaSArIDJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aCAtIDEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHZhciBzY2lkLFxuICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2lkOiBzY2lkLFxuICAgICAgICAgICAgcGF1c2VkOiBwYXVzZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pKHBhcnNlcik7XG4gIHJldHVybiBwYXJzZXI7XG59XG5cbnZhciB3cml0ZXI7XG52YXIgaGFzUmVxdWlyZWRXcml0ZXI7XG5mdW5jdGlvbiByZXF1aXJlV3JpdGVyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRXcml0ZXIpIHJldHVybiB3cml0ZXI7XG4gIGhhc1JlcXVpcmVkV3JpdGVyID0gMTtcbiAgdmFyIGdyYW1tYXIgPSByZXF1aXJlR3JhbW1hcigpO1xuXG4gIC8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xuICB2YXIgZm9ybWF0UmVnRXhwID0gLyVbc2R2JV0vZztcbiAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXRTdHIpIHtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgICAgcmV0dXJuIHg7IC8vIG1pc3NpbmcgYXJndW1lbnRcbiAgICAgIH1cbiAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgICAgaSArPSAxO1xuICAgICAgc3dpdGNoICh4KSB7XG4gICAgICAgIGNhc2UgJyUlJzpcbiAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgICBjYXNlICclcyc6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhhcmcpO1xuICAgICAgICBjYXNlICclZCc6XG4gICAgICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgICAgICBjYXNlICcldic6XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIE5COiB3ZSBkaXNjYXJkIGV4Y2VzcyBhcmd1bWVudHMgLSB0aGV5IGFyZSB0eXBpY2FsbHkgdW5kZWZpbmVkIGZyb20gbWFrZUxpbmVcbiAgfTtcbiAgdmFyIG1ha2VMaW5lID0gZnVuY3Rpb24gKHR5cGUsIG9iaiwgbG9jYXRpb24pIHtcbiAgICB2YXIgc3RyID0gb2JqLmZvcm1hdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gb2JqLmZvcm1hdChvYmoucHVzaCA/IGxvY2F0aW9uIDogbG9jYXRpb25bb2JqLm5hbWVdKSA6IG9iai5mb3JtYXQ7XG4gICAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gICAgaWYgKG9iai5uYW1lcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICAgIGlmIChvYmoubmFtZSkge1xuICAgICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV1bbl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZvciBtTGluZSBhbmQgcHVzaCBhdHRyaWJ1dGVzXG4gICAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lc1tpXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIFJGQyBzcGVjaWZpZWQgb3JkZXJcbiAgLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcbiAgdmFyIGRlZmF1bHRPdXRlck9yZGVyID0gWyd2JywgJ28nLCAncycsICdpJywgJ3UnLCAnZScsICdwJywgJ2MnLCAnYicsICd0JywgJ3InLCAneicsICdhJ107XG4gIHZhciBkZWZhdWx0SW5uZXJPcmRlciA9IFsnaScsICdjJywgJ2InLCAnYSddO1xuICB3cml0ZXIgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIC8vIGVuc3VyZSBjZXJ0YWluIHByb3BlcnRpZXMgZXhpc3RcbiAgICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcbiAgICAgIHNlc3Npb24udmVyc2lvbiA9IDA7IC8vICd2PTAnIG11c3QgYmUgdGhlcmUgKG9ubHkgZGVmaW5lZCB2ZXJzaW9uIGF0bSlcbiAgICB9XG4gICAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XG4gICAgICBzZXNzaW9uLm5hbWUgPSAnICc7IC8vICdzPSAnIG11c3QgYmUgdGhlcmUgaWYgbm8gbWVhbmluZ2Z1bCBuYW1lIHNldFxuICAgIH1cbiAgICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgICBpZiAobUxpbmUucGF5bG9hZHMgPT0gbnVsbCkge1xuICAgICAgICBtTGluZS5wYXlsb2FkcyA9ICcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBvdXRlck9yZGVyID0gb3B0cy5vdXRlck9yZGVyIHx8IGRlZmF1bHRPdXRlck9yZGVyO1xuICAgIHZhciBpbm5lck9yZGVyID0gb3B0cy5pbm5lck9yZGVyIHx8IGRlZmF1bHRJbm5lck9yZGVyO1xuICAgIHZhciBzZHAgPSBbXTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBvdXRlck9yZGVyIGZvciBtYXRjaGluZyBwcm9wZXJ0aWVzIG9uIHNlc3Npb25cbiAgICBvdXRlck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmoubmFtZSBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIHNlc3Npb24pKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoucHVzaCBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBzZXNzaW9uW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHRoZW4gZm9yIGVhY2ggbWVkaWEgbGluZSwgZm9sbG93IHRoZSBpbm5lck9yZGVyXG4gICAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgICAgc2RwLnB1c2gobWFrZUxpbmUoJ20nLCBncmFtbWFyLm1bMF0sIG1MaW5lKSk7XG4gICAgICBpbm5lck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgbUxpbmUpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9iai5wdXNoIGluIG1MaW5lICYmIG1MaW5lW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZHAuam9pbignXFxyXFxuJykgKyAnXFxyXFxuJztcbiAgfTtcbiAgcmV0dXJuIHdyaXRlcjtcbn1cblxudmFyIGhhc1JlcXVpcmVkTGliO1xuZnVuY3Rpb24gcmVxdWlyZUxpYigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkTGliKSByZXR1cm4gbGliO1xuICBoYXNSZXF1aXJlZExpYiA9IDE7XG4gIHZhciBwYXJzZXIgPSByZXF1aXJlUGFyc2VyKCk7XG4gIHZhciB3cml0ZXIgPSByZXF1aXJlV3JpdGVyKCk7XG4gIHZhciBncmFtbWFyID0gcmVxdWlyZUdyYW1tYXIoKTtcbiAgbGliLmdyYW1tYXIgPSBncmFtbWFyO1xuICBsaWIud3JpdGUgPSB3cml0ZXI7XG4gIGxpYi5wYXJzZSA9IHBhcnNlci5wYXJzZTtcbiAgbGliLnBhcnNlUGFyYW1zID0gcGFyc2VyLnBhcnNlUGFyYW1zO1xuICBsaWIucGFyc2VGbXRwQ29uZmlnID0gcGFyc2VyLnBhcnNlRm10cENvbmZpZzsgLy8gQWxpYXMgb2YgcGFyc2VQYXJhbXMoKS5cbiAgbGliLnBhcnNlUGF5bG9hZHMgPSBwYXJzZXIucGFyc2VQYXlsb2FkcztcbiAgbGliLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IHBhcnNlci5wYXJzZVJlbW90ZUNhbmRpZGF0ZXM7XG4gIGxpYi5wYXJzZUltYWdlQXR0cmlidXRlcyA9IHBhcnNlci5wYXJzZUltYWdlQXR0cmlidXRlcztcbiAgbGliLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IHBhcnNlci5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3Q7XG4gIHJldHVybiBsaWI7XG59XG5cbnZhciBsaWJFeHBvcnRzID0gcmVxdWlyZUxpYigpO1xuXG5mdW5jdGlvbiByKHIsIGUsIG4pIHtcbiAgdmFyIGksIHQsIG87XG4gIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDUwKSwgdm9pZCAwID09PSBuICYmIChuID0ge30pO1xuICB2YXIgYSA9IG51bGwgIT0gKGkgPSBuLmlzSW1tZWRpYXRlKSAmJiBpLFxuICAgIHUgPSBudWxsICE9ICh0ID0gbi5jYWxsYmFjaykgJiYgdCxcbiAgICBjID0gbi5tYXhXYWl0LFxuICAgIHYgPSBEYXRlLm5vdygpLFxuICAgIGwgPSBbXTtcbiAgZnVuY3Rpb24gZigpIHtcbiAgICBpZiAodm9pZCAwICE9PSBjKSB7XG4gICAgICB2YXIgciA9IERhdGUubm93KCkgLSB2O1xuICAgICAgaWYgKHIgKyBlID49IGMpIHJldHVybiBjIC0gcjtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgdmFyIGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICBuID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGksIHQpIHtcbiAgICAgIHZhciBjID0gYSAmJiB2b2lkIDAgPT09IG87XG4gICAgICBpZiAodm9pZCAwICE9PSBvICYmIGNsZWFyVGltZW91dChvKSwgbyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobyA9IHZvaWQgMCwgdiA9IERhdGUubm93KCksICFhKSB7XG4gICAgICAgICAgdmFyIGkgPSByLmFwcGx5KG4sIGUpO1xuICAgICAgICAgIHUgJiYgdShpKSwgbC5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHIucmVzb2x2ZSkoaSk7XG4gICAgICAgICAgfSksIGwgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSwgZigpKSwgYykge1xuICAgICAgICB2YXIgZCA9IHIuYXBwbHkobiwgZSk7XG4gICAgICAgIHJldHVybiB1ICYmIHUoZCksIGkoZCk7XG4gICAgICB9XG4gICAgICBsLnB1c2goe1xuICAgICAgICByZXNvbHZlOiBpLFxuICAgICAgICByZWplY3Q6IHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZC5jYW5jZWwgPSBmdW5jdGlvbiAocikge1xuICAgIHZvaWQgMCAhPT0gbyAmJiBjbGVhclRpbWVvdXQobyksIGwuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuICgwLCBlLnJlamVjdCkocik7XG4gICAgfSksIGwgPSBbXTtcbiAgfSwgZDtcbn1cblxuLyogVGhlIHN2YyBjb2RlYyAoYXYxL3ZwOSkgd291bGQgdXNlIGEgdmVyeSBsb3cgYml0cmF0ZSBhdCB0aGUgYmVnaW5pbmcgYW5kXG5pbmNyZWFzZSBzbG93bHkgYnkgdGhlIGJhbmR3aWR0aCBlc3RpbWF0b3IgdW50aWwgaXQgcmVhY2ggdGhlIHRhcmdldCBiaXRyYXRlLiBUaGVcbnByb2Nlc3MgY29tbW9ubHkgY29zdCBtb3JlIHRoYW4gMTAgc2Vjb25kcyBjYXVzZSBzdWJzY3JpYmVyIHdpbGwgZ2V0IGJsdXIgdmlkZW8gYXRcbnRoZSBmaXJzdCBmZXcgc2Vjb25kcy4gU28gd2UgdXNlIGEgNzAlIG9mIHRhcmdldCBiaXRyYXRlIGhlcmUgYXMgdGhlIHN0YXJ0IGJpdHJhdGUgdG9cbmVsaW1pbmF0ZSB0aGlzIGlzc3VlLlxuKi9cbmNvbnN0IHN0YXJ0Qml0cmF0ZUZvclNWQyA9IDAuNztcbmNvbnN0IGRlYm91bmNlSW50ZXJ2YWwgPSAyMDtcbmNvbnN0IFBDRXZlbnRzID0ge1xuICBOZWdvdGlhdGlvblN0YXJ0ZWQ6ICduZWdvdGlhdGlvblN0YXJ0ZWQnLFxuICBOZWdvdGlhdGlvbkNvbXBsZXRlOiAnbmVnb3RpYXRpb25Db21wbGV0ZScsXG4gIFJUUFZpZGVvUGF5bG9hZFR5cGVzOiAncnRwVmlkZW9QYXlsb2FkVHlwZXMnXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUENUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGdldCBwYygpIHtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICB0aGlzLl9wYyA9IHRoaXMuY3JlYXRlUEMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5kZEV4dElEID0gMDtcbiAgICB0aGlzLmxhdGVzdE9mZmVySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzID0gW107XG4gICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gW107XG4gICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IFtdO1xuICAgIC8vIGRlYm91bmNlZCBuZWdvdGlhdGUgaW50ZXJmYWNlXG4gICAgdGhpcy5uZWdvdGlhdGUgPSByKG9uRXJyb3IgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCBkZWJvdW5jZUludGVydmFsKTtcbiAgICB0aGlzLmNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9udHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QQ1RyYW5zcG9ydCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9wYyA9IHRoaXMuY3JlYXRlUEMoKTtcbiAgICB0aGlzLm9mZmVyTG9jayA9IG5ldyBfKCk7XG4gIH1cbiAgY3JlYXRlUEMoKSB7XG4gICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24odGhpcy5jb25maWcpO1xuICAgIHBjLm9uaWNlY2FuZGlkYXRlID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFldi5jYW5kaWRhdGUpIHJldHVybjtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2LmNhbmRpZGF0ZSk7XG4gICAgfTtcbiAgICBwYy5vbmljZWNhbmRpZGF0ZWVycm9yID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XG4gICAgfTtcbiAgICBwYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHBjLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgfTtcbiAgICBwYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vblNpZ25hbGluZ1N0YXRlY2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgfTtcbiAgICBwYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHBjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgfTtcbiAgICBwYy5vbmRhdGFjaGFubmVsID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XG4gICAgfTtcbiAgICBwYy5vbnRyYWNrID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vblRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XG4gICAgfTtcbiAgICByZXR1cm4gcGM7XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gKF9hID0gdGhpcy5sb2dnZXJPcHRpb25zKS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gIH1cbiAgZ2V0IGlzSUNFQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYyAhPT0gbnVsbCAmJiAodGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJyk7XG4gIH1cbiAgYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbiAmJiAhdGhpcy5yZXN0YXJ0aW5nSWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QsIG9mZmVySWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInICYmIHRoaXMubGF0ZXN0T2ZmZXJJZCA+IDAgJiYgb2ZmZXJJZCA+IDAgJiYgb2ZmZXJJZCAhPT0gdGhpcy5sYXRlc3RPZmZlcklkKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2lnbm9yaW5nIGFuc3dlciBmb3Igb2xkIG9mZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgb2ZmZXJJZCxcbiAgICAgICAgICBsYXRlc3RPZmZlcklkOiB0aGlzLmxhdGVzdE9mZmVySWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgbXVuZ2VkU0RQID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNkLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzdGVyZW9NaWRzLFxuICAgICAgICAgIG5hY2tNaWRzXG4gICAgICAgIH0gPSBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKHNkKTtcbiAgICAgICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gc3RlcmVvTWlkcztcbiAgICAgICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IG5hY2tNaWRzO1xuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IHNkLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgICAgY29uc3QgbWlkID0gZ2V0TWlkU3RyaW5nKG1lZGlhLm1pZCk7XG4gICAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIC8vIG11bmdlIHNkcCBmb3Igb3B1cyBiaXRyYXRlIHNldHRpbmdzXG4gICAgICAgICAgICB0aGlzLnRyYWNrQml0cmF0ZXMuc29tZSh0cmFja2JyID0+IHtcbiAgICAgICAgICAgICAgaWYgKCF0cmFja2JyLnRyYW5zY2VpdmVyIHx8IG1pZCAhPSB0cmFja2JyLnRyYW5zY2VpdmVyLm1pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgY29kZWNQYXlsb2FkID0gMDtcbiAgICAgICAgICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocnRwLmNvZGVjLnRvVXBwZXJDYXNlKCkgPT09IHRyYWNrYnIuY29kZWMudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgY29kZWNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBmbXRwRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcbiAgICAgICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnID0gZm10cC5jb25maWcuc3BsaXQoJzsnKS5maWx0ZXIoYXR0ciA9PiAhYXR0ci5pbmNsdWRlcygnbWF4YXZlcmFnZWJpdHJhdGUnKSkuam9pbignOycpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrYnIubWF4YnIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO21heGF2ZXJhZ2ViaXRyYXRlPVwiLmNvbmNhdCh0cmFja2JyLm1heGJyICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbXRwRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZm10cEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrYnIubWF4YnIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBtZWRpYS5mbXRwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlY1BheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogXCJtYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtdW5nZWRTRFAgPSBsaWJFeHBvcnRzLndyaXRlKHNkcFBhcnNlZCk7XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChzZCwgbXVuZ2VkU0RQLCB0cnVlKTtcbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMuZm9yRWFjaChjYW5kaWRhdGUgPT4ge1xuICAgICAgICB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzID0gW107XG4gICAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnJlbmVnb3RpYXRlKSB7XG4gICAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSBmYWxzZTtcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUpO1xuICAgICAgICBpZiAoc2Quc2RwKSB7XG4gICAgICAgICAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZShzZC5zZHApO1xuICAgICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgbWVkaWEucnRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5vZmZlckxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMub25PZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIElDRScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGMgJiYgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xuICAgICAgICAgIC8vIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSBwZWVyIHRvIGFjY2VwdCBvdXIgb2ZmZXIsIHNvIHdlJ2xsIGp1c3Qgd2FpdFxuICAgICAgICAgIC8vIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIHdoZW4gSUNFIHJlc3RhcnQgaXMgbmVlZGVkXG4gICAgICAgICAgY29uc3QgY3VycmVudFNEID0gdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkgJiYgY3VycmVudFNEKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWQgYnV0IHdlIGRvbid0IGhhdmUgYSByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHRoZSBiZXN0IHRoaW5nIHRvIGRvIGlzIHRvIHJlY3JlYXRlIHRoZSBwZWVyY29ubmVjdGlvblxuICAgICAgICAgICAgeWllbGQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oY3VycmVudFNEKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wYyB8fCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgY3JlYXRlT2ZmZXIgd2l0aCBjbG9zZWQgcGVlciBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWN0dWFsbHkgbmVnb3RpYXRlXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdGFydGluZyB0byBuZWdvdGlhdGUnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgb2ZmZXIgaWQgYXQgdGhlIHN0YXJ0IHRvIGVuc3VyZSB0aGUgb2ZmZXIgaXMgYWx3YXlzID4gMCBzbyB0aGF0IHdlIGNhbiB1c2UgMCBhcyBhIGRlZmF1bHQgdmFsdWUgZm9yIGxlZ2FjeSBiZWhhdmlvclxuICAgICAgICBjb25zdCBvZmZlcklkID0gdGhpcy5sYXRlc3RPZmZlcklkICsgMTtcbiAgICAgICAgdGhpcy5sYXRlc3RPZmZlcklkID0gb2ZmZXJJZDtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB5aWVsZCB0aGlzLnBjLmNyZWF0ZU9mZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnb3JpZ2luYWwgb2ZmZXInLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBzZHA6IG9mZmVyLnNkcFxuICAgICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZSgoX2EgPSBvZmZlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICAgIGVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbihtZWRpYSk7XG4gICAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgWydhbGwnXSwgW10pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUodHJhY2ticiA9PiB7XG4gICAgICAgICAgICAgIGlmICghbWVkaWEubXNpZCB8fCAhdHJhY2tici5jaWQgfHwgIW1lZGlhLm1zaWQuaW5jbHVkZXModHJhY2tici5jaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xuICAgICAgICAgICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChydHAuY29kZWMudG9VcHBlckNhc2UoKSA9PT0gdHJhY2tici5jb2RlYy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY29kZWNQYXlsb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU1ZDQ29kZWModHJhY2tici5jb2RlYykgJiYgIWlzU2FmYXJpKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEsIHNkcFBhcnNlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIGJpdHJhdGUgc2V0dGluZyB0aGF0IGNhbid0IGFwcGx5IGJ5IHNlbmRFbmNvZGluZ1xuICAgICAgICAgICAgICBpZiAoIWlzU1ZDQ29kZWModHJhY2tici5jb2RlYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzdGFydEJpdHJhdGUgPSBNYXRoLnJvdW5kKHRyYWNrYnIubWF4YnIgKiBzdGFydEJpdHJhdGVGb3JTVkMpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xuICAgICAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgYW5vdGhlciB0cmFjaydzIGZtdHAgYWxyZWFkeSBpcyBzZXQsIHdlIGNhbm5vdCBvdmVycmlkZSB0aGUgYml0cmF0ZVxuICAgICAgICAgICAgICAgICAgLy8gdGhpcyBoYXMgdGhlIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nIGZvcmNlZCB0byB1c2UgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHRyYWNrJ3MgYml0cmF0ZSBmb3IgYWxsIHRyYWNrc1xuICAgICAgICAgICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygneC1nb29nbGUtc3RhcnQtYml0cmF0ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9XCIuY29uY2F0KHN0YXJ0Qml0cmF0ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RPZmZlcklkID4gb2ZmZXJJZCkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2xhdGVzdE9mZmVySWQgbWlzbWF0Y2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGxhdGVzdE9mZmVySWQ6IHRoaXMubGF0ZXN0T2ZmZXJJZCxcbiAgICAgICAgICAgIG9mZmVySWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKG9mZmVyLCBsaWJFeHBvcnRzLndyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgICB0aGlzLm9uT2ZmZXIob2ZmZXIsIHRoaXMubGF0ZXN0T2ZmZXJJZCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBbmRTZXRBbnN3ZXIoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IGFuc3dlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhKTtcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIHRoaXMucmVtb3RlU3RlcmVvTWlkcywgdGhpcy5yZW1vdGVOYWNrTWlkcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAoYW5zd2VyLCBsaWJFeHBvcnRzLndyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cbiAgYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRUcmFuc2NlaXZlck9mS2luZChraW5kLCB0cmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wYy5hZGRUcmFuc2NlaXZlcihraW5kLCB0cmFuc2NlaXZlckluaXQpO1xuICB9XG4gIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGFkZCB0cmFjaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2spO1xuICB9XG4gIHNldFRyYWNrQ29kZWNCaXRyYXRlKGluZm8pIHtcbiAgICB0aGlzLnRyYWNrQml0cmF0ZXMucHVzaChpbmZvKTtcbiAgfVxuICBzZXRDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgY2xvc2VkLCBjYW5ub3QgY29uZmlndXJlJyk7XG4gICAgfVxuICAgIHJldHVybiAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcbiAgfVxuICBjYW5SZW1vdmVUcmFjaygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlVHJhY2spO1xuICB9XG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG4gIGdldENvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWNlQ29ubmVjdGlvblN0YXRlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnY2xvc2VkJztcbiAgfVxuICBnZXRTaWduYWxsaW5nU3RhdGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWduYWxpbmdTdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0VHJhbnNjZWl2ZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICB9XG4gIGdldFNlbmRlcnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTZW5kZXJzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICB9XG4gIGdldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsRGVzY3JpcHRpb247XG4gIH1cbiAgZ2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnBjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlRGVzY3JpcHRpb247XG4gIH1cbiAgZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGMuZ2V0U3RhdHMoKTtcbiAgfVxuICBnZXRDb25uZWN0ZWRBZGRyZXNzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9ICcnO1xuICAgICAgY29uc3QgY2FuZGlkYXRlUGFpcnMgPSBuZXcgTWFwKCk7XG4gICAgICAvLyBpZCAtPiBjYW5kaWRhdGUgaXBcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBzd2l0Y2ggKHYudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3RyYW5zcG9ydCc6XG4gICAgICAgICAgICBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9IHYuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjYW5kaWRhdGUtcGFpcic6XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPT09ICcnICYmIHYuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FuZGlkYXRlUGFpcnMuc2V0KHYuaWQsIHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmVtb3RlLWNhbmRpZGF0ZSc6XG4gICAgICAgICAgICBjYW5kaWRhdGVzLnNldCh2LmlkLCBcIlwiLmNvbmNhdCh2LmFkZHJlc3MsIFwiOlwiKS5jb25jYXQodi5wb3J0KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RlZElEID0gKF9hID0gY2FuZGlkYXRlUGFpcnMuZ2V0KHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW90ZUNhbmRpZGF0ZUlkO1xuICAgICAgaWYgKHNlbGVjdGVkSUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXMuZ2V0KHNlbGVjdGVkSUQpO1xuICAgIH0pO1xuICB9XG4gIHNldE11bmdlZFNEUChzZCwgbXVuZ2VkLCByZW1vdGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKG11bmdlZCkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFNkcCA9IHNkLnNkcDtcbiAgICAgICAgc2Quc2RwID0gbXVuZ2VkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBtdW5nZWQgXCIuY29uY2F0KHJlbW90ZSA/ICdyZW1vdGUnIDogJ2xvY2FsJywgXCIgZGVzY3JpcHRpb25cIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgaWYgKHJlbW90ZSkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJub3QgYWJsZSB0byBzZXQgXCIuY29uY2F0KHNkLnR5cGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gdW5tb2RpZmllZCBzZHBcIiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICBzZHA6IG11bmdlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBzZC5zZHAgPSBvcmlnaW5hbFNkcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlbW90ZSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbGV0IG1zZyA9ICd1bmtub3duIGVycm9yJztcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG1zZyA9IGUubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBtc2cgPSBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHtcbiAgICAgICAgICBlcnJvcjogbXNnLFxuICAgICAgICAgIHNkcDogc2Quc2RwXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmVtb3RlICYmIHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICBmaWVsZHMucmVtb3RlU2RwID0gdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5lcnJvcihcInVuYWJsZSB0byBzZXQgXCIuY29uY2F0KHNkLnR5cGUpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBmaWVsZHNcbiAgICAgICAgfSkpO1xuICAgICAgICB0aHJvdyBuZXcgTmVnb3RpYXRpb25FcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEsIHNkcCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGRGb3VuZCA9IChfYSA9IG1lZGlhLmV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZXh0ID0+IHtcbiAgICAgIGlmIChleHQudXJpID09PSBkZEV4dGVuc2lvblVSSSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICBpZiAoIWRkRm91bmQpIHtcbiAgICAgIGlmICh0aGlzLmRkRXh0SUQgPT09IDApIHtcbiAgICAgICAgbGV0IG1heElEID0gMDtcbiAgICAgICAgc2RwLm1lZGlhLmZvckVhY2gobSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmIChtLnR5cGUgIT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9hID0gbS5leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKGV4dCA9PiB7XG4gICAgICAgICAgICBpZiAoZXh0LnZhbHVlID4gbWF4SUQpIHtcbiAgICAgICAgICAgICAgbWF4SUQgPSBleHQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRkRXh0SUQgPSBtYXhJRCArIDE7XG4gICAgICB9XG4gICAgICAoX2IgPSBtZWRpYS5leHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZGRFeHRJRCxcbiAgICAgICAgdXJpOiBkZEV4dGVuc2lvblVSSVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIHN0ZXJlb01pZHMsIG5hY2tNaWRzKSB7XG4gIC8vIHNkcC10cmFuc2Zvcm0gdHlwZXMgZG9uJ3QgaW5jbHVkZSBudW1iZXIgaG93ZXZlciB0aGUgcGFyc2VyIG91dHB1dHMgbWlkcyBhcyBudW1iZXJzIGluIHNvbWUgY2FzZXNcbiAgY29uc3QgbWlkID0gZ2V0TWlkU3RyaW5nKG1lZGlhLm1pZCk7XG4gIC8vIGZvdW5kIG9wdXMgY29kZWMgdG8gYWRkIG5hY2sgZmJcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcbiAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICBpZiAocnRwLmNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgIG9wdXNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgLy8gYWRkIG5hY2sgcnRjcGZiIGlmIG5vdCBleGlzdFxuICBpZiAob3B1c1BheWxvYWQgPiAwKSB7XG4gICAgaWYgKCFtZWRpYS5ydGNwRmIpIHtcbiAgICAgIG1lZGlhLnJ0Y3BGYiA9IFtdO1xuICAgIH1cbiAgICBpZiAobmFja01pZHMuaW5jbHVkZXMobWlkKSAmJiAhbWVkaWEucnRjcEZiLnNvbWUoZmIgPT4gZmIucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQgJiYgZmIudHlwZSA9PT0gJ25hY2snKSkge1xuICAgICAgbWVkaWEucnRjcEZiLnB1c2goe1xuICAgICAgICBwYXlsb2FkOiBvcHVzUGF5bG9hZCxcbiAgICAgICAgdHlwZTogJ25hY2snXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0ZXJlb01pZHMuaW5jbHVkZXMobWlkKSB8fCBzdGVyZW9NaWRzLmxlbmd0aCA9PT0gMSAmJiBzdGVyZW9NaWRzWzBdID09PSAnYWxsJykge1xuICAgICAgbWVkaWEuZm10cC5zb21lKGZtdHAgPT4ge1xuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xuICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3N0ZXJlbz0xJykpIHtcbiAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7c3RlcmVvPTEnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIob2ZmZXIpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBzdGVyZW9NaWRzID0gW107XG4gIGNvbnN0IG5hY2tNaWRzID0gW107XG4gIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gb2ZmZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gIGxldCBvcHVzUGF5bG9hZCA9IDA7XG4gIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWlkID0gZ2V0TWlkU3RyaW5nKG1lZGlhLm1pZCk7XG4gICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgICAgIGlmIChydHAuY29kZWMgPT09ICdvcHVzJykge1xuICAgICAgICAgIG9wdXNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBpZiAoKF9hID0gbWVkaWEucnRjcEZiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZShmYiA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpKSB7XG4gICAgICAgIG5hY2tNaWRzLnB1c2gobWlkKTtcbiAgICAgIH1cbiAgICAgIG1lZGlhLmZtdHAuc29tZShmbXRwID0+IHtcbiAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQpIHtcbiAgICAgICAgICBpZiAoZm10cC5jb25maWcuaW5jbHVkZXMoJ3Nwcm9wLXN0ZXJlbz0xJykpIHtcbiAgICAgICAgICAgIHN0ZXJlb01pZHMucHVzaChtaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0ZXJlb01pZHMsXG4gICAgbmFja01pZHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbihtZWRpYSkge1xuICAvLyBDaHJvbWUgY291bGQgZ2VuZXJhdGUgc2RwIHdpdGggYyA9IElOIElQNCA8aXB2NiBhZGRyPlxuICAvLyBpbiBlZGdlIGNhc2UgYW5kIHJldHVybiBlcnJvciB3aGVuIHNldCBzZHAuVGhpcyBpcyBub3QgYVxuICAvLyBzZGsgZXJyb3IgYnV0IGNvcnJlY3QgaXQgaWYgdGhlIGlzc3VlIGRldGVjdGVkLlxuICBpZiAobWVkaWEuY29ubmVjdGlvbikge1xuICAgIGNvbnN0IGlzVjYgPSBtZWRpYS5jb25uZWN0aW9uLmlwLmluZGV4T2YoJzonKSA+PSAwO1xuICAgIGlmIChtZWRpYS5jb25uZWN0aW9uLnZlcnNpb24gPT09IDQgJiYgaXNWNiB8fCBtZWRpYS5jb25uZWN0aW9uLnZlcnNpb24gPT09IDYgJiYgIWlzVjYpIHtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIGR1bW15IGFkZHJlc3NcbiAgICAgIG1lZGlhLmNvbm5lY3Rpb24uaXAgPSAnMC4wLjAuMCc7XG4gICAgICBtZWRpYS5jb25uZWN0aW9uLnZlcnNpb24gPSA0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWlkU3RyaW5nKG1pZCkge1xuICByZXR1cm4gdHlwZW9mIG1pZCA9PT0gJ251bWJlcicgPyBtaWQudG9GaXhlZCgwKSA6IG1pZDtcbn1cblxuY29uc3QgZGVmYXVsdFZpZGVvQ29kZWMgPSAndnA4JztcbmNvbnN0IHB1Ymxpc2hEZWZhdWx0cyA9IHtcbiAgYXVkaW9QcmVzZXQ6IEF1ZGlvUHJlc2V0cy5tdXNpYyxcbiAgZHR4OiB0cnVlLFxuICByZWQ6IHRydWUsXG4gIGZvcmNlU3RlcmVvOiBmYWxzZSxcbiAgc2ltdWxjYXN0OiB0cnVlLFxuICBzY3JlZW5TaGFyZUVuY29kaW5nOiBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMxNS5lbmNvZGluZyxcbiAgc3RvcE1pY1RyYWNrT25NdXRlOiBmYWxzZSxcbiAgdmlkZW9Db2RlYzogZGVmYXVsdFZpZGVvQ29kZWMsXG4gIGJhY2t1cENvZGVjOiB0cnVlLFxuICBwcmVDb25uZWN0QnVmZmVyOiBmYWxzZVxufTtcbmNvbnN0IGF1ZGlvRGVmYXVsdHMgPSB7XG4gIGRldmljZUlkOiB7XG4gICAgaWRlYWw6ICdkZWZhdWx0J1xuICB9LFxuICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gIHZvaWNlSXNvbGF0aW9uOiB0cnVlXG59O1xuY29uc3QgdmlkZW9EZWZhdWx0cyA9IHtcbiAgZGV2aWNlSWQ6IHtcbiAgICBpZGVhbDogJ2RlZmF1bHQnXG4gIH0sXG4gIHJlc29sdXRpb246IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb25cbn07XG5jb25zdCByb29tT3B0aW9uRGVmYXVsdHMgPSB7XG4gIGFkYXB0aXZlU3RyZWFtOiBmYWxzZSxcbiAgZHluYWNhc3Q6IGZhbHNlLFxuICBzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoOiB0cnVlLFxuICByZWNvbm5lY3RQb2xpY3k6IG5ldyBEZWZhdWx0UmVjb25uZWN0UG9saWN5KCksXG4gIGRpc2Nvbm5lY3RPblBhZ2VMZWF2ZTogdHJ1ZSxcbiAgd2ViQXVkaW9NaXg6IGZhbHNlLFxuICBzaW5nbGVQZWVyQ29ubmVjdGlvbjogZmFsc2Vcbn07XG5jb25zdCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzID0ge1xuICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICBtYXhSZXRyaWVzOiAxLFxuICBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IDE1MDAwLFxuICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxufTtcblxudmFyIFBDVHJhbnNwb3J0U3RhdGU7XG4oZnVuY3Rpb24gKFBDVHJhbnNwb3J0U3RhdGUpIHtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiTkVXXCJdID0gMF0gPSBcIk5FV1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMV0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ09OTkVDVEVEXCJdID0gMl0gPSBcIkNPTk5FQ1RFRFwiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJGQUlMRURcIl0gPSAzXSA9IFwiRkFJTEVEXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNMT1NJTkdcIl0gPSA0XSA9IFwiQ0xPU0lOR1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDTE9TRURcIl0gPSA1XSA9IFwiQ0xPU0VEXCI7XG59KShQQ1RyYW5zcG9ydFN0YXRlIHx8IChQQ1RyYW5zcG9ydFN0YXRlID0ge30pKTtcbmNsYXNzIFBDVHJhbnNwb3J0TWFuYWdlciB7XG4gIGdldCBuZWVkc1B1Ymxpc2hlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuICBnZXQgbmVlZHNTdWJzY3JpYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG4gIGNvbnN0cnVjdG9yKHJ0Y0NvbmZpZywgbW9kZSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCA9IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlcyA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzLm1hcCh0ciA9PiB0ci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XG4gICAgICBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ2Nvbm5lY3RlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnZmFpbGVkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjb25uZWN0aW5nJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVElORztcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ2Nsb3NlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NFRDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0lORztcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ25ldycpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwicGMgc3RhdGUgY2hhbmdlOiBmcm9tIFwiLmNvbmNhdChQQ1RyYW5zcG9ydFN0YXRlW3ByZXZpb3VzU3RhdGVdLCBcIiB0byBcIikuY29uY2F0KFBDVHJhbnNwb3J0U3RhdGVbdGhpcy5zdGF0ZV0pLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAoX2EgPSB0aGlzLm9uU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMuc3RhdGUsIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpLCAoX2IgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBDTWFuYWdlcik7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkID0gbW9kZSAhPT0gJ3N1YnNjcmliZXItcHJpbWFyeSc7XG4gICAgdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgPSBtb2RlID09PSAnc3Vic2NyaWJlci1wcmltYXJ5JztcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcsIGxvZ2dlck9wdGlvbnMpO1xuICAgIGlmIChtb2RlICE9PSAncHVibGlzaGVyLW9ubHknKSB7XG4gICAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgUENUcmFuc3BvcnQocnRjQ29uZmlnLCBsb2dnZXJPcHRpb25zKTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlID0gY2FuZGlkYXRlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICAgIH07XG4gICAgICAvLyBpbiBzdWJzY3JpYmVyIHByaW1hcnkgbW9kZSwgc2VydmVyIHNpZGUgb3BlbnMgc3ViIGRhdGEgY2hhbm5lbHMuXG4gICAgICB0aGlzLnN1YnNjcmliZXIub25EYXRhQ2hhbm5lbCA9IGV2ID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLm9uRGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnN1YnNjcmliZXIub25UcmFjayA9IGV2ID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMucHVibGlzaGVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDYW5kaWRhdGUgPSBjYW5kaWRhdGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgY2FuZGlkYXRlLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICB9O1xuICAgIHRoaXMucHVibGlzaGVyLm9uVHJhY2sgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHRoaXMucHVibGlzaGVyLm9uT2ZmZXIgPSAob2ZmZXIsIG9mZmVySWQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25QdWJsaXNoZXJPZmZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgb2ZmZXIsIG9mZmVySWQpO1xuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMucmVtb3RlT2ZmZXJMb2NrID0gbmV3IF8oKTtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgfVxuICByZXF1aXJlUHVibGlzaGVyKCkge1xuICAgIGxldCByZXF1aXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuICBjcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVBbmRTZW5kT2ZmZXIob3B0aW9ucyk7XG4gIH1cbiAgc2V0UHVibGlzaGVyQW5zd2VyKHNkLCBvZmZlcklkKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkLCBvZmZlcklkKTtcbiAgfVxuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMucHVibGlzaGVyICYmIHRoaXMucHVibGlzaGVyLmdldFNpZ25hbGxpbmdTdGF0ZSgpICE9PSAnY2xvc2VkJykge1xuICAgICAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLnB1Ymxpc2hlcjtcbiAgICAgICAgZm9yIChjb25zdCBzZW5kZXIgb2YgcHVibGlzaGVyLmdldFNlbmRlcnMoKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZWFjdC1uYXRpdmUtd2VicnRjIGRvZXNuJ3QgaGF2ZSByZW1vdmVUcmFjayB5ZXQuXG4gICAgICAgICAgICBpZiAocHVibGlzaGVyLmNhblJlbW92ZVRyYWNrKCkpIHtcbiAgICAgICAgICAgICAgcHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHJlbW92ZVRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5wdWJsaXNoZXIuY2xvc2UoKSwgKF9hID0gdGhpcy5zdWJzY3JpYmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKV0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIHRyaWdnZXJJY2VSZXN0YXJ0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgcmVzdGFydCBwdWJsaXNoZXIgaWYgaXQncyBuZWVkZWRcbiAgICAgIGlmICh0aGlzLm5lZWRzUHVibGlzaGVyKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKHtcbiAgICAgICAgICBpY2VSZXN0YXJ0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgKF9hID0gdGhpcy5zdWJzY3JpYmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCwgb2ZmZXJJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgb2ZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgUlRDU2RwVHlwZTogc2QudHlwZSxcbiAgICAgICAgc2RwOiBzZC5zZHAsXG4gICAgICAgIHNpZ25hbGluZ1N0YXRlOiAoX2EgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTaWduYWxsaW5nU3RhdGUoKS50b1N0cmluZygpXG4gICAgICB9KSk7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnJlbW90ZU9mZmVyTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0geWllbGQgKF9iID0gdGhpcy5zdWJzY3JpYmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QsIG9mZmVySWQpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuc3dlciB0aGUgb2ZmZXJcbiAgICAgICAgY29uc3QgYW5zd2VyID0geWllbGQgKF9jID0gdGhpcy5zdWJzY3JpYmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3JlYXRlQW5kU2V0QW5zd2VyKCk7XG4gICAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZywgaWNlUmVzdGFydCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLnB1Ymxpc2hlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgKF9hID0gdGhpcy5zdWJzY3JpYmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Q29uZmlndXJhdGlvbihjb25maWcpO1xuICAgIGlmIChpY2VSZXN0YXJ0KSB7XG4gICAgICB0aGlzLnRyaWdnZXJJY2VSZXN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIGVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RlZCcgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCduZWdvdGlhdGlvbiByZXF1aXJlZCwgc3RhcnQgbmVnb3RpYXRpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKChfYSA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKHRyYW5zcG9ydCA9PiB0aGlzLmVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZCh0cmFuc3BvcnQsIGFib3J0Q29udHJvbGxlciwgdGltZW91dCkpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5lZ290aWF0ZShhYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbmVnb3RpYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KCduZWdvdGlhdGlvbiB0aW1lZCBvdXQnKTtcbiAgICAgICAgfSwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG5lZ290aWF0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KCduZWdvdGlhdGlvbiBhYm9ydGVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCwgKCkgPT4ge1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZShlID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrLCB0cmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cbiAgYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXJPZktpbmQoa2luZCwgdHJhbnNjZWl2ZXJJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmFkZFRyYW5zY2VpdmVyT2ZLaW5kKGtpbmQsIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cbiAgZ2V0TWlkRm9yUmVjZWl2ZXIocmVjZWl2ZXIpIHtcbiAgICBjb25zdCB0cmFuc2NlaXZlcnMgPSB0aGlzLnN1YnNjcmliZXIgPyB0aGlzLnN1YnNjcmliZXIuZ2V0VHJhbnNjZWl2ZXJzKCkgOiB0aGlzLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKTtcbiAgICBjb25zdCBtYXRjaGluZ1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXJzLmZpbmQodHJhbnNjZWl2ZXIgPT4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIgPT09IHJlY2VpdmVyKTtcbiAgICByZXR1cm4gbWF0Y2hpbmdUcmFuc2NlaXZlciA9PT0gbnVsbCB8fCBtYXRjaGluZ1RyYW5zY2VpdmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaGluZ1RyYW5zY2VpdmVyLm1pZDtcbiAgfVxuICBhZGRQdWJsaXNoZXJUcmFjayh0cmFjaykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFjayh0cmFjayk7XG4gIH1cbiAgY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgcmVxdWlyZWQgdHJhbnNwb3J0J3MgYWRkcmVzcyBpZiBubyBleHBsaWNpdCB0YXJnZXQgaXMgc3BlY2lmaWVkXG4gICAqL1xuICBnZXRDb25uZWN0ZWRBZGRyZXNzKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHNbMF0uZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICB9XG4gIGdldCByZXF1aXJlZFRyYW5zcG9ydHMoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0cyA9IFtdO1xuICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5wdWJsaXNoZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgJiYgdGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5zdWJzY3JpYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gIH1cbiAgZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHBjVHJhbnNwb3J0XzEsIGFib3J0Q29udHJvbGxlcl8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHBjVHJhbnNwb3J0LCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlID0gcGNUcmFuc3BvcnQuZ2V0Q29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2Fib3J0IHRyYW5zcG9ydCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignY291bGQgbm90IGVzdGFibGlzaCBwYyBjb25uZWN0aW9uJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5zdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTsgLy8gRklYTUUgd2Ugc2hvdWxkbid0IHJlbHkgb24gYHNsZWVwYCBpbiB0aGUgY29ubmVjdGlvbiBwYXRocywgYXMgaXQgaW52b2tlcyBgc2V0VGltZW91dGAgd2hpY2ggY2FuIGJlIGRyYXN0aWNhbGx5IHRocm90dGxlZCBieSBicm93c2VyIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IERFRkFVTFRfTUFYX0FHRV9NUyA9IDUwMDA7XG5jb25zdCBTVE9QX1JFRkVUQ0hfREVMQVlfTVMgPSAzMDAwMDtcbmNsYXNzIFJlZ2lvblVybFByb3ZpZGVyIHtcbiAgc3RhdGljIGZldGNoUmVnaW9uU2V0dGluZ3Moc2VydmVyVXJsLCB0b2tlbiwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIFJlZ2lvblVybFByb3ZpZGVyLmZldGNoTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlID0geWllbGQgZmV0Y2goXCJcIi5jb25jYXQoZ2V0Q2xvdWRDb25maWdVcmwoc2VydmVyVXJsKSwgXCIvcmVnaW9uc1wiKSwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiLmNvbmNhdCh0b2tlbilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlZ2lvblNldHRpbmdzUmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBtYXhBZ2UgPSBleHRyYWN0TWF4QWdlRnJvbVJlcXVlc3RIZWFkZXJzKHJlZ2lvblNldHRpbmdzUmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgY29uc3QgbWF4QWdlSW5NcyA9IG1heEFnZSA/IG1heEFnZSAqIDEwMDAgOiBERUZBVUxUX01BWF9BR0VfTVM7XG4gICAgICAgICAgY29uc3QgcmVnaW9uU2V0dGluZ3MgPSB5aWVsZCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVnaW9uU2V0dGluZ3MsXG4gICAgICAgICAgICB1cGRhdGVkQXRJbk1zOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgbWF4QWdlSW5Nc1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIkNvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3M6IFwiLmNvbmNhdChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1c1RleHQpLCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1cyA9PT0gNDAxID8gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgOiBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvciwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgICAgLy8gcmV0aHJvdyBjb25uZWN0aW9uIGVycm9yc1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiUmVnaW9uIGZldGNoaW5nIHdhcyBhYm9ydGVkXCIsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdyYXAgb3RoZXIgZXJyb3JzIGFzIGNvbm5lY3Rpb24gZXJyb3JzIChlLmcuIHRpbWVvdXRzKVxuICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzLCBcIi5jb25jYXQoZSBpbnN0YW5jZW9mIEVycm9yID8gXCJcIi5jb25jYXQoZS5uYW1lLCBcIjogXCIpLmNvbmNhdChlLm1lc3NhZ2UpIDogZSksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHNjaGVkdWxlUmVmZXRjaCh1cmwsIHRva2VuLCBtYXhBZ2VJbk1zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBSZWdpb25VcmxQcm92aWRlci5zZXR0aW5nc1RpbWVvdXRzLmdldCh1cmwuaG9zdG5hbWUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgUmVnaW9uVXJsUHJvdmlkZXIuc2V0dGluZ3NUaW1lb3V0cy5zZXQodXJsLmhvc3RuYW1lLCBzZXRUaW1lb3V0KCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IHlpZWxkIFJlZ2lvblVybFByb3ZpZGVyLmZldGNoUmVnaW9uU2V0dGluZ3ModXJsLCB0b2tlbik7XG4gICAgICAgICAgUmVnaW9uVXJsUHJvdmlkZXIudXBkYXRlQ2FjaGVkUmVnaW9uU2V0dGluZ3ModXJsLCB0b2tlbiwgbmV3U2V0dGluZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd0b2tlbiBpcyBub3QgdmFsaWQsIGNhbmNlbGxpbmcgYXV0byByZWdpb24gcmVmcmVzaCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdhdXRvIHJlZmV0Y2hpbmcgb2YgcmVnaW9uIHNldHRpbmdzIGZhaWxlZCcsIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gY29udGludWUgcmV0cnlpbmcgd2l0aCB0aGUgc2FtZSBtYXggYWdlXG4gICAgICAgICAgUmVnaW9uVXJsUHJvdmlkZXIuc2NoZWR1bGVSZWZldGNoKHVybCwgdG9rZW4sIG1heEFnZUluTXMpO1xuICAgICAgICB9XG4gICAgICB9KSwgbWF4QWdlSW5NcykpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVDYWNoZWRSZWdpb25TZXR0aW5ncyh1cmwsIHRva2VuLCBzZXR0aW5ncykge1xuICAgIFJlZ2lvblVybFByb3ZpZGVyLmNhY2hlLnNldCh1cmwuaG9zdG5hbWUsIHNldHRpbmdzKTtcbiAgICBSZWdpb25VcmxQcm92aWRlci5zY2hlZHVsZVJlZmV0Y2godXJsLCB0b2tlbiwgc2V0dGluZ3MubWF4QWdlSW5Ncyk7XG4gIH1cbiAgc3RhdGljIHN0b3BSZWZldGNoKGhvc3RuYW1lKSB7XG4gICAgY29uc3QgdGltZW91dCA9IFJlZ2lvblVybFByb3ZpZGVyLnNldHRpbmdzVGltZW91dHMuZ2V0KGhvc3RuYW1lKTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgUmVnaW9uVXJsUHJvdmlkZXIuc2V0dGluZ3NUaW1lb3V0cy5kZWxldGUoaG9zdG5hbWUpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgc2NoZWR1bGVDbGVhbnVwKGhvc3RuYW1lKSB7XG4gICAgbGV0IHRyYWNrZXIgPSBSZWdpb25VcmxQcm92aWRlci5jb25uZWN0aW9uVHJhY2tlcnMuZ2V0KGhvc3RuYW1lKTtcbiAgICBpZiAoIXRyYWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2FuY2VsIGFueSBleGlzdGluZyBjbGVhbnVwIHRpbWVvdXRcbiAgICBpZiAodHJhY2tlci5jbGVhbnVwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyYWNrZXIuY2xlYW51cFRpbWVvdXQpO1xuICAgIH1cbiAgICAvLyBTY2hlZHVsZSBjbGVhbnVwIHRvIHN0b3AgcmVmZXRjaCBhZnRlciBkZWxheVxuICAgIHRyYWNrZXIuY2xlYW51cFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFja2VyID0gUmVnaW9uVXJsUHJvdmlkZXIuY29ubmVjdGlvblRyYWNrZXJzLmdldChob3N0bmFtZSk7XG4gICAgICBpZiAoY3VycmVudFRyYWNrZXIgJiYgY3VycmVudFRyYWNrZXIuY29ubmVjdGlvbkNvdW50ID09PSAwKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3N0b3BwaW5nIHJlZ2lvbiByZWZldGNoIGFmdGVyIGRpc2Nvbm5lY3QgZGVsYXknLCB7XG4gICAgICAgICAgaG9zdG5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJlZ2lvblVybFByb3ZpZGVyLnN0b3BSZWZldGNoKGhvc3RuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VHJhY2tlcikge1xuICAgICAgICBjdXJyZW50VHJhY2tlci5jbGVhbnVwVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCBTVE9QX1JFRkVUQ0hfREVMQVlfTVMpO1xuICB9XG4gIHN0YXRpYyBjYW5jZWxDbGVhbnVwKGhvc3RuYW1lKSB7XG4gICAgY29uc3QgdHJhY2tlciA9IFJlZ2lvblVybFByb3ZpZGVyLmNvbm5lY3Rpb25UcmFja2Vycy5nZXQoaG9zdG5hbWUpO1xuICAgIGlmICh0cmFja2VyID09PSBudWxsIHx8IHRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrZXIuY2xlYW51cFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFja2VyLmNsZWFudXBUaW1lb3V0KTtcbiAgICAgIHRyYWNrZXIuY2xlYW51cFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIG5vdGlmeUNvbm5lY3RlZCgpIHtcbiAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuc2VydmVyVXJsLmhvc3RuYW1lO1xuICAgIGxldCB0cmFja2VyID0gUmVnaW9uVXJsUHJvdmlkZXIuY29ubmVjdGlvblRyYWNrZXJzLmdldChob3N0bmFtZSk7XG4gICAgaWYgKCF0cmFja2VyKSB7XG4gICAgICB0cmFja2VyID0ge1xuICAgICAgICBjb25uZWN0aW9uQ291bnQ6IDBcbiAgICAgIH07XG4gICAgICBSZWdpb25VcmxQcm92aWRlci5jb25uZWN0aW9uVHJhY2tlcnMuc2V0KGhvc3RuYW1lLCB0cmFja2VyKTtcbiAgICB9XG4gICAgdHJhY2tlci5jb25uZWN0aW9uQ291bnQrKztcbiAgICAvLyBDYW5jZWwgYW55IHNjaGVkdWxlZCBjbGVhbnVwIHNpbmNlIHdlIGhhdmUgYW4gYWN0aXZlIGNvbm5lY3Rpb25cbiAgICBSZWdpb25VcmxQcm92aWRlci5jYW5jZWxDbGVhbnVwKGhvc3RuYW1lKTtcbiAgfVxuICBub3RpZnlEaXNjb25uZWN0ZWQoKSB7XG4gICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLnNlcnZlclVybC5ob3N0bmFtZTtcbiAgICBjb25zdCB0cmFja2VyID0gUmVnaW9uVXJsUHJvdmlkZXIuY29ubmVjdGlvblRyYWNrZXJzLmdldChob3N0bmFtZSk7XG4gICAgaWYgKCF0cmFja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrZXIuY29ubmVjdGlvbkNvdW50ID0gTWF0aC5tYXgoMCwgdHJhY2tlci5jb25uZWN0aW9uQ291bnQgLSAxKTtcbiAgICAvLyBJZiBubyBtb3JlIGNvbm5lY3Rpb25zLCBzY2hlZHVsZSBjbGVhbnVwXG4gICAgaWYgKHRyYWNrZXIuY29ubmVjdGlvbkNvdW50ID09PSAwKSB7XG4gICAgICBSZWdpb25VcmxQcm92aWRlci5zY2hlZHVsZUNsZWFudXAoaG9zdG5hbWUpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zID0gW107XG4gICAgdGhpcy5zZXJ2ZXJVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIHVwZGF0ZVRva2VuKHRva2VuKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIGlzQ2xvdWQoKSB7XG4gICAgcmV0dXJuIGlzQ2xvdWQodGhpcy5zZXJ2ZXJVcmwpO1xuICB9XG4gIGdldFNlcnZlclVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmZXRjaFJlZ2lvblNldHRpbmdzKGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBSZWdpb25VcmxQcm92aWRlci5mZXRjaFJlZ2lvblNldHRpbmdzKHRoaXMuc2VydmVyVXJsLCB0aGlzLnRva2VuLCBhYm9ydFNpZ25hbCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dEJlc3RSZWdpb25VcmwoYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQ2xvdWQoKSkge1xuICAgICAgICB0aHJvdyBFcnJvcigncmVnaW9uIGF2YWlsYWJpbGl0eSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgTGl2ZUtpdCBDbG91ZCBkb21haW5zJyk7XG4gICAgICB9XG4gICAgICBsZXQgY2FjaGVkU2V0dGluZ3MgPSBSZWdpb25VcmxQcm92aWRlci5jYWNoZS5nZXQodGhpcy5zZXJ2ZXJVcmwuaG9zdG5hbWUpO1xuICAgICAgaWYgKCFjYWNoZWRTZXR0aW5ncyB8fCBEYXRlLm5vdygpIC0gY2FjaGVkU2V0dGluZ3MudXBkYXRlZEF0SW5NcyA+IGNhY2hlZFNldHRpbmdzLm1heEFnZUluTXMpIHtcbiAgICAgICAgY2FjaGVkU2V0dGluZ3MgPSB5aWVsZCB0aGlzLmZldGNoUmVnaW9uU2V0dGluZ3MoYWJvcnRTaWduYWwpO1xuICAgICAgICBSZWdpb25VcmxQcm92aWRlci51cGRhdGVDYWNoZWRSZWdpb25TZXR0aW5ncyh0aGlzLnNlcnZlclVybCwgdGhpcy50b2tlbiwgY2FjaGVkU2V0dGluZ3MpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaW9uc0xlZnQgPSBjYWNoZWRTZXR0aW5ncy5yZWdpb25TZXR0aW5ncy5yZWdpb25zLmZpbHRlcihyZWdpb24gPT4gIXRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5maW5kKGF0dGVtcHRlZCA9PiBhdHRlbXB0ZWQudXJsID09PSByZWdpb24udXJsKSk7XG4gICAgICBpZiAocmVnaW9uc0xlZnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0UmVnaW9uID0gcmVnaW9uc0xlZnRbMF07XG4gICAgICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5wdXNoKG5leHRSZWdpb24pO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwibmV4dCByZWdpb246IFwiLmNvbmNhdChuZXh0UmVnaW9uLnJlZ2lvbikpO1xuICAgICAgICByZXR1cm4gbmV4dFJlZ2lvbi51cmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXNldEF0dGVtcHRzKCkge1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xuICB9XG4gIHNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhzZXR0aW5ncykge1xuICAgIFJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZUNhY2hlZFJlZ2lvblNldHRpbmdzKHRoaXMuc2VydmVyVXJsLCB0aGlzLnRva2VuLCBzZXR0aW5ncyk7XG4gIH1cbn1cblJlZ2lvblVybFByb3ZpZGVyLmNhY2hlID0gbmV3IE1hcCgpO1xuUmVnaW9uVXJsUHJvdmlkZXIuc2V0dGluZ3NUaW1lb3V0cyA9IG5ldyBNYXAoKTtcblJlZ2lvblVybFByb3ZpZGVyLmNvbm5lY3Rpb25UcmFja2VycyA9IG5ldyBNYXAoKTtcblJlZ2lvblVybFByb3ZpZGVyLmZldGNoTG9jayA9IG5ldyBfKCk7XG5mdW5jdGlvbiBnZXRDbG91ZENvbmZpZ1VybChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHNlcnZlclVybC5wcm90b2NvbC5yZXBsYWNlKCd3cycsICdodHRwJyksIFwiLy9cIikuY29uY2F0KHNlcnZlclVybC5ob3N0LCBcIi9zZXR0aW5nc1wiKTtcbn1cblxuLy8gU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogMjAyNCBMaXZlS2l0LCBJbmMuXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbi8qKlxuICogU3BlY2lhbGl6ZWQgZXJyb3IgaGFuZGxpbmcgZm9yIFJQQyBtZXRob2RzLlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIHR5cGUsIHdoZW4gdGhyb3duIGluIGEgbWV0aG9kIGhhbmRsZXIsIHdpbGwgaGF2ZSB0aGVpciBgbWVzc2FnZWBcbiAqIHNlcmlhbGl6ZWQgYW5kIHNlbnQgYWNyb3NzIHRoZSB3aXJlLiBUaGUgc2VuZGVyIHdpbGwgcmVjZWl2ZSBhbiBlcXVpdmFsZW50IGVycm9yIG9uIHRoZSBvdGhlciBzaWRlLlxuICpcbiAqIEJ1aWx0LWluIHR5cGVzIGFyZSBpbmNsdWRlZCBidXQgZGV2ZWxvcGVycyBtYXkgdXNlIGFueSBzdHJpbmcsIHdpdGggYSBtYXggbGVuZ3RoIG9mIDI1NiBieXRlcy5cbiAqL1xuY2xhc3MgUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2RlIGFuZCBtZXNzYWdlLCBwbHVzIGFuIG9wdGlvbmFsIGRhdGEgcGF5bG9hZC5cbiAgICpcbiAgICogSWYgdGhyb3duIGluIGFuIFJQQyBtZXRob2QgaGFuZGxlciwgdGhlIGVycm9yIHdpbGwgYmUgc2VudCBiYWNrIHRvIHRoZSBjYWxsZXIuXG4gICAqXG4gICAqIEVycm9yIGNvZGVzIDEwMDEtMTk5OSBhcmUgcmVzZXJ2ZWQgZm9yIGJ1aWx0LWluIGVycm9ycyAoc2VlIFJwY0Vycm9yLkVycm9yQ29kZSBmb3IgdGhlaXIgbWVhbmluZ3MpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gdHJ1bmNhdGVCeXRlcyhtZXNzYWdlLCBScGNFcnJvci5NQVhfTUVTU0FHRV9CWVRFUyk7XG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IHRydW5jYXRlQnl0ZXMoZGF0YSwgUnBjRXJyb3IuTUFYX0RBVEFfQllURVMpIDogdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBmcm9tUHJvdG8ocHJvdG8pIHtcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yKHByb3RvLmNvZGUsIHByb3RvLm1lc3NhZ2UsIHByb3RvLmRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvUHJvdG8oKSB7XG4gICAgcmV0dXJuIG5ldyBScGNFcnJvciQxKHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCBmcm9tIHRoZSBjb2RlLCB3aXRoIGFuIGF1dG8tcG9wdWxhdGVkIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGJ1aWx0SW4oa2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBScGNFcnJvcihScGNFcnJvci5FcnJvckNvZGVba2V5XSwgUnBjRXJyb3IuRXJyb3JNZXNzYWdlW2tleV0sIGRhdGEpO1xuICB9XG59XG5ScGNFcnJvci5NQVhfTUVTU0FHRV9CWVRFUyA9IDI1NjtcblJwY0Vycm9yLk1BWF9EQVRBX0JZVEVTID0gMTUzNjA7IC8vIDE1IEtCXG5ScGNFcnJvci5FcnJvckNvZGUgPSB7XG4gIEFQUExJQ0FUSU9OX0VSUk9SOiAxNTAwLFxuICBDT05ORUNUSU9OX1RJTUVPVVQ6IDE1MDEsXG4gIFJFU1BPTlNFX1RJTUVPVVQ6IDE1MDIsXG4gIFJFQ0lQSUVOVF9ESVNDT05ORUNURUQ6IDE1MDMsXG4gIFJFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFOiAxNTA0LFxuICBTRU5EX0ZBSUxFRDogMTUwNSxcbiAgVU5TVVBQT1JURURfTUVUSE9EOiAxNDAwLFxuICBSRUNJUElFTlRfTk9UX0ZPVU5EOiAxNDAxLFxuICBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFOiAxNDAyLFxuICBVTlNVUFBPUlRFRF9TRVJWRVI6IDE0MDMsXG4gIFVOU1VQUE9SVEVEX1ZFUlNJT046IDE0MDRcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5ScGNFcnJvci5FcnJvck1lc3NhZ2UgPSB7XG4gIEFQUExJQ0FUSU9OX0VSUk9SOiAnQXBwbGljYXRpb24gZXJyb3IgaW4gbWV0aG9kIGhhbmRsZXInLFxuICBDT05ORUNUSU9OX1RJTUVPVVQ6ICdDb25uZWN0aW9uIHRpbWVvdXQnLFxuICBSRVNQT05TRV9USU1FT1VUOiAnUmVzcG9uc2UgdGltZW91dCcsXG4gIFJFQ0lQSUVOVF9ESVNDT05ORUNURUQ6ICdSZWNpcGllbnQgZGlzY29ubmVjdGVkJyxcbiAgUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0U6ICdSZXNwb25zZSBwYXlsb2FkIHRvbyBsYXJnZScsXG4gIFNFTkRfRkFJTEVEOiAnRmFpbGVkIHRvIHNlbmQnLFxuICBVTlNVUFBPUlRFRF9NRVRIT0Q6ICdNZXRob2Qgbm90IHN1cHBvcnRlZCBhdCBkZXN0aW5hdGlvbicsXG4gIFJFQ0lQSUVOVF9OT1RfRk9VTkQ6ICdSZWNpcGllbnQgbm90IGZvdW5kJyxcbiAgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRTogJ1JlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UnLFxuICBVTlNVUFBPUlRFRF9TRVJWRVI6ICdSUEMgbm90IHN1cHBvcnRlZCBieSBzZXJ2ZXInLFxuICBVTlNVUFBPUlRFRF9WRVJTSU9OOiAnVW5zdXBwb3J0ZWQgUlBDIHZlcnNpb24nXG59O1xuLypcbiAqIE1heGltdW0gcGF5bG9hZCBzaXplIGZvciBSUEMgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy4gSWYgYSBwYXlsb2FkIGV4Y2VlZHMgdGhpcyBzaXplLFxuICogdGhlIFJQQyBjYWxsIHdpbGwgZmFpbCB3aXRoIGEgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRSgxNDAyKSBvciBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRSgxNTA0KSBlcnJvci5cbiAqL1xuY29uc3QgTUFYX1BBWUxPQURfQllURVMgPSAxNTM2MDsgLy8gMTUgS0Jcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0cikubGVuZ3RoO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJ1bmNhdGVCeXRlcyhzdHIsIG1heEJ5dGVzKSB7XG4gIGlmIChieXRlTGVuZ3RoKHN0cikgPD0gbWF4Qnl0ZXMpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGxldCBsb3cgPSAwO1xuICBsZXQgaGlnaCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoICsgMSkgLyAyKTtcbiAgICBpZiAoZW5jb2Rlci5lbmNvZGUoc3RyLnNsaWNlKDAsIG1pZCkpLmxlbmd0aCA8PSBtYXhCeXRlcykge1xuICAgICAgbG93ID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBsb3cpO1xufVxuXG5jb25zdCBtb25pdG9yRnJlcXVlbmN5ID0gMjAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVCaXRyYXRlKGN1cnJlbnRTdGF0cywgcHJldlN0YXRzKSB7XG4gIGlmICghcHJldlN0YXRzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IGJ5dGVzTm93O1xuICBsZXQgYnl0ZXNQcmV2O1xuICBpZiAoJ2J5dGVzUmVjZWl2ZWQnIGluIGN1cnJlbnRTdGF0cykge1xuICAgIGJ5dGVzTm93ID0gY3VycmVudFN0YXRzLmJ5dGVzUmVjZWl2ZWQ7XG4gICAgYnl0ZXNQcmV2ID0gcHJldlN0YXRzLmJ5dGVzUmVjZWl2ZWQ7XG4gIH0gZWxzZSBpZiAoJ2J5dGVzU2VudCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgYnl0ZXNOb3cgPSBjdXJyZW50U3RhdHMuYnl0ZXNTZW50O1xuICAgIGJ5dGVzUHJldiA9IHByZXZTdGF0cy5ieXRlc1NlbnQ7XG4gIH1cbiAgaWYgKGJ5dGVzTm93ID09PSB1bmRlZmluZWQgfHwgYnl0ZXNQcmV2ID09PSB1bmRlZmluZWQgfHwgY3VycmVudFN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkIHx8IHByZXZTdGF0cy50aW1lc3RhbXAgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAoYnl0ZXNOb3cgLSBieXRlc1ByZXYpICogOCAqIDEwMDAgLyAoY3VycmVudFN0YXRzLnRpbWVzdGFtcCAtIHByZXZTdGF0cy50aW1lc3RhbXApO1xufVxuXG4vLyBDaGVjayBpZiBNZWRpYVJlY29yZGVyIGlzIGF2YWlsYWJsZVxuY29uc3QgaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlID0gdHlwZW9mIE1lZGlhUmVjb3JkZXIgIT09ICd1bmRlZmluZWQnO1xuLy8gRmFsbGJhY2sgY2xhc3MgZm9yIGVudmlyb25tZW50cyB3aXRob3V0IE1lZGlhUmVjb3JkZXJcbmNsYXNzIEZhbGxiYWNrUmVjb3JkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhUmVjb3JkZXIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gIH1cbn1cbi8vIFVzZSBjb25kaXRpb25hbCBpbmhlcml0YW5jZSB0byBhdm9pZCBwYXJzZS10aW1lIGVycm9yc1xuY29uc3QgUmVjb3JkZXJCYXNlID0gaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlID8gTWVkaWFSZWNvcmRlciA6IEZhbGxiYWNrUmVjb3JkZXI7XG5jbGFzcyBMb2NhbFRyYWNrUmVjb3JkZXIgZXh0ZW5kcyBSZWNvcmRlckJhc2Uge1xuICBjb25zdHJ1Y3Rvcih0cmFjaywgb3B0aW9ucykge1xuICAgIGlmICghaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhUmVjb3JkZXIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICAgIHN1cGVyKG5ldyBNZWRpYVN0cmVhbShbdHJhY2subWVkaWFTdHJlYW1UcmFja10pLCBvcHRpb25zKTtcbiAgICBsZXQgZGF0YUxpc3RlbmVyO1xuICAgIGxldCBzdHJlYW1Db250cm9sbGVyO1xuICAgIGNvbnN0IGlzQ2xvc2VkID0gKCkgPT4gc3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU3RvcCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGRhdGFMaXN0ZW5lcik7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3AnLCBvblN0b3ApO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgc3RyZWFtQ29udHJvbGxlciA9PT0gbnVsbCB8fCBzdHJlYW1Db250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBzdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3Qgb25FcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPT09IG51bGwgfHwgc3RyZWFtQ29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RyZWFtQ29udHJvbGxlci5lcnJvcihldmVudCk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RhdGFhdmFpbGFibGUnLCBkYXRhTGlzdGVuZXIpO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9wJywgb25TdG9wKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0aGlzLmJ5dGVTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgZGF0YUxpc3RlbmVyID0gZXZlbnQgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgIGlmIChldmVudC5kYXRhLmFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IHlpZWxkIGV2ZW50LmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWN0LW5hdGl2ZSBwYXNzZXMgb3ZlciBVaW50OEFycmF5cyBkaXJlY3RseVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5ieXRlQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGRhdGEgPSBldmVudC5kYXRhLmJ5dGVBcnJheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBkYXRhIGF2YWlsYWJsZSEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZGF0YUxpc3RlbmVyKTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgb25TdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdzdG9wJywgb25TdG9wKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gIH1cbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiByZWNvcmRpbmcgaXMgc3VwcG9ydGVkXG5mdW5jdGlvbiBpc1JlY29yZGluZ1N1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIGlzTWVkaWFSZWNvcmRlckF2YWlsYWJsZTtcbn1cblxuY29uc3QgREVGQVVMVF9ESU1FTlNJT05TX1RJTUVPVVQgPSAxMDAwO1xuY29uc3QgUFJFX0NPTk5FQ1RfQlVGRkVSX1RJTUVPVVQgPSAxMDAwMDtcbmNsYXNzIExvY2FsVHJhY2sgZXh0ZW5kcyBUcmFjayB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IHNlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0IHNlbmRlcihzZW5kZXIpIHtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gIH1cbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJhaW50cztcbiAgfVxuICBnZXQgaGFzUHJlQ29ubmVjdEJ1ZmZlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLmxvY2FsVHJhY2tSZWNvcmRlcjtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBraW5kLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLm1hbnVhbGx5U3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50ID0gKCkgPT4gdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyKCkuY2F0Y2goKCkgPT4gdGhpcy5sb2cuZGVidWcoJ3RyYWNrIG11dGUgYm91bmNlIGdvdCBjYW5jZWxsZWQgYnkgYW4gdW5tdXRlIGV2ZW50JywgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyID0gcigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW0oKTtcbiAgICB9KSwgNTAwMCk7XG4gICAgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgndW5tdXRlJyk7XG4gICAgICB5aWVsZCB0aGlzLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kKSB7XG4gICAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgIHRoaXMubXV0ZUxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMucGF1c2VVcHN0cmVhbUxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMudHJhY2tDaGFuZ2VMb2NrID0gbmV3IF8oKTtcbiAgICB0aGlzLnRyYWNrQ2hhbmdlTG9jay5sb2NrKCkudGhlbih1bmxvY2sgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhVHJhY2ssIHRydWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIGFkZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIsIGNvbnN0cmFpbnRzIGFyZSBzeW5jZWQgd2l0aCBNZWRpYVN0cmVhbVRyYWNrXG4gICAgdGhpcy5fY29uc3RyYWludHMgPSBtZWRpYVRyYWNrLmdldENvbnN0cmFpbnRzKCk7XG4gICAgaWYgKGNvbnN0cmFpbnRzKSB7XG4gICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgIH1cbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suaWQ7XG4gIH1cbiAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMua2luZCAhPT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQ7XG4gIH1cbiAgZ2V0IGlzVXNlclByb3ZpZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkQnlVc2VyO1xuICB9XG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvY2Vzc2VkVHJhY2spICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiByZXR1cm5zIG1lZGlhU3RyZWFtVHJhY2sgc2V0dGluZ3Mgb2YgdGhlIGNhcHR1cmluZyBtZWRpYXN0cmVhbXRyYWNrIHNvdXJjZSAtIGlnbm9yaW5nIHByb2Nlc3NvcnNcbiAgICovXG4gIGdldFNvdXJjZVRyYWNrU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgfVxuICBzZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrLCBmb3JjZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAobmV3VHJhY2sgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIC8vIGRldGFjaFxuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgnbmV3LXRyYWNrJyk7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWFTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW25ld1RyYWNrXSk7XG4gICAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgLy8gd2hlbiB1bmRlcmx5aW5nIHRyYWNrIGVtaXRzIG11dGUsIGl0IGluZGljYXRlcyB0aGF0IHRoZSBkZXZpY2UgaXMgdW5hYmxlXG4gICAgICAgIC8vIHRvIHByb2R1Y2UgbWVkaWEuIEluIHRoaXMgY2FzZSB3ZSdsbCBuZWVkIHRvIHNpZ25hbCB3aXRoIHJlbW90ZSB0aGF0XG4gICAgICAgIC8vIHRoZSB0cmFjayBpcyBcIm11dGVkXCJcbiAgICAgICAgLy8gbm90ZSB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIExvY2FsVHJhY2subXV0ZSBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvXG4gICAgICAgIC8vIHRvdWNoIE1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZFxuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbmV3VHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgIH1cbiAgICAgIGxldCBwcm9jZXNzZWRUcmFjaztcbiAgICAgIGlmICh0aGlzLnByb2Nlc3NvciAmJiBuZXdUcmFjaykge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NvckVsZW1lbnQpIHtcbiAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQobmV3VHJhY2ssIHRoaXMucHJvY2Vzc29yRWxlbWVudCk7XG4gICAgICAgICAgLy8gZW5zdXJlIHRoZSBwcm9jZXNzb3JFbGVtZW50IGl0c2VsZiBzdGF5cyBtdXRlZFxuICAgICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5wcm9jZXNzb3IucmVzdGFydCh7XG4gICAgICAgICAgdHJhY2s6IG5ld1RyYWNrLFxuICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICBlbGVtZW50OiB0aGlzLnByb2Nlc3NvckVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NlZFRyYWNrID0gdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2s7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZW5kZXIgJiYgKChfYSA9IHRoaXMuc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHByb2Nlc3NlZFRyYWNrICE9PSBudWxsICYmIHByb2Nlc3NlZFRyYWNrICE9PSB2b2lkIDAgPyBwcm9jZXNzZWRUcmFjayA6IG5ld1RyYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGBuZXdUcmFja2AgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV4aXN0aW5nIHRyYWNrLCBzdG9wIHRoZVxuICAgICAgLy8gb2xkZXIgdHJhY2sganVzdCBiZWZvcmUgcmVwbGFjaW5nIGl0XG4gICAgICBpZiAoIXRoaXMucHJvdmlkZWRCeVVzZXIgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAhPT0gbmV3VHJhY2spIHtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrID0gbmV3VHJhY2s7XG4gICAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgICAgLy8gc3luYyBtdXRlZCBzdGF0ZSB3aXRoIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBuZXdseSBwcm92aWRlZCB0cmFja1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhdGhpcy5pc011dGVkO1xuICAgICAgICAvLyB3aGVuIGEgdmFsaWQgdHJhY2sgaXMgcmVwbGFjZSwgd2UnZCB3YW50IHRvIHN0YXJ0IHByb2R1Y2luZ1xuICAgICAgICB5aWVsZCB0aGlzLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQocHJvY2Vzc2VkVHJhY2sgIT09IG51bGwgJiYgcHJvY2Vzc2VkVHJhY2sgIT09IHZvaWQgMCA/IHByb2Nlc3NlZFRyYWNrIDogbmV3VHJhY2ssIGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2FpdEZvckRpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBERUZBVUxUX0RJTUVOU0lPTlNfVElNRU9VVDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChfdGhpcy5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2V0IGRpbWVuc2lvbnMgZm9yIGF1ZGlvIHRyYWNrcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3MpID09PSAnaU9TJykge1xuICAgICAgICAgIC8vIGJyb3dzZXJzIHJlcG9ydCB3cm9uZyBpbml0aWFsIHJlc29sdXRpb24gb24gaU9TLlxuICAgICAgICAgIC8vIHdoZW4gc2xpZ2h0bHkgZGVsYXlpbmcgdGhlIGNhbGwgdG8gLmdldFNldHRpbmdzKCksIHRoZSBjb3JyZWN0IHJlc29sdXRpb24gaXMgYmVpbmcgcmVwb3J0ZWRcbiAgICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRlZCA8IHRpbWVvdXQpIHtcbiAgICAgICAgICBjb25zdCBkaW1zID0gX3RoaXMuZGltZW5zaW9ucztcbiAgICAgICAgICBpZiAoZGltcykge1xuICAgICAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byBnZXQgdHJhY2sgZGltZW5zaW9ucyBhZnRlciB0aW1lb3V0Jyk7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0RGV2aWNlSWQoZGV2aWNlSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkID09PSBkZXZpY2VJZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgPT09IHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgIC8vIHdoZW4gdHJhY2sgaXMgbXV0ZWQsIHVuZGVybHlpbmcgbWVkaWEgc3RyZWFtIHRyYWNrIGlzIHN0b3BwZWQgYW5kXG4gICAgICAvLyB3aWxsIGJlIHJlc3RhcnRlZCBsYXRlclxuICAgICAgaWYgKHRoaXMuaXNNdXRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICByZXR1cm4gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgRGV2aWNlSUQgb2YgdGhlIGRldmljZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIGZvciB0aGlzIHRyYWNrXG4gICAqL1xuICBnZXREZXZpY2VJZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGxldCBub3JtYWxpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gc2NyZWVuIHNoYXJlIGRvZXNuJ3QgaGF2ZSBhIHVzYWJsZSBkZXZpY2UgaWRcbiAgICAgICAgaWYgKF90aGlzMi5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgZ3JvdXBJZFxuICAgICAgICB9ID0gX3RoaXMyLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgIGNvbnN0IGtpbmQgPSBfdGhpczIua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbyA/ICdhdWRpb2lucHV0JyA6ICd2aWRlb2lucHV0JztcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSA/IERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5ub3JtYWxpemVEZXZpY2VJZChraW5kLCBkZXZpY2VJZCwgZ3JvdXBJZCkgOiBkZXZpY2VJZDtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNldFRyYWNrTXV0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZChmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICByZXBsYWNlVHJhY2sodHJhY2ssIHVzZXJQcm92aWRlZE9yT3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnRyYWNrQ2hhbmdlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gcmVwbGFjZSBhbiB1bnB1Ymxpc2hlZCB0cmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjaztcbiAgICAgICAgbGV0IHN0b3BQcm9jZXNzb3I7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlclByb3ZpZGVkT3JPcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB1c2VyUHJvdmlkZWRUcmFjayA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyUHJvdmlkZWRPck9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVzZXJQcm92aWRlZFRyYWNrID0gdXNlclByb3ZpZGVkT3JPcHRpb25zLnVzZXJQcm92aWRlZFRyYWNrO1xuICAgICAgICAgIHN0b3BQcm9jZXNzb3IgPSB1c2VyUHJvdmlkZWRPck9wdGlvbnMuc3RvcFByb2Nlc3NvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2sgIT09IG51bGwgJiYgdXNlclByb3ZpZGVkVHJhY2sgIT09IHZvaWQgMCA/IHVzZXJQcm92aWRlZFRyYWNrIDogdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlcGxhY2UgTWVkaWFTdHJlYW1UcmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayh0cmFjayk7XG4gICAgICAgIC8vIHRoaXMgbXVzdCBiZSBzeW5jZWQgKmFmdGVyKiBzZXR0aW5nIG1lZGlhU3RyZWFtVHJhY2sgYWJvdmUsIHNpbmNlIGl0IHJlbGllc1xuICAgICAgICAvLyBvbiB0aGUgcHJldmlvdXMgc3RhdGUgaW4gb3JkZXIgdG8gY2xlYW51cFxuICAgICAgICBpZiAoc3RvcFByb2Nlc3NvciAmJiB0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRoaXMuaW50ZXJuYWxTdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN0YXJ0KGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnRyYWNrQ2hhbmdlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLl9jb25zdHJhaW50cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgIGZhY2luZ01vZGVcbiAgICAgICAgICB9ID0gY29uc3RyYWludHMsXG4gICAgICAgICAgb3RoZXJDb25zdHJhaW50cyA9IF9fcmVzdChjb25zdHJhaW50cywgW1wiZGV2aWNlSWRcIiwgXCJmYWNpbmdNb2RlXCJdKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgdHJhY2sgd2l0aCBjb25zdHJhaW50cycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGNvbnN0cmFpbnRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgIHZpZGVvOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgc3RyZWFtQ29uc3RyYWludHMudmlkZW8gPSBkZXZpY2VJZCB8fCBmYWNpbmdNb2RlID8ge1xuICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICBmYWNpbmdNb2RlXG4gICAgICAgICAgfSA6IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29uc3RyYWludHMuYXVkaW8gPSBkZXZpY2VJZCA/IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZGV2aWNlSWRcbiAgICAgICAgICB9LCBvdGhlckNvbnN0cmFpbnRzKSA6IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2Ugc3RlcHMgYXJlIGR1cGxpY2F0ZWQgZnJvbSBzZXRNZWRpYVN0cmVhbVRyYWNrIGJlY2F1c2Ugd2UgbXVzdCBzdG9wXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyB0cmFja3MgYmVmb3JlIG5ldyB0cmFja3MgY2FuIGJlIGFjcXVpcmVkXG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgLy8gb24gU2FmYXJpLCB0aGUgb2xkIGF1ZGlvIHRyYWNrIG11c3QgYmUgc3RvcHBlZCBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY3F1aXJlXG4gICAgICAgIC8vIHRoZSBuZXcgdHJhY2ssIG90aGVyd2lzZSB0aGUgbmV3IHRyYWNrIHdpbGwgc3RvcCB3aXRoXG4gICAgICAgIC8vICdBIE1lZGlhU3RyZWFtVHJhY2sgZW5kZWQgZHVlIHRvIGEgY2FwdHVyZSBmYWlsdXJlYFxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgLy8gY3JlYXRlIG5ldyB0cmFjayBhbmQgYXR0YWNoXG4gICAgICAgIGNvbnN0IG1lZGlhU3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoc3RyZWFtQ29uc3RyYWludHMpO1xuICAgICAgICBjb25zdCBuZXdUcmFjayA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgLy8gd2UgYWxyZWFkeSBjYXB0dXJlZCB0aGUgYXVkaW8gdHJhY2sgd2l0aCB0aGUgY29uc3RyYWludHMsIHNvIHdlIG9ubHkgbmVlZCB0byBhcHBseSB0aGUgdmlkZW8gY29uc3RyYWludHNcbiAgICAgICAgICB5aWVsZCBuZXdUcmFjay5hcHBseUNvbnN0cmFpbnRzKG90aGVyQ29uc3RyYWludHMpO1xuICAgICAgICB9XG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZS1hY3F1aXJlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgeWllbGQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrKTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsbHlTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybigndHJhY2sgd2FzIHN0b3BwZWQgZHVyaW5nIGEgcmVzdGFydCwgc3RvcHBpbmcgcmVzdGFydGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgXCIuY29uY2F0KHRoaXMua2luZCwgXCIgdHJhY2sgXCIpLmNvbmNhdChtdXRlZCA/ICdtdXRlZCcgOiAndW5tdXRlZCcpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGlmICh0aGlzLmlzTXV0ZWQgPT09IG11dGVkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICB9XG4gIGdldCBuZWVkc1JlQWNxdWlzaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSAhPT0gJ2xpdmUnIHx8IHRoaXMuX21lZGlhU3RyZWFtVHJhY2subXV0ZWQgfHwgIXRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCB8fCB0aGlzLnJlYWNxdWlyZVRyYWNrO1xuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ2aXNpYmlsaXR5IGNoYW5nZWQsIGlzIGluIEJhY2tncm91bmQ6IFwiLmNvbmNhdCh0aGlzLmlzSW5CYWNrZ3JvdW5kKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLm5lZWRzUmVBY3F1aXNpdGlvbiAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCAmJiAhdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJhY2sgbmVlZHMgdG8gYmUgcmVhY3F1aXJlZCwgcmVzdGFydGluZyBcIi5jb25jYXQodGhpcy5zb3VyY2UpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gdHJ1ZTtcbiAgICBzdXBlci5zdG9wKCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAoX2EgPSB0aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICB0aGlzLnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogcGF1c2VzIHB1Ymxpc2hpbmcgdG8gdGhlIHNlcnZlciB3aXRob3V0IGRpc2FibGluZyB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFja1xuICAgKiB0aGlzIGlzIHVzZWQgdG8gZGlzcGxheSBhIHVzZXIncyBvd24gdmlkZW8gbG9jYWxseSB3aGlsZSBwYXVzaW5nIHB1Ymxpc2hpbmcgdG9cbiAgICogdGhlIHNlcnZlci5cbiAgICogdGhpcyBBUEkgaXMgdW5zdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIgZHVlIHRvIGEgYnVnXG4gICAqKi9cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybigndW5hYmxlIHRvIHBhdXNlIHVwc3RyZWFtIGZvciBhbiB1bnB1Ymxpc2hlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcyk7XG4gICAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICAgIGlmICgoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLm5hbWUpID09PSAnU2FmYXJpJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCAnMTIuMCcpIDwgMCkge1xuICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODQ5MTFcbiAgICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigncGF1c2VVcHN0cmVhbSBpcyBub3Qgc3VwcG9ydGVkIG9uIFNhZmFyaSA8IDEyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcmVzdW1lIHVwc3RyZWFtIGZvciBhbiB1bnB1Ymxpc2hlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzKTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgLy8gdGhpcyBvcGVyYXRpb24gaXMgbm9vcCBpZiBtZWRpYXN0cmVhbXRyYWNrIGlzIGFscmVhZHkgYmVpbmcgc2VudFxuICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBMb2NhbFRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBTZW5kZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIHJldHVybiBzdGF0c1JlcG9ydDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIHByb2Nlc3NvciBvbiB0aGlzIHRyYWNrLlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqXG4gICAqIEBwYXJhbSBwcm9jZXNzb3JcbiAgICogQHBhcmFtIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocHJvY2Vzc29yKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzMy50cmFja0NoYW5nZUxvY2subG9jaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzMy5sb2cuZGVidWcoJ3NldHRpbmcgdXAgcHJvY2Vzc29yJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NvckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KF90aGlzMy5raW5kKTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICAgICAga2luZDogX3RoaXMzLmtpbmQsXG4gICAgICAgICAgICB0cmFjazogX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICAgICAgZWxlbWVudDogcHJvY2Vzc29yRWxlbWVudCxcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dDogX3RoaXMzLmF1ZGlvQ29udGV4dFxuICAgICAgICAgIH07XG4gICAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICAgICAgX3RoaXMzLmxvZy5kZWJ1ZygncHJvY2Vzc29yIGluaXRpYWxpemVkJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGlmIChfdGhpczMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpczMuaW50ZXJuYWxTdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGhpczMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQoX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLCBwcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzb3JFbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICBwcm9jZXNzb3JFbGVtZW50LnBsYXkoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBvbiBTYWZhcmkgd2hlbiB0aGUgcHJvY2Vzc29yIGlzIHJlc3RhcnRlZCwgdHJ5IGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICAgICAgX3RoaXMzLmxvZy53YXJuKCdmYWlsZWQgdG8gcGxheSBwcm9jZXNzb3IgZWxlbWVudCwgcmV0cnlpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yRWxlbWVudC5wbGF5KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBwbGF5IHByb2Nlc3NvciBlbGVtZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMubG9nLmVycm9yKCdmYWlsZWQgdG8gcGxheSBwcm9jZXNzb3IgZWxlbWVudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzMy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgICAgX3RoaXMzLnByb2Nlc3NvckVsZW1lbnQgPSBwcm9jZXNzb3JFbGVtZW50O1xuICAgICAgICAgIGlmIChfdGhpczMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIF90aGlzMy5hdHRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgIGlmIChlbCAhPT0gX3RoaXMzLnByb2Nlc3NvckVsZW1lbnQgJiYgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICBkZXRhY2hUcmFjayhfdGhpczMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQoX3RoaXMzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaywgZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCAoX2EgPSBfdGhpczMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZVRyYWNrKF90aGlzMy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczMuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCBfdGhpczMucHJvY2Vzc29yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIGdldFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3I7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB0cmFjayBwcm9jZXNzb3JcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L3RyYWNrLXByb2Nlc3NvcnMtanMgZm9yIGV4YW1wbGUgdXNhZ2VcbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RvcFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIGxldCBrZWVwRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBfdGhpczQudHJhY2tDaGFuZ2VMb2NrLmxvY2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCBfdGhpczQuaW50ZXJuYWxTdG9wUHJvY2Vzc29yKGtlZXBFbGVtZW50KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGUgY2FsbGVyIGhhcyBhY3F1aXJlZCBhIHRyYWNrQ2hhbmdlTG9jayBhbHJlYWR5LlxuICAgKiBUaGUgcHVibGljIGZhY2luZyBtZXRob2QgZm9yIHN0b3BwaW5nIHRoZSBwcm9jZXNzb3IgaXMgYHN0b3BQcm9jZXNzb3JgIGFuZCBpdCB3cmFwcyB0aGlzIG1ldGhvZCBpbiB0aGUgdHJhY2tDaGFuZ2VMb2NrLlxuICAgKi9cbiAgaW50ZXJuYWxTdG9wUHJvY2Vzc29yKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgbGV0IGtlZXBFbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghX3RoaXM1LnByb2Nlc3NvcikgcmV0dXJuO1xuICAgICAgICBfdGhpczUubG9nLmRlYnVnKCdzdG9wcGluZyBwcm9jZXNzb3InLCBfdGhpczUubG9nQ29udGV4dCk7XG4gICAgICAgIChfYSA9IF90aGlzNS5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICAgIHlpZWxkIF90aGlzNS5wcm9jZXNzb3IuZGVzdHJveSgpO1xuICAgICAgICBfdGhpczUucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIWtlZXBFbGVtZW50KSB7XG4gICAgICAgICAgKF9iID0gX3RoaXM1LnByb2Nlc3NvckVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmUoKTtcbiAgICAgICAgICBfdGhpczUucHJvY2Vzc29yRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBvcmlnaW5hbCB0cmFjayBjb25zdHJhaW50cyBpbiBjYXNlIHRoZSBwcm9jZXNzb3IgY2hhbmdlZCB0aGVtXG4gICAgICAgIHlpZWxkIF90aGlzNS5fbWVkaWFTdHJlYW1UcmFjay5hcHBseUNvbnN0cmFpbnRzKF90aGlzNS5fY29uc3RyYWludHMpO1xuICAgICAgICAvLyBmb3JjZSByZS1zZXR0aW5nIG9mIHRoZSBtZWRpYVN0cmVhbVRyYWNrIG9uIHRoZSBzZW5kZXJcbiAgICAgICAgeWllbGQgX3RoaXM1LnNldE1lZGlhU3RyZWFtVHJhY2soX3RoaXM1Ll9tZWRpYVN0cmVhbVRyYWNrLCB0cnVlKTtcbiAgICAgICAgX3RoaXM1LmVtaXQoVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGFydFByZUNvbm5lY3RCdWZmZXIoKSB7XG4gICAgbGV0IHRpbWVzbGljZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTAwO1xuICAgIGlmICghaXNSZWNvcmRpbmdTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5sb2cud2FybignTWVkaWFSZWNvcmRlciBpcyBub3QgYXZhaWxhYmxlLCBjYW5ub3Qgc3RhcnQgcHJlY29ubmVjdCBidWZmZXInLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubG9jYWxUcmFja1JlY29yZGVyKSB7XG4gICAgICBsZXQgbWltZVR5cGUgPSAnYXVkaW8vd2VibTtjb2RlY3M9b3B1cyc7XG4gICAgICBpZiAoIU1lZGlhUmVjb3JkZXIuaXNUeXBlU3VwcG9ydGVkKG1pbWVUeXBlKSkge1xuICAgICAgICAvLyBpT1MgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdmlkZW8vbXA0IGFzIGEgbWltZSB0eXBlIC0gZXZlbiBmb3IgYXVkaW8uXG4gICAgICAgIG1pbWVUeXBlID0gJ3ZpZGVvL21wNCc7XG4gICAgICB9XG4gICAgICB0aGlzLmxvY2FsVHJhY2tSZWNvcmRlciA9IG5ldyBMb2NhbFRyYWNrUmVjb3JkZXIodGhpcywge1xuICAgICAgICBtaW1lVHlwZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3ByZWNvbm5lY3QgYnVmZmVyIGFscmVhZHkgc3RhcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvY2FsVHJhY2tSZWNvcmRlci5zdGFydCh0aW1lc2xpY2UpO1xuICAgIHRoaXMuYXV0b1N0b3BQcmVDb25uZWN0QnVmZmVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwcmVjb25uZWN0IGJ1ZmZlciB0aW1lZCBvdXQsIHN0b3BwaW5nIHJlY29yZGluZyBhdXRvbWF0aWNhbGx5JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuc3RvcFByZUNvbm5lY3RCdWZmZXIoKTtcbiAgICB9LCBQUkVfQ09OTkVDVF9CVUZGRVJfVElNRU9VVCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdG9wUHJlQ29ubmVjdEJ1ZmZlcigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvU3RvcFByZUNvbm5lY3RCdWZmZXIpO1xuICAgIGlmICh0aGlzLmxvY2FsVHJhY2tSZWNvcmRlcikge1xuICAgICAgdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIuc3RvcCgpO1xuICAgICAgdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0UHJlQ29ubmVjdEJ1ZmZlcigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMubG9jYWxUcmFja1JlY29yZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnl0ZVN0cmVhbTtcbiAgfVxuICBnZXRQcmVDb25uZWN0QnVmZmVyTWltZVR5cGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLmxvY2FsVHJhY2tSZWNvcmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1pbWVUeXBlO1xuICB9XG59XG5cbmNsYXNzIExvY2FsQXVkaW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICAvKipcbiAgICogYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgZW5oYW5jZWQgbm9pc2UgY2FuY2VsbGF0aW9uIGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIG9uIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldCBlbmhhbmNlZE5vaXNlQ2FuY2VsbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgbGV0IGF1ZGlvQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgVHJhY2suS2luZC5BdWRpbywgY29uc3RyYWludHMsIHVzZXJQcm92aWRlZFRyYWNrLCBsb2dnZXJPcHRpb25zKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5zdG9wT25NdXRlID0gZmFsc2U7XG4gICAgdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0cztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cykge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckVuYWJsZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXNLcmlzcE5vaXNlRmlsdGVyRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcIktyaXNwIG5vaXNlIGZpbHRlciBlbmFibGVkXCIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiS3Jpc3Agbm9pc2UgZmlsdGVyIGRpc2FibGVkXCIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzYWJsZWQgc3BlY2lhbCBoYW5kbGluZyBhcyBpdCB3aWxsIGNhdXNlIEJUIGhlYWRzZXRzIHRvIHN3aXRjaCBjb21tdW5pY2F0aW9uIG1vZGVzXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgdGhpcy5zdG9wT25NdXRlICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBtaWNyb3Bob25lIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICB1bm11dGU6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci51bm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdUcmFjayBhbHJlYWR5IHVubXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPSB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09IHVud3JhcENvbnN0cmFpbnQodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQpO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMoe1xuICAgICAgICAgIGF1ZGlvOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgIH0pO1xuICB9XG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHJlc3RhcnQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN0YXJ0XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgX3N1cGVyLnJlc3RhcnQuY2FsbCh0aGlzLCBjb25zdHJhaW50cyk7XG4gICAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3IoKSB7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy50cmFja0NoYW5nZUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc1JlYWN0TmF0aXZlKCkgJiYgIXRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0F1ZGlvIGNvbnRleHQgbmVlZHMgdG8gYmUgc2V0IG9uIExvY2FsQXVkaW9UcmFjayBpbiBvcmRlciB0byBlbmFibGUgcHJvY2Vzc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRoaXMuaW50ZXJuYWxTdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgLy8gUk4gd29uJ3QgaGF2ZSBvciB1c2UgQXVkaW9Db250ZXh0XG4gICAgICAgICAgYXVkaW9Db250ZXh0OiB0aGlzLmF1ZGlvQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgdXAgYXVkaW8gcHJvY2Vzc29yIFwiLmNvbmNhdChwcm9jZXNzb3IubmFtZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgeWllbGQgKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuYWJsZS1say1rcmlzcC1ub2lzZS1maWx0ZXInLCB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUpO1xuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc2FibGUtbGsta3Jpc3Atbm9pc2UtZmlsdGVyJywgdGhpcy5oYW5kbGVLcmlzcE5vaXNlRmlsdGVyRGlzYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMucHJvY2Vzc29yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICB9XG4gIGdldFNlbmRlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgbGV0IGF1ZGlvU3RhdHM7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgIGF1ZGlvU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICByb3VuZFRyaXBUaW1lOiB2LnJvdW5kVHJpcFRpbWUsXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXVkaW9TdGF0cztcbiAgICB9KTtcbiAgfVxuICBjaGVja0ZvclNpbGVuY2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBkZXRlY3RTaWxlbmNlKHRoaXMpO1xuICAgICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc2lsZW5jZSBkZXRlY3RlZCBvbiBsb2NhbCBhdWRpbyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9TaWxlbmNlRGV0ZWN0ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrSXNTaWxlbnQ7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgbG9nZ2VyT3B0aW9ucykge1xuICBzd2l0Y2ggKG1lZGlhU3RyZWFtVHJhY2sua2luZCkge1xuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxBdWRpb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSwgdW5kZWZpbmVkLCBsb2dnZXJPcHRpb25zKTtcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsVmlkZW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIGxvZ2dlck9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoXCJ1bnN1cHBvcnRlZCB0cmFjayB0eXBlOiBcIi5jb25jYXQobWVkaWFTdHJlYW1UcmFjay5raW5kKSk7XG4gIH1cbn1cbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgcHJlc2V0czE2OSA9IE9iamVjdC52YWx1ZXMoVmlkZW9QcmVzZXRzKTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgcHJlc2V0czQzID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHM0Myk7XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHByZXNldHNTY3JlZW5TaGFyZSA9IE9iamVjdC52YWx1ZXMoU2NyZWVuU2hhcmVQcmVzZXRzKTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjkgPSBbVmlkZW9QcmVzZXRzLmgxODAsIFZpZGVvUHJlc2V0cy5oMzYwXTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0MyA9IFtWaWRlb1ByZXNldHM0My5oMTgwLCBWaWRlb1ByZXNldHM0My5oMzYwXTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMgPSBmcm9tUHJlc2V0ID0+IHtcbiAgY29uc3QgbGF5ZXJzID0gW3tcbiAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IDIsXG4gICAgZnBzOiBmcm9tUHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZVxuICB9XTtcbiAgcmV0dXJuIGxheWVycy5tYXAodCA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gbmV3IFZpZGVvUHJlc2V0KE1hdGguZmxvb3IoZnJvbVByZXNldC53aWR0aCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5mbG9vcihmcm9tUHJlc2V0LmhlaWdodCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5tYXgoMTUwMDAwLCBNYXRoLmZsb29yKGZyb21QcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZSAvIChNYXRoLnBvdyh0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSwgMikgKiAoKChfYSA9IGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAzMCkgLyAoKF9iID0gdC5mcHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDMwKSkpKSksIHQuZnBzLCBmcm9tUHJlc2V0LmVuY29kaW5nLnByaW9yaXR5KTtcbiAgfSk7XG59O1xuLy8gLyoqXG4vLyAgKlxuLy8gICogQGludGVybmFsXG4vLyAgKiBAZXhwZXJpbWVudGFsXG4vLyAgKi9cbi8vIGNvbnN0IGNvbXB1dGVEZWZhdWx0TXVsdGlDb2RlY1NpbXVsY2FzdEVuY29kaW5ncyA9ICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xuLy8gICAvLyB1c2UgdnA4IGFzIGEgZGVmYXVsdFxuLy8gICBjb25zdCB2cDggPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGZhbHNlLCB3aWR0aCwgaGVpZ2h0KTtcbi8vICAgY29uc3QgdnA5ID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMC45IH07XG4vLyAgIGNvbnN0IGgyNjQgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAxLjEgfTtcbi8vICAgY29uc3QgYXYxID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMC43IH07XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdnA4LFxuLy8gICAgIHZwOSxcbi8vICAgICBoMjY0LFxuLy8gICAgIGF2MSxcbi8vICAgfTtcbi8vIH07XG5jb25zdCB2aWRlb1JpZHMgPSBbJ3EnLCAnaCcsICdmJ107XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGNvbXB1dGVWaWRlb0VuY29kaW5ncyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCB2aWRlb0VuY29kaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvRW5jb2Rpbmc7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZUVuY29kaW5nO1xuICB9XG4gIGNvbnN0IHVzZVNpbXVsY2FzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaW11bGNhc3Q7XG4gIGNvbnN0IHNjYWxhYmlsaXR5TW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2FsYWJpbGl0eU1vZGU7XG4gIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9Db2RlYztcbiAgaWYgKCF2aWRlb0VuY29kaW5nICYmICF1c2VTaW11bGNhc3QgJiYgIXNjYWxhYmlsaXR5TW9kZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgIC8vIHdoZW4gd2UgYXJlbid0IHNpbXVsY2FzdGluZyBvciBzdmMsIHdpbGwgbmVlZCB0byByZXR1cm4gYSBzaW5nbGUgZW5jb2Rpbmcgd2l0aG91dFxuICAgIC8vIGNhcHBpbmcgYmFuZHdpZHRoLiB3ZSBhbHdheXMgcmVxdWlyZSBhIGVuY29kaW5nIGZvciBkeW5hY2FzdFxuICAgIHJldHVybiBbe31dO1xuICB9XG4gIGlmICghdmlkZW9FbmNvZGluZykge1xuICAgIC8vIGZpbmQgdGhlIHJpZ2h0IGVuY29kaW5nIGJhc2VkIG9uIHdpZHRoL2hlaWdodFxuICAgIHZpZGVvRW5jb2RpbmcgPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIHZpZGVvQ29kZWMpO1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3VzaW5nIHZpZGVvIGVuY29kaW5nJywgdmlkZW9FbmNvZGluZyk7XG4gIH1cbiAgY29uc3Qgc291cmNlRnJhbWVyYXRlID0gdmlkZW9FbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gIGNvbnN0IG9yaWdpbmFsID0gbmV3IFZpZGVvUHJlc2V0KHdpZHRoLCBoZWlnaHQsIHZpZGVvRW5jb2RpbmcubWF4Qml0cmF0ZSwgdmlkZW9FbmNvZGluZy5tYXhGcmFtZXJhdGUsIHZpZGVvRW5jb2RpbmcucHJpb3JpdHkpO1xuICBpZiAoc2NhbGFiaWxpdHlNb2RlICYmIGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICBjb25zdCBzbSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoc2NhbGFiaWxpdHlNb2RlKTtcbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgICBpZiAoc20uc3BhdGlhbCA+IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIHNjYWxhYmlsaXR5TW9kZTogXCIuY29uY2F0KHNjYWxhYmlsaXR5TW9kZSkpO1xuICAgIH1cbiAgICAvLyBCZWZvcmUgTTExMyBpbiBDaHJvbWUsIGRlZmluaW5nIG11bHRpcGxlIGVuY29kaW5ncyB3aXRoIGFuIFNWQyBjb2RlYyBpbmRpY2F0ZWRcbiAgICAvLyB0aGF0IFNWQyBtb2RlIHNob3VsZCBiZSB1c2VkLiBTYWZhcmkgc3RpbGwgd29ya3MgdGhpcyB3YXkuXG4gICAgLy8gVGhpcyBpcyBhIGJpdCBjb25mdXNpbmcgYnV0IGlzIGR1ZSB0byBob3cgbGlid2VicnRjIGludGVycHJldGVkIHRoZSBlbmNvZGluZ3MgZmllbGRcbiAgICAvLyBiZWZvcmUgTTExMy5cbiAgICAvLyBBbm5vdW5jZWQgaGVyZTogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9nL2Rpc2N1c3Mtd2VicnRjL2MvLVFRM3B4cmwtZnc/cGxpPTFcbiAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgIGlmIChpc1NhZmFyaUJhc2VkKCkgfHxcbiAgICAvLyBFdmVuIHRobyBSTiBydW5zIE0xMTQsIGl0IGRvZXMgbm90IHByb2R1Y2UgU1ZDIGxheWVycyB3aGVuIGEgc2luZ2xlIGVuY29kaW5nXG4gICAgLy8gaXMgcHJvdmlkZWQuIFNvIHdlJ2xsIHVzZSB0aGUgbGVnYWN5IFNWQyBzcGVjaWZpY2F0aW9uIGZvciBub3cuXG4gICAgLy8gVE9ETzogd2hlbiB3ZSB1cHN0cmVhbSBsaWJ3ZWJydGMsIHRoaXMgd2lsbCBuZWVkIGFkZGl0aW9uYWwgdmVyaWZpY2F0aW9uXG4gICAgaXNSZWFjdE5hdGl2ZSgpIHx8IChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdDaHJvbWUnICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIudmVyc2lvbiwgJzExMycpIDwgMCkge1xuICAgICAgY29uc3QgYml0cmF0ZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAyIDogMztcbiAgICAgIC8vIHNhZmFyaSAxOC40IHVzZXMgYSBkaWZmZXJlbnQgc3ZjIEFQSSB0aGF0IHJlcXVpcmVzIHNjYWxlUmVzb2x1dGlvbkRvd25CeSB0byBiZSBzZXQuXG4gICAgICBjb25zdCByZXF1aXJlU2NhbGUgPSBpc1NhZmFyaVN2Y0FwaShicm93c2VyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICAgIC8vIGluIGxlZ2FjeSBTVkMsIHNjYWxlUmVzb2x1dGlvbkRvd25CeSBjYW5ub3QgYmUgc2V0XG4gICAgICAgIGVuY29kaW5ncy5wdXNoKHtcbiAgICAgICAgICByaWQ6IHZpZGVvUmlkc1syIC0gaV0sXG4gICAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlIC8gTWF0aC5wb3coYml0cmF0ZXNSYXRpbywgaSksXG4gICAgICAgICAgbWF4RnJhbWVyYXRlOiBvcmlnaW5hbC5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiByZXF1aXJlU2NhbGUgPyBNYXRoLnBvdygyLCBpKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGxlZ2FjeSBTVkMsIHNjYWxhYmlsaXR5TW9kZSBpcyBzZXQgb25seSBvbiB0aGUgZmlyc3QgZW5jb2RpbmdcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUgPSBzY2FsYWJpbGl0eU1vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5ncy5wdXNoKHtcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGU6IG9yaWdpbmFsLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBzY2FsYWJpbGl0eU1vZGU6IHNjYWxhYmlsaXR5TW9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmdzWzBdLnByaW9yaXR5ID0gb3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZ3NbMF0ubmV0d29ya1ByaW9yaXR5ID0gb3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJ1c2luZyBzdmMgZW5jb2RpbmdcIiwge1xuICAgICAgZW5jb2RpbmdzXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kaW5ncztcbiAgfVxuICBpZiAoIXVzZVNpbXVsY2FzdCkge1xuICAgIHJldHVybiBbdmlkZW9FbmNvZGluZ107XG4gIH1cbiAgbGV0IHByZXNldHMgPSBbXTtcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICBwcmVzZXRzID0gKF9hID0gc29ydFByZXNldHMob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcmVlblNoYXJlU2ltdWxjYXN0TGF5ZXJzKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCk7XG4gIH0gZWxzZSB7XG4gICAgcHJlc2V0cyA9IChfYiA9IHNvcnRQcmVzZXRzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb1NpbXVsY2FzdExheWVycykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpO1xuICB9XG4gIGxldCBtaWRQcmVzZXQ7XG4gIGlmIChwcmVzZXRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBsb3dQcmVzZXQgPSBwcmVzZXRzWzBdO1xuICAgIGlmIChwcmVzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIFssIG1pZFByZXNldF0gPSBwcmVzZXRzO1xuICAgIH1cbiAgICAvLyBOT1RFOlxuICAgIC8vICAgMS4gT3JkZXJpbmcgb2YgdGhlc2UgZW5jb2RpbmdzIGlzIGltcG9ydGFudC4gQ2hyb21lIHNlZW1zXG4gICAgLy8gICAgICB0byB1c2UgdGhlIGluZGV4IGludG8gZW5jb2RpbmdzIHRvIGRlY2lkZSB3aGljaCBsYXllclxuICAgIC8vICAgICAgdG8gZGlzYWJsZSB3aGVuIENQVSBjb25zdHJhaW5lZC5cbiAgICAvLyAgICAgIFNvIGVuY29kaW5ncyBzaG91bGQgYmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHNwYXRpYWxcbiAgICAvLyAgICAgIHJlc29sdXRpb24gb3JkZXIuXG4gICAgLy8gICAyLiBsaXZla2l0LXNlcnZlciB0cmFuc2xhdGVzIHJpZHMgaW50byBsYXllcnMuIFNvLCBhbGwgZW5jb2RpbmdzXG4gICAgLy8gICAgICBzaG91bGQgaGF2ZSB0aGUgYmFzZSBsYXllciBgcWAgYW5kIHRoZW4gbW9yZSBhZGRlZFxuICAgIC8vICAgICAgYmFzZWQgb24gb3RoZXIgY29uZGl0aW9ucy5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHNpemUgPj0gOTYwICYmIG1pZFByZXNldCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG1pZFByZXNldCwgb3JpZ2luYWxdLCBzb3VyY2VGcmFtZXJhdGUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA+PSA0ODApIHtcbiAgICAgIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbbG93UHJlc2V0LCBvcmlnaW5hbF0sIHNvdXJjZUZyYW1lcmF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbb3JpZ2luYWxdKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cykge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIC8vIGJhY2t1cENvZGVjIHNob3VsZCBub3QgYmUgdHJ1ZSBhbnltb3JlLCBkZWZhdWx0IGNvZGVjIGlzIHNldCBpbiBMb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hcbiAgaWYgKCFvcHRzLmJhY2t1cENvZGVjIHx8IG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUgfHwgb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyA9PT0gb3B0cy52aWRlb0NvZGVjKSB7XG4gICAgLy8gYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmcgaXMgZGlzYWJsZWRcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMpIHtcbiAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3JlcXVlc3RlZCBhIGRpZmZlcmVudCBjb2RlYyB0aGFuIHNwZWNpZmllZCBhcyBiYWNrdXAnLCB7XG4gICAgICBzZXJ2ZXJSZXF1ZXN0ZWQ6IHZpZGVvQ29kZWMsXG4gICAgICBiYWNrdXA6IG9wdHMuYmFja3VwQ29kZWMuY29kZWNcbiAgICB9KTtcbiAgfVxuICBvcHRzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAvLyB1c2UgYmFja3VwIGVuY29kaW5nIHNldHRpbmcgYXMgdmlkZW9FbmNvZGluZyBmb3IgYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmdcbiAgb3B0cy52aWRlb0VuY29kaW5nID0gb3B0cy5iYWNrdXBDb2RlYy5lbmNvZGluZztcbiAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGNvbnN0IHdpZHRoID0gKF9hID0gc2V0dGluZ3Mud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gKF9jID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGVpZ2h0O1xuICAvLyBkaXNhYmxlIHNpbXVsY2FzdCBmb3Igc2NyZWVuc2hhcmUgYmFja3VwIGNvZGVjIHNpbmNlIEwxVHggaXMgdXNlZCBieSBwcmltYXJ5IGNvZGVjXG4gIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiBvcHRzLnNpbXVsY2FzdCkge1xuICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBvcHRzKTtcbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBjb2RlYykge1xuICBjb25zdCBwcmVzZXRzID0gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCk7XG4gIGxldCB7XG4gICAgZW5jb2RpbmdcbiAgfSA9IHByZXNldHNbMF07XG4gIC8vIGhhbmRsZSBwb3J0cmFpdCBieSBzd2FwcGluZyBkaW1lbnNpb25zXG4gIGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVzZXRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcHJlc2V0ID0gcHJlc2V0c1tpXTtcbiAgICBlbmNvZGluZyA9IHByZXNldC5lbmNvZGluZztcbiAgICBpZiAocHJlc2V0LndpZHRoID49IHNpemUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBwcmVzZXRzIGFyZSBiYXNlZCBvbiB0aGUgYXNzdW1wdGlvbiBvZiB2cDggYXMgYSBjb2RlY1xuICAvLyBmb3Igb3RoZXIgY29kZWNzIHdlIGFkanVzdCB0aGUgbWF4Qml0cmF0ZSBpZiBubyBzcGVjaWZpYyB2aWRlb0VuY29kaW5nIGhhcyBiZWVuIHByb3ZpZGVkXG4gIC8vIHVzZXJzIHNob3VsZCBvdmVycmlkZSB0aGVzZSB3aXRoIG9uZXMgdGhhdCBhcmUgb3B0aW1pemVkIGZvciB0aGVpciB1c2UgY2FzZVxuICAvLyBOT1RFOiBTVkMgY29kZWMgYml0cmF0ZXMgYXJlIGluY2x1c2l2ZSBvZiBhbGwgc2NhbGFiaWxpdHkgbGF5ZXJzLiB3aGlsZVxuICAvLyBiaXRyYXRlIGZvciBub24tU1ZDIGNvZGVjcyBkb2VzIG5vdCBpbmNsdWRlIG90aGVyIHNpbXVsY2FzdCBsYXllcnMuXG4gIGlmIChjb2RlYykge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ2F2MSc6XG4gICAgICBjYXNlICdoMjY1JzpcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC43O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3ZwOSc6XG4gICAgICAgIGVuY29kaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZSAqIDAuODU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5jb2Rpbmc7XG59XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICByZXR1cm4gcHJlc2V0c1NjcmVlblNoYXJlO1xuICB9XG4gIGNvbnN0IGFzcGVjdCA9IHdpZHRoID4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBoZWlnaHQgLyB3aWR0aDtcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XG4gICAgcmV0dXJuIHByZXNldHMxNjk7XG4gIH1cbiAgcmV0dXJuIHByZXNldHM0Mztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCkge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyhvcmlnaW5hbCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gb3JpZ2luYWw7XG4gIGNvbnN0IGFzcGVjdCA9IHdpZHRoID4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBoZWlnaHQgLyB3aWR0aDtcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5O1xuICB9XG4gIHJldHVybiBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzO1xufVxuLy8gcHJlc2V0cyBzaG91bGQgYmUgb3JkZXJlZCBieSBsb3csIG1lZGl1bSwgaGlnaFxuZnVuY3Rpb24gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgcHJlc2V0cywgc291cmNlRnJhbWVyYXRlKSB7XG4gIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICBwcmVzZXRzLmZvckVhY2goKHByZXNldCwgaWR4KSA9PiB7XG4gICAgaWYgKGlkeCA+PSB2aWRlb1JpZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCByaWQgPSB2aWRlb1JpZHNbaWR4XTtcbiAgICBjb25zdCBlbmNvZGluZyA9IHtcbiAgICAgIHJpZCxcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgc2l6ZSAvIE1hdGgubWluKHByZXNldC53aWR0aCwgcHJlc2V0LmhlaWdodCkpLFxuICAgICAgbWF4Qml0cmF0ZTogcHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGVcbiAgICB9O1xuICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBzb3VyY2VGcmFtZXJhdGUgaXMgdGhlIGhpZ2hlc3QgZnJhbWVyYXRlIGFwcGxpZWQgYWNyb3NzIGFsbCBsYXllcnMgc28gdGhhdCB0aGVcbiAgICAvLyBvcmlnaW5hbCBlbmNvZGluZyBkb2Vzbid0IGdldCBidW1wZWQgdW5pbnRlbnRpb25hbGx5IGJ5IGFueSBvZiB0aGUgb3RoZXIgbGF5ZXJzXG4gICAgY29uc3QgbWF4RnJhbWVyYXRlID0gc291cmNlRnJhbWVyYXRlICYmIHByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUgPyBNYXRoLm1pbihzb3VyY2VGcmFtZXJhdGUsIHByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUpIDogcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICBpZiAobWF4RnJhbWVyYXRlKSB7XG4gICAgICBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPSBtYXhGcmFtZXJhdGU7XG4gICAgfVxuICAgIGNvbnN0IGNhblNldFByaW9yaXR5ID0gaXNGaXJlRm94KCkgfHwgaWR4ID09PSAwO1xuICAgIGlmIChwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHkgJiYgY2FuU2V0UHJpb3JpdHkpIHtcbiAgICAgIGVuY29kaW5nLnByaW9yaXR5ID0gcHJlc2V0LmVuY29kaW5nLnByaW9yaXR5O1xuICAgICAgZW5jb2RpbmcubmV0d29ya1ByaW9yaXR5ID0gcHJlc2V0LmVuY29kaW5nLnByaW9yaXR5O1xuICAgIH1cbiAgICBlbmNvZGluZ3MucHVzaChlbmNvZGluZyk7XG4gIH0pO1xuICAvLyBSTiBpb3Mgc2ltdWxjYXN0IHJlcXVpcmVzIGFsbCBzYW1lIGZyYW1lcmF0ZXMuXG4gIGlmIChpc1JlYWN0TmF0aXZlKCkgJiYgZ2V0UmVhY3ROYXRpdmVPcygpID09PSAnaW9zJykge1xuICAgIGxldCB0b3BGcmFtZXJhdGUgPSB1bmRlZmluZWQ7XG4gICAgZW5jb2RpbmdzLmZvckVhY2goZW5jb2RpbmcgPT4ge1xuICAgICAgaWYgKCF0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZy5tYXhGcmFtZXJhdGUgJiYgZW5jb2RpbmcubWF4RnJhbWVyYXRlID4gdG9wRnJhbWVyYXRlKSB7XG4gICAgICAgIHRvcEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbm90aWZ5T25jZSA9IHRydWU7XG4gICAgZW5jb2RpbmdzLmZvckVhY2goZW5jb2RpbmcgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAhPSB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgaWYgKG5vdGlmeU9uY2UpIHtcbiAgICAgICAgICBub3RpZnlPbmNlID0gZmFsc2U7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiU2ltdWxjYXN0IG9uIGlPUyBSZWFjdC1OYXRpdmUgcmVxdWlyZXMgYWxsIGVuY29kaW5ncyB0byBzaGFyZSB0aGUgc2FtZSBmcmFtZXJhdGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcIlNldHRpbmcgZnJhbWVyYXRlIG9mIGVuY29kaW5nIFxcXCJcIi5jb25jYXQoKF9hID0gZW5jb2RpbmcucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJywgXCJcXFwiIHRvIFwiKS5jb25jYXQodG9wRnJhbWVyYXRlKSk7XG4gICAgICAgIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IHRvcEZyYW1lcmF0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZW5jb2RpbmdzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gc29ydFByZXNldHMocHJlc2V0cykge1xuICBpZiAoIXByZXNldHMpIHJldHVybjtcbiAgcmV0dXJuIHByZXNldHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGVuY29kaW5nOiBhRW5jXG4gICAgfSA9IGE7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2Rpbmc6IGJFbmNcbiAgICB9ID0gYjtcbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlID4gYkVuYy5tYXhCaXRyYXRlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA8IGJFbmMubWF4Qml0cmF0ZSkgcmV0dXJuIC0xO1xuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPT09IGJFbmMubWF4Qml0cmF0ZSAmJiBhRW5jLm1heEZyYW1lcmF0ZSAmJiBiRW5jLm1heEZyYW1lcmF0ZSkge1xuICAgICAgcmV0dXJuIGFFbmMubWF4RnJhbWVyYXRlID4gYkVuYy5tYXhGcmFtZXJhdGUgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFNjYWxhYmlsaXR5TW9kZSB7XG4gIGNvbnN0cnVjdG9yKHNjYWxhYmlsaXR5TW9kZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBzY2FsYWJpbGl0eU1vZGUubWF0Y2goL15MKFxcZClUKFxcZCkoaHxfS0VZfF9LRVlfU0hJRlQpezAsMX0kLyk7XG4gICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFiaWxpdHkgbW9kZScpO1xuICAgIH1cbiAgICB0aGlzLnNwYXRpYWwgPSBwYXJzZUludChyZXN1bHRzWzFdKTtcbiAgICB0aGlzLnRlbXBvcmFsID0gcGFyc2VJbnQocmVzdWx0c1syXSk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMykge1xuICAgICAgc3dpdGNoIChyZXN1bHRzWzNdKSB7XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBjYXNlICdfS0VZJzpcbiAgICAgICAgY2FzZSAnX0tFWV9TSElGVCc6XG4gICAgICAgICAgdGhpcy5zdWZmaXggPSByZXN1bHRzWzNdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIFwiTFwiLmNvbmNhdCh0aGlzLnNwYXRpYWwsIFwiVFwiKS5jb25jYXQodGhpcy50ZW1wb3JhbCkuY29uY2F0KChfYSA9IHRoaXMuc3VmZml4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERlZmF1bHREZWdyYWRhdGlvblByZWZlcmVuY2UodHJhY2spIHtcbiAgLy8gYSBmZXcgb2YgcmVhc29ucyB3ZSBoYXZlIGRpZmZlcmVudCBkZWZhdWx0IHBhdGhzOlxuICAvLyAxLiB3aXRob3V0IHRoaXMsIENocm9tZSBzZWVtcyB0byBhZ2dyZXNzaXZlbHkgcmVzaXplIHRoZSBTVkMgdmlkZW8gc3RhdGluZyBgcXVhbGl0eS1saW1pdGF0aW9uOiBiYW5kd2lkdGhgIGV2ZW4gd2hlbiBCVyBpc24ndCBhbiBpc3N1ZVxuICAvLyAyLiBzaW5jZSB3ZSBhcmUgb3ZlcnJpZGluZyBjb250ZW50SGludCB0byBtb3Rpb24gKHRvIHdvcmthcm91bmQgTDFUMyBwdWJsaXNoaW5nKSwgaXQgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGRlZ3JhZGF0aW9uUHJlZmVyZW5jZSB0byBgYmFsYW5jZWRgXG4gIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSB8fCB0cmFjay5jb25zdHJhaW50cy5oZWlnaHQgJiYgdW53cmFwQ29uc3RyYWludCh0cmFjay5jb25zdHJhaW50cy5oZWlnaHQpID49IDEwODApIHtcbiAgICByZXR1cm4gJ21haW50YWluLXJlc29sdXRpb24nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnYmFsYW5jZWQnO1xuICB9XG59XG5cbmNvbnN0IHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjID0gNTAwMDtcbmNsYXNzIExvY2FsVmlkZW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICBnZXQgc2VuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zZW5kZXI7XG4gIH1cbiAgc2V0IHNlbmRlcihzZW5kZXIpIHtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gICAgaWYgKHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlKSB7XG4gICAgICB0aGlzLnNldERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0aGlzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgVHJhY2suS2luZC5WaWRlbywgY29uc3RyYWludHMsIHVzZXJQcm92aWRlZFRyYWNrLCBsb2dnZXJPcHRpb25zKTtcbiAgICAvKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSA9ICdiYWxhbmNlZCc7XG4gICAgdGhpcy5pc0NwdUNvbnN0cmFpbmVkID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpbWl6ZUZvclBlcmZvcm1hbmNlID0gZmFsc2U7XG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0cztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCB2aWRlbyBzZW5kZXIgc3RhdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzTWFwID0gbmV3IE1hcChzdGF0cy5tYXAocyA9PiBbcy5yaWQsIHNdKSk7XG4gICAgICBjb25zdCBpc0NwdUNvbnN0cmFpbmVkID0gc3RhdHMuc29tZShzID0+IHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb24gPT09ICdjcHUnKTtcbiAgICAgIGlmIChpc0NwdUNvbnN0cmFpbmVkICE9PSB0aGlzLmlzQ3B1Q29uc3RyYWluZWQpIHtcbiAgICAgICAgdGhpcy5pc0NwdUNvbnN0cmFpbmVkID0gaXNDcHVDb25zdHJhaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuaXNDcHVDb25zdHJhaW5lZCkge1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkNwdUNvbnN0cmFpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJldlN0YXRzKSB7XG4gICAgICAgIGxldCB0b3RhbEJpdHJhdGUgPSAwO1xuICAgICAgICBzdGF0c01hcC5mb3JFYWNoKChzLCBrZXkpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgcHJldiA9IChfYSA9IHRoaXMucHJldlN0YXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGtleSk7XG4gICAgICAgICAgdG90YWxCaXRyYXRlICs9IGNvbXB1dGVCaXRyYXRlKHMsIHByZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSB0b3RhbEJpdHJhdGU7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzTWFwO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZGVyTG9jayA9IG5ldyBfKCk7XG4gIH1cbiAgZ2V0IGlzU2ltdWxjYXN0KCkge1xuICAgIGlmICh0aGlzLnNlbmRlciAmJiB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCkuZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcihzaWduYWxDbGllbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNhdmUgb3JpZ2luYWwgZW5jb2RpbmdzXG4gICAgLy8gVE9ETyA6IG1lcmdlIHNpbXVsY2FzdCB0cmFja3Mgc3RhdHNcbiAgICBjb25zdCBwYXJhbXMgPSAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBhcmFtZXRlcnMoKTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICB0aGlzLmVuY29kaW5ncyA9IHBhcmFtcy5lbmNvZGluZ3M7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLmZvckVhY2godHJhY2tJbmZvID0+IHtcbiAgICAgIHRyYWNrSW5mby5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9KTtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHBhdXNlVXBzdHJlYW06IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5wYXVzZVVwc3RyZWFtXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICB2YXIgX2Q7XG4gICAgICB5aWVsZCBfc3VwZXIucGF1c2VVcHN0cmVhbS5jYWxsKHRoaXMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBfZiA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZzsgX2cgPSB5aWVsZCBfZi5uZXh0KCksIF9hID0gX2cuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcbiAgICAgICAgICBfYyA9IF9nLnZhbHVlO1xuICAgICAgICAgIF9lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICB5aWVsZCAoX2QgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gX2YucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICByZXN1bWVVcHN0cmVhbToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnJlc3VtZVVwc3RyZWFtXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICB2YXIgX2Q7XG4gICAgICB5aWVsZCBfc3VwZXIucmVzdW1lVXBzdHJlYW0uY2FsbCh0aGlzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcbiAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgeWllbGQgKF9kID0gc2Muc2VuZGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVwbGFjZVRyYWNrKHNjLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICBlXzIgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBjYW1lcmEgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHVubXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgdW5tdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xuICAgIHN1cGVyLnNldFRyYWNrTXV0ZWQobXV0ZWQpO1xuICAgIGZvciAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB9XG4gIH1cbiAgZ2V0U2VuZGVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgY29uc3QgdnMgPSB7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICBmcmFtZUhlaWdodDogdi5mcmFtZUhlaWdodCxcbiAgICAgICAgICAgIGZyYW1lV2lkdGg6IHYuZnJhbWVXaWR0aCxcbiAgICAgICAgICAgIGZyYW1lc1BlclNlY29uZDogdi5mcmFtZXNQZXJTZWNvbmQsXG4gICAgICAgICAgICBmcmFtZXNTZW50OiB2LmZyYW1lc1NlbnQsXG4gICAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uLFxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM6IHYucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMsXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMsXG4gICAgICAgICAgICByaWQ6IChfYSA9IHYucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2LmlkLFxuICAgICAgICAgICAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50OiB2LnJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCxcbiAgICAgICAgICAgIHRhcmdldEJpdHJhdGU6IHYudGFyZ2V0Qml0cmF0ZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXBcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vwqBsb2NhdGUgdGhlIGFwcHJvcHJpYXRlIHJlbW90ZS1pbmJvdW5kLXJ0cCBpdGVtXG4gICAgICAgICAgY29uc3QgciA9IHN0YXRzLmdldCh2LnJlbW90ZUlkKTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgdnMuaml0dGVyID0gci5qaXR0ZXI7XG4gICAgICAgICAgICB2cy5wYWNrZXRzTG9zdCA9IHIucGFja2V0c0xvc3Q7XG4gICAgICAgICAgICB2cy5yb3VuZFRyaXBUaW1lID0gci5yb3VuZFRyaXBUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtcy5wdXNoKHZzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBtYWtlIHN1cmUgaGlnaGVzdCByZXMgbGF5ZXIgaXMgYWx3YXlzIGZpcnN0XG4gICAgICBpdGVtcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoKF9hID0gYi5mcmFtZVdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAtICgoX2IgPSBhLmZyYW1lV2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSk7XG4gIH1cbiAgc2V0UHVibGlzaGluZ1F1YWxpdHkobWF4UXVhbGl0eSkge1xuICAgIGNvbnN0IHF1YWxpdGllcyA9IFtdO1xuICAgIGZvciAobGV0IHEgPSBWaWRlb1F1YWxpdHkuTE9XOyBxIDw9IFZpZGVvUXVhbGl0eS5ISUdIOyBxICs9IDEpIHtcbiAgICAgIHF1YWxpdGllcy5wdXNoKG5ldyBTdWJzY3JpYmVkUXVhbGl0eSh7XG4gICAgICAgIHF1YWxpdHk6IHEsXG4gICAgICAgIGVuYWJsZWQ6IHEgPD0gbWF4UXVhbGl0eVxuICAgICAgfSkpO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgcHVibGlzaGluZyBxdWFsaXR5LiBtYXggcXVhbGl0eSBcIi5jb25jYXQobWF4UXVhbGl0eSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGlzU1ZDQ29kZWModGhpcy5jb2RlYyksIHF1YWxpdGllcyk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgIHZhciBfZDtcbiAgICAgIGxldCBjb25zdHJhaW50cztcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKHtcbiAgICAgICAgICB2aWRlbzogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgY29uc3RyYWludHMgPSBzdHJlYW1Db25zdHJhaW50cy52aWRlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0KGNvbnN0cmFpbnRzKTtcbiAgICAgIC8vIHJlc2V0IGNwdSBjb25zdHJhaW5lZCBzdGF0ZSBhZnRlciB0cmFjayBpcyByZXN0YXJ0ZWRcbiAgICAgIHRoaXMuaXNDcHVDb25zdHJhaW5lZCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBfZiA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZzsgX2cgPSB5aWVsZCBfZi5uZXh0KCksIF9hID0gX2cuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcbiAgICAgICAgICBfYyA9IF9nLnZhbHVlO1xuICAgICAgICAgIF9lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICBpZiAoc2Muc2VuZGVyICYmICgoX2QgPSBzYy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3RhdGUpICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgc2MubWVkaWFTdHJlYW1UcmFjayA9IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpO1xuICAgICAgICAgICAgeWllbGQgc2Muc2VuZGVyLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfM18xKSB7XG4gICAgICAgIGVfMyA9IHtcbiAgICAgICAgICBlcnJvcjogZV8zXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gX2YucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0UHJvY2Vzc29yKHByb2Nlc3Nvcl8xKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBzZXRQcm9jZXNzb3I6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5zZXRQcm9jZXNzb3JcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocHJvY2Vzc29yKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgZV80LCBfYiwgX2M7XG4gICAgICAgIHZhciBfZCwgX2U7XG4gICAgICAgIHlpZWxkIF9zdXBlci5zZXRQcm9jZXNzb3IuY2FsbChfdGhpcywgcHJvY2Vzc29yLCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSk7XG4gICAgICAgIGlmICgoX2QgPSBfdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIF9nID0gX19hc3luY1ZhbHVlcyhfdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfaDsgX2ggPSB5aWVsZCBfZy5uZXh0KCksIF9hID0gX2guZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgX2MgPSBfaC52YWx1ZTtcbiAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICAgICAgeWllbGQgKF9lID0gc2Muc2VuZGVyKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVwbGFjZVRyYWNrKF90aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZV80XzEpIHtcbiAgICAgICAgICAgIGVfNCA9IHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVfNF8xXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBfZy5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9nKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBzZXREZWdyYWRhdGlvblByZWZlcmVuY2UocHJlZmVyZW5jZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSA9IHByZWZlcmVuY2U7XG4gICAgICBpZiAodGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgZGVncmFkYXRpb25QcmVmZXJlbmNlIHRvIFwiLmNvbmNhdChwcmVmZXJlbmNlKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgcGFyYW1zLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSA9IHByZWZlcmVuY2U7XG4gICAgICAgICAgdGhpcy5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcImZhaWxlZCB0byBzZXQgZGVncmFkYXRpb25QcmVmZXJlbmNlXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZFNpbXVsY2FzdFRyYWNrKGNvZGVjLCBlbmNvZGluZ3MpIHtcbiAgICBpZiAodGhpcy5zaW11bGNhc3RDb2RlY3MuaGFzKGNvZGVjKSkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXCJcIi5jb25jYXQoY29kZWMsIFwiIGFscmVhZHkgYWRkZWQsIHNraXBwaW5nIGFkZGluZyBzaW11bGNhc3QgY29kZWNcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHtcbiAgICAgIGNvZGVjLFxuICAgICAgbWVkaWFTdHJlYW1UcmFjazogdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCksXG4gICAgICBzZW5kZXI6IHVuZGVmaW5lZCxcbiAgICAgIGVuY29kaW5nc1xuICAgIH07XG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3Muc2V0KGNvZGVjLCBzaW11bGNhc3RDb2RlY0luZm8pO1xuICAgIHJldHVybiBzaW11bGNhc3RDb2RlY0luZm87XG4gIH1cbiAgc2V0U2ltdWxjYXN0VHJhY2tTZW5kZXIoY29kZWMsIHNlbmRlcikge1xuICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHRoaXMuc2ltdWxjYXN0Q29kZWNzLmdldChjb2RlYyk7XG4gICAgaWYgKCFzaW11bGNhc3RDb2RlY0luZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlciA9IHNlbmRlcjtcbiAgICAvLyBicm93c2VyIHdpbGwgcmVlbmFibGUgZGlzYWJsZWQgY29kZWMvbGF5ZXJzIGFmdGVyIG5ldyBjb2RlYyBoYXMgYmVlbiBwdWJsaXNoZWQsXG4gICAgLy8gc28gcmVmcmVzaCBzdWJzY3JpYmVkQ29kZWNzIGFmdGVyIHB1Ymxpc2ggYSBuZXcgY29kZWNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZWRDb2RlY3MpIHtcbiAgICAgICAgdGhpcy5zZXRQdWJsaXNoaW5nQ29kZWNzKHRoaXMuc3Vic2NyaWJlZENvZGVjcyk7XG4gICAgICB9XG4gICAgfSwgcmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogU2V0cyBjb2RlY3MgdGhhdCBzaG91bGQgYmUgcHVibGlzaGluZywgcmV0dXJucyBuZXcgY29kZWNzIHRoYXQgaGF2ZSBub3QgeWV0XG4gICAqIGJlZW4gcHVibGlzaGVkXG4gICAqL1xuICBzZXRQdWJsaXNoaW5nQ29kZWNzKGNvZGVjcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIGNvZGVjc18xLCBjb2RlY3NfMV8xO1xuICAgICAgdmFyIF9iLCBlXzUsIF9jLCBfZDtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgY29kZWNzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGNvZGVjcyxcbiAgICAgICAgY3VycmVudENvZGVjOiB0aGlzLmNvZGVjXG4gICAgICB9KSk7XG4gICAgICAvLyBvbmx5IGVuYWJsZSBzaW11bGNhc3QgY29kZWMgZm9yIHByZWZlcmVuY2UgY29kZWMgc2V0dGVkXG4gICAgICBpZiAoIXRoaXMuY29kZWMgJiYgY29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGlzU1ZDQ29kZWMoY29kZWNzWzBdLmNvZGVjKSwgY29kZWNzWzBdLnF1YWxpdGllcyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3Vic2NyaWJlZENvZGVjcyA9IGNvZGVjcztcbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfYSA9IHRydWUsIGNvZGVjc18xID0gX19hc3luY1ZhbHVlcyhjb2RlY3MpOyBjb2RlY3NfMV8xID0geWllbGQgY29kZWNzXzEubmV4dCgpLCBfYiA9IGNvZGVjc18xXzEuZG9uZSwgIV9iOyBfYSA9IHRydWUpIHtcbiAgICAgICAgICBfZCA9IGNvZGVjc18xXzEudmFsdWU7XG4gICAgICAgICAgX2EgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IF9kO1xuICAgICAgICAgIGlmICghdGhpcy5jb2RlYyB8fCB0aGlzLmNvZGVjID09PSBjb2RlYy5jb2RlYykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGlzU1ZDQ29kZWMoY29kZWMuY29kZWMpLCBjb2RlYy5xdWFsaXRpZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMuY29kZWMpO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cnkgc2V0UHVibGlzaGluZ0NvZGVjIGZvciBcIi5jb25jYXQoY29kZWMuY29kZWMpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgc2ltdWxjYXN0Q29kZWNJbmZvXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoIXNpbXVsY2FzdENvZGVjSW5mbyB8fCAhc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlcikge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHEgb2YgY29kZWMucXVhbGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgbmV3Q29kZWNzLnB1c2goY29kZWMuY29kZWMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cnkgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlciBcIi5jb25jYXQoY29kZWMuY29kZWMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICB5aWVsZCBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIsIHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MsIGNvZGVjLnF1YWxpdGllcywgdGhpcy5zZW5kZXJMb2NrLCBpc1NWQ0NvZGVjKGNvZGVjLmNvZGVjKSwgdGhpcy5sb2csIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzVfMSkge1xuICAgICAgICBlXzUgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfNV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2EgJiYgIV9iICYmIChfYyA9IGNvZGVjc18xLnJldHVybikpIHlpZWxkIF9jLmNhbGwoY29kZWNzXzEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0NvZGVjcztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgbGF5ZXJzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmdcbiAgICovXG4gIHNldFB1Ymxpc2hpbmdMYXllcnMoaXNTdmMsIHF1YWxpdGllcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZUZvclBlcmZvcm1hbmNlKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oJ3NraXBwaW5nIHNldFB1Ymxpc2hpbmdMYXllcnMgZHVlIHRvIG9wdGltaXplZCBwdWJsaXNoaW5nIHBlcmZvcm1hbmNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgcXVhbGl0aWVzXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBsYXllcnMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcXVhbGl0aWVzXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyIHx8ICF0aGlzLmVuY29kaW5ncykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5aWVsZCBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHRoaXMuc2VuZGVyLCB0aGlzLmVuY29kaW5ncywgcXVhbGl0aWVzLCB0aGlzLnNlbmRlckxvY2ssIGlzU3ZjLCB0aGlzLmxvZywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVzaWduZWQgZm9yIGxvd2VyIHBvd2VyZWQgZGV2aWNlcywgcmVkdWNlcyB2aWRlbyBwdWJsaXNoaW5nIHF1YWxpdHkgYW5kIGRpc2FibGVzIHNpbXVsY2FzdC5cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgcHJpb3JpdGl6ZVBlcmZvcm1hbmNlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5zZW5kZXJMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMub3B0aW1pemVGb3JQZXJmb3JtYW5jZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHBhcmFtcy5lbmNvZGluZ3MubWFwKChlLCBpZHgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZSksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogaWR4ID09PSAwLFxuICAgICAgICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiBNYXRoLm1heCgxLCBNYXRoLmNlaWwoKChfYSA9IHRoaXMubWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmhlaWdodCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMzYwKSAvIDM2MCkpLFxuICAgICAgICAgICAgc2NhbGFiaWxpdHlNb2RlOiBpZHggPT09IDAgJiYgaXNTVkNDb2RlYyh0aGlzLmNvZGVjKSA/ICdMMVQzJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1heEZyYW1lcmF0ZTogaWR4ID09PSAwID8gMTUgOiAwLFxuICAgICAgICAgICAgbWF4Qml0cmF0ZTogaWR4ID09PSAwID8gZS5tYXhCaXRyYXRlIDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcGVyZm9ybWFuY2Ugb3B0aW1pc2VkIGVuY29kaW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVuY29kaW5nczogcGFyYW1zLmVuY29kaW5nc1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdzID0gcGFyYW1zLmVuY29kaW5ncztcbiAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignZmFpbGVkIHRvIHNldCBwZXJmb3JtYW5jZSBvcHRpbWlzZWQgZW5jb2RpbmdzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLm9wdGltaXplRm9yUGVyZm9ybWFuY2UgPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNJbkJhY2tncm91bmQgJiYgdGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoc2VuZGVyLCBzZW5kZXJFbmNvZGluZ3MsIHF1YWxpdGllcywgc2VuZGVyTG9jaywgaXNTVkMsIGxvZywgbG9nQ29udGV4dCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHNlbmRlckxvY2subG9jaygpO1xuICAgIGxvZy5kZWJ1Zygnc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcbiAgICAgIHNlbmRlcixcbiAgICAgIHF1YWxpdGllcyxcbiAgICAgIHNlbmRlckVuY29kaW5nc1xuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5jb2RpbmdzXG4gICAgICB9ID0gcGFyYW1zO1xuICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuY29kaW5ncy5sZW5ndGggIT09IHNlbmRlckVuY29kaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgbG9nLndhcm4oJ2Nhbm5vdCBzZXQgcHVibGlzaGluZyBsYXllcnMsIGVuY29kaW5ncyBtaXNtYXRjaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgICAgc2VuZGVyRW5jb2RpbmdzXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIC8qIGRpc2FibGUgY2xvc2FibGUgc3BhdGlhbCBsYXllciBhcyBpdCBoYXMgdmlkZW8gYmx1ciAvIGZyb3plbiBpc3N1ZSB3aXRoIGN1cnJlbnQgc2VydmVyIC8gY2xpZW50XG4gICAgICAxLiBjaHJvbWUgMTEzOiB3aGVuIHN3aXRjaGluZyB0byB1cCBsYXllciB3aXRoIHNjYWxhYmlsaXR5IE1vZGUgY2hhbmdlLCBpdCB3aWxsIGdlbmVyYXRlIGFcbiAgICAgICAgICAgIGxvdyByZXNvbHV0aW9uIGZyYW1lIGFuZCByZWNvdmVyIHZlcnkgcXVpY2tseSwgYnV0IG5vdGljYWJsZVxuICAgICAgMi4gbGl2ZWtpdCBzZnU6IGFkZGl0aW9uYWwgcGxpIHJlcXVlc3QgY2F1c2UgdmlkZW8gZnJvemVuIGZvciBhIGZldyBmcmFtZXMsIGFsc28gbm90aWNhYmxlICovXG4gICAgICBjb25zdCBjbG9zYWJsZVNwYXRpYWwgPSBmYWxzZTtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGlmIChjbG9zYWJsZVNwYXRpYWwgJiYgZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSkgOyBlbHNlIHtcbiAgICAgICAgaWYgKGlzU1ZDKSB7XG4gICAgICAgICAgY29uc3QgaGFzRW5hYmxlZEVuY29kaW5nID0gcXVhbGl0aWVzLnNvbWUocSA9PiBxLmVuYWJsZWQpO1xuICAgICAgICAgIGlmIChoYXNFbmFibGVkRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHF1YWxpdGllcy5mb3JFYWNoKHEgPT4gcS5lbmFibGVkID0gdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNpbXVsY2FzdCBkeW5hY2FzdCBlbmNvZGluZ3NcbiAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgbGV0IHJpZCA9IChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgICAgaWYgKHJpZCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJpZCA9ICdxJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZChyaWQpO1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWFsaXR5ID0gcXVhbGl0aWVzLmZpbmQocSA9PiBxLnF1YWxpdHkgPT09IHF1YWxpdHkpO1xuICAgICAgICAgIGlmICghc3Vic2NyaWJlZFF1YWxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSAhPT0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkO1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBsYXllciBcIi5jb25jYXQoc3Vic2NyaWJlZFF1YWxpdHkucXVhbGl0eSwgXCIgdG8gXCIpLmNvbmNhdChlbmNvZGluZy5hY3RpdmUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnKSwgbG9nQ29udGV4dCk7XG4gICAgICAgICAgICAvLyBGaXJlRm94IGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyBlbmNvZGluZy5hY3RpdmUgdG8gZmFsc2UsIHNvIHdlXG4gICAgICAgICAgICAvLyBoYXZlIGEgd29ya2Fyb3VuZCBvZiBsb3dlcmluZyBpdHMgYml0cmF0ZSBhbmQgcmVzb2x1dGlvbiB0byB0aGUgbWluLlxuICAgICAgICAgICAgaWYgKGlzRmlyZUZveCgpKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhGcmFtZVJhdGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gNDtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gMTA7XG4gICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEZyYW1lUmF0ZSA9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBlbmNvZGluZ3NcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVuY29kaW5nczogcGFyYW1zLmVuY29kaW5nc1xuICAgICAgICB9KSk7XG4gICAgICAgIHlpZWxkIHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKSB7XG4gIHN3aXRjaCAocmlkKSB7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcbiAgICBjYXNlICdxJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gIH1cbn1cbmZ1bmN0aW9uIHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyh3aWR0aCwgaGVpZ2h0LCBlbmNvZGluZ3MsIHN2Yykge1xuICAvLyBkZWZhdWx0IHRvIGEgc2luZ2xlIGxheWVyLCBIUVxuICBpZiAoIWVuY29kaW5ncykge1xuICAgIHJldHVybiBbbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgcXVhbGl0eTogVmlkZW9RdWFsaXR5LkhJR0gsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJpdHJhdGU6IDAsXG4gICAgICBzc3JjOiAwXG4gICAgfSldO1xuICB9XG4gIGlmIChzdmMpIHtcbiAgICAvLyBzdmMgbGF5ZXJzXG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGNvbnN0IGVuY29kaW5nU00gPSBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlO1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShlbmNvZGluZ1NNKTtcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcbiAgICBjb25zdCByZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAxLjUgOiAyO1xuICAgIGNvbnN0IGJpdHJhdGVzUmF0aW8gPSBzbS5zdWZmaXggPT0gJ2gnID8gMiA6IDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbS5zcGF0aWFsOyBpICs9IDEpIHtcbiAgICAgIGxheWVycy5wdXNoKG5ldyBWaWRlb0xheWVyKHtcbiAgICAgICAgcXVhbGl0eTogTWF0aC5taW4oVmlkZW9RdWFsaXR5LkhJR0gsIHNtLnNwYXRpYWwgLSAxKSAtIGksXG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBNYXRoLnBvdyhyZXNSYXRpbywgaSkpLFxuICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyBNYXRoLnBvdyhyZXNSYXRpbywgaSkpLFxuICAgICAgICBiaXRyYXRlOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSA/IE1hdGguY2VpbChlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIE1hdGgucG93KGJpdHJhdGVzUmF0aW8sIGkpKSA6IDAsXG4gICAgICAgIHNzcmM6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuICByZXR1cm4gZW5jb2RpbmdzLm1hcChlbmNvZGluZyA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3Qgc2NhbGUgPSAoX2EgPSBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgbGV0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQoKF9iID0gZW5jb2RpbmcucmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKHtcbiAgICAgIHF1YWxpdHksXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoIC8gc2NhbGUpLFxuICAgICAgaGVpZ2h0OiBNYXRoLmNlaWwoaGVpZ2h0IC8gc2NhbGUpLFxuICAgICAgYml0cmF0ZTogKF9jID0gZW5jb2RpbmcubWF4Qml0cmF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCxcbiAgICAgIHNzcmM6IDBcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IGxvc3N5RGF0YUNoYW5uZWwgPSAnX2xvc3N5JztcbmNvbnN0IHJlbGlhYmxlRGF0YUNoYW5uZWwgPSAnX3JlbGlhYmxlJztcbmNvbnN0IG1pblJlY29ubmVjdFdhaXQgPSAyICogMTAwMDtcbmNvbnN0IGxlYXZlUmVjb25uZWN0ID0gJ2xlYXZlLXJlY29ubmVjdCc7XG5jb25zdCByZWxpYWJlUmVjZWl2ZVN0YXRlVFRMID0gMzAwMDA7XG52YXIgUENTdGF0ZTtcbihmdW5jdGlvbiAoUENTdGF0ZSkge1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJOZXdcIl0gPSAwXSA9IFwiTmV3XCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IDFdID0gXCJDb25uZWN0ZWRcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gMl0gPSBcIkRpc2Nvbm5lY3RlZFwiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJSZWNvbm5lY3RpbmdcIl0gPSAzXSA9IFwiUmVjb25uZWN0aW5nXCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNsb3NlZFwiXSA9IDRdID0gXCJDbG9zZWRcIjtcbn0pKFBDU3RhdGUgfHwgKFBDU3RhdGUgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkO1xuICB9XG4gIGdldCBwZW5kaW5nUmVjb25uZWN0KCkge1xuICAgIHJldHVybiAhIXRoaXMucmVjb25uZWN0VGltZW91dDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ0Y0NvbmZpZyA9IHt9O1xuICAgIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5sYXRlc3RSZW1vdGVPZmZlcklkID0gMDtcbiAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gZmFsc2U7XG4gICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5OZXc7XG4gICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzID0ge307XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RTdGFydCA9IDA7XG4gICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgLyoqIGtlZXBzIHRyYWNrIG9mIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBoYXMgYmVlbiB0cmllZCAqL1xuICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcbiAgICAvKiogc3BlY2lmaWVzIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIHJldHJ5ICovXG4gICAgdGhpcy5tYXhKb2luQXR0ZW1wdHMgPSAxO1xuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5yZWxpYWJsZURhdGFTZXF1ZW5jZSA9IDE7XG4gICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIgPSBuZXcgRGF0YVBhY2tldEJ1ZmZlcigpO1xuICAgIHRoaXMucmVsaWFibGVSZWNlaXZlZFN0YXRlID0gbmV3IFRUTE1hcChyZWxpYWJlUmVjZWl2ZVN0YXRlVFRMKTtcbiAgICB0aGlzLm1pZFRvVHJhY2tJZCA9IHt9O1xuICAgIC8qKiB1c2VkIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IHdhaXRpbmcgdG8gcmVjb25uZWN0ICovXG4gICAgdGhpcy5pc1dhaXRpbmdGb3JOZXR3b3JrUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbCA9IF9hID0+IF9fYXdhaXRlcih0aGlzLCBbX2FdLCB2b2lkIDAsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHtcbiAgICAgICAgY2hhbm5lbFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgX3RoaXMucmVsaWFibGVEQ1N1YiA9IGNoYW5uZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5sYWJlbCA9PT0gbG9zc3lEYXRhQ2hhbm5lbCkge1xuICAgICAgICAgIF90aGlzLmxvc3N5RENTdWIgPSBjaGFubmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5sb2cuZGVidWcoXCJvbiBkYXRhIGNoYW5uZWwgXCIuY29uY2F0KGNoYW5uZWwuaWQsIFwiLCBcIikuY29uY2F0KGNoYW5uZWwubGFiZWwpLCBfdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgY2hhbm5lbC5vbm1lc3NhZ2UgPSBfdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZURhdGFNZXNzYWdlID0gbWVzc2FnZSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc3BlY3QgaW5jb21pbmcgZGF0YSBtZXNzYWdlIG9yZGVyIGJ5IHByb2Nlc3NpbmcgbWVzc2FnZSBldmVudHMgb25lIGFmdGVyIHRoZSBvdGhlclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5kYXRhUHJvY2Vzc0xvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZGVjb2RlXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlciA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgYnVmZmVyID0geWllbGQgbWVzc2FnZS5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ3Vuc3VwcG9ydGVkIGRhdGEgdHlwZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcCA9IERhdGFQYWNrZXQuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgaWYgKGRwLnNlcXVlbmNlID4gMCAmJiBkcC5wYXJ0aWNpcGFudFNpZCAhPT0gJycpIHtcbiAgICAgICAgICBjb25zdCBsYXN0U2VxID0gdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUuZ2V0KGRwLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgICBpZiAobGFzdFNlcSAmJiBkcC5zZXF1ZW5jZSA8PSBsYXN0U2VxKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZHVwbGljYXRlIG9yIG91dC1vZi1vcmRlciBwYWNrZXRzIGluIHJlbGlhYmxlIGNoYW5uZWxcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUuc2V0KGRwLnBhcnRpY2lwYW50U2lkLCBkcC5zZXF1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnc3BlYWtlcicpIHtcbiAgICAgICAgICAvLyBkaXNwYXRjaCBzcGVha2VyIHVwZGF0ZXNcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIGRwLnZhbHVlLnZhbHVlLnNwZWFrZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKF9iID0gZHAudmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ2VuY3J5cHRlZFBhY2tldCcpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdSZWNlaXZlZCBlbmNyeXB0ZWQgcGFja2V0IGJ1dCBFMkVFIG5vdCBzZXQgdXAnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0geWllbGQgKF9jID0gdGhpcy5lMmVlTWFuYWdlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmhhbmRsZUVuY3J5cHRlZERhdGEoZHAudmFsdWUudmFsdWUuZW5jcnlwdGVkVmFsdWUsIGRwLnZhbHVlLnZhbHVlLml2LCBkcC5wYXJ0aWNpcGFudElkZW50aXR5LCBkcC52YWx1ZS52YWx1ZS5rZXlJbmRleCk7XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkUGFja2V0ID0gRW5jcnlwdGVkUGFja2V0UGF5bG9hZC5mcm9tQmluYXJ5KGRlY3J5cHRlZERhdGEucGF5bG9hZCk7XG4gICAgICAgICAgY29uc3QgbmV3RHAgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAgICB2YWx1ZTogZGVjcnlwdGVkUGFja2V0LnZhbHVlLFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogZHAucGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50U2lkOiBkcC5wYXJ0aWNpcGFudFNpZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICgoKF9kID0gbmV3RHAudmFsdWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYXNlKSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBhcHBseVVzZXJEYXRhQ29tcGF0KG5ld0RwLCBuZXdEcC52YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIG5ld0RwLCBkcC52YWx1ZS52YWx1ZS5lbmNyeXB0aW9uVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCgoX2UgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhc2UpID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGFwcGx5VXNlckRhdGFDb21wYXQoZHAsIGRwLnZhbHVlLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgZHAsIEVuY3J5cHRpb25fVHlwZS5OT05FKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVEYXRhRXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/ICdsb3NzeScgOiAncmVsaWFibGUnO1xuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCAmJiBldmVudC5lcnJvcikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IGV2ZW50LmVycm9yO1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIkRhdGFDaGFubmVsIGVycm9yIG9uIFwiLmNvbmNhdChjaGFubmVsS2luZCwgXCI6IFwiKS5jb25jYXQoZXZlbnQubWVzc2FnZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwiVW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93ID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsS2luZCA9IGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyBEYXRhUGFja2V0X0tpbmQuTE9TU1kgOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhjaGFubmVsS2luZCk7XG4gICAgfTtcbiAgICAvLyB3ZWJzb2NrZXQgcmVjb25uZWN0IGJlaGF2aW9yLiBpZiB3ZWJzb2NrZXQgaXMgaW50ZXJydXB0ZWQsIGFuZCB0aGUgUGVlckNvbm5lY3Rpb25cbiAgICAvLyBjb250aW51ZXMgdG8gd29yaywgd2UgY2FuIHJlY29ubmVjdCB0byB3ZWJzb2NrZXQgdG8gY29udGludWUgdGhlIHNlc3Npb25cbiAgICAvLyBhZnRlciBhIG51bWJlciBvZiByZXRyaWVzLCB3ZSdsbCBjbG9zZSBhbmQgZ2l2ZSB1cCBwZXJtYW5lbnRseVxuICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCA9IChjb25uZWN0aW9uLCBkaXNjb25uZWN0UmVhc29uKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cud2FybihcIlwiLmNvbmNhdChjb25uZWN0aW9uLCBcIiBkaXNjb25uZWN0ZWRcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAvLyBvbmx5IHJlc2V0IHN0YXJ0IHRpbWUgb24gdGhlIGZpcnN0IHRyeVxuICAgICAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSBkdXJhdGlvbiA9PiB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oXCJjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyIFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzLCBcIiBhdHRlbXB0cywgXCIpLmNvbmNhdChkdXJhdGlvbiwgXCJtcy4gZ2l2aW5nIHVwXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQ7XG4gICAgICBsZXQgZGVsYXkgPSB0aGlzLmdldE5leHRSZXRyeURlbGF5KHtcbiAgICAgICAgZWxhcHNlZE1zOiBkdXJhdGlvbixcbiAgICAgICAgcmV0cnlDb3VudDogdGhpcy5yZWNvbm5lY3RBdHRlbXB0c1xuICAgICAgfSk7XG4gICAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgZGlzY29ubmVjdChkdXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25uZWN0aW9uID09PSBsZWF2ZVJlY29ubmVjdCkge1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY29ubmVjdGluZyBpbiBcIi5jb25jYXQoZGVsYXksIFwibXNcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgaWYgKHRoaXMudG9rZW4gJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgICAvLyB0b2tlbiBtYXkgaGF2ZSBiZWVuIHJlZnJlc2hlZCwgd2UgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhlIHJlZ2lvblVybFByb3ZpZGVyXG4gICAgICAgIC8vIHNpbmNlIHRoZSBjdXJyZW50IGVuZ2luZSBtYXkgaGF2ZSBpbmhlcml0ZWQgYSByZWdpb25hbCB1cmxcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0aGlzLnRva2VuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5hdHRlbXB0UmVjb25uZWN0KGRpc2Nvbm5lY3RSZWFzb24pLmZpbmFsbHkoKCkgPT4gdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gdW5kZWZpbmVkKSwgZGVsYXkpO1xuICAgIH07XG4gICAgdGhpcy53YWl0Rm9yUmVzdGFydGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25SZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5SZXN0YXJ0ZWQsIG9uUmVzdGFydGVkKTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzID0ga2luZCA9PiB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgICAgIGlmIChkYykge1xuICAgICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLmFsaWduQnVmZmVyZWRBbW91bnQoZGMuYnVmZmVyZWRBbW91bnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpO1xuICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgIT09ICd1bmRlZmluZWQnICYmIHN0YXR1cyAhPT0gdGhpcy5kY0J1ZmZlclN0YXR1cy5nZXQoa2luZCkpIHtcbiAgICAgICAgdGhpcy5kY0J1ZmZlclN0YXR1cy5zZXQoa2luZCwgc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaXNCdWZmZXJTdGF0dXNMb3cgPSBraW5kID0+IHtcbiAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgICBpZiAoZGMpIHtcbiAgICAgICAgcmV0dXJuIGRjLmJ1ZmZlcmVkQW1vdW50IDw9IGRjLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnVybCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoYXNOZXR3b3JrQ29ubmVjdGlvbiA9IHlpZWxkIGZldGNoKHRvSHR0cFVybCh0aGlzLnVybCksIHtcbiAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgIH0pLnRoZW4ocmVzcCA9PiByZXNwLm9rKS5jYXRjaCgoKSA9PiBmYWxzZSk7XG4gICAgICBpZiAoIWhhc05ldHdvcmtDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmluZm8oJ2RldGVjdGVkIG5ldHdvcmsgcmVjb25uZWN0ZWQnKTtcbiAgICAgIGlmIChcbiAgICAgIC8vIGluIGNhc2UgdGhlIGVuZ2luZSBpcyBjdXJyZW50bHkgcmVjb25uZWN0aW5nLCBhdHRlbXB0IGEgcmVjb25uZWN0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBicm93c2VyIHN0YXRlIGhhcyBjaGFuZ2VkIHRvICdvbkxpbmUnXG4gICAgICB0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcgfHxcbiAgICAgIC8vIGFsc28gaWYgdGhlIGJyb3dzZXIgd2VudCBvZmZsaW5lIGJlZm9yZSBhbmQgdGhlIGVuZ2luZSBzdGlsbCB0aGlua3MgaXQncyBpbiBhIGNvbm5lY3RlZCBzdGF0ZSwgdHJlYXQgaXQgYXMgYSBuZXR3b3JrIGludGVycnVwdGlvbiB0aGF0IHdlIGhhdmVuJ3Qgbm90aWNlZCB5ZXRcbiAgICAgIHRoaXMuaXNXYWl0aW5nRm9yTmV0d29ya1JlY29ubmVjdCAmJiB0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcbiAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JOZXR3b3JrUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVCcm93c2VyT2ZmbGluZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy51cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFtmZXRjaCh0b0h0dHBVcmwodGhpcy51cmwpLCB7XG4gICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgfSksXG4gICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gaW50ZXJuZXQgY29ubmVjdGlvbiB0aGUgZmV0Y2ggcmVqZWN0cyBpbW1lZGlhdGVseSwgc28gd2Ugb25seSB1c2UgYSBzaG9ydCB0aW1lb3V0IGhlcmVcbiAgICAgICAgc2xlZXAoNDAwMCkudGhlbigoKSA9PiBQcm9taXNlLnJlamVjdCgpKV0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBvbmx5IHNldCBpZiB0aGUgYnJvd3NlciBzdGlsbCB0aGlua3MgaXQncyBvZmZsaW5lIGFmdGVyIHRoZSByZXF1ZXN0IGZhaWxlZFxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuaW5mbygnZGV0ZWN0ZWQgbmV0d29yayBpbnRlcnJ1cHRpb24nKTtcbiAgICAgICAgICB0aGlzLmlzV2FpdGluZ0Zvck5ldHdvcmtSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gb3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5FbmdpbmUpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IHtcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBTaWduYWxDbGllbnQodW5kZWZpbmVkLCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50LnNpZ25hbExhdGVuY3kgPSB0aGlzLm9wdGlvbnMuZXhwU2lnbmFsTGF0ZW5jeTtcbiAgICB0aGlzLnJlY29ubmVjdFBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQb2xpY3k7XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMuZGNCdWZmZXJTdGF0dXMgPSBuZXcgTWFwKFtbRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlXSwgW0RhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZV1dKTtcbiAgICB0aGlzLmNsaWVudC5vblBhcnRpY2lwYW50VXBkYXRlID0gdXBkYXRlcyA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHVwZGF0ZXMpO1xuICAgIHRoaXMuY2xpZW50Lm9uQ29ubmVjdGlvblF1YWxpdHkgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uUm9vbVVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvbkVycm9yID0gcmVzcCA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHJlc3ApO1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblNwZWFrZXJzQ2hhbmdlZCA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3RyZWFtU3RhdGVVcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblJlcXVlc3RSZXNwb25zZSA9IHJlc3BvbnNlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXF1ZXN0UmVzcG9uc2UsIHJlc3BvbnNlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiAoX2IgPSAoX2EgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lLFxuICAgICAgcm9vbUlEOiAoX2QgPSAoX2MgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJvb20pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zaWQsXG4gICAgICBwYXJ0aWNpcGFudDogKF9mID0gKF9lID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmlkZW50aXR5LFxuICAgICAgcElEOiB0aGlzLnBhcnRpY2lwYW50U2lkXG4gICAgfTtcbiAgfVxuICBqb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgdGhpcy5zaWduYWxPcHRzID0gb3B0cztcbiAgICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gb3B0cy5tYXhSZXRyaWVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5qb2luQXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNsaWVudC5qb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgICAgdGhpcy5faXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnk7XG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNvbmZpZ3VyZShqb2luUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBvZmZlclxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlclByaW1hcnkgfHwgam9pblJlc3BvbnNlLmZhc3RQdWJsaXNoKSB7XG4gICAgICAgICAgdGhpcy5uZWdvdGlhdGUoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcihlcnIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3Rlck9uTGluZUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbiA9IGpvaW5SZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCBqb2luUmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIGlmIChlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiQ291bGRuJ3QgY29ubmVjdCB0byBzZXJ2ZXIsIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMuam9pbkF0dGVtcHRzLCBcIiBvZiBcIikuY29uY2F0KHRoaXMubWF4Sm9pbkF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmpvaW5BdHRlbXB0cyA8IHRoaXMubWF4Sm9pbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNsb3NpbmcpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbGVhbnVwUGVlckNvbm5lY3Rpb25zKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICB0aGlzLnBjTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGRjQ2xlYW51cCA9IGRjID0+IHtcbiAgICAgICAgaWYgKCFkYykgcmV0dXJuO1xuICAgICAgICBkYy5jbG9zZSgpO1xuICAgICAgICBkYy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gbnVsbDtcbiAgICAgICAgZGMub25jbG9zZSA9IG51bGw7XG4gICAgICAgIGRjLm9uY2xvc2luZyA9IG51bGw7XG4gICAgICAgIGRjLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBkYy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBkYy5vbm9wZW4gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLmxvc3N5REMpO1xuICAgICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQ1N1Yik7XG4gICAgICBkY0NsZWFudXAodGhpcy5yZWxpYWJsZURDKTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlRENTdWIpO1xuICAgICAgdGhpcy5sb3NzeURDID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sb3NzeURDU3ViID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZURDID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZURDU3ViID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIgPSBuZXcgRGF0YVBhY2tldEJ1ZmZlcigpO1xuICAgICAgdGhpcy5yZWxpYWJsZURhdGFTZXF1ZW5jZSA9IDE7XG4gICAgICB0aGlzLnJlbGlhYmxlUmVjZWl2ZWRTdGF0ZS5jbGVhcigpO1xuICAgIH0pO1xuICB9XG4gIGNsZWFudXBDbGllbnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gICAgICB0aGlzLmNsaWVudC5yZXNldENhbGxiYWNrcygpO1xuICAgIH0pO1xuICB9XG4gIGFkZFRyYWNrKHJlcSkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXSkge1xuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCdhIHRyYWNrIHdpdGggdGhlIHNhbWUgSUQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF07XG4gICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdwdWJsaWNhdGlvbiBvZiBsb2NhbCB0cmFjayB0aW1lZCBvdXQsIG5vIHJlc3BvbnNlIGZyb20gc2VydmVyJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLlRpbWVvdXQpKTtcbiAgICAgIH0sIDEwMDAwKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdID0ge1xuICAgICAgICByZXNvbHZlOiBpbmZvID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGluZm8pO1xuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW5jZWxsZWQgcHVibGljYXRpb24gYnkgY2FsbGluZyB1bnB1Ymxpc2gnKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQWRkVHJhY2socmVxKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBzZW5kZXIgZnJvbSBQZWVyQ29ubmVjdGlvbiwgcmV0dXJuaW5nIHRydWUgaWYgaXQgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5XG4gICAqIGFuZCBhIG5lZ290aWF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgKiBAcGFyYW0gc2VuZGVyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVqZWN0XG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdmYWlsZWQgdG8gcmVtb3ZlIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVNdXRlU3RhdHVzKHRyYWNrU2lkLCBtdXRlZCkge1xuICAgIHRoaXMuY2xpZW50LnNlbmRNdXRlVHJhY2sodHJhY2tTaWQsIG11dGVkKTtcbiAgfVxuICBnZXQgZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yZWxpYWJsZURDU3ViKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZTtcbiAgfVxuICBnZXRDb25uZWN0ZWRTZXJ2ZXJBZGRyZXNzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHNldFJlZ2lvblVybFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHByb3ZpZGVyO1xuICB9XG4gIGNvbmZpZ3VyZShqb2luUmVzcG9uc2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIC8vIGFscmVhZHkgY29uZmlndXJlZFxuICAgICAgaWYgKHRoaXMucGNNYW5hZ2VyICYmIHRoaXMucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IChfYSA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZDtcbiAgICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IHRoaXMubWFrZVJUQ0NvbmZpZ3VyYXRpb24oam9pblJlc3BvbnNlKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gbmV3IFBDVHJhbnNwb3J0TWFuYWdlcihydGNDb25maWcsIHRoaXMub3B0aW9ucy5zaW5nbGVQZWVyQ29ubmVjdGlvbiA/ICdwdWJsaXNoZXItb25seScgOiBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnkgPyAnc3Vic2NyaWJlci1wcmltYXJ5JyA6ICdwdWJsaXNoZXItcHJpbWFyeScsIHRoaXMubG9nZ2VyT3B0aW9ucyk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuVHJhbnNwb3J0c0NyZWF0ZWQsIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlciwgdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlcik7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vbkljZUNhbmRpZGF0ZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblB1Ymxpc2hlck9mZmVyID0gKG9mZmVyLCBvZmZlcklkKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50LnNlbmRPZmZlcihvZmZlciwgb2ZmZXJJZCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5wY01hbmFnZXIub25EYXRhQ2hhbm5lbCA9IHRoaXMuaGFuZGxlRGF0YUNoYW5uZWw7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblN0YXRlQ2hhbmdlID0gKGNvbm5lY3Rpb25TdGF0ZSwgcHVibGlzaGVyU3RhdGUsIHN1YnNjcmliZXJTdGF0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByaW1hcnkgUEMgc3RhdGUgY2hhbmdlZCBcIi5jb25jYXQoY29ubmVjdGlvblN0YXRlKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgaWYgKFsnY2xvc2VkJywgJ2Rpc2Nvbm5lY3RlZCcsICdmYWlsZWQnXS5pbmNsdWRlcyhwdWJsaXNoZXJTdGF0ZSkpIHtcbiAgICAgICAgICAvLyByZXNldCBwdWJsaXNoZXIgY29ubmVjdGlvbiBwcm9taXNlXG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSB0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuTmV3O1xuICAgICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGVkLCBqb2luUmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEKSB7XG4gICAgICAgICAgLy8gb24gU2FmYXJpLCBQZWVyQ29ubmVjdGlvbiB3aWxsIHN3aXRjaCB0byAnZGlzY29ubmVjdGVkJyBkdXJpbmcgcmVuZWdvdGlhdGlvblxuICAgICAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkIHx8IHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdwZWVyY29ubmVjdGlvbiBmYWlsZWQnLCBzdWJzY3JpYmVyU3RhdGUgPT09ICdmYWlsZWQnID8gUmVjb25uZWN0UmVhc29uLlJSX1NVQlNDUklCRVJfRkFJTEVEIDogUmVjb25uZWN0UmVhc29uLlJSX1BVQkxJU0hFUl9GQUlMRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkZXRlY3QgY2FzZXMgd2hlcmUgYm90aCBzaWduYWwgY2xpZW50IGFuZCBwZWVyIGNvbm5lY3Rpb24gYXJlIHNldmVyZWQgYW5kIGFzc3VtZSB0aGF0IHVzZXIgaGFzIGxvc3QgbmV0d29yayBjb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IGlzU2lnbmFsU2V2ZXJlZCA9IHRoaXMuY2xpZW50LmlzRGlzY29ubmVjdGVkIHx8IHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgICAgICAgY29uc3QgaXNQQ1NldmVyZWQgPSBbUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQsIFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0lORywgUENUcmFuc3BvcnRTdGF0ZS5DTE9TRURdLmluY2x1ZGVzKGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGlmIChpc1NpZ25hbFNldmVyZWQgJiYgaXNQQ1NldmVyZWQgJiYgIXRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50Lk9mZmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uVHJhY2sgPSBldiA9PiB7XG4gICAgICAgIC8vIHRoaXMgZmlyZXMgYWZ0ZXIgdGhlIHVuZGVybHlpbmcgdHJhbnNjZWl2ZXIgaXMgc3RvcHBlZCBhbmQgcG90ZW50aWFsbHlcbiAgICAgICAgLy8gcGVlciBjb25uZWN0aW9uIGNsb3NlZCwgc28gZG8gbm90IGJ1YmJsZSB1cCBpZiB0aGVyZSBhcmUgbm8gc3RyZWFtc1xuICAgICAgICBpZiAoZXYuc3RyZWFtcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCwgZXYudHJhY2ssIGV2LnN0cmVhbXNbMF0sIGV2LnJlY2VpdmVyKTtcbiAgICAgIH07XG4gICAgICBpZiAoIXN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsKChfYiA9IGpvaW5SZXNwb25zZS5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHJvdG9jb2wpKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKSB7XG4gICAgLy8gY29uZmlndXJlIHNpZ25hbGluZyBjbGllbnRcbiAgICB0aGlzLmNsaWVudC5vbkFuc3dlciA9IChzZCwgb2ZmZXJJZCwgbWlkVG9UcmFja0lkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgYW5zd2VyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGUsXG4gICAgICAgIHNkcDogc2Quc2RwLFxuICAgICAgICBtaWRUb1RyYWNrSWRcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMubWlkVG9UcmFja0lkID0gbWlkVG9UcmFja0lkO1xuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuc2V0UHVibGlzaGVyQW5zd2VyKHNkLCBvZmZlcklkKTtcbiAgICB9KTtcbiAgICAvLyBhZGQgY2FuZGlkYXRlIG9uIHRyaWNrbGVcbiAgICB0aGlzLmNsaWVudC5vblRyaWNrbGUgPSAoY2FuZGlkYXRlLCB0YXJnZXQpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ2dvdCBJQ0UgY2FuZGlkYXRlIGZyb20gcGVlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgIHRhcmdldFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5wY01hbmFnZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICB9O1xuICAgIC8vIHdoZW4gc2VydmVyIGNyZWF0ZXMgYW4gb2ZmZXIgZm9yIHRoZSBjbGllbnRcbiAgICB0aGlzLmNsaWVudC5vbk9mZmVyID0gKHNkLCBvZmZlcklkLCBtaWRUb1RyYWNrSWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubGF0ZXN0UmVtb3RlT2ZmZXJJZCA9IG9mZmVySWQ7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubWlkVG9UcmFja0lkID0gbWlkVG9UcmFja0lkO1xuICAgICAgY29uc3QgYW5zd2VyID0geWllbGQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCwgb2ZmZXJJZCk7XG4gICAgICBpZiAoYW5zd2VyKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LnNlbmRBbnN3ZXIoYW5zd2VyLCBvZmZlcklkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tQdWJsaXNoZWQgPSByZXMgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHRyYWNrUHVibGlzaGVkUmVzcG9uc2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgY2lkOiByZXMuY2lkLFxuICAgICAgICB0cmFjazogKF9hID0gcmVzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwibWlzc2luZyB0cmFjayByZXNvbHZlciBmb3IgXCIuY29uY2F0KHJlcy5jaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBjaWQ6IHJlcy5jaWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0gPSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXTtcbiAgICAgIHJlc29sdmUocmVzLnRyYWNrKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gcmVzcG9uc2UgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcmVzcG9uc2UpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrU3Vic2NyaWJlZCA9IHRyYWNrU2lkID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tTaWQpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25Ub2tlblJlZnJlc2ggPSB0b2tlbiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlVG9rZW4odG9rZW4pO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25SZW1vdGVNdXRlQ2hhbmdlZCA9ICh0cmFja1NpZCwgbXV0ZWQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCB0cmFja1NpZCwgbXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vblJvb21Nb3ZlZCA9IHJlcyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gKF9hID0gcmVzLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkO1xuICAgICAgaWYgKHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlLnJvb20gPSByZXMucm9vbTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Sb29tTW92ZWQsIHJlcyk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbk1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudCA9IHJlcXVpcmVtZW50ID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCB0cmFuc2NlaXZlckluaXQgPSB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgfTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZW1lbnQubnVtQXVkaW9zOyBpKyspIHtcbiAgICAgICAgKF9hID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlck9mS2luZCgnYXVkaW8nLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1aXJlbWVudC5udW1WaWRlb3M7IGkrKykge1xuICAgICAgICAoX2IgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyT2ZLaW5kKCd2aWRlbycsIHRyYW5zY2VpdmVySW5pdCk7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZ290aWF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJywgUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25MZWF2ZSA9IGxlYXZlID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdjbGllbnQgbGVhdmUgcmVxdWVzdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICByZWFzb246IGxlYXZlID09PSBudWxsIHx8IGxlYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWF2ZS5yZWFzb25cbiAgICAgIH0pKTtcbiAgICAgIGlmIChsZWF2ZS5yZWdpb25zICYmIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0aW5nIHJlZ2lvbnMnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyh7XG4gICAgICAgICAgdXBkYXRlZEF0SW5NczogRGF0ZS5ub3coKSxcbiAgICAgICAgICBtYXhBZ2VJbk1zOiBERUZBVUxUX01BWF9BR0VfTVMsXG4gICAgICAgICAgcmVnaW9uU2V0dGluZ3M6IGxlYXZlLnJlZ2lvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGxlYXZlLmFjdGlvbikge1xuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uRElTQ09OTkVDVDpcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBsZWF2ZSA9PT0gbnVsbCB8fCBsZWF2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmUucmVhc29uKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRUNPTk5FQ1Q6XG4gICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QobGVhdmVSZWNvbm5lY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uUkVTVU1FOlxuICAgICAgICAgIC8vIHJlY29ubmVjdCBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIG5leHQgYXR0ZW1wdFxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChsZWF2ZVJlY29ubmVjdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBtYWtlUlRDQ29uZmlndXJhdGlvbihzZXJ2ZXJSZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBydGNDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJ0Y0NvbmZpZyk7XG4gICAgaWYgKChfYSA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmUyZWVFbmFibGVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnRTJFRSAtIHNldHRpbmcgdXAgdHJhbnNwb3J0cyB3aXRoIGluc2VydGFibGUgc3RyZWFtcycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAvLyAgdGhpcyBtYWtlcyBzdXJlIHRoYXQgbm8gZGF0YSBpcyBzZW50IGJlZm9yZSB0aGUgdHJhbnNmb3JtcyBhcmUgcmVhZHlcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJ0Y0NvbmZpZy5lbmNvZGVkSW5zZXJ0YWJsZVN0cmVhbXMgPSB0cnVlO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgSUNFIHNlcnZlcnMgYmVmb3JlIGNyZWF0aW5nIFBlZXJDb25uZWN0aW9uXG4gICAgaWYgKHNlcnZlclJlc3BvbnNlLmljZVNlcnZlcnMgJiYgIXJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICBjb25zdCBydGNJY2VTZXJ2ZXJzID0gW107XG4gICAgICBzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzLmZvckVhY2goaWNlU2VydmVyID0+IHtcbiAgICAgICAgY29uc3QgcnRjSWNlU2VydmVyID0ge1xuICAgICAgICAgIHVybHM6IGljZVNlcnZlci51cmxzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpY2VTZXJ2ZXIudXNlcm5hbWUpIHJ0Y0ljZVNlcnZlci51c2VybmFtZSA9IGljZVNlcnZlci51c2VybmFtZTtcbiAgICAgICAgaWYgKGljZVNlcnZlci5jcmVkZW50aWFsKSB7XG4gICAgICAgICAgcnRjSWNlU2VydmVyLmNyZWRlbnRpYWwgPSBpY2VTZXJ2ZXIuY3JlZGVudGlhbDtcbiAgICAgICAgfVxuICAgICAgICBydGNJY2VTZXJ2ZXJzLnB1c2gocnRjSWNlU2VydmVyKTtcbiAgICAgIH0pO1xuICAgICAgcnRjQ29uZmlnLmljZVNlcnZlcnMgPSBydGNJY2VTZXJ2ZXJzO1xuICAgIH1cbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbiAmJiBzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uLmZvcmNlUmVsYXkgPT09IENsaWVudENvbmZpZ1NldHRpbmcuRU5BQkxFRCkge1xuICAgICAgcnRjQ29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSA9ICdyZWxheSc7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBydGNDb25maWcuc2RwU2VtYW50aWNzID0gJ3VuaWZpZWQtcGxhbic7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJ0Y0NvbmZpZy5jb250aW51YWxHYXRoZXJpbmdQb2xpY3kgPSAnZ2F0aGVyX2NvbnRpbnVhbGx5JztcbiAgICByZXR1cm4gcnRjQ29uZmlnO1xuICB9XG4gIGNyZWF0ZURhdGFDaGFubmVscygpIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNsZWFyIG9sZCBkYXRhIGNoYW5uZWwgY2FsbGJhY2tzIGlmIHJlY3JlYXRlXG4gICAgaWYgKHRoaXMubG9zc3lEQykge1xuICAgICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLmxvc3N5REMub25lcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGlhYmxlREMpIHtcbiAgICAgIHRoaXMucmVsaWFibGVEQy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5yZWxpYWJsZURDLm9uZXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgZGF0YSBjaGFubmVsc1xuICAgIHRoaXMubG9zc3lEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxvc3N5RGF0YUNoYW5uZWwsIHtcbiAgICAgIG9yZGVyZWQ6IGZhbHNlLFxuICAgICAgbWF4UmV0cmFuc21pdHM6IDBcbiAgICB9KTtcbiAgICB0aGlzLnJlbGlhYmxlREMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChyZWxpYWJsZURhdGFDaGFubmVsLCB7XG4gICAgICBvcmRlcmVkOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gYWxzbyBoYW5kbGUgbWVzc2FnZXMgb3ZlciB0aGUgcHViIGNoYW5uZWwsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMubG9zc3lEQy5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xuICAgIHRoaXMucmVsaWFibGVEQy5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xuICAgIC8vIGhhbmRsZSBkYXRhY2hhbm5lbCBlcnJvcnNcbiAgICB0aGlzLmxvc3N5REMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gdGhpcy5oYW5kbGVEYXRhRXJyb3I7XG4gICAgLy8gc2V0IHVwIGRjIGJ1ZmZlciB0aHJlc2hvbGQsIHNldCB0byA2NGtCIChvdGhlcndpc2UgMCBieSBkZWZhdWx0KVxuICAgIHRoaXMubG9zc3lEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuICAgIHRoaXMucmVsaWFibGVEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuICAgIC8vIGhhbmRsZSBidWZmZXIgYW1vdW50IGxvdyBldmVudHNcbiAgICB0aGlzLmxvc3N5REMub25idWZmZXJlZGFtb3VudGxvdyA9IHRoaXMuaGFuZGxlQnVmZmVyZWRBbW91bnRMb3c7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xuICB9XG4gIGNyZWF0ZVNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0geWllbGQgdGhpcy5jcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigndXNpbmcgYWRkLXRyYWNrIGZhbGxiYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0geWllbGQgdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUmVxdWlyZWQgd2ViUlRDIEFQSXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVNpbXVsY2FzdFNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBzdG9yZSBSVENSdHBTZW5kZXJcbiAgICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzQWRkVHJhY2soKSkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYWRkLXRyYWNrIGZhbGxiYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ0Nhbm5vdCBzdHJlYW0gb24gdGhpcyBkZXZpY2UnKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICAgIGlmICh0cmFjay5tZWRpYVN0cmVhbSkge1xuICAgICAgICBzdHJlYW1zLnB1c2godHJhY2subWVkaWFTdHJlYW0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJhY2suY29kZWMgPSBvcHRzLnZpZGVvQ29kZWM7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2NlaXZlckluaXQgPSB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgc3RyZWFtc1xuICAgICAgfTtcbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBhZGRUcmFuc2NlaXZlciBmb3IgcmVhY3QtbmF0aXZlIGlzIGFzeW5jLiB3ZWIgaXMgc3luY2hyb25vdXMsIGJ1dCBhd2FpdCB3b24ndCBlZmZlY3QgaXQuXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVNpbXVsY2FzdFRyYW5zY2VpdmVyU2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdCA9IHtcbiAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknXG4gICAgICB9O1xuICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgIH1cbiAgICAgIC8vIGFkZFRyYW5zY2VpdmVyIGZvciByZWFjdC1uYXRpdmUgaXMgYXN5bmMuIHdlYiBpcyBzeW5jaHJvbm91cywgYnV0IGF3YWl0IHdvbid0IGVmZmVjdCBpdC5cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0geWllbGQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIoc2ltdWxjYXN0VHJhY2subWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgICAgIGlmICghb3B0cy52aWRlb0NvZGVjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNrLnNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKG9wdHMudmlkZW9Db2RlYywgdHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFjayh0cmFjayk7XG4gICAgfSk7XG4gIH1cbiAgYXR0ZW1wdFJlY29ubmVjdChyZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZ3VhcmQgZm9yIGF0dGVtcHRpbmcgcmVjb25uZWN0aW9uIG11bHRpcGxlIHRpbWVzIHdoaWxlIG9uZSBhdHRlbXB0IGlzIHN0aWxsIG5vdCBmaW5pc2hlZFxuICAgICAgaWYgKHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2FscmVhZHkgYXR0ZW1wdGluZyByZWNvbm5lY3QsIHJldHVybmluZyBlYXJseScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9hID0gdGhpcy5jbGllbnRDb25maWd1cmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdW1lQ29ubmVjdGlvbikgPT09IENsaWVudENvbmZpZ1NldHRpbmcuRElTQUJMRUQgfHxcbiAgICAgIC8vIHNpZ25hbGluZyBzdGF0ZSBjb3VsZCBjaGFuZ2UgdG8gY2xvc2VkIGR1ZSB0byBoYXJkd2FyZSBzbGVlcFxuICAgICAgLy8gdGhvc2UgY29ubmVjdGlvbnMgY2Fubm90IGJlIHJlc3VtZWRcbiAgICAgICgoX2MgPSAoX2IgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmN1cnJlbnRTdGF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogUENUcmFuc3BvcnRTdGF0ZS5ORVcpID09PSBQQ1RyYW5zcG9ydFN0YXRlLk5FVykge1xuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydENvbm5lY3Rpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyArPSAxO1xuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdW5yZWNvdmVyYWJsZSBlcnJvcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgLy8gdW5yZWNvdmVyYWJsZVxuICAgICAgICAgIHJlY292ZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIShlIGluc3RhbmNlb2YgU2lnbmFsUmVjb25uZWN0RXJyb3IpKSB7XG4gICAgICAgICAgLy8gY2Fubm90IHJlc3VtZVxuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdyZWNvbm5lY3QnLCBSZWNvbm5lY3RSZWFzb24uUlJfVU5LTk9XTik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cuaW5mbyhcImNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsIFwiIGF0dGVtcHRzLCBcIikuY29uY2F0KERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0LCBcIm1zLiBnaXZpbmcgdXBcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXROZXh0UmV0cnlEZWxheShjb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlY29ubmVjdFBvbGljeS5uZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignZW5jb3VudGVyZWQgZXJyb3IgaW4gcmVjb25uZWN0IHBvbGljeScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlcnJvcjogZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBlcnJvciBpbiB1c2VyIGNvZGUgd2l0aCBwcm92aWRlZCByZWNvbm5lY3QgcG9saWN5LCBzdG9wIHJlY29ubmVjdGluZ1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3RhcnRDb25uZWN0aW9uKHJlZ2lvblVybCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy51cmwgfHwgIXRoaXMudG9rZW4pIHtcbiAgICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdXJsIG9yIHRva2VuIG5vdCBzYXZlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJyZWNvbm5lY3RpbmcsIGF0dGVtcHQ6IFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcpO1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQuc2VuZExlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwUGVlckNvbm5lY3Rpb25zKCk7XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cENsaWVudCgpO1xuICAgICAgICBsZXQgam9pblJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdGhpcy5zaWduYWxPcHRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdhdHRlbXB0ZWQgY29ubmVjdGlvbiByZXN0YXJ0LCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIHByZXNlbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGluIGNhc2UgYSByZWdpb25VcmwgaXMgcGFzc2VkLCB0aGUgcmVnaW9uIFVSTCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICAgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5qb2luKHJlZ2lvblVybCAhPT0gbnVsbCAmJiByZWdpb25VcmwgIT09IHZvaWQgMCA/IHJlZ2lvblVybCA6IHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLnNpZ25hbE9wdHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZS5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdG9rZW4gbWlnaHQgYmUgZXhwaXJlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG91bGRGYWlsTmV4dCkge1xuICAgICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgam9pblJlc3BvbnNlKTtcbiAgICAgICAgeWllbGQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xuICAgICAgICAvLyByZS1jaGVjayBzaWduYWwgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyBlbmdpbmUgYXMgcmVzdW1lZFxuICAgICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc2V0QXR0ZW1wdHMoKTtcbiAgICAgICAgLy8gcmVjb25uZWN0IHN1Y2Nlc3NcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3RhcnRlZCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBuZXh0UmVnaW9uVXJsID0geWllbGQgKF9iID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE5leHRCZXN0UmVnaW9uVXJsKCk7XG4gICAgICAgIGlmIChuZXh0UmVnaW9uVXJsKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbihuZXh0UmVnaW9uVXJsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gbW9yZSByZWdpb25zIHRvIHRyeSAob3Igd2UncmUgbm90IG9uIGNsb3VkKVxuICAgICAgICAgIChfYyA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN1bWVDb25uZWN0aW9uKHJlYXNvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgIC8vIHBlcm1hbmVudCBmYWlsdXJlLCBkb24ndCBhdHRlbXB0IHJlY29ubmVjdGlvblxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdXJsIG9yIHRva2VuIG5vdCBzYXZlZCcpO1xuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBwdWJsaXNoZXIgcmVjb25uZWN0XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgYW5kIHN1YnNjcmliZXIgY29ubmVjdGlvbnMgdW5zZXQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmluZm8oXCJyZXN1bWluZyBzaWduYWwgY29ubmVjdGlvbiwgYXR0ZW1wdCBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1pbmcpO1xuICAgICAgbGV0IHJlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcbiAgICAgICAgcmVzID0geWllbGQgdGhpcy5jbGllbnQucmVjb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLnBhcnRpY2lwYW50U2lkLCByZWFzb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnJvci5tZXNzYWdlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0KSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKHJlcyk7XG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnVwZGF0ZUNvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSB7XG4gICAgICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2Uuc2VydmVySW5mbyA9IHJlcy5zZXJ2ZXJJbmZvO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdEaWQgbm90IHJlY2VpdmUgcmVjb25uZWN0IHJlc3BvbnNlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICAgIHlpZWxkIHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcbiAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcbiAgICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXG4gICAgICAvLyAoZm9yIHNhZmFyaSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0Njg4KVxuICAgICAgaWYgKCgoX2EgPSB0aGlzLnJlbGlhYmxlREMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nICYmIHRoaXMucmVsaWFibGVEQy5pZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5sYXN0TWVzc2FnZVNlcSkge1xuICAgICAgICB0aGlzLnJlc2VuZFJlbGlhYmxlTWVzc2FnZXNGb3JSZXN1bWUocmVzLmxhc3RNZXNzYWdlU2VxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc3VtZSBzdWNjZXNzXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1lZCk7XG4gICAgfSk7XG4gIH1cbiAgd2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGltZW91dCwgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5lbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yUENSZWNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5SZWNvbm5lY3Rpbmc7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnd2FpdGluZyBmb3IgcGVlciBjb25uZWN0aW9uIHRvIHJlY29ubmVjdCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBzbGVlcChtaW5SZWNvbm5lY3RXYWl0KTsgLy8gRklYTUUgc2V0VGltZW91dCBhZ2FpbiBub3QgaWRlYWwgZm9yIGEgY29ubmVjdGlvbiBjcml0aWNhbCBwYXRoXG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5lbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24odW5kZWZpbmVkLCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBUT0RPIGRvIHdlIG5lZWQgYSBgZmFpbGVkYCBzdGF0ZSBoZXJlIGZvciB0aGUgUEM/XG4gICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiY291bGQgbm90IGVzdGFibGlzaCBQQyBjb25uZWN0aW9uLCBcIi5jb25jYXQoZS5tZXNzYWdlKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGlzaFJwY1Jlc3BvbnNlKGRlc3RpbmF0aW9uSWRlbnRpdHksIHJlcXVlc3RJZCwgcGF5bG9hZCwgZXJyb3IpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdycGNSZXNwb25zZScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBScGNSZXNwb25zZSh7XG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICB2YWx1ZTogZXJyb3IgPyB7XG4gICAgICAgICAgICAgIGNhc2U6ICdlcnJvcicsXG4gICAgICAgICAgICAgIHZhbHVlOiBlcnJvci50b1Byb3RvKClcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdwYXlsb2FkJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQgIT09IG51bGwgJiYgcGF5bG9hZCAhPT0gdm9pZCAwID8gcGF5bG9hZCA6ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHB1Ymxpc2hScGNBY2soZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbZGVzdGluYXRpb25JZGVudGl0eV0sXG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAncnBjQWNrJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY0Fjayh7XG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvIGhhdmUgYSBkYXRhIGNvbm5lY3Rpb25cbiAgICAgIHlpZWxkIHRoaXMuZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpO1xuICAgICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIgJiYgdGhpcy5lMmVlTWFuYWdlci5pc0RhdGFDaGFubmVsRW5jcnlwdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgZW5jcnlwdGFibGVQYWNrZXQgPSBhc0VuY3J5cHRhYmxlUGFja2V0KHBhY2tldCk7XG4gICAgICAgIGlmIChlbmNyeXB0YWJsZVBhY2tldCkge1xuICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSB5aWVsZCB0aGlzLmUyZWVNYW5hZ2VyLmVuY3J5cHREYXRhKGVuY3J5cHRhYmxlUGFja2V0LnRvQmluYXJ5KCkpO1xuICAgICAgICAgIHBhY2tldC52YWx1ZSA9IHtcbiAgICAgICAgICAgIGNhc2U6ICdlbmNyeXB0ZWRQYWNrZXQnLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBFbmNyeXB0ZWRQYWNrZXQoe1xuICAgICAgICAgICAgICBlbmNyeXB0ZWRWYWx1ZTogZW5jcnlwdGVkRGF0YS5wYXlsb2FkLFxuICAgICAgICAgICAgICBpdjogZW5jcnlwdGVkRGF0YS5pdixcbiAgICAgICAgICAgICAga2V5SW5kZXg6IGVuY3J5cHRlZERhdGEua2V5SW5kZXhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICBwYWNrZXQuc2VxdWVuY2UgPSB0aGlzLnJlbGlhYmxlRGF0YVNlcXVlbmNlO1xuICAgICAgICB0aGlzLnJlbGlhYmxlRGF0YVNlcXVlbmNlICs9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBtc2cgPSBwYWNrZXQudG9CaW5hcnkoKTtcbiAgICAgIHlpZWxkIHRoaXMud2FpdEZvckJ1ZmZlclN0YXR1c0xvdyhraW5kKTtcbiAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgICBpZiAoZGMpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLnB1c2goe1xuICAgICAgICAgICAgZGF0YTogbXNnLFxuICAgICAgICAgICAgc2VxdWVuY2U6IHBhY2tldC5zZXF1ZW5jZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGMuc2VuZChtc2cpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoa2luZCk7XG4gICAgfSk7XG4gIH1cbiAgcmVzZW5kUmVsaWFibGVNZXNzYWdlc0ZvclJlc3VtZShsYXN0TWVzc2FnZVNlcSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgaWYgKGRjKSB7XG4gICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLnBvcFRvU2VxdWVuY2UobGFzdE1lc3NhZ2VTZXEpO1xuICAgICAgICB0aGlzLnJlbGlhYmxlTWVzc2FnZUJ1ZmZlci5nZXRBbGwoKS5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgZGMuc2VuZChtc2cuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yQnVmZmVyU3RhdHVzTG93KGtpbmQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCkpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25DbG9zaW5nID0gKCkgPT4gcmVqZWN0KCdFbmdpbmUgY2xvc2VkJyk7XG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkNsb3NpbmcpO1xuICAgICAgICB3aGlsZSAoIXRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XG4gICAgICAgICAgeWllbGQgc2xlZXAoMTApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uQ2xvc2luZyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZChraW5kXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBsZXQgc3Vic2NyaWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zdWJzY3JpYmVyUHJpbWFyeTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghX3RoaXMyLnBjTWFuYWdlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN1YnNjcmliZXIgPyBfdGhpczIucGNNYW5hZ2VyLnN1YnNjcmliZXIgOiBfdGhpczIucGNNYW5hZ2VyLnB1Ymxpc2hlcjtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHN1YnNjcmliZXIgPyAnU3Vic2NyaWJlcicgOiAnUHVibGlzaGVyJztcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiXCIuY29uY2F0KHRyYW5zcG9ydE5hbWUsIFwiIGNvbm5lY3Rpb24gbm90IHNldFwiKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZWVkTmVnb3RpYXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKCFzdWJzY3JpYmVyICYmICFfdGhpczIuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgX3RoaXMyLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgICAgIG5lZWROZWdvdGlhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZWVkTmVnb3RpYXRpb24gJiYgIXN1YnNjcmliZXIgJiYgIV90aGlzMi5wY01hbmFnZXIucHVibGlzaGVyLmlzSUNFQ29ubmVjdGVkICYmIF90aGlzMi5wY01hbmFnZXIucHVibGlzaGVyLmdldElDRUNvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY2hlY2tpbmcnKSB7XG4gICAgICAgICAgbmVlZE5lZ290aWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZE5lZ290aWF0aW9uKSB7XG4gICAgICAgICAgLy8gc3RhcnQgbmVnb3RpYXRpb25cbiAgICAgICAgICBfdGhpczIubmVnb3RpYXRlKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoZXJyLCBfdGhpczIubG9nQ29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbm5lbCA9IF90aGlzMi5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3Vic2NyaWJlcik7XG4gICAgICAgIGlmICgodGFyZ2V0Q2hhbm5lbCA9PT0gbnVsbCB8fCB0YXJnZXRDaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRDaGFubmVsLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2FpdCB1bnRpbCBJQ0UgY29ubmVjdGVkXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIF90aGlzMi5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICAgIHdoaWxlIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgICBpZiAodHJhbnNwb3J0LmlzSUNFQ29ubmVjdGVkICYmICgoX2EgPSBfdGhpczIuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCBzbGVlcCg1MCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcImNvdWxkIG5vdCBlc3RhYmxpc2ggXCIuY29uY2F0KHRyYW5zcG9ydE5hbWUsIFwiIGNvbm5lY3Rpb24sIHN0YXRlOiBcIikuY29uY2F0KHRyYW5zcG9ydC5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBlbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucHVibGlzaGVyQ29ubmVjdGlvblByb21pc2UpIHtcbiAgICAgICAgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZChraW5kLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICB2ZXJpZnlUcmFuc3BvcnQoKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBwcmltYXJ5IGNvbm5lY3Rpb25cbiAgICBpZiAodGhpcy5wY01hbmFnZXIuY3VycmVudFN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgc2lnbmFsIGlzIGNvbm5lY3RlZFxuICAgIGlmICghdGhpcy5jbGllbnQud3MgfHwgdGhpcy5jbGllbnQud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIG5lZ290aWF0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gb2JzZXJ2ZSBzaWduYWwgc3RhdGVcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICByZWplY3QobmV3IE5lZ290aWF0aW9uRXJyb3IoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBjTWFuYWdlci5yZXF1aXJlUHVibGlzaGVyKCk7XG4gICAgICAgIC8vIGRvbid0IG5lZ290aWF0ZSB3aXRob3V0IGFueSB0cmFuc2NlaXZlcnMgb3IgZGF0YSBjaGFubmVsLCBpdCB3aWxsIGdlbmVyYXRlIHNkcCB3aXRob3V0IGljZSBmcmFnIHRoZW4gbmVnb3RpYXRlIGZhaWxlZFxuICAgICAgICBpZiAodGhpcy5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpLmxlbmd0aCA9PSAwICYmICF0aGlzLmxvc3N5REMgJiYgIXRoaXMucmVsaWFibGVEQykge1xuICAgICAgICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBoYW5kbGVDbG9zZWQgPSAoKSA9PiB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2VuZ2luZSBkaXNjb25uZWN0ZWQgd2hpbGUgbmVnb3RpYXRpb24gd2FzIG9uZ29pbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgcmVqZWN0KCdjYW5ub3QgbmVnb3RpYXRlIG9uIGNsb3NlZCBlbmdpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKEVuZ2luZUV2ZW50LkNsb3NpbmcsIGhhbmRsZUNsb3NlZCk7XG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLCBydHBUeXBlcyA9PiB7XG4gICAgICAgICAgY29uc3QgcnRwTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHJ0cFR5cGVzLmZvckVhY2gocnRwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gcnRwLmNvZGVjLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoaXNWaWRlb0NvZGVjKGNvZGVjKSkge1xuICAgICAgICAgICAgICBydHBNYXAuc2V0KHJ0cC5wYXlsb2FkLCBjb2RlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJUUFZpZGVvTWFwVXBkYXRlLCBydHBNYXApO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5uZWdvdGlhdGUoYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5lZ290aWF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnbmVnb3RpYXRpb24nLCBSZWNvbm5lY3RSZWFzb24uUlJfVU5LTk9XTik7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIGhhbmRsZUNsb3NlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBkYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3ViKSB7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQztcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5MT1NTWSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3NzeURDU3ViO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDU3ViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdzeW5jIHN0YXRlIGNhbm5vdCBiZSBzZW50IHdpdGhvdXQgcGVlciBjb25uZWN0aW9uIHNldHVwJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNQdWJsaXNoZXJPZmZlciA9IHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRMb2NhbERlc2NyaXB0aW9uKCk7XG4gICAgY29uc3QgcHJldmlvdXNQdWJsaXNoZXJBbnN3ZXIgPSB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0UmVtb3RlRGVzY3JpcHRpb24oKTtcbiAgICBjb25zdCBwcmV2aW91c1N1YnNjcmliZXJPZmZlciA9IChfYSA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRSZW1vdGVEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IHByZXZpb3VzU3Vic2NyaWJlckFuc3dlciA9IChfYiA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRMb2NhbERlc2NyaXB0aW9uKCk7XG4gICAgLyogMS4gYXV0b3N1YnNjcmliZSBvbiwgc28gc3Vic2NyaWJlZCB0cmFja3MgPSBhbGwgdHJhY2tzIC0gdW5zdWIgdHJhY2tzLFxuICAgICAgICAgIGluIHRoaXMgY2FzZSwgd2Ugc2VuZCB1bnN1YiB0cmFja3MsIHNvIHNlcnZlciBhZGQgYWxsIHRyYWNrcyB0byB0aGlzXG4gICAgICAgICAgc3Vic2NyaWJlIHBjIGFuZCB1bnN1YiBzcGVjaWFsIHRyYWNrcyBmcm9tIGl0LlxuICAgICAgIDIuIGF1dG9zdWJzY3JpYmUgb2ZmLCB3ZSBzZW5kIHN1YnNjcmliZWQgdHJhY2tzLlxuICAgICovXG4gICAgY29uc3QgYXV0b1N1YnNjcmliZSA9IChfZCA9IChfYyA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmF1dG9TdWJzY3JpYmUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWU7XG4gICAgY29uc3QgdHJhY2tTaWRzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgdHJhY2tTaWRzRGlzYWJsZWQgPSBuZXcgQXJyYXkoKTtcbiAgICByZW1vdGVUcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZiAodHJhY2suaXNEZXNpcmVkICE9PSBhdXRvU3Vic2NyaWJlKSB7XG4gICAgICAgIHRyYWNrU2lkcy5wdXNoKHRyYWNrLnRyYWNrU2lkKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suaXNFbmFibGVkKSB7XG4gICAgICAgIHRyYWNrU2lkc0Rpc2FibGVkLnB1c2godHJhY2sudHJhY2tTaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuY2xpZW50LnNlbmRTeW5jU3RhdGUobmV3IFN5bmNTdGF0ZSh7XG4gICAgICBhbnN3ZXI6IHRoaXMub3B0aW9ucy5zaW5nbGVQZWVyQ29ubmVjdGlvbiA/IHByZXZpb3VzUHVibGlzaGVyQW5zd2VyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHNkcDogcHJldmlvdXNQdWJsaXNoZXJBbnN3ZXIuc2RwLFxuICAgICAgICB0eXBlOiBwcmV2aW91c1B1Ymxpc2hlckFuc3dlci50eXBlXG4gICAgICB9KSA6IHVuZGVmaW5lZCA6IHByZXZpb3VzU3Vic2NyaWJlckFuc3dlciA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICBzZHA6IHByZXZpb3VzU3Vic2NyaWJlckFuc3dlci5zZHAsXG4gICAgICAgIHR5cGU6IHByZXZpb3VzU3Vic2NyaWJlckFuc3dlci50eXBlXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgIG9mZmVyOiB0aGlzLm9wdGlvbnMuc2luZ2xlUGVlckNvbm5lY3Rpb24gPyBwcmV2aW91c1B1Ymxpc2hlck9mZmVyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHNkcDogcHJldmlvdXNQdWJsaXNoZXJPZmZlci5zZHAsXG4gICAgICAgIHR5cGU6IHByZXZpb3VzUHVibGlzaGVyT2ZmZXIudHlwZVxuICAgICAgfSkgOiB1bmRlZmluZWQgOiBwcmV2aW91c1N1YnNjcmliZXJPZmZlciA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICBzZHA6IHByZXZpb3VzU3Vic2NyaWJlck9mZmVyLnNkcCxcbiAgICAgICAgdHlwZTogcHJldmlvdXNTdWJzY3JpYmVyT2ZmZXIudHlwZVxuICAgICAgfSkgOiB1bmRlZmluZWQsXG4gICAgICBzdWJzY3JpcHRpb246IG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oe1xuICAgICAgICB0cmFja1NpZHMsXG4gICAgICAgIHN1YnNjcmliZTogIWF1dG9TdWJzY3JpYmUsXG4gICAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbXVxuICAgICAgfSksXG4gICAgICBwdWJsaXNoVHJhY2tzOiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyhsb2NhbFRyYWNrcyksXG4gICAgICBkYXRhQ2hhbm5lbHM6IHRoaXMuZGF0YUNoYW5uZWxzSW5mbygpLFxuICAgICAgdHJhY2tTaWRzRGlzYWJsZWQsXG4gICAgICBkYXRhY2hhbm5lbFJlY2VpdmVTdGF0ZXM6IHRoaXMucmVsaWFibGVSZWNlaXZlZFN0YXRlLm1hcCgoc2VxLCBzaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhQ2hhbm5lbFJlY2VpdmVTdGF0ZSh7XG4gICAgICAgICAgcHVibGlzaGVyU2lkOiBzaWQsXG4gICAgICAgICAgbGFzdFNlcTogc2VxXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICB9KSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIGZhaWxOZXh0KCkge1xuICAgIC8vIGRlYnVnZ2luZyBtZXRob2QgdG8gZmFpbCB0aGUgbmV4dCByZWNvbm5lY3QvcmVzdW1lIGF0dGVtcHRcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gdHJ1ZTtcbiAgfVxuICBkYXRhQ2hhbm5lbHNJbmZvKCkge1xuICAgIGNvbnN0IGluZm9zID0gW107XG4gICAgY29uc3QgZ2V0SW5mbyA9IChkYywgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoKGRjID09PSBudWxsIHx8IGRjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYy5pZCkgIT09IHVuZGVmaW5lZCAmJiBkYy5pZCAhPT0gbnVsbCkge1xuICAgICAgICBpbmZvcy5wdXNoKG5ldyBEYXRhQ2hhbm5lbEluZm8oe1xuICAgICAgICAgIGxhYmVsOiBkYy5sYWJlbCxcbiAgICAgICAgICBpZDogZGMuaWQsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICByZXR1cm4gaW5mb3M7XG4gIH1cbiAgY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgfVxuICByZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT2ZmbGluZSk7XG4gICAgfVxuICB9XG4gIGRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9mZmxpbmUpO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja0lkRm9yUmVjZWl2ZXIocmVjZWl2ZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWlkID0gKF9hID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRNaWRGb3JSZWNlaXZlcihyZWNlaXZlcik7XG4gICAgaWYgKG1pZCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBPYmplY3QuZW50cmllcyh0aGlzLm1pZFRvVHJhY2tJZCkuZmluZChfcmVmMiA9PiB7XG4gICAgICAgIGxldCBba2V5XSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4ga2V5ID09PSBtaWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBTaWduYWxSZWNvbm5lY3RFcnJvciBleHRlbmRzIEVycm9yIHt9XG5mdW5jdGlvbiBzdXBwb3J0T3B0aW9uYWxEYXRhY2hhbm5lbChwcm90b2NvbCkge1xuICByZXR1cm4gcHJvdG9jb2wgIT09IHVuZGVmaW5lZCAmJiBwcm90b2NvbCA+IDEzO1xufVxuZnVuY3Rpb24gYXBwbHlVc2VyRGF0YUNvbXBhdChuZXdPYmosIG9sZE9iaikge1xuICBjb25zdCBwYXJ0aWNpcGFudElkZW50aXR5ID0gbmV3T2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgPyBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA6IG9sZE9iai5wYXJ0aWNpcGFudElkZW50aXR5O1xuICBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XG4gIG9sZE9iai5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gbmV3T2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcy5sZW5ndGggIT09IDAgPyBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzIDogb2xkT2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcbiAgbmV3T2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IGRlc3RpbmF0aW9uSWRlbnRpdGllcztcbiAgb2xkT2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IGRlc3RpbmF0aW9uSWRlbnRpdGllcztcbn1cblxuY2xhc3MgQmFzZVN0cmVhbVJlYWRlciB7XG4gIGdldCBpbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZvO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdmFsaWRhdGVCeXRlc1JlY2VpdmVkKCkge1xuICAgIGxldCBkb25lUmVjZWl2aW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHRoaXMudG90YWxCeXRlU2l6ZSAhPT0gJ251bWJlcicgfHwgdGhpcy50b3RhbEJ5dGVTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkb25lUmVjZWl2aW5nICYmIHRoaXMuYnl0ZXNSZWNlaXZlZCA8IHRoaXMudG90YWxCeXRlU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IERhdGFTdHJlYW1FcnJvcihcIk5vdCBlbm91Z2ggY2h1bmsocykgcmVjZWl2ZWQgLSBleHBlY3RlZCBcIi5jb25jYXQodGhpcy50b3RhbEJ5dGVTaXplLCBcIiBieXRlcyBvZiBkYXRhIHRvdGFsLCBvbmx5IHJlY2VpdmVkIFwiKS5jb25jYXQodGhpcy5ieXRlc1JlY2VpdmVkLCBcIiBieXRlc1wiKSwgRGF0YVN0cmVhbUVycm9yUmVhc29uLkluY29tcGxldGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc1JlY2VpdmVkID4gdGhpcy50b3RhbEJ5dGVTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiRXh0cmEgY2h1bmsocykgcmVjZWl2ZWQgLSBleHBlY3RlZCBcIi5jb25jYXQodGhpcy50b3RhbEJ5dGVTaXplLCBcIiBieXRlcyBvZiBkYXRhIHRvdGFsLCByZWNlaXZlZCBcIikuY29uY2F0KHRoaXMuYnl0ZXNSZWNlaXZlZCwgXCIgYnl0ZXNcIiksIERhdGFTdHJlYW1FcnJvclJlYXNvbi5MZW5ndGhFeGNlZWRlZCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKGluZm8sIHN0cmVhbSwgdG90YWxCeXRlU2l6ZSwgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSkge1xuICAgIHRoaXMucmVhZGVyID0gc3RyZWFtO1xuICAgIHRoaXMudG90YWxCeXRlU2l6ZSA9IHRvdGFsQnl0ZVNpemU7XG4gICAgdGhpcy5faW5mbyA9IGluZm87XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcbiAgICB0aGlzLm91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUgPSBvdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlO1xuICB9XG59XG5jbGFzcyBCeXRlU3RyZWFtUmVhZGVyIGV4dGVuZHMgQmFzZVN0cmVhbVJlYWRlciB7XG4gIGhhbmRsZUNodW5rUmVjZWl2ZWQoY2h1bmspIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGNodW5rLmNvbnRlbnQuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLnZhbGlkYXRlQnl0ZXNSZWNlaXZlZCgpO1xuICAgIGNvbnN0IGN1cnJlbnRQcm9ncmVzcyA9IHRoaXMudG90YWxCeXRlU2l6ZSA/IHRoaXMuYnl0ZXNSZWNlaXZlZCAvIHRoaXMudG90YWxCeXRlU2l6ZSA6IHVuZGVmaW5lZDtcbiAgICAoX2EgPSB0aGlzLm9uUHJvZ3Jlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGN1cnJlbnRQcm9ncmVzcyk7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnJlYWRlci5nZXRSZWFkZXIoKTtcbiAgICBsZXQgcmVqZWN0aW5nU2lnbmFsRnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgIGxldCBhY3RpdmVTaWduYWwgPSBudWxsO1xuICAgIGxldCBvbkFib3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaWduYWwpIHtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuc2lnbmFsO1xuICAgICAgb25BYm9ydCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSByZWplY3RpbmdTaWduYWxGdXR1cmUucmVqZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZWplY3RpbmdTaWduYWxGdXR1cmUsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgfTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpO1xuICAgICAgYWN0aXZlU2lnbmFsID0gc2lnbmFsO1xuICAgIH1cbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBpZiAoYWN0aXZlU2lnbmFsICYmIG9uQWJvcnQpIHtcbiAgICAgICAgYWN0aXZlU2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hbCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHlpZWxkIFByb21pc2UucmFjZShbcmVhZGVyLnJlYWQoKSxcbiAgICAgICAgICAvLyBSZWplY3RzIGlmIHRoaXMuc2lnbmFsIGlzIGFib3J0ZWRcbiAgICAgICAgICByZWplY3RpbmdTaWduYWxGdXR1cmUucHJvbWlzZSxcbiAgICAgICAgICAvLyBSZWplY3RzIGlmIHNvbWV0aGluZyBleHRlcm5hbCBzYXlzIGl0IHNob3VsZCwgbGlrZSBhIHBhcnRpY2lwYW50IGRpc2Nvbm5lY3RpbmcsIGV0Y1xuICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMub3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb21pc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgIC8qIG5ldmVyIHJlc29sdmVzICovXG4gICAgICAgICAgfSldKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUJ5dGVzUmVjZWl2ZWQodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNodW5rUmVjZWl2ZWQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5jb250ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAvLyBub3RlOiBgcmV0dXJuYCBydW5zIG9ubHkgZm9yIHByZW1hdHVyZSBleGl0cywgc2VlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scyNlcnJvcnNfZHVyaW5nX2l0ZXJhdGlvblxuICAgICAgcmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIEFib3J0U2lnbmFsLCB3aGljaCBpZiBhYm9ydGVkLCB3aWxsIHRlcm1pbmF0ZSB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgKiBzdHJlYW0gaXRlcmF0aW9uIG9wZXJhdGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdoZW4gdXNpbmcgQWJvcnRTaWduYWwudGltZW91dCguLi4pLCB0aGUgdGltZW91dCBhcHBsaWVzIGFjcm9zc1xuICAgKiB0aGUgd2hvbGUgaXRlcmF0aW9uIG9wZXJhdGlvbiwgbm90IGp1c3Qgb25lIGluZGl2aWR1YWwgY2h1bmsgcmVhZC5cbiAgICovXG4gIHdpdGhBYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWFkQWxsKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgbGV0IGNodW5rcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBvcHRzLnNpZ25hbCA/IF90aGlzLndpdGhBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCkgOiBfdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhdG9yXzEgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhdG9yKSwgaXRlcmF0b3JfMV8xOyBpdGVyYXRvcl8xXzEgPSB5aWVsZCBpdGVyYXRvcl8xLm5leHQoKSwgX2EgPSBpdGVyYXRvcl8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgIF9jID0gaXRlcmF0b3JfMV8xLnZhbHVlO1xuICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICBjaHVua3MuYWRkKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgICAgZV8xID0ge1xuICAgICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmF0b3JfMS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKGl0ZXJhdG9yXzEpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGNodW5rcyk7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0byByZWFkIGNodW5rcyBmcm9tIGEgUmVhZGFibGVTdHJlYW0gYW5kIHByb3ZpZGUgdGhlbSBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LlxuICovXG5jbGFzcyBUZXh0U3RyZWFtUmVhZGVyIGV4dGVuZHMgQmFzZVN0cmVhbVJlYWRlciB7XG4gIC8qKlxuICAgKiBBIFRleHRTdHJlYW1SZWFkZXIgaW5zdGFuY2UgY2FuIGJlIHVzZWQgYXMgYW4gQXN5bmNJdGVyYXRvciB0aGF0IHJldHVybnMgdGhlIGVudGlyZSBzdHJpbmdcbiAgICogdGhhdCBoYXMgYmVlbiByZWNlaXZlZCB1cCB0byB0aGUgY3VycmVudCBwb2ludCBpbiB0aW1lLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5mbywgc3RyZWFtLCB0b3RhbENodW5rQ291bnQsIG91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpIHtcbiAgICBzdXBlcihpbmZvLCBzdHJlYW0sIHRvdGFsQ2h1bmtDb3VudCwgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSk7XG4gICAgdGhpcy5yZWNlaXZlZENodW5rcyA9IG5ldyBNYXAoKTtcbiAgfVxuICBoYW5kbGVDaHVua1JlY2VpdmVkKGNodW5rKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGluZGV4ID0gYmlnSW50VG9OdW1iZXIoY2h1bmsuY2h1bmtJbmRleCk7XG4gICAgY29uc3QgcHJldmlvdXNDaHVua0F0SW5kZXggPSB0aGlzLnJlY2VpdmVkQ2h1bmtzLmdldChpbmRleCk7XG4gICAgaWYgKHByZXZpb3VzQ2h1bmtBdEluZGV4ICYmIHByZXZpb3VzQ2h1bmtBdEluZGV4LnZlcnNpb24gPiBjaHVuay52ZXJzaW9uKSB7XG4gICAgICAvLyB3ZSBoYXZlIGEgbmV3ZXIgdmVyc2lvbiBhbHJlYWR5LCBkcm9wcGluZyB0aGUgb2xkIG9uZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlY2VpdmVkQ2h1bmtzLnNldChpbmRleCwgY2h1bmspO1xuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBjaHVuay5jb250ZW50LmJ5dGVMZW5ndGg7XG4gICAgdGhpcy52YWxpZGF0ZUJ5dGVzUmVjZWl2ZWQoKTtcbiAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLnRvdGFsQnl0ZVNpemUgPyB0aGlzLmJ5dGVzUmVjZWl2ZWQgLyB0aGlzLnRvdGFsQnl0ZVNpemUgOiB1bmRlZmluZWQ7XG4gICAgKF9hID0gdGhpcy5vblByb2dyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjdXJyZW50UHJvZ3Jlc3MpO1xuICB9XG4gIC8qKlxuICAgKiBBc3luYyBpdGVyYXRvciBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyB1c2FnZSBvZiBgZm9yIGF3YWl0Li4ub2ZgIHN5bnRheC5cbiAgICogWWllbGRzIHN0cnVjdHVyZWQgY2h1bmtzIGZyb20gdGhlIHN0cmVhbS5cbiAgICpcbiAgICovXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXIuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7XG4gICAgICBmYXRhbDogdHJ1ZVxuICAgIH0pO1xuICAgIGxldCByZWplY3RpbmdTaWduYWxGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgbGV0IGFjdGl2ZVNpZ25hbCA9IG51bGw7XG4gICAgbGV0IG9uQWJvcnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnNpZ25hbCkge1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5zaWduYWw7XG4gICAgICBvbkFib3J0ID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHJlamVjdGluZ1NpZ25hbEZ1dHVyZS5yZWplY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHJlamVjdGluZ1NpZ25hbEZ1dHVyZSwgc2lnbmFsLnJlYXNvbik7XG4gICAgICB9O1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydCk7XG4gICAgICBhY3RpdmVTaWduYWwgPSBzaWduYWw7XG4gICAgfVxuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIGlmIChhY3RpdmVTaWduYWwgJiYgb25BYm9ydCkge1xuICAgICAgICBhY3RpdmVTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnbmFsID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkb25lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0geWllbGQgUHJvbWlzZS5yYWNlKFtyZWFkZXIucmVhZCgpLFxuICAgICAgICAgIC8vIFJlamVjdHMgaWYgdGhpcy5zaWduYWwgaXMgYWJvcnRlZFxuICAgICAgICAgIHJlamVjdGluZ1NpZ25hbEZ1dHVyZS5wcm9taXNlLFxuICAgICAgICAgIC8vIFJlamVjdHMgaWYgc29tZXRoaW5nIGV4dGVybmFsIHNheXMgaXQgc2hvdWxkLCBsaWtlIGEgcGFydGljaXBhbnQgZGlzY29ubmVjdGluZywgZXRjXG4gICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgICAgICAgLyogbmV2ZXIgcmVzb2x2ZXMgKi9cbiAgICAgICAgICB9KV0pO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQnl0ZXNSZWNlaXZlZCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2h1bmtSZWNlaXZlZCh2YWx1ZSk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZFJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlY29kZWRSZXN1bHQgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZS5jb250ZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiQ2Fubm90IGRlY29kZSBkYXRhc3RyZWFtIGNodW5rIFwiLmNvbmNhdCh2YWx1ZS5jaHVua0luZGV4LCBcIiBhcyB0ZXh0OiBcIikuY29uY2F0KGVyciksIERhdGFTdHJlYW1FcnJvclJlYXNvbi5EZWNvZGVGYWlsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVkUmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAvLyBub3RlOiBgcmV0dXJuYCBydW5zIG9ubHkgZm9yIHByZW1hdHVyZSBleGl0cywgc2VlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scyNlcnJvcnNfZHVyaW5nX2l0ZXJhdGlvblxuICAgICAgcmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIEFib3J0U2lnbmFsLCB3aGljaCBpZiBhYm9ydGVkLCB3aWxsIHRlcm1pbmF0ZSB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgKiBzdHJlYW0gaXRlcmF0aW9uIG9wZXJhdGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdoZW4gdXNpbmcgQWJvcnRTaWduYWwudGltZW91dCguLi4pLCB0aGUgdGltZW91dCBhcHBsaWVzIGFjcm9zc1xuICAgKiB0aGUgd2hvbGUgaXRlcmF0aW9uIG9wZXJhdGlvbiwgbm90IGp1c3Qgb25lIGluZGl2aWR1YWwgY2h1bmsgcmVhZC5cbiAgICovXG4gIHdpdGhBYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWFkQWxsKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgIGxldCBmaW5hbFN0cmluZyA9ICcnO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IG9wdHMuc2lnbmFsID8gX3RoaXMyLndpdGhBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCkgOiBfdGhpczI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYXRvcl8yID0gX19hc3luY1ZhbHVlcyhpdGVyYXRvciksIGl0ZXJhdG9yXzJfMTsgaXRlcmF0b3JfMl8xID0geWllbGQgaXRlcmF0b3JfMi5uZXh0KCksIF9hID0gaXRlcmF0b3JfMl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICBfYyA9IGl0ZXJhdG9yXzJfMS52YWx1ZTtcbiAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgZmluYWxTdHJpbmcgKz0gY2h1bms7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICAgIGVfMiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhdG9yXzIucmV0dXJuKSkgeWllbGQgX2IuY2FsbChpdGVyYXRvcl8yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxTdHJpbmc7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgSW5jb21pbmdEYXRhU3RyZWFtTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRleHRTdHJlYW1IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiQSB0ZXh0IHN0cmVhbSBoYW5kbGVyIGZvciB0b3BpYyBcXFwiXCIuY29uY2F0KHRvcGljLCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuXCIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uSGFuZGxlckFscmVhZHlSZWdpc3RlcmVkKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cbiAgdW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljKSB7XG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcbiAgfVxuICByZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiQSBieXRlIHN0cmVhbSBoYW5kbGVyIGZvciB0b3BpYyBcXFwiXCIuY29uY2F0KHRvcGljLCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuXCIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uSGFuZGxlckFscmVhZHlSZWdpc3RlcmVkKTtcbiAgICB9XG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cbiAgdW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljKSB7XG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcbiAgfVxuICBjbGVhckNvbnRyb2xsZXJzKCkge1xuICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmNsZWFyKCk7XG4gICAgdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuY2xlYXIoKTtcbiAgfVxuICB2YWxpZGF0ZVBhcnRpY2lwYW50SGFzTm9BY3RpdmVEYXRhU3RyZWFtcyhwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIC8vIFRlcm1pbmF0ZSBhbnkgaW4gZmxpZ2h0IGRhdGEgc3RyZWFtIHJlY2VpdmVzIGZyb20gdGhlIGdpdmVuIHBhcnRpY2lwYW50XG4gICAgY29uc3QgdGV4dFN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZW50cmllcygpKS5maWx0ZXIoZW50cnkgPT4gZW50cnlbMV0uc2VuZGluZ1BhcnRpY2lwYW50SWRlbnRpdHkgPT09IHBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgIGNvbnN0IGJ5dGVTdHJlYW1zQmVpbmdTZW50QnlEaXNjb25uZWN0aW5nUGFydGljaXBhbnQgPSBBcnJheS5mcm9tKHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmVudHJpZXMoKSkuZmlsdGVyKGVudHJ5ID0+IGVudHJ5WzFdLnNlbmRpbmdQYXJ0aWNpcGFudElkZW50aXR5ID09PSBwYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICBpZiAodGV4dFN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudC5sZW5ndGggPiAwIHx8IGJ5dGVTdHJlYW1zQmVpbmdTZW50QnlEaXNjb25uZWN0aW5nUGFydGljaXBhbnQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYWJub3JtYWxFbmRFcnJvciA9IG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJQYXJ0aWNpcGFudCBcIi5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSwgXCIgdW5leHBlY3RlZGx5IGRpc2Nvbm5lY3RlZCBpbiB0aGUgbWlkZGxlIG9mIHNlbmRpbmcgZGF0YVwiKSwgRGF0YVN0cmVhbUVycm9yUmVhc29uLkFibm9ybWFsRW5kKTtcbiAgICAgIGZvciAoY29uc3QgW2lkLCBjb250cm9sbGVyXSBvZiBieXRlU3RyZWFtc0JlaW5nU2VudEJ5RGlzY29ubmVjdGluZ1BhcnRpY2lwYW50KSB7XG4gICAgICAgIChfYiA9IChfYSA9IGNvbnRyb2xsZXIub3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSkucmVqZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgYWJub3JtYWxFbmRFcnJvcik7XG4gICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtpZCwgY29udHJvbGxlcl0gb2YgdGV4dFN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudCkge1xuICAgICAgICAoX2QgPSAoX2MgPSBjb250cm9sbGVyLm91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpLnJlamVjdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIGFibm9ybWFsRW5kRXJyb3IpO1xuICAgICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVEYXRhU3RyZWFtUGFja2V0KHBhY2tldCwgZW5jcnlwdGlvblR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgc3dpdGNoIChwYWNrZXQudmFsdWUuY2FzZSkge1xuICAgICAgICBjYXNlICdzdHJlYW1IZWFkZXInOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0cmVhbUhlYWRlcihwYWNrZXQudmFsdWUudmFsdWUsIHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5LCBlbmNyeXB0aW9uVHlwZSk7XG4gICAgICAgIGNhc2UgJ3N0cmVhbUNodW5rJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdHJlYW1DaHVuayhwYWNrZXQudmFsdWUudmFsdWUsIGVuY3J5cHRpb25UeXBlKTtcbiAgICAgICAgY2FzZSAnc3RyZWFtVHJhaWxlcic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RyZWFtVHJhaWxlcihwYWNrZXQudmFsdWUudmFsdWUsIGVuY3J5cHRpb25UeXBlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhUGFja2V0IG9mIHZhbHVlIFxcXCJcIi5jb25jYXQocGFja2V0LnZhbHVlLmNhc2UsIFwiXFxcIiBpcyBub3QgZGF0YSBzdHJlYW0gcmVsYXRlZCFcIikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVN0cmVhbUhlYWRlcihzdHJlYW1IZWFkZXIsIHBhcnRpY2lwYW50SWRlbnRpdHksIGVuY3J5cHRpb25UeXBlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChzdHJlYW1IZWFkZXIuY29udGVudEhlYWRlci5jYXNlID09PSAnYnl0ZUhlYWRlcicpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtSGFuZGxlckNhbGxiYWNrID0gdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuZ2V0KHN0cmVhbUhlYWRlci50b3BpYyk7XG4gICAgICAgIGlmICghc3RyZWFtSGFuZGxlckNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2lnbm9yaW5nIGluY29taW5nIGJ5dGUgc3RyZWFtIGR1ZSB0byBubyBoYW5kbGVyIGZvciB0b3BpYycsIHN0cmVhbUhlYWRlci50b3BpYyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBjb25zdCBvdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgICBvdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlLnByb21pc2UuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICBpZDogc3RyZWFtSGVhZGVyLnN0cmVhbUlkLFxuICAgICAgICAgIG5hbWU6IChfYSA9IHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLnZhbHVlLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1bmtub3duJyxcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxuICAgICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRvcGljOiBzdHJlYW1IZWFkZXIudG9waWMsXG4gICAgICAgICAgdGltZXN0YW1wOiBiaWdJbnRUb051bWJlcihzdHJlYW1IZWFkZXIudGltZXN0YW1wKSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzdHJlYW1IZWFkZXIuYXR0cmlidXRlcyxcbiAgICAgICAgICBlbmNyeXB0aW9uVHlwZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmhhcyhzdHJlYW1IZWFkZXIuc3RyZWFtSWQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJBIGRhdGEgc3RyZWFtIHJlYWQgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgYSBzdHJlYW0gd2l0aCBpZCBcIi5jb25jYXQoc3RyZWFtSGVhZGVyLnN0cmVhbUlkLCBcIi5cIiksIERhdGFTdHJlYW1FcnJvclJlYXNvbi5BbHJlYWR5T3BlbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLnNldChzdHJlYW1IZWFkZXIuc3RyZWFtSWQsIHtcbiAgICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogc3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBzZW5kaW5nUGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICAgICAgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtSGFuZGxlckNhbGxiYWNrKG5ldyBCeXRlU3RyZWFtUmVhZGVyKGluZm8sIHN0cmVhbSwgYmlnSW50VG9OdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSwgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSksIHtcbiAgICAgICAgICBpZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtSGVhZGVyLmNvbnRlbnRIZWFkZXIuY2FzZSA9PT0gJ3RleHRIZWFkZXInKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUhhbmRsZXJDYWxsYmFjayA9IHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzLmdldChzdHJlYW1IZWFkZXIudG9waWMpO1xuICAgICAgICBpZiAoIXN0cmVhbUhhbmRsZXJDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdpZ25vcmluZyBpbmNvbWluZyB0ZXh0IHN0cmVhbSBkdWUgdG8gbm8gaGFuZGxlciBmb3IgdG9waWMnLCBzdHJlYW1IZWFkZXIudG9waWMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICAgICAgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZS5wcm9taXNlLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgaWQ6IHN0cmVhbUhlYWRlci5zdHJlYW1JZCxcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxuICAgICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRvcGljOiBzdHJlYW1IZWFkZXIudG9waWMsXG4gICAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoc3RyZWFtSGVhZGVyLnRpbWVzdGFtcCksXG4gICAgICAgICAgYXR0cmlidXRlczogc3RyZWFtSGVhZGVyLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgZW5jcnlwdGlvblR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5oYXMoc3RyZWFtSGVhZGVyLnN0cmVhbUlkKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiQSBkYXRhIHN0cmVhbSByZWFkIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgZm9yIGEgc3RyZWFtIHdpdGggaWQgXCIuY29uY2F0KHN0cmVhbUhlYWRlci5zdHJlYW1JZCwgXCIuXCIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uQWxyZWFkeU9wZW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5zZXQoc3RyZWFtSGVhZGVyLnN0cmVhbUlkLCB7XG4gICAgICAgICAgICAgIGluZm8sXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXI6IHN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgc2VuZGluZ1BhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgICAgICAgIG91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbUhhbmRsZXJDYWxsYmFjayhuZXcgVGV4dFN0cmVhbVJlYWRlcihpbmZvLCBzdHJlYW0sIGJpZ0ludFRvTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCksIG91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpLCB7XG4gICAgICAgICAgaWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU3RyZWFtQ2h1bmsoY2h1bmssIGVuY3J5cHRpb25UeXBlKSB7XG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldChjaHVuay5zdHJlYW1JZCk7XG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcbiAgICAgIGlmIChmaWxlQnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUgIT09IGVuY3J5cHRpb25UeXBlKSB7XG4gICAgICAgIGZpbGVCdWZmZXIuY29udHJvbGxlci5lcnJvcihuZXcgRGF0YVN0cmVhbUVycm9yKFwiRW5jcnlwdGlvbiB0eXBlIG1pc21hdGNoIGZvciBzdHJlYW0gXCIuY29uY2F0KGNodW5rLnN0cmVhbUlkLCBcIi4gRXhwZWN0ZWQgXCIpLmNvbmNhdChlbmNyeXB0aW9uVHlwZSwgXCIsIGdvdCBcIikuY29uY2F0KGZpbGVCdWZmZXIuaW5mby5lbmNyeXB0aW9uVHlwZSksIERhdGFTdHJlYW1FcnJvclJlYXNvbi5FbmNyeXB0aW9uVHlwZU1pc21hdGNoKSk7XG4gICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZShjaHVuay5zdHJlYW1JZCk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWxlQnVmZmVyLmNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHRCdWZmZXIgPSB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5nZXQoY2h1bmsuc3RyZWFtSWQpO1xuICAgIGlmICh0ZXh0QnVmZmVyKSB7XG4gICAgICBpZiAodGV4dEJ1ZmZlci5pbmZvLmVuY3J5cHRpb25UeXBlICE9PSBlbmNyeXB0aW9uVHlwZSkge1xuICAgICAgICB0ZXh0QnVmZmVyLmNvbnRyb2xsZXIuZXJyb3IobmV3IERhdGFTdHJlYW1FcnJvcihcIkVuY3J5cHRpb24gdHlwZSBtaXNtYXRjaCBmb3Igc3RyZWFtIFwiLmNvbmNhdChjaHVuay5zdHJlYW1JZCwgXCIuIEV4cGVjdGVkIFwiKS5jb25jYXQoZW5jcnlwdGlvblR5cGUsIFwiLCBnb3QgXCIpLmNvbmNhdCh0ZXh0QnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uRW5jcnlwdGlvblR5cGVNaXNtYXRjaCkpO1xuICAgICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5kZWxldGUoY2h1bmsuc3RyZWFtSWQpO1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVTdHJlYW1UcmFpbGVyKHRyYWlsZXIsIGVuY3J5cHRpb25UeXBlKSB7XG4gICAgY29uc3QgdGV4dEJ1ZmZlciA9IHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmdldCh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICBpZiAodGV4dEJ1ZmZlcikge1xuICAgICAgaWYgKHRleHRCdWZmZXIuaW5mby5lbmNyeXB0aW9uVHlwZSAhPT0gZW5jcnlwdGlvblR5cGUpIHtcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmVycm9yKG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJFbmNyeXB0aW9uIHR5cGUgbWlzbWF0Y2ggZm9yIHN0cmVhbSBcIi5jb25jYXQodHJhaWxlci5zdHJlYW1JZCwgXCIuIEV4cGVjdGVkIFwiKS5jb25jYXQoZW5jcnlwdGlvblR5cGUsIFwiLCBnb3QgXCIpLmNvbmNhdCh0ZXh0QnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uRW5jcnlwdGlvblR5cGVNaXNtYXRjaCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dEJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRleHRCdWZmZXIuaW5mby5hdHRyaWJ1dGVzKSwgdHJhaWxlci5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZSh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldCh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICBpZiAoZmlsZUJ1ZmZlcikge1xuICAgICAgaWYgKGZpbGVCdWZmZXIuaW5mby5lbmNyeXB0aW9uVHlwZSAhPT0gZW5jcnlwdGlvblR5cGUpIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmVycm9yKG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJFbmNyeXB0aW9uIHR5cGUgbWlzbWF0Y2ggZm9yIHN0cmVhbSBcIi5jb25jYXQodHJhaWxlci5zdHJlYW1JZCwgXCIuIEV4cGVjdGVkIFwiKS5jb25jYXQoZW5jcnlwdGlvblR5cGUsIFwiLCBnb3QgXCIpLmNvbmNhdChmaWxlQnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uRW5jcnlwdGlvblR5cGVNaXNtYXRjaCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpbGVCdWZmZXIuaW5mby5hdHRyaWJ1dGVzKSwgdHJhaWxlci5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5kZWxldGUodHJhaWxlci5zdHJlYW1JZCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEJhc2VTdHJlYW1Xcml0ZXIge1xuICBjb25zdHJ1Y3Rvcih3cml0YWJsZVN0cmVhbSwgaW5mbywgb25DbG9zZSkge1xuICAgIHRoaXMud3JpdGFibGVTdHJlYW0gPSB3cml0YWJsZVN0cmVhbTtcbiAgICB0aGlzLmRlZmF1bHRXcml0ZXIgPSB3cml0YWJsZVN0cmVhbS5nZXRXcml0ZXIoKTtcbiAgICB0aGlzLm9uQ2xvc2UgPSBvbkNsb3NlO1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gIH1cbiAgd3JpdGUoY2h1bmspIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0V3JpdGVyLndyaXRlKGNodW5rKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgeWllbGQgdGhpcy5kZWZhdWx0V3JpdGVyLmNsb3NlKCk7XG4gICAgICB0aGlzLmRlZmF1bHRXcml0ZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIChfYSA9IHRoaXMub25DbG9zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFRleHRTdHJlYW1Xcml0ZXIgZXh0ZW5kcyBCYXNlU3RyZWFtV3JpdGVyIHt9XG5jbGFzcyBCeXRlU3RyZWFtV3JpdGVyIGV4dGVuZHMgQmFzZVN0cmVhbVdyaXRlciB7fVxuXG5jb25zdCBTVFJFQU1fQ0hVTktfU0laRSA9IDE1MDAwO1xuLyoqXG4gKiBNYW5hZ2VzIHNlbmRpbmcgY3VzdG9tIHVzZXIgZGF0YSB2aWEgZGF0YSBjaGFubmVscy5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBPdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZW5naW5lLCBsb2cpIHtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLmxvZyA9IGxvZztcbiAgfVxuICBzZXR1cEVuZ2luZShlbmdpbmUpIHtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgfVxuICAvKioge0Bpbmhlcml0RG9jIExvY2FsUGFydGljaXBhbnQuc2VuZFRleHR9ICovXG4gIHNlbmRUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgY29uc3QgdGV4dEluQnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgICBjb25zdCB0b3RhbFRleHRMZW5ndGggPSB0ZXh0SW5CeXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgY29uc3QgZmlsZUlkcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRhY2htZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoKSA9PiBjcnlwdG8ucmFuZG9tVVVJRCgpKTtcbiAgICAgIGNvbnN0IHByb2dyZXNzZXMgPSBuZXcgQXJyYXkoZmlsZUlkcyA/IGZpbGVJZHMubGVuZ3RoICsgMSA6IDEpLmZpbGwoMCk7XG4gICAgICBjb25zdCBoYW5kbGVQcm9ncmVzcyA9IChwcm9ncmVzcywgaWR4KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcHJvZ3Jlc3Nlc1tpZHhdID0gcHJvZ3Jlc3M7XG4gICAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBwcm9ncmVzc2VzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XG4gICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblByb2dyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB0b3RhbFByb2dyZXNzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnN0cmVhbVRleHQoe1xuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgdG90YWxTaXplOiB0b3RhbFRleHRMZW5ndGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgdG9waWM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYyxcbiAgICAgICAgYXR0YWNoZWRTdHJlYW1JZHM6IGZpbGVJZHMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHdyaXRlci53cml0ZSh0ZXh0KTtcbiAgICAgIC8vIHNldCB0ZXh0IHBhcnQgb2YgcHJvZ3Jlc3MgdG8gMVxuICAgICAgaGFuZGxlUHJvZ3Jlc3MoMSwgMCk7XG4gICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzKSAmJiBmaWxlSWRzKSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKG9wdGlvbnMuYXR0YWNobWVudHMubWFwKChmaWxlLCBpZHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEZpbGUoZmlsZUlkc1tpZHhdLCBmaWxlLCB7XG4gICAgICAgICAgICB0b3BpYzogb3B0aW9ucy50b3BpYyxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICBvblByb2dyZXNzOiBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZVByb2dyZXNzKHByb2dyZXNzLCBpZHggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cml0ZXIuaW5mbztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWwgQ0FVVElPTiwgbWlnaHQgZ2V0IHJlbW92ZWQgaW4gYSBtaW5vciByZWxlYXNlXG4gICAqL1xuICBzdHJlYW1UZXh0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBjb25zdCBzdHJlYW1JZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdHJlYW1JZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB0b3BpYzogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgc2l6ZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvdGFsU2l6ZSxcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICAgIGVuY3J5cHRpb25UeXBlOiAoKF9jID0gdGhpcy5lbmdpbmUuZTJlZU1hbmFnZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pc0RhdGFDaGFubmVsRW5jcnlwdGlvbkVuYWJsZWQpID8gRW5jcnlwdGlvbl9UeXBlLkdDTSA6IEVuY3J5cHRpb25fVHlwZS5OT05FXG4gICAgICB9O1xuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IERhdGFTdHJlYW1fSGVhZGVyKHtcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIG1pbWVUeXBlOiBpbmZvLm1pbWVUeXBlLFxuICAgICAgICB0b3BpYzogaW5mby50b3BpYyxcbiAgICAgICAgdGltZXN0YW1wOiBudW1iZXJUb0JpZ0ludChpbmZvLnRpbWVzdGFtcCksXG4gICAgICAgIHRvdGFsTGVuZ3RoOiBudW1iZXJUb0JpZ0ludChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG90YWxTaXplKSxcbiAgICAgICAgYXR0cmlidXRlczogaW5mby5hdHRyaWJ1dGVzLFxuICAgICAgICBjb250ZW50SGVhZGVyOiB7XG4gICAgICAgICAgY2FzZTogJ3RleHRIZWFkZXInLFxuICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YVN0cmVhbV9UZXh0SGVhZGVyKHtcbiAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgYXR0YWNoZWRTdHJlYW1JZHM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRhY2hlZFN0cmVhbUlkcyxcbiAgICAgICAgICAgIHJlcGx5VG9TdHJlYW1JZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcGx5VG9TdHJlYW1JZCxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSkgPT09ICd1cGRhdGUnID8gRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlLlVQREFURSA6IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZS5DUkVBVEVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXM7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAnc3RyZWFtSGVhZGVyJyxcbiAgICAgICAgICB2YWx1ZTogaGVhZGVyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgbGV0IGNodW5rSWQgPSAwO1xuICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5lbmdpbmU7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgIC8vIEltcGxlbWVudCB0aGUgc2lua1xuICAgICAgICB3cml0ZSh0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGV4dEJ5dGVDaHVuayBvZiBzcGxpdFV0ZjgodGV4dCwgU1RSRUFNX0NIVU5LX1NJWkUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IERhdGFTdHJlYW1fQ2h1bmsoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRleHRCeXRlQ2h1bmssXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICAgICAgY2h1bmtJbmRleDogbnVtYmVyVG9CaWdJbnQoY2h1bmtJZClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbUNodW5rJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVua1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHlpZWxkIGVuZ2luZS5zZW5kRGF0YVBhY2tldChjaHVua1BhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgICAgICAgICAgY2h1bmtJZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHJhaWxlciA9IG5ldyBEYXRhU3RyZWFtX1RyYWlsZXIoe1xuICAgICAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbVRyYWlsZXInLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFpbGVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgZW5naW5lLnNlbmREYXRhUGFja2V0KHRyYWlsZXJQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0KGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTaW5rIGVycm9yOicsIGVycik7XG4gICAgICAgICAgLy8gVE9ETyBoYW5kbGUgYWJvcnRzIHRvIHNpZ25hbCBzb21ldGhpbmcgdG8gcmVjZWl2ZXIgc2lkZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxldCBvbkVuZ2luZUNsb3NlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgZW5naW5lLm9uY2UoRW5naW5lRXZlbnQuQ2xvc2luZywgb25FbmdpbmVDbG9zZSk7XG4gICAgICBjb25zdCB3cml0ZXIgPSBuZXcgVGV4dFN0cmVhbVdyaXRlcih3cml0YWJsZVN0cmVhbSwgaW5mbywgKCkgPT4gdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uRW5naW5lQ2xvc2UpKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSk7XG4gIH1cbiAgc2VuZEZpbGUoZmlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzdHJlYW1JZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICB5aWVsZCB0aGlzLl9zZW5kRmlsZShzdHJlYW1JZCwgZmlsZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogc3RyZWFtSWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgX3NlbmRGaWxlKHN0cmVhbUlkLCBmaWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IHlpZWxkIHRoaXMuc3RyZWFtQnl0ZXMoe1xuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgdG90YWxTaXplOiBmaWxlLnNpemUsXG4gICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgbWltZVR5cGU6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZS50eXBlLFxuICAgICAgICB0b3BpYzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljLFxuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVhZGVyID0gZmlsZS5zdHJlYW0oKS5nZXRSZWFkZXIoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkb25lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gPSB5aWVsZCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHdyaXRlci53cml0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIHJldHVybiB3cml0ZXIuaW5mbztcbiAgICB9KTtcbiAgfVxuICBzdHJlYW1CeXRlcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RyZWFtSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICBtaW1lVHlwZTogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgdG9waWM6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3RhbFNpemUsXG4gICAgICAgIG5hbWU6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAndW5rbm93bicsXG4gICAgICAgIGVuY3J5cHRpb25UeXBlOiAoKF9lID0gdGhpcy5lbmdpbmUuZTJlZU1hbmFnZXIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5pc0RhdGFDaGFubmVsRW5jcnlwdGlvbkVuYWJsZWQpID8gRW5jcnlwdGlvbl9UeXBlLkdDTSA6IEVuY3J5cHRpb25fVHlwZS5OT05FXG4gICAgICB9O1xuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IERhdGFTdHJlYW1fSGVhZGVyKHtcbiAgICAgICAgdG90YWxMZW5ndGg6IG51bWJlclRvQmlnSW50KChfZiA9IGluZm8uc2l6ZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMCksXG4gICAgICAgIG1pbWVUeXBlOiBpbmZvLm1pbWVUeXBlLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgdG9waWM6IGluZm8udG9waWMsXG4gICAgICAgIHRpbWVzdGFtcDogbnVtYmVyVG9CaWdJbnQoRGF0ZS5ub3coKSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGluZm8uYXR0cmlidXRlcyxcbiAgICAgICAgY29udGVudEhlYWRlcjoge1xuICAgICAgICAgIGNhc2U6ICdieXRlSGVhZGVyJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fQnl0ZUhlYWRlcih7XG4gICAgICAgICAgICBuYW1lOiBpbmZvLm5hbWVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdzdHJlYW1IZWFkZXInLFxuICAgICAgICAgIHZhbHVlOiBoZWFkZXJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICBsZXQgY2h1bmtJZCA9IDA7XG4gICAgICBjb25zdCB3cml0ZU11dGV4ID0gbmV3IF8oKTtcbiAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuZW5naW5lO1xuICAgICAgY29uc3QgbG9nTG9jYWwgPSB0aGlzLmxvZztcbiAgICAgIGNvbnN0IHdyaXRhYmxlU3RyZWFtID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgd3JpdGVNdXRleC5sb2NrKCk7XG4gICAgICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aGlsZSAoYnl0ZU9mZnNldCA8IGNodW5rLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJDaHVuayA9IGNodW5rLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBTVFJFQU1fQ0hVTktfU0laRSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtQYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBjYXNlOiAnc3RyZWFtQ2h1bmsnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN1YkNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgICAgICAgICAgIGNodW5rSW5kZXg6IG51bWJlclRvQmlnSW50KGNodW5rSWQpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQgZW5naW5lLnNlbmREYXRhUGFja2V0KGNodW5rUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgICAgICAgICAgIGNodW5rSWQgKz0gMTtcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IHN1YkNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHVubG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHJhaWxlciA9IG5ldyBEYXRhU3RyZWFtX1RyYWlsZXIoe1xuICAgICAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbVRyYWlsZXInLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFpbGVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgZW5naW5lLnNlbmREYXRhUGFja2V0KHRyYWlsZXJQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0KGVycikge1xuICAgICAgICAgIGxvZ0xvY2FsLmVycm9yKCdTaW5rIGVycm9yOicsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYnl0ZVdyaXRlciA9IG5ldyBCeXRlU3RyZWFtV3JpdGVyKHdyaXRhYmxlU3RyZWFtLCBpbmZvKTtcbiAgICAgIHJldHVybiBieXRlV3JpdGVyO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFJlbW90ZVRyYWNrIGV4dGVuZHMgVHJhY2sge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIGtpbmQsIHJlY2VpdmVyLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywga2luZCwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5zaWQgPSBzaWQ7XG4gICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TWVkaWFTdHJlYW0oc3RyZWFtKSB7XG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICBjb25zdCBvblJlbW92ZVRyYWNrID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRyYWNrID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICAgICAgICBpZiAodGhpcy5yZWNlaXZlciAmJiAncGxheW91dERlbGF5SGludCcgaW4gdGhpcy5yZWNlaXZlcikge1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc3RhcnRNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZW5hYmxlKCk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZGlzYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIFJlbW90ZVRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBSZWNlaXZlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5yZWNlaXZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0c1JlcG9ydCA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIHJldHVybiBzdGF0c1JlcG9ydDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRvIHNldCBhIHBsYXlvdXQgZGVsYXkgKGluIHNlY29uZHMpIGZvciB0aGlzIHRyYWNrLlxuICAgKiBBIGhpZ2hlciB2YWx1ZSBhbGxvd3MgZm9yIG1vcmUgYnVmZmVyaW5nIG9mIHRoZSB0cmFjayBpbiB0aGUgYnJvd3NlclxuICAgKiBhbmQgd2lsbCByZXN1bHQgaW4gYSBkZWxheSBvZiBtZWRpYSBiZWluZyBwbGF5ZWQgYmFjayBvZiBgZGVsYXlJblNlY29uZHNgXG4gICAqL1xuICBzZXRQbGF5b3V0RGVsYXkoZGVsYXlJblNlY29uZHMpIHtcbiAgICBpZiAodGhpcy5yZWNlaXZlcikge1xuICAgICAgaWYgKCdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludCA9IGRlbGF5SW5TZWNvbmRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignUGxheW91dCBkZWxheSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdDYW5ub3Qgc2V0IHBsYXlvdXQgZGVsYXksIHRyYWNrIGFscmVhZHkgZW5kZWQnKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGxheW91dCBkZWxheSAoaW4gc2Vjb25kcykgb2YgdGhpcyB0cmFjay5cbiAgICovXG4gIGdldFBsYXlvdXREZWxheSgpIHtcbiAgICBpZiAodGhpcy5yZWNlaXZlcikge1xuICAgICAgaWYgKCdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVyLnBsYXlvdXREZWxheUhpbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdQbGF5b3V0IGRlbGF5IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ0Nhbm5vdCBnZXQgcGxheW91dCBkZWxheSwgdHJhY2sgYWxyZWFkeSBlbmRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKCkge1xuICAgIGlmICghdGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMubW9uaXRvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5tb25pdG9yUmVjZWl2ZXIoKSwgbW9uaXRvckZyZXF1ZW5jeSk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c1N5bmNocm9uaXphdGlvblNvdXJjZXMoKSkge1xuICAgICAgdGhpcy5yZWdpc3RlclRpbWVTeW5jVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyVGltZVN5bmNVcGRhdGUoKSB7XG4gICAgY29uc3QgbG9vcCA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMudGltZVN5bmNIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbG9vcCgpKTtcbiAgICAgIGNvbnN0IHNvdXJjZXMgPSAoX2EgPSB0aGlzLnJlY2VpdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3luY2hyb25pemF0aW9uU291cmNlcygpWzBdO1xuICAgICAgaWYgKHNvdXJjZXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICBydHBUaW1lc3RhbXBcbiAgICAgICAgfSA9IHNvdXJjZXM7XG4gICAgICAgIGlmIChydHBUaW1lc3RhbXAgJiYgdGhpcy5ydHBUaW1lc3RhbXAgIT09IHJ0cFRpbWVzdGFtcCkge1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlRpbWVTeW5jVXBkYXRlLCB7XG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBydHBUaW1lc3RhbXBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJ0cFRpbWVzdGFtcCA9IHJ0cFRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbG9vcCgpO1xuICB9XG59XG5cbmNsYXNzIFJlbW90ZUF1ZGlvVHJhY2sgZXh0ZW5kcyBSZW1vdGVUcmFjayB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIGF1ZGlvQ29udGV4dCwgYXVkaW9PdXRwdXQsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBzaWQsIFRyYWNrLktpbmQuQXVkaW8sIHJlY2VpdmVyLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLm1vbml0b3JSZWNlaXZlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5nZXRSZWNlaXZlclN0YXRzKCk7XG4gICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMgJiYgdGhpcy5yZWNlaXZlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IFtdO1xuICAgIGlmIChhdWRpb091dHB1dCkge1xuICAgICAgdGhpcy5zaW5rSWQgPSBhdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHNldHMgdGhlIHZvbHVtZSBmb3IgYWxsIGF0dGFjaGVkIGF1ZGlvIGVsZW1lbnRzXG4gICAqL1xuICBzZXRWb2x1bWUodm9sdW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5hdHRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgKF9hID0gdGhpcy5nYWluTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHZvbHVtZSwgMCwgMC4xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5fc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudFZvbHVtZSA9IHZvbHVtZTtcbiAgfVxuICAvKipcbiAgICogZ2V0cyB0aGUgdm9sdW1lIG9mIGF0dGFjaGVkIGF1ZGlvIGVsZW1lbnRzIChsb3VkZXN0KVxuICAgKi9cbiAgZ2V0Vm9sdW1lKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRWb2x1bWU7XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIC8vIFJOIHZvbHVtZSB2YWx1ZSBkZWZhdWx0cyB0byAxLjAgaWYgaGFzbid0IGJlZW4gY2hhbmdlZC5cbiAgICAgIHJldHVybiAxLjA7XG4gICAgfVxuICAgIGxldCBoaWdoZXN0Vm9sdW1lID0gMDtcbiAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50LnZvbHVtZSA+IGhpZ2hlc3RWb2x1bWUpIHtcbiAgICAgICAgaGlnaGVzdFZvbHVtZSA9IGVsZW1lbnQudm9sdW1lO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoaWdoZXN0Vm9sdW1lO1xuICB9XG4gIC8qKlxuICAgKiBjYWxscyBzZXRTaW5rSWQgb24gYWxsIGF0dGFjaGVkIGVsZW1lbnRzLCBpZiBzdXBwb3J0ZWRcbiAgICogQHBhcmFtIGRldmljZUlkIGF1ZGlvIG91dHB1dCBkZXZpY2VcbiAgICovXG4gIHNldFNpbmtJZChkZXZpY2VJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNpbmtJZCA9IGRldmljZUlkO1xuICAgICAgeWllbGQgUHJvbWlzZS5hbGwodGhpcy5hdHRhY2hlZEVsZW1lbnRzLm1hcChlbG0gPT4ge1xuICAgICAgICBpZiAoIXN1cHBvcnRzU2V0U2lua0lkKGVsbSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICByZXR1cm4gZWxtLnNldFNpbmtJZChkZXZpY2VJZCk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICBjb25zdCBuZWVkc05ld1dlYkF1ZGlvQ29ubmVjdGlvbiA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDA7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2lua0lkICYmIHN1cHBvcnRzU2V0U2lua0lkKGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50LnNldFNpbmtJZCh0aGlzLnNpbmtJZCkuY2F0Y2goZSA9PiB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdGYWlsZWQgdG8gc2V0IHNpbmsgaWQgb24gcmVtb3RlIGF1ZGlvIHRyYWNrJywgZSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhdWRpbyBjb250ZXh0IG1hcHBpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC52b2x1bWUgPSAwO1xuICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2b2x1bWUgc2V0dGluZyBpcyBiZWluZyBhcHBsaWVkIHRvIHRoZSBuZXdseSBhdHRhY2hlZCBlbGVtZW50XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBkZXRhY2goZWxlbWVudCkge1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBhbnkgYXR0YWNoZWQgZWxlbWVudHMgYWZ0ZXIgZGV0YWNoaW5nLCBjb25uZWN0IHdlYmF1ZGlvIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQncyBsZWZ0XG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICAgIGlmIChhdWRpb0NvbnRleHQgJiYgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKGF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBub2RlcyAtIEFuIGFycmF5IG9mIFdlYkF1ZGlvIG5vZGVzLiBUaGVzZSBub2RlcyBzaG91bGQgbm90IGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHdoZW4gcGFzc2VkLCBhcyB0aGUgc2RrIHdpbGwgdGFrZSBjYXJlIG9mIGNvbm5lY3RpbmcgdGhlbSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzKSB7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gbm9kZXM7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwICYmIHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdFdlYkF1ZGlvKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIC8vIEB0cy1pZ25vcmUgYXR0YWNoZWQgZWxlbWVudHMgYWx3YXlzIGhhdmUgYSBzcmNPYmplY3Qgc2V0XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShlbGVtZW50LnNyY09iamVjdCk7XG4gICAgbGV0IGxhc3ROb2RlID0gdGhpcy5zb3VyY2VOb2RlO1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGFzdE5vZGUuY29ubmVjdChub2RlKTtcbiAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICB9KTtcbiAgICB0aGlzLmdhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgbGFzdE5vZGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICB0aGlzLmdhaW5Ob2RlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgdGhpcy5nYWluTm9kZS5nYWluLnNldFRhcmdldEF0VGltZSh0aGlzLmVsZW1lbnRWb2x1bWUsIDAsIDAuMSk7XG4gICAgfVxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgY29udGV4dC5yZXN1bWUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIG5ldyBFcnJvcihcIkF1ZGlvIENvbnRleHQgY291bGRuJ3QgYmUgc3RhcnRlZCBhdXRvbWF0aWNhbGx5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RXZWJBdWRpbygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgKF9iID0gdGhpcy5zb3VyY2VOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgaml0dGVyOiB2LmppdHRlcixcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGNvbmNlYWxlZFNhbXBsZXM6IHYuY29uY2VhbGVkU2FtcGxlcyxcbiAgICAgICAgICAgIGNvbmNlYWxtZW50RXZlbnRzOiB2LmNvbmNlYWxtZW50RXZlbnRzLFxuICAgICAgICAgICAgc2lsZW50Q29uY2VhbGVkU2FtcGxlczogdi5zaWxlbnRDb25jZWFsZWRTYW1wbGVzLFxuICAgICAgICAgICAgc2lsZW50Q29uY2VhbG1lbnRFdmVudHM6IHYuc2lsZW50Q29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgICB0b3RhbEF1ZGlvRW5lcmd5OiB2LnRvdGFsQXVkaW9FbmVyZ3ksXG4gICAgICAgICAgICB0b3RhbFNhbXBsZXNEdXJhdGlvbjogdi50b3RhbFNhbXBsZXNEdXJhdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgUkVBQ1RJT05fREVMQVkgPSAxMDA7XG5jbGFzcyBSZW1vdGVWaWRlb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLlZpZGVvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSBbXTtcbiAgICB0aGlzLm1vbml0b3JSZWNlaXZlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5nZXRSZWNlaXZlclN0YXRzKCk7XG4gICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMgJiYgdGhpcy5yZWNlaXZlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICAgIH0pO1xuICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplID0gcigoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcbiAgfVxuICBnZXQgaXNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgc2V0U3RyZWFtU3RhdGUodmFsdWUpIHtcbiAgICBzdXBlci5zZXRTdHJlYW1TdGF0ZSh2YWx1ZSk7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NldFN0cmVhbVN0YXRlJywgdmFsdWUpO1xuICAgIGlmICh0aGlzLmlzQWRhcHRpdmVTdHJlYW0gJiYgdmFsdWUgPT09IFRyYWNrLlN0cmVhbVN0YXRlLkFjdGl2ZSkge1xuICAgICAgLy8gdXBkYXRlIHZpc2liaWxpdHkgZm9yIGFkYXB0aXZlIHN0cmVhbSB0cmFja3Mgd2hlbiBzdHJlYW0gc3RhdGUgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXIgaXMgYWN0aXZlXG4gICAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byBlbnN1cmUgdGhlIHRyYWNrIGlzIHN0b3BwZWQgd2hlbiB0aGVyZSdzIG5vIGVsZW1lbnQgYXR0YWNoZWQgdG8gaXQgYXQgYWxsXG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5vdGU6IFdoZW4gdXNpbmcgYWRhcHRpdmVTdHJlYW0sIHlvdSBuZWVkIHRvIHVzZSByZW1vdGVWaWRlb1RyYWNrLmF0dGFjaCgpIHRvIGFkZCB0aGUgdHJhY2sgdG8gYSBIVE1MVmlkZW9FbGVtZW50LCBvdGhlcndpc2UgeW91ciB2aWRlbyB0cmFja3MgbWlnaHQgbmV2ZXIgc3RhcnRcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TXV0ZWQobXV0ZWQpIHtcbiAgICBzdXBlci5zZXRNdXRlZChtdXRlZCk7XG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAvLyBkZXRhY2ggb3IgYXR0YWNoXG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyBJdCdzIHBvc3NpYmxlIGF0dGFjaCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgb24gYW4gZWxlbWVudC4gV2hlbiB0aGF0J3NcbiAgICAvLyB0aGUgY2FzZSwgd2UnZCB3YW50IHRvIGF2b2lkIGFkZGluZyBkdXBsaWNhdGUgZWxlbWVudEluZm9zXG4gICAgaWYgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKGluZm8gPT4gaW5mby5lbGVtZW50ID09PSBlbGVtZW50KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlbGVtZW50SW5mbyA9IG5ldyBIVE1MRWxlbWVudEluZm8oZWxlbWVudCk7XG4gICAgICB0aGlzLm9ic2VydmVFbGVtZW50SW5mbyhlbGVtZW50SW5mbyk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBPYnNlcnZlIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzIHdoZW4gYWRhcHRpdmUgc3RyZWFtaW5nLlxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBvYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pIHtcbiAgICBpZiAodGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICYmIHRoaXMuZWxlbWVudEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvID09PSBlbGVtZW50SW5mbykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudEluZm8uaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgfTtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5wdXNoKGVsZW1lbnRJbmZvKTtcbiAgICAgIGVsZW1lbnRJbmZvLm9ic2VydmUoKTtcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IHJlc2l6ZSB1cGRhdGUgY3ljbGVcbiAgICAgIC8vIGlmIHRoZSB0YWIgaXMgYmFja2dyb3VuZGVkLCB0aGUgaW5pdGlhbCByZXNpemUgZXZlbnQgZG9lcyBub3QgZmlyZSB1bnRpbFxuICAgICAgLy8gdGhlIHRhYiBjb21lcyBpbnRvIGZvY3VzIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cud2FybigndmlzaWJpbGl0eSByZXNpemUgb2JzZXJ2ZXIgbm90IHRyaWdnZXJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdG9wIG9ic2VydmluZyBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKCF0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyBpZ25vcmVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8gPT09IGVsZW1lbnRJbmZvKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2Ygc3RvcEVsZW1lbnRJbmZvcykge1xuICAgICAgaW5mby5zdG9wT2JzZXJ2aW5nKCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKGluZm8gPT4gaW5mbyAhPT0gZWxlbWVudEluZm8pO1xuICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XG4gIH1cbiAgZGV0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZGV0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgZGV0YWNoZWRFbGVtZW50cyA9IHN1cGVyLmRldGFjaCgpO1xuICAgIGZvciAoY29uc3QgZSBvZiBkZXRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50KGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGV0YWNoZWRFbGVtZW50cztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldERlY29kZXJJbXBsZW1lbnRhdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucHJldlN0YXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjb2RlckltcGxlbWVudGF0aW9uO1xuICB9XG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xuICAgICAgbGV0IGNvZGVjSUQgPSAnJztcbiAgICAgIGxldCBjb2RlY3MgPSBuZXcgTWFwKCk7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBpZiAodi50eXBlID09PSAnaW5ib3VuZC1ydHAnKSB7XG4gICAgICAgICAgY29kZWNJRCA9IHYuY29kZWNJZDtcbiAgICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgZnJhbWVzRGVjb2RlZDogdi5mcmFtZXNEZWNvZGVkLFxuICAgICAgICAgICAgZnJhbWVzRHJvcHBlZDogdi5mcmFtZXNEcm9wcGVkLFxuICAgICAgICAgICAgZnJhbWVzUmVjZWl2ZWQ6IHYuZnJhbWVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBwYWNrZXRzUmVjZWl2ZWQ6IHYucGFja2V0c1JlY2VpdmVkLFxuICAgICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmcmFtZUhlaWdodDogdi5mcmFtZUhlaWdodCxcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgICBuYWNrQ291bnQ6IHYubmFja0NvdW50LFxuICAgICAgICAgICAgaml0dGVyOiB2LmppdHRlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBkZWNvZGVySW1wbGVtZW50YXRpb246IHYuZGVjb2RlckltcGxlbWVudGF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09ICdjb2RlYycpIHtcbiAgICAgICAgICBjb2RlY3Muc2V0KHYuaWQsIHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNlaXZlclN0YXRzICYmIGNvZGVjSUQgIT09ICcnICYmIGNvZGVjcy5nZXQoY29kZWNJRCkpIHtcbiAgICAgICAgcmVjZWl2ZXJTdGF0cy5taW1lVHlwZSA9IGNvZGVjcy5nZXQoY29kZWNJRCkubWltZVR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgICB9KTtcbiAgfVxuICBzdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGluZm8pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVmlzaWJpbGl0eShmb3JjZUVtaXQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxhc3RWaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5lbGVtZW50SW5mb3MucmVkdWNlKChwcmV2LCBpbmZvKSA9PiBNYXRoLm1heChwcmV2LCBpbmZvLnZpc2liaWxpdHlDaGFuZ2VkQXQgfHwgMCksIDApO1xuICAgIGNvbnN0IGJhY2tncm91bmRQYXVzZSA9ICgoX2IgPSAoX2EgPSB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZVZpZGVvSW5CYWNrZ3JvdW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICkgPyB0aGlzLmlzSW5CYWNrZ3JvdW5kIDogZmFsc2U7XG4gICAgY29uc3QgaXNQaVBNb2RlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZShpbmZvID0+IGluZm8ucGljdHVyZUluUGljdHVyZSk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZShpbmZvID0+IGluZm8udmlzaWJsZSkgJiYgIWJhY2tncm91bmRQYXVzZSB8fCBpc1BpUE1vZGU7XG4gICAgaWYgKHRoaXMubGFzdFZpc2libGUgPT09IGlzVmlzaWJsZSAmJiAhZm9yY2VFbWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNWaXNpYmxlICYmIERhdGUubm93KCkgLSBsYXN0VmlzaWJpbGl0eUNoYW5nZSA8IFJFQUNUSU9OX0RFTEFZKSB7XG4gICAgICAvLyBkZWxheSBoaWRkZW4gZXZlbnRzXG4gICAgICBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdFZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIGlzVmlzaWJsZSwgdGhpcyk7XG4gIH1cbiAgdXBkYXRlRGltZW5zaW9ucygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5nZXRQaXhlbERlbnNpdHkoKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGhpcy5lbGVtZW50SW5mb3MpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50V2lkdGggPSBpbmZvLndpZHRoKCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudEhlaWdodCA9IGluZm8uaGVpZ2h0KCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBpZiAoY3VycmVudEVsZW1lbnRXaWR0aCArIGN1cnJlbnRFbGVtZW50SGVpZ2h0ID4gbWF4V2lkdGggKyBtYXhIZWlnaHQpIHtcbiAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50RWxlbWVudFdpZHRoO1xuICAgICAgICBtYXhIZWlnaHQgPSBjdXJyZW50RWxlbWVudEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCgoX2EgPSB0aGlzLmxhc3REaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpID09PSBtYXhXaWR0aCAmJiAoKF9iID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgPT09IG1heEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3REaW1lbnNpb25zID0ge1xuICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcbiAgICB9O1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMubGFzdERpbWVuc2lvbnMsIHRoaXMpO1xuICB9XG4gIGdldFBpeGVsRGVuc2l0eSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gKF9hID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGl4ZWxEZW5zaXR5O1xuICAgIGlmIChwaXhlbERlbnNpdHkgPT09ICdzY3JlZW4nKSB7XG4gICAgICByZXR1cm4gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIH0gZWxzZSBpZiAoIXBpeGVsRGVuc2l0eSkge1xuICAgICAgLy8gd2hlbiB1bnNldCwgd2UnbGwgcGljayBhIHNhbmUgZGVmYXVsdCBoZXJlLlxuICAgICAgLy8gZm9yIGhpZ2hlciBwaXhlbCBkZW5zaXR5IGRldmljZXMgKG1vYmlsZSBwaG9uZXMsIGV0YyksIHdlJ2xsIHVzZSAyXG4gICAgICAvLyBvdGhlcndpc2UgaXQgZGVmYXVsdHMgdG8gMVxuICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgIGlmIChkZXZpY2VQaXhlbFJhdGlvID4gMikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxEZW5zaXR5O1xuICB9XG59XG5jbGFzcyBIVE1MRWxlbWVudEluZm8ge1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUCB8fCB0aGlzLmlzSW50ZXJzZWN0aW5nO1xuICB9XG4gIGdldCBwaWN0dXJlSW5QaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGlQO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZpc2libGUpIHtcbiAgICB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQgPSBlbnRyeSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgaXNJbnRlcnNlY3RpbmdcbiAgICAgIH0gPSBlbnRyeTtcbiAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25FbnRlclBpUCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgKF9iID0gKF9hID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpbmRvdykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xuICAgICAgKF9jID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm9uTGVhdmVQaVAgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICAgIChfYSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gdmlzaWJsZSAhPT0gbnVsbCAmJiB2aXNpYmxlICE9PSB2b2lkIDAgPyB2aXNpYmxlIDogaXNFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50KTtcbiAgICB0aGlzLmlzUGlQID0gaXNXZWIoKSAmJiBpc0VsZW1lbnRJblBpUChlbGVtZW50KTtcbiAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQXQgPSAwO1xuICB9XG4gIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIH1cbiAgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG4gIG9ic2VydmUoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLy8gbWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgY3VycmVudCB2aXNpYmxlIHN0YXRlIG9uY2Ugd2Ugc3RhcnQgdG8gb2JzZXJ2ZVxuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSBpc0VsZW1lbnRJblZpZXdwb3J0KHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5lbGVtZW50LmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMuaGFuZGxlUmVzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9IHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZDtcbiAgICBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICBnZXRSZXNpemVPYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgICAoX2EgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXInLCB0aGlzLm9uRW50ZXJQaVApO1xuICAgIChfYyA9IChfYiA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aW5kb3cpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gIH1cbiAgc3RvcE9ic2VydmluZygpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIChfYSA9IGdldEludGVyc2VjdGlvbk9ic2VydmVyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICAoX2IgPSBnZXRSZXNpemVPYnNlcnZlcigpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gICAgKF9jID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VudGVyJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICAoX2UgPSAoX2QgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qud2luZG93KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICB9XG59XG5mdW5jdGlvbiBpc0VsZW1lbnRJblBpUChlbCkge1xuICB2YXIgX2EsIF9iO1xuICAvLyBTaW1wbGUgdmlkZW8gUGlQXG4gIGlmIChkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCA9PT0gZWwpIHJldHVybiB0cnVlO1xuICAvLyBEb2N1bWVudCBQaVBcbiAgaWYgKChfYSA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aW5kb3cpIHJldHVybiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsLCAoX2IgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2luZG93KTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gZG9lcyBub3QgYWNjb3VudCBmb3Igb2NjbHVzaW9uIGJ5IG90aGVyIGVsZW1lbnRzIG9yIG9wYWNpdHkgcHJvcGVydHlcbmZ1bmN0aW9uIGlzRWxlbWVudEluVmlld3BvcnQoZWwsIHdpbikge1xuICBjb25zdCB2aWV3cG9ydFdpbmRvdyA9IHdpbiB8fCB3aW5kb3c7XG4gIGxldCB0b3AgPSBlbC5vZmZzZXRUb3A7XG4gIGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcbiAgY29uc3Qgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICBjb25zdCB7XG4gICAgaGlkZGVuXG4gIH0gPSBlbDtcbiAgY29uc3Qge1xuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB3aGlsZSAoZWwub2Zmc2V0UGFyZW50KSB7XG4gICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgdG9wICs9IGVsLm9mZnNldFRvcDtcbiAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG4gIH1cbiAgcmV0dXJuIHRvcCA8IHZpZXdwb3J0V2luZG93LnBhZ2VZT2Zmc2V0ICsgdmlld3BvcnRXaW5kb3cuaW5uZXJIZWlnaHQgJiYgbGVmdCA8IHZpZXdwb3J0V2luZG93LnBhZ2VYT2Zmc2V0ICsgdmlld3BvcnRXaW5kb3cuaW5uZXJXaWR0aCAmJiB0b3AgKyBoZWlnaHQgPiB2aWV3cG9ydFdpbmRvdy5wYWdlWU9mZnNldCAmJiBsZWZ0ICsgd2lkdGggPiB2aWV3cG9ydFdpbmRvdy5wYWdlWE9mZnNldCAmJiAhaGlkZGVuICYmIGRpc3BsYXkgIT09ICdub25lJztcbn1cblxuY2xhc3MgVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioa2luZCwgaWQsIG5hbWUsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVuY3J5cHRpb24gPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5oYW5kbGVNdXRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50Lk11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVW5tdXRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVubXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucyA9PT0gbnVsbCB8fCBsb2dnZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlB1YmxpY2F0aW9uKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IHRoaXMubG9nZ2VyQ29udGV4dENiO1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLnRyYWNrU2lkID0gaWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBuYW1lO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLmhhbmRsZU11dGVkKTtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcbiAgICB9XG4gICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgLy8gZm9yd2FyZCBldmVudHNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSk7XG4gIH1cbiAgZ2V0IGlzTXV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgfVxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgaXNFbmNyeXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cbiAgLyoqXG4gICAqIGFuIFtBdWRpb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGFuIGF1ZGlvIHRyYWNrXG4gICAqL1xuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICBpZiAoaXNBdWRpb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGFuIFtWaWRlb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGEgdmlkZW8gdHJhY2tcbiAgICovXG4gIGdldCB2aWRlb1RyYWNrKCkge1xuICAgIGlmIChpc1ZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIHRoaXMudHJhY2tTaWQgPSBpbmZvLnNpZDtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IGluZm8ubmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLnNvdXJjZUZyb21Qcm90byhpbmZvLnNvdXJjZSk7XG4gICAgdGhpcy5taW1lVHlwZSA9IGluZm8ubWltZVR5cGU7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiBpbmZvLndpZHRoID4gMCkge1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0ge1xuICAgICAgICB3aWR0aDogaW5mby53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbmZvLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2ltdWxjYXN0ZWQgPSBpbmZvLnNpbXVsY2FzdDtcbiAgICB9XG4gICAgdGhpcy5lbmNyeXB0aW9uID0gaW5mby5lbmNyeXB0aW9uO1xuICAgIHRoaXMudHJhY2tJbmZvID0gaW5mbztcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRlIHB1YmxpY2F0aW9uIGluZm8nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGluZm9cbiAgICB9KSk7XG4gIH1cbn1cbihmdW5jdGlvbiAoVHJhY2tQdWJsaWNhdGlvbikge1xuICAoZnVuY3Rpb24gKFN1YnNjcmlwdGlvblN0YXR1cykge1xuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIkRlc2lyZWRcIl0gPSBcImRlc2lyZWRcIjtcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdHVzW1wiVW5zdWJzY3JpYmVkXCJdID0gXCJ1bnN1YnNjcmliZWRcIjtcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMgfHwgKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzID0ge30pKTtcbiAgKGZ1bmN0aW9uIChQZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgUGVybWlzc2lvblN0YXR1c1tcIkFsbG93ZWRcIl0gPSBcImFsbG93ZWRcIjtcbiAgICBQZXJtaXNzaW9uU3RhdHVzW1wiTm90QWxsb3dlZFwiXSA9IFwibm90X2FsbG93ZWRcIjtcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMgPSB7fSkpO1xufSkoVHJhY2tQdWJsaWNhdGlvbiB8fCAoVHJhY2tQdWJsaWNhdGlvbiA9IHt9KSk7XG5cbmNsYXNzIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xuICBnZXQgaXNVcHN0cmVhbVBhdXNlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG4gIGNvbnN0cnVjdG9yKGtpbmQsIHRpLCB0cmFjaywgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy50cmFjayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhhbmRsZVRyYWNrRW5kZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNwdUNvbnN0cmFpbmVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudHJhY2sgJiYgaXNWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkNwdUNvbnN0cmFpbmVkLCB0aGlzLnRyYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gICAgdGhpcy5zZXRUcmFjayh0cmFjayk7XG4gIH1cbiAgc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuQ3B1Q29uc3RyYWluZWQsIHRoaXMuaGFuZGxlQ3B1Q29uc3RyYWluZWQpO1xuICAgIH1cbiAgICBzdXBlci5zZXRUcmFjayh0cmFjayk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5DcHVDb25zdHJhaW5lZCwgdGhpcy5oYW5kbGVDcHVDb25zdHJhaW5lZCk7XG4gICAgfVxuICB9XG4gIGdldCBpc011dGVkKCkge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjay5pc011dGVkO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNNdXRlZDtcbiAgfVxuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICByZXR1cm4gc3VwZXIuYXVkaW9UcmFjaztcbiAgfVxuICBnZXQgdmlkZW9UcmFjaygpIHtcbiAgICByZXR1cm4gc3VwZXIudmlkZW9UcmFjaztcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogTXV0ZSB0aGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cbiAgICovXG4gIG11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubXV0ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVbm11dGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cbiAgICovXG4gIHVubXV0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm11dGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF1c2VzIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gZnJvbSBiZWluZyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHNpZ25hbHMgXCJtdXRlZFwiIGV2ZW50IHRvIG90aGVyIHBhcnRpY2lwYW50c1xuICAgKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gcGF1c2UgdGhlIHN0cmVhbSB3aXRob3V0IHBhdXNpbmcgdGhlIGxvY2FsIG1lZGlhIHN0cmVhbSB0cmFja1xuICAgKi9cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgeWllbGQgKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlVXBzdHJlYW0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyBzZW5kaW5nIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gdG8gdGhlIHNlcnZlciBhZnRlciBhIGNhbGwgdG8gW1twYXVzZVVwc3RyZWFtKCldXVxuICAgKiBhbmQgc2lnbmFscyBcInVubXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHMgKHVubGVzcyB0aGUgdHJhY2sgaXMgZXhwbGljaXRseSBtdXRlZClcbiAgICovXG4gIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdW1lVXBzdHJlYW0oKTtcbiAgICB9KTtcbiAgfVxuICBnZXRUcmFja0ZlYXR1cmVzKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaXNBdWRpb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMudHJhY2suZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpO1xuICAgICAgY29uc3QgZmVhdHVyZXMgPSBuZXcgU2V0KCk7XG4gICAgICBpZiAoc2V0dGluZ3MuYXV0b0dhaW5Db250cm9sKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9BVVRPX0dBSU5fQ09OVFJPTCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuZWNob0NhbmNlbGxhdGlvbikge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfRUNIT19DQU5DRUxMQVRJT04pO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLm5vaXNlU3VwcHJlc3Npb24pIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PSVNFX1NVUFBSRVNTSU9OKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy5jaGFubmVsQ291bnQgJiYgc2V0dGluZ3MuY2hhbm5lbENvdW50ID4gMSkge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfU1RFUkVPKTtcbiAgICAgIH1cbiAgICAgIGlmICghKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmR0eCkpIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PX0RUWCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50cmFjay5lbmhhbmNlZE5vaXNlQ2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT04pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZmVhdHVyZXMudmFsdWVzKCkpO1xuICAgIH0gZWxzZSByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbG9jYWwgdmlkZW8gYW5kIGF1ZGlvIHRyYWNrIGF0IHRoZSBzYW1lIHRpbWUuIFdoZW4gYWNxdWlyaW5nIGJvdGhcbiAqIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3MgdG9nZXRoZXIsIGl0J2xsIGRpc3BsYXkgYSBzaW5nbGUgcGVybWlzc2lvbiBwcm9tcHQgdG9cbiAqIHRoZSB1c2VyIGluc3RlYWQgb2YgdHdvIHNlcGFyYXRlIG9uZXMuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFRyYWNrcyhvcHRpb25zLCBsb2dnZXJPcHRpb25zKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogb3B0aW9ucyA9IHt9O1xuICAgIGxldCBhdHRlbXB0RXhhY3RNYXRjaCA9IGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvUHJvY2Vzc29yLFxuICAgICAgdmlkZW9Qcm9jZXNzb3IsXG4gICAgICBvcHRpb25zV2l0aG91dFByb2Nlc3NvcjogaW50ZXJuYWxPcHRpb25zXG4gICAgfSA9IGV4dHJhY3RQcm9jZXNzb3JzRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgbGV0IHJldHJ5QXVkaW9PcHRpb25zID0gaW50ZXJuYWxPcHRpb25zLmF1ZGlvO1xuICAgIGxldCByZXRyeVZpZGVvT3B0aW9ucyA9IGludGVybmFsT3B0aW9ucy52aWRlbztcbiAgICBpZiAoYXVkaW9Qcm9jZXNzb3IgJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGludGVybmFsT3B0aW9ucy5hdWRpby5wcm9jZXNzb3IgPSBhdWRpb1Byb2Nlc3NvcjtcbiAgICB9XG4gICAgaWYgKHZpZGVvUHJvY2Vzc29yICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8ucHJvY2Vzc29yID0gdmlkZW9Qcm9jZXNzb3I7XG4gICAgfVxuICAgIC8vIGlmIHRoZSB1c2VyIHBhc3NlcyBhIGRldmljZSBpZCBhcyBhIHN0cmluZywgd2UgZGVmYXVsdCB0byBleGFjdCBtYXRjaFxuICAgIGlmIChvcHRpb25zLmF1ZGlvICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkZXZpY2VJZCA9IGludGVybmFsT3B0aW9ucy5hdWRpby5kZXZpY2VJZDtcbiAgICAgIGludGVybmFsT3B0aW9ucy5hdWRpby5kZXZpY2VJZCA9IHtcbiAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICB9O1xuICAgICAgYXR0ZW1wdEV4YWN0TWF0Y2ggPSB0cnVlO1xuICAgICAgcmV0cnlBdWRpb09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGVybmFsT3B0aW9ucy5hdWRpbyksIHtcbiAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICBpZGVhbDogZGV2aWNlSWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMudmlkZW8gJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGRldmljZUlkID0gaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkO1xuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkID0ge1xuICAgICAgICBleGFjdDogZGV2aWNlSWRcbiAgICAgIH07XG4gICAgICBhdHRlbXB0RXhhY3RNYXRjaCA9IHRydWU7XG4gICAgICByZXRyeVZpZGVvT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxPcHRpb25zLnZpZGVvKSwge1xuICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgIGlkZWFsOiBkZXZpY2VJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gdHJ1ZSkge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID0ge1xuICAgICAgICBkZXZpY2VJZDogJ2RlZmF1bHQnXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgaW50ZXJuYWxPcHRpb25zLmF1ZGlvICE9PSBudWxsKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGVybmFsT3B0aW9ucy5hdWRpbyksIHtcbiAgICAgICAgZGV2aWNlSWQ6IGludGVybmFsT3B0aW9ucy5hdWRpby5kZXZpY2VJZCB8fCAnZGVmYXVsdCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPSB7XG4gICAgICAgIGRldmljZUlkOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0JyAmJiAhaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQgPSAnZGVmYXVsdCc7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBtZXJnZURlZmF1bHRPcHRpb25zKGludGVybmFsT3B0aW9ucywgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cyk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJvbWlzZSBvbiBEZXZpY2VNYW5hZ2VyIGFuZCBhd2FpdCBpdCBpbiBnZXRMb2NhbERldmljZXMoKVxuICAgIC8vIHdvcmtzIGFyb3VuZCBpT1MgU2FmYXJpIEJ1ZyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc5MzYzXG4gICAgY29uc3QgbWVkaWFQcm9taXNlID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMuYXVkaW8pIHtcbiAgICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ2F1ZGlvaW5wdXQnKSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMudmlkZW8pIHtcbiAgICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ3ZpZGVvaW5wdXQnKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBtZWRpYVByb21pc2U7XG4gICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwoc3RyZWFtLmdldFRyYWNrcygpLm1hcChtZWRpYVN0cmVhbVRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgaXNBdWRpbyA9IG1lZGlhU3RyZWFtVHJhY2sua2luZCA9PT0gJ2F1ZGlvJztcbiAgICAgICAgbGV0IHRyYWNrT3B0aW9ucyA9IGlzQXVkaW8gPyBvcHRzLmF1ZGlvIDogb3B0cy52aWRlbztcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja09wdGlvbnMgPT09ICdib29sZWFuJyB8fCAhdHJhY2tPcHRpb25zKSB7XG4gICAgICAgICAgdHJhY2tPcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYWNrQ29uc3RyYWludHM7XG4gICAgICAgIGNvbnN0IGNvbk9yQm9vbCA9IGlzQXVkaW8gPyBjb25zdHJhaW50cy5hdWRpbyA6IGNvbnN0cmFpbnRzLnZpZGVvO1xuICAgICAgICBpZiAodHlwZW9mIGNvbk9yQm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIGNvbnN0cmFpbnRzIHdpdGggdGhlIGRldmljZSBpZCB0aGUgdXNlciBnYXZlIHBlcm1pc3Npb25zIHRvIGluIHRoZSBwZXJtaXNzaW9uIHByb21wdFxuICAgICAgICAvLyBvdGhlcndpc2UgZWFjaCB0cmFjayByZXN0YXJ0IChlLmcuIG11dGUgLSB1bm11dGUpIHdpbGwgdHJ5IHRvIGluaXRpYWxpemUgdGhlIGRldmljZSBhZ2FpbiAtPiBjYXVzaW5nIGFkZGl0aW9uYWwgcGVybWlzc2lvbiBwcm9tcHRzXG4gICAgICAgIGNvbnN0IG5ld0RldmljZUlkID0gbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgICAgICBpZiAoKHRyYWNrQ29uc3RyYWludHMgPT09IG51bGwgfHwgdHJhY2tDb25zdHJhaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCkgJiYgdW53cmFwQ29uc3RyYWludCh0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkKSAhPT0gbmV3RGV2aWNlSWQpIHtcbiAgICAgICAgICB0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkID0gbmV3RGV2aWNlSWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRyYWNrQ29uc3RyYWludHMpIHtcbiAgICAgICAgICB0cmFja0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgZGV2aWNlSWQ6IG5ld0RldmljZUlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFjayA9IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgdHJhY2tDb25zdHJhaW50cywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2subWVkaWFTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGlmIChpc0F1ZGlvVHJhY2sodHJhY2spICYmIGF1ZGlvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdHJhY2suc2V0UHJvY2Vzc29yKGF1ZGlvUHJvY2Vzc29yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spICYmIHZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdHJhY2suc2V0UHJvY2Vzc29yKHZpZGVvUHJvY2Vzc29yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9KSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghYXR0ZW1wdEV4YWN0TWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVMb2NhbFRyYWNrcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIGF1ZGlvOiByZXRyeUF1ZGlvT3B0aW9ucyxcbiAgICAgICAgdmlkZW86IHJldHJ5VmlkZW9PcHRpb25zXG4gICAgICB9KSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFtbTG9jYWxWaWRlb1RyYWNrXV0gd2l0aCBnZXRVc2VyTWVkaWEoKVxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxWaWRlb1RyYWNrKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgICBhdWRpbzogZmFsc2UsXG4gICAgICB2aWRlbzogb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cmFja3NbMF07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9jYWxBdWRpb1RyYWNrKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgICBhdWRpbzogb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogdHJ1ZSxcbiAgICAgIHZpZGVvOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0cmFja3NbMF07XG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCAmJiAhaXNTYWZhcmkxN0Jhc2VkKCkpIHtcbiAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XG4gICAgfVxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcignZ2V0RGlzcGxheU1lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCdubyB2aWRlbyB0cmFjayBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICBzY3JlZW5WaWRlby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSBbc2NyZWVuVmlkZW9dO1xuICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY3JlZW5BdWRpbyA9IG5ldyBMb2NhbEF1ZGlvVHJhY2soc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICBsb2NhbFRyYWNrcy5wdXNoKHNjcmVlbkF1ZGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xuICB9KTtcbn1cblxudmFyIENvbm5lY3Rpb25RdWFsaXR5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uUXVhbGl0eSkge1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIkV4Y2VsbGVudFwiXSA9IFwiZXhjZWxsZW50XCI7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiR29vZFwiXSA9IFwiZ29vZFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIlBvb3JcIl0gPSBcInBvb3JcIjtcbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IGEgcGFydGljaXBhbnQgaGFzIHRlbXBvcmFyaWx5IChvciBwZXJtYW5lbnRseSkgbG9zdCBjb25uZWN0aW9uIHRvIExpdmVLaXQuXG4gICAqIEZvciBwZXJtYW5lbnQgZGlzY29ubmVjdGlvbiBhIGBQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIGFmdGVyIGEgdGltZW91dFxuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJMb3N0XCJdID0gXCJsb3N0XCI7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xufSkoQ29ubmVjdGlvblF1YWxpdHkgfHwgKENvbm5lY3Rpb25RdWFsaXR5ID0ge30pKTtcbmZ1bmN0aW9uIHF1YWxpdHlGcm9tUHJvdG8ocSkge1xuICBzd2l0Y2ggKHEpIHtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuRVhDRUxMRU5UOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LkV4Y2VsbGVudDtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuR09PRDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Hb29kO1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5QT09SOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlBvb3I7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkxPU1Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuTG9zdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG4gIH1cbn1cbmNsYXNzIFBhcnRpY2lwYW50IGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gIH1cbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrUHVibGljYXRpb25zLnNpemUgPiAwICYmIEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZXZlcnkodHIgPT4gdHIuaXNFbmNyeXB0ZWQpO1xuICB9XG4gIGdldCBpc0FnZW50KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2VudCkgfHwgdGhpcy5raW5kID09PSBQYXJ0aWNpcGFudEluZm9fS2luZC5BR0VOVDtcbiAgfVxuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5wYXJ0aWNpcGFudEluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgPT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkU7XG4gIH1cbiAgZ2V0IGtpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tpbmQ7XG4gIH1cbiAgLyoqIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMsIHNpbWlsYXIgdG8gbWV0YWRhdGEsIGJ1dCBhcyBhIGtleS92YWx1ZSBtYXAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYXR0cmlidXRlcykpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3Ioc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogUGFydGljaXBhbnRJbmZvX0tpbmQuU1RBTkRBUkQ7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIGF1ZGlvIGxldmVsIGJldHdlZW4gMC0xLjAsIDEgYmVpbmcgbG91ZGVzdCwgMCBiZWluZyBzb2Z0ZXN0ICovXG4gICAgdGhpcy5hdWRpb0xldmVsID0gMDtcbiAgICAvKiogaWYgcGFydGljaXBhbnQgaXMgY3VycmVudGx5IHNwZWFraW5nICovXG4gICAgdGhpcy5pc1NwZWFraW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zID09PSBudWxsIHx8IGxvZ2dlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUGFydGljaXBhbnQpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2tpbmQgPSBraW5kO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzICE9PSBudWxsICYmIGF0dHJpYnV0ZXMgIT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgc291cmNlIGZpbHRlciwgZm9yIGV4YW1wbGUsIGdldHRpbmdcbiAgICogdGhlIHVzZXIncyBjYW1lcmEgdHJhY2sgd2l0aCBnZXRUcmFja0J5U291cmNlKFRyYWNrLlNvdXJjZS5DYW1lcmEpLlxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja1B1YmxpY2F0aW9ucykge1xuICAgICAgaWYgKHB1Yi5zb3VyY2UgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgdHJhY2sncyBuYW1lLlxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMpIHtcbiAgICAgIGlmIChwdWIudHJhY2tOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCB0aGUgcGFydGljaXBhbnQgaXMgYWN0aXZlIGFuZCByZWFkeSB0byByZWNlaXZlIGRhdGEgbWVzc2FnZXNcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcGFydGljaXBhbnQgaXMgYWN0aXZlXG4gICAqL1xuICB3YWl0VW50aWxBY3RpdmUoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWN0aXZlRnV0dXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVGdXR1cmUucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgdGhpcy5vbmNlKFBhcnRpY2lwYW50RXZlbnQuQWN0aXZlLCAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5hY3RpdmVGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvbHZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICB0aGlzLmFjdGl2ZUZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGdXR1cmUucHJvbWlzZTtcbiAgfVxuICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xuICB9XG4gIGdldCBpc0NhbWVyYUVuYWJsZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNNaWNyb3Bob25lRW5hYmxlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNTY3JlZW5TaGFyZUVuYWJsZWQoKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLlNjcmVlblNoYXJlKTtcbiAgICByZXR1cm4gISF0cmFjaztcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqIHdoZW4gcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tICovXG4gIGdldCBqb2luZWRBdCgpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIucGFyc2VJbnQodGhpcy5wYXJ0aWNpcGFudEluZm8uam9pbmVkQXQudG9TdHJpbmcoKSkgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgdXBkYXRlIGNvdWxkIGJlIGFwcGxpZWQgb3V0IG9mIG9yZGVyIGR1ZSB0byBhd2FpdFxuICAgIC8vIGR1cmluZyByZWNvbm5lY3Qgc2VxdWVuY2VzLiB3aGVuIHRoYXQgaGFwcGVucywgaXQncyBwb3NzaWJsZSBmb3Igc2VydmVyXG4gICAgLy8gdG8gaGF2ZSBzZW50IG1vcmUgcmVjZW50IHZlcnNpb24gb2YgcGFydGljaXBhbnQgaW5mbyB3aGlsZSBKUyBpcyB3YWl0aW5nXG4gICAgLy8gdG8gcHJvY2VzcyB0aGUgZXhpc3RpbmcgcGF5bG9hZC5cbiAgICAvLyB3aGVuIHRoZSBwYXJ0aWNpcGFudCBzaWQgcmVtYWlucyB0aGUgc2FtZSwgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIGxhdGVyIHZlcnNpb25cbiAgICAvLyBvZiB0aGUgcGF5bG9hZCwgdGhleSBjYW4gYmUgc2FmZWx5IHNraXBwZWRcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8gJiYgdGhpcy5wYXJ0aWNpcGFudEluZm8uc2lkID09PSBpbmZvLnNpZCAmJiB0aGlzLnBhcnRpY2lwYW50SW5mby52ZXJzaW9uID4gaW5mby52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaWRlbnRpdHkgPSBpbmZvLmlkZW50aXR5O1xuICAgIHRoaXMuc2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy5fc2V0TmFtZShpbmZvLm5hbWUpO1xuICAgIHRoaXMuX3NldE1ldGFkYXRhKGluZm8ubWV0YWRhdGEpO1xuICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoaW5mby5hdHRyaWJ1dGVzKTtcbiAgICBpZiAoaW5mby5zdGF0ZSA9PT0gUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSAmJiAoKF9hID0gdGhpcy5wYXJ0aWNpcGFudEluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkUpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkFjdGl2ZSk7XG4gICAgfVxuICAgIGlmIChpbmZvLnBlcm1pc3Npb24pIHtcbiAgICAgIHRoaXMuc2V0UGVybWlzc2lvbnMoaW5mby5wZXJtaXNzaW9uKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoaXMgbGFzdCBzbyBzZXRNZXRhZGF0YSBjYW4gZGV0ZWN0IGNoYW5nZXNcbiAgICB0aGlzLnBhcnRpY2lwYW50SW5mbyA9IGluZm87XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcbiAgICoqL1xuICBfc2V0TWV0YWRhdGEobWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5tZXRhZGF0YSAhPT0gbWQ7XG4gICAgY29uc3QgcHJldk1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBwcmV2TWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuICBfc2V0TmFtZShuYW1lKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMubmFtZSAhPT0gbmFtZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcbiAgICoqL1xuICBfc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgZGlmZiA9IGRpZmZBdHRyaWJ1dGVzKHRoaXMuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgaWYgKE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBkaWZmKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHBlcm1pc3Npb25zLmNhblB1Ymxpc2ggIT09ICgoX2EgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUHVibGlzaCkgfHwgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlICE9PSAoKF9iID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhblN1YnNjcmliZSkgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaERhdGEgIT09ICgoX2MgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FuUHVibGlzaERhdGEpIHx8IHBlcm1pc3Npb25zLmhpZGRlbiAhPT0gKChfZCA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oaWRkZW4pIHx8IHBlcm1pc3Npb25zLnJlY29yZGVyICE9PSAoKF9lID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlY29yZGVyKSB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5sZW5ndGggIT09IHRoaXMucGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSk7XG4gICAgfSkgfHwgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlTWV0cmljcyAhPT0gKChfZiA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYW5TdWJzY3JpYmVNZXRyaWNzKTtcbiAgICB0aGlzLnBlcm1pc3Npb25zID0gcGVybWlzc2lvbnM7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldElzU3BlYWtpbmcoc3BlYWtpbmcpIHtcbiAgICBpZiAoc3BlYWtpbmcgPT09IHRoaXMuaXNTcGVha2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU3BlYWtpbmcgPSBzcGVha2luZztcbiAgICBpZiAoc3BlYWtpbmcpIHtcbiAgICAgIHRoaXMubGFzdFNwb2tlQXQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Jc1NwZWFraW5nQ2hhbmdlZCwgc3BlYWtpbmcpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0Q29ubmVjdGlvblF1YWxpdHkocSkge1xuICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBxdWFsaXR5RnJvbVByb3RvKHEpO1xuICAgIGlmIChwcmV2UXVhbGl0eSAhPT0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXREaXNjb25uZWN0ZWQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodGhpcy5hY3RpdmVGdXR1cmUpIHtcbiAgICAgIChfYiA9IChfYSA9IHRoaXMuYWN0aXZlRnV0dXJlKS5yZWplY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXcgRXJyb3IoJ1BhcnRpY2lwYW50IGRpc2Nvbm5lY3RlZCcpKTtcbiAgICAgIHRoaXMuYWN0aXZlRnV0dXJlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoY3R4KSB7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBjdHg7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2godHJhY2sgPT4gaXNBdWRpb1RyYWNrKHRyYWNrLnRyYWNrKSAmJiB0cmFjay50cmFjay5zZXRBdWRpb0NvbnRleHQoY3R4KSk7XG4gIH1cbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xuICAgIC8vIGZvcndhcmQgcHVibGljYXRpb24gZHJpdmVuIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuTXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVubXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHB1YiA9IHB1YmxpY2F0aW9uO1xuICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgIHB1Yi50cmFjay5zaWQgPSBwdWJsaWNhdGlvbi50cmFja1NpZDtcbiAgICB9XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwZXJtcykge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgaWYgKCFwZXJtcy5wYXJ0aWNpcGFudFNpZCAmJiAhcGVybXMucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFjayBwZXJtaXNzaW9uLCBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIG9mIHBhcnRpY2lwYW50SWRlbnRpdHkgYW5kIHBhcnRpY2lwYW50U2lkJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oe1xuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IChfYSA9IHBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgIHBhcnRpY2lwYW50U2lkOiAoX2IgPSBwZXJtcy5wYXJ0aWNpcGFudFNpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgYWxsVHJhY2tzOiAoX2MgPSBwZXJtcy5hbGxvd0FsbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UsXG4gICAgdHJhY2tTaWRzOiBwZXJtcy5hbGxvd2VkVHJhY2tTaWRzIHx8IFtdXG4gIH0pO1xufVxuXG5jbGFzcyBMb2NhbFBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHNpZCwgaWRlbnRpdHksIGVuZ2luZSwgb3B0aW9ucywgcm9vbVJwY0hhbmRsZXJzLCByb29tT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlcikge1xuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5lbmdpbmUubG9nQ29udGV4dFxuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gW107XG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSB0cnVlO1xuICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICB0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdBY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhbmRsZVJlY29ubmVjdGluZyA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5yZWNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVJlY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIChfYiA9IChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ2xvc2luZyA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgaWYgKHRoaXMucmVjb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlLnByb21pc2UuY2F0Y2goZSA9PiB0aGlzLmxvZy53YXJuKGUubWVzc2FnZSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVqZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbmV3IEVycm9yKCdHb3QgZGlzY29ubmVjdGVkIGR1cmluZyByZWNvbm5lY3Rpb24gYXR0ZW1wdCcpKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUpIHtcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUpLnJlamVjdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIG5ldyBFcnJvcignR290IGRpc2Nvbm5lY3RlZCB3aXRob3V0IHNpZ25hbCBjb25uZWN0ZWQnKSk7XG4gICAgICAgIHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgKF9mID0gKF9lID0gdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlamVjdCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UsIG5ldyBFcnJvcignR290IGRpc2Nvbm5lY3RlZCB3aXRob3V0IGFjdGl2ZSBhZ2VudCBwcmVzZW50JykpO1xuICAgICAgdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZmlyc3RBY3RpdmVBZ2VudCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU2lnbmFsQ29ubmVjdGVkID0gam9pblJlc3BvbnNlID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAoam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlSW5mbyhqb2luUmVzcG9uc2UucGFydGljaXBhbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSkge1xuICAgICAgICB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICAgIH1cbiAgICAgIChfYiA9IChfYSA9IHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKS5yZXNvbHZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVNpZ25hbFJlcXVlc3RSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWFzb24sXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3QgPSB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgIGlmICh0YXJnZXRSZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZWFzb24gIT09IFJlcXVlc3RSZXNwb25zZV9SZWFzb24uT0spIHtcbiAgICAgICAgICB0YXJnZXRSZXF1ZXN0LnJlamVjdChuZXcgU2lnbmFsUmVxdWVzdEVycm9yKG1lc3NhZ2UsIHJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEYXRhUGFja2V0ID0gcGFja2V0ID0+IHtcbiAgICAgIHN3aXRjaCAocGFja2V0LnZhbHVlLmNhc2UpIHtcbiAgICAgICAgY2FzZSAncnBjUmVzcG9uc2UnOlxuICAgICAgICAgIGxldCBycGNSZXNwb25zZSA9IHBhY2tldC52YWx1ZS52YWx1ZTtcbiAgICAgICAgICBsZXQgcGF5bG9hZCA9IG51bGw7XG4gICAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgICBpZiAocnBjUmVzcG9uc2UudmFsdWUuY2FzZSA9PT0gJ3BheWxvYWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcnBjUmVzcG9uc2UudmFsdWUudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChycGNSZXNwb25zZS52YWx1ZS5jYXNlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBlcnJvciA9IFJwY0Vycm9yLmZyb21Qcm90byhycGNSZXNwb25zZS52YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdScGNSZXNwb25zZShycGNSZXNwb25zZS5yZXF1ZXN0SWQsIHBheWxvYWQsIGVycm9yKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnBjQWNrJzpcbiAgICAgICAgICBsZXQgcnBjQWNrID0gcGFja2V0LnZhbHVlLnZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdScGNBY2socnBjQWNrLnJlcXVlc3RJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgdHJhY2sgc3Vic2NyaXB0aW9uIHBlcm1pc3Npb25zJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ6IHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLFxuICAgICAgICBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM6IHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXG4gICAgICB9KSk7XG4gICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLCB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucy5tYXAocCA9PiB0cmFja1Blcm1pc3Npb25Ub1Byb3RvKHApKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5vblRyYWNrVW5tdXRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc1Vwc3RyZWFtUGF1c2VkKTtcbiAgICB9O1xuICAgIC8vIHdoZW4gdGhlIGxvY2FsIHRyYWNrIGNoYW5nZXMgaW4gbXV0ZSBzdGF0dXMsIHdlJ2xsIG5vdGlmeSBzZXJ2ZXIgYXMgc3VjaFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLm9uVHJhY2tNdXRlZCA9ICh0cmFjaywgbXV0ZWQpID0+IHtcbiAgICAgIGlmIChtdXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suc2lkKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgdXBkYXRlIG11dGUgc3RhdHVzIGZvciB1bnB1Ymxpc2hlZCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmdpbmUudXBkYXRlTXV0ZVN0YXR1cyh0cmFjay5zaWQsIG11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkID0gdHJhY2sgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vwc3RyZWFtIHBhdXNlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSByZXN1bWVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRyYWNrLmlzTXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5vblRyYWNrRmVhdHVyZVVwZGF0ZSA9IHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5nZXQodHJhY2suc2lkKTtcbiAgICAgIGlmICghcHViKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3QgdXBkYXRlIGxvY2FsIGF1ZGlvIHRyYWNrIHNldHRpbmdzLCBtaXNzaW5nIHB1YmxpY2F0aW9uIGZvciB0cmFjayBcIi5jb25jYXQodHJhY2suc2lkKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrU2lkLCBwdWIuZ2V0VHJhY2tGZWF0dXJlcygpKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja0NwdUNvbnN0cmFpbmVkID0gKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3RyYWNrIGNwdSBjb25zdHJhaW5lZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tDcHVDb25zdHJhaW5lZCwgdHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgIHZhciBfZDtcbiAgICAgIGlmICghKChfZCA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5keW5hY2FzdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmdldCh1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgc3Vic2NyaWJlZCBxdWFsaXR5IHVwZGF0ZSBmb3IgdW5rbm93biB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHRyYWNrU2lkOiB1cGRhdGUudHJhY2tTaWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXB1Yi52aWRlb1RyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IHlpZWxkIHB1Yi52aWRlb1RyYWNrLnNldFB1Ymxpc2hpbmdDb2RlY3ModXBkYXRlLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBuZXdDb2RlY3NfMSA9IF9fYXN5bmNWYWx1ZXMobmV3Q29kZWNzKSwgbmV3Q29kZWNzXzFfMTsgbmV3Q29kZWNzXzFfMSA9IHlpZWxkIG5ld0NvZGVjc18xLm5leHQoKSwgX2EgPSBuZXdDb2RlY3NfMV8xLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBuZXdDb2RlY3NfMV8xLnZhbHVlO1xuICAgICAgICAgIF9lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgY29kZWMgPSBfYztcbiAgICAgICAgICBpZiAoaXNCYWNrdXBDb2RlYyhjb2RlYykpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaCBcIi5jb25jYXQoY29kZWMsIFwiIGZvciBcIikuY29uY2F0KHB1Yi52aWRlb1RyYWNrLnNpZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpKSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayhwdWIudmlkZW9UcmFjaywgY29kZWMsIHB1Yi5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gbmV3Q29kZWNzXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChuZXdDb2RlY3NfMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSB1bnB1Ymxpc2hlZCA9PiB7XG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHVucHVibGlzaGVkLnRyYWNrU2lkKTtcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgdW5wdWJsaXNoZWQgZXZlbnQgZm9yIHVua25vd24gdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICB0cmFja1NpZDogdW5wdWJsaXNoZWQudHJhY2tTaWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCA9IHRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSB8fCB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgbG9jYWwgdHJhY2sgZHVlIHRvIFRyYWNrRW5kZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25zID0geWllbGQgbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGVybWlzc2lvbiBxdWVyeSBmb3IgY2FtZXJhIGFuZCBtaWNyb3Bob25lIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBuYW1lOiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgPyAnY2FtZXJhJyA6ICdtaWNyb3Bob25lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucyAmJiBjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybihcInVzZXIgaGFzIHJldm9rZWQgYWNjZXNzIHRvIFwiLmNvbmNhdCh0cmFjay5zb3VyY2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGdyYW50ZWQgY2hhbmdlIGFmdGVyIHBlcm1pc3Npb25zIHdlcmUgZGVuaWVkIHRvIHRyeSBhbmQgcmVzdW1lIHRoZW5cbiAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zLnN0YXRlICE9PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRVc2VyTWVkaWEgUGVybWlzc2lvbiBkZW5pZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBwZXJtaXNzaW9ucyBxdWVyeSBmYWlscyBmb3IgZmlyZWZveCwgd2UgY29udGludWUgYW5kIHRyeSB0byByZXN0YXJ0IHRoZSB0cmFja1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd0cmFjayBlbmRlZCwgYXR0ZW1wdGluZyB0byB1c2UgYSBkaWZmZXJlbnQgZGV2aWNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCBkZXZpY2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgIHlpZWxkIHRyYWNrLnJlc3RhcnRUcmFjayh7XG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6ICdkZWZhdWx0J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlpZWxkIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJjb3VsZCBub3QgcmVzdGFydCB0cmFjaywgbXV0aW5nIGluc3RlYWRcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLnJvb21PcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNldHVwRW5naW5lKGVuZ2luZSk7XG4gICAgdGhpcy5hY3RpdmVEZXZpY2VNYXAgPSBuZXcgTWFwKFtbJ2F1ZGlvaW5wdXQnLCAnZGVmYXVsdCddLCBbJ3ZpZGVvaW5wdXQnLCAnZGVmYXVsdCddLCBbJ2F1ZGlvb3V0cHV0JywgJ2RlZmF1bHQnXV0pO1xuICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucnBjSGFuZGxlcnMgPSByb29tUnBjSGFuZGxlcnM7XG4gICAgdGhpcy5yb29tT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlciA9IHJvb21PdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyO1xuICB9XG4gIGdldCBsYXN0Q2FtZXJhRXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhRXJyb3I7XG4gIH1cbiAgZ2V0IGxhc3RNaWNyb3Bob25lRXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMubWljcm9waG9uZUVycm9yO1xuICB9XG4gIGdldCBpc0UyRUVFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb25UeXBlICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSkge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwRW5naW5lKGVuZ2luZSkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCAodHJhY2tTaWQsIG11dGVkKSA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldCh0cmFja1NpZCk7XG4gICAgICBpZiAoIXB1YiB8fCAhcHViLnRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtdXRlZCkge1xuICAgICAgICBwdWIubXV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHViLnVubXV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgoX2EgPSB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUmVzb2x2ZWQpIHtcbiAgICAgIHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5Db25uZWN0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgdGhpcy5oYW5kbGVTaWduYWxDb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuUmVzdGFydGluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZykub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLmhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LkNsb3NpbmcsIHRoaXMuaGFuZGxlQ2xvc2luZykub24oRW5naW5lRXZlbnQuU2lnbmFsUmVxdWVzdFJlc3BvbnNlLCB0aGlzLmhhbmRsZVNpZ25hbFJlcXVlc3RSZXNwb25zZSkub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxuICAgKiBtZXRob2Qgd2lsbCB0aHJvdyBpZiB0aGUgdXNlciBkb2Vzbid0IGhhdmUgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgc2V0TWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xuICAgICAgICBtZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW5kIHVwZGF0ZXMgdGhlIG5hbWUgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIHNldE5hbWUobmFtZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLnJlcXVlc3RNZXRhZGF0YVVwZGF0ZSh7XG4gICAgICAgIG5hbWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb3IgdXBkYXRlIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMuIEl0IHdpbGwgbWFrZSB1cGRhdGVzIG9ubHkgdG8ga2V5cyB0aGF0XG4gICAqIGFyZSBwcmVzZW50IGluIGBhdHRyaWJ1dGVzYCwgYW5kIHdpbGwgbm90IG92ZXJyaWRlIG90aGVycy5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgdG8gdXBkYXRlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0TWV0YWRhdGFVcGRhdGUoX2EpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCB7XG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBuYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgaXNSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0geWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKChfYSA9IG1ldGFkYXRhICE9PSBudWxsICYmIG1ldGFkYXRhICE9PSB2b2lkIDAgPyBtZXRhZGF0YSA6IHRoaXMubWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCAoX2IgPSBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiB0aGlzLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwge1xuICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICByZWplY3Q6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3aGlsZSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUgPCA1MDAwICYmICFpc1JlamVjdGVkKSB7XG4gICAgICAgICAgICAgIGlmICgoIW5hbWUgfHwgdGhpcy5uYW1lID09PSBuYW1lKSAmJiAoIW1ldGFkYXRhIHx8IHRoaXMubWV0YWRhdGEgPT09IG1ldGFkYXRhKSAmJiAoIWF0dHJpYnV0ZXMgfHwgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZXZlcnkoX3JlZjIgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2tleV0gPT09IHZhbHVlIHx8IHZhbHVlID09PSAnJyAmJiAhdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KG5ldyBTaWduYWxSZXF1ZXN0RXJyb3IoJ1JlcXVlc3QgdG8gdXBkYXRlIGxvY2FsIG1ldGFkYXRhIHRpbWVkIG91dCcsICdUaW1lb3V0RXJyb3InKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhIHBhcnRpY2lwYW50J3MgY2FtZXJhIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRDYW1lcmFFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5DYW1lcmEsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIG1pY3JvcGhvbmUgdHJhY2suXG4gICAqXG4gICAqIElmIGEgdHJhY2sgaGFzIGFscmVhZHkgcHVibGlzaGVkLCBpdCdsbCBtdXRlIG9yIHVubXV0ZSB0aGUgdHJhY2suXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcbiAgICovXG4gIHNldE1pY3JvcGhvbmVFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IG9yIHN0b3Agc2hhcmluZyBhIHBhcnRpY2lwYW50J3Mgc2NyZWVuXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcbiAgICovXG4gIHNldFNjcmVlblNoYXJlRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEUyRUVFbmFibGVkKGVuYWJsZWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IGVuYWJsZWQgPyBFbmNyeXB0aW9uX1R5cGUuR0NNIDogRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgICB5aWVsZCB0aGlzLnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRUcmFja0VuYWJsZWQoc291cmNlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldFRyYWNrRW5hYmxlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVuYWJsZWRcbiAgICAgIH0pKTtcbiAgICAgIGlmICh0aGlzLnJlcHVibGlzaFByb21pc2UpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yZXB1Ymxpc2hQcm9taXNlO1xuICAgICAgfVxuICAgICAgbGV0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB5aWVsZCB0cmFjay51bm11dGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgbG9jYWxUcmFja3M7XG4gICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFjayA9IHlpZWxkIHRoaXMud2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXBlbmRpbmdUcmFjaykge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCd3YWl0aW5nIGZvciBwZW5kaW5nIHB1YmxpY2F0aW9uIHByb21pc2UgdGltZWQgb3V0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHBlbmRpbmdUcmFjayA9PT0gbnVsbCB8fCBwZW5kaW5nVHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdUcmFjay51bm11dGUoKTtcbiAgICAgICAgICAgIHJldHVybiBwZW5kaW5nVHJhY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLkNhbWVyYTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAgIHZpZGVvOiAoX2EgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgICBhdWRpbzogKF9iID0gb3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlU2NyZWVuVHJhY2tzKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3Ioc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2NhbFRyYWNrcyA9PT0gbnVsbCB8fCBsb2NhbFRyYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYWxUcmFja3MuZm9yRWFjaCh0ciA9PiB7XG4gICAgICAgICAgICAgIHRyLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgZSwgc291cmNlVG9LaW5kKHNvdXJjZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoc291cmNlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgbG9jYWxUcmFjayBvZiBsb2NhbFRyYWNrcykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yb29tT3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmIGlzQXVkaW9UcmFjayhsb2NhbFRyYWNrKSAmJiBvcHRzLnByZUNvbm5lY3RCdWZmZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnc3RhcnRpbmcgcHJlY29ubmVjdCBidWZmZXIgZm9yIG1pY3JvcGhvbmUnLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgICAgICAgbG9jYWxUcmFjay5zdGFydFByZUNvbm5lY3RCdWZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhbFRyYWNrIG9mIGxvY2FsVHJhY2tzKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3B1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sobG9jYWxUcmFjaykpKTtcbiAgICAgICAgICAgICAgcHVibGlzaFByb21pc2VzLnB1c2godGhpcy5wdWJsaXNoVHJhY2sobG9jYWxUcmFjaywgcHVibGlzaE9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrcyA9IHlpZWxkIFByb21pc2UuYWxsKHB1Ymxpc2hQcm9taXNlcyk7XG4gICAgICAgICAgICAvLyBmb3Igc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9ucyBpbmNsdWRpbmcgYXVkaW8sIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0aGUgc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9uLCBub3QgdGhlIHNjcmVlbiBzaGFyZSBhdWRpbyBvbmVcbiAgICAgICAgICAgIC8vIHJldmlzaXQgaWYgd2Ugd2FudCB0byByZXR1cm4gYW4gYXJyYXkgb2YgdHJhY2tzIGluc3RlYWQgZm9yIHYyXG4gICAgICAgICAgICBbdHJhY2tdID0gcHVibGlzaGVkVHJhY2tzO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsVHJhY2tzID09PSBudWxsIHx8IGxvY2FsVHJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NhbFRyYWNrcy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICAgICAgdHIuc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEodHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLnRyYWNrKSAmJiB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUncyBubyB0cmFjayBhdmFpbGFibGUgeWV0IGZpcnN0IHdhaXQgZm9yIHBlbmRpbmcgcHVibGlzaGluZyBwcm9taXNlcyBvZiB0aGF0IHNvdXJjZSB0byBzZWUgaWYgaXQgYmVjb21lcyBhdmFpbGFibGVcbiAgICAgICAgICB0cmFjayA9IHlpZWxkIHRoaXMud2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnd2FpdGluZyBmb3IgcGVuZGluZyBwdWJsaWNhdGlvbiBwcm9taXNlIHRpbWVkIG91dCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLnRyYWNrKSB7XG4gICAgICAgICAgLy8gc2NyZWVuc2hhcmUgY2Fubm90IGJlIG11dGVkLCB1bnB1Ymxpc2ggaW5zdGVhZFxuICAgICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgICAgdHJhY2sgPSB5aWVsZCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvVHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8pO1xuICAgICAgICAgICAgaWYgKHNjcmVlbkF1ZGlvVHJhY2sgJiYgc2NyZWVuQXVkaW9UcmFjay50cmFjaykge1xuICAgICAgICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYm90aCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIGRpc3BsYXlpbmcgYSBzaW5nbGUgUGVybWlzc2lvbiBEaWFsb2cgYm94IHRvIHRoZSBlbmQgdXNlci5cbiAgICovXG4gIGVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhUcmFjay5Tb3VyY2UuQ2FtZXJhKSB8fCB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkpIHtcbiAgICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMucHVibGlzaFRyYWNrKHRyYWNrKSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGxvY2FsIGNhbWVyYSBhbmQvb3IgbWljcm9waG9uZSB0cmFja3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGNyZWF0ZVRyYWNrcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBvcHRpb25zID0ge307XG4gICAgICBjb25zdCBtZXJnZWRPcHRpb25zV2l0aFByb2Nlc3NvcnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdWRpb0NhcHR1cmVEZWZhdWx0cywgKF9iID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpZGVvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKG1lcmdlZE9wdGlvbnNXaXRoUHJvY2Vzc29ycywge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbG9jYWxUcmFja3MgPSB0cmFja3MubWFwKHRyYWNrID0+IHtcbiAgICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cmFjay5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gICAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAgICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcignZ2V0RGlzcGxheU1lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCAmJiAhaXNTYWZhcmkxN0Jhc2VkKCkpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjb25zdHJhaW4gdGhlIGRpbWVuc2lvbnMsIG90aGVyd2lzZSBpdCBjb3VsZCBsZWFkIHRvIGxvdyBiaXRyYXRlXG4gICAgICAgIC8vIGR1ZSB0byBlbmNvZGluZyBhIGh1Z2UgdmlkZW8uIEVuY29kaW5nIHN1Y2ggbGFyZ2Ugc3VyZmFjZXMgaXMgcmVhbGx5IGV4cGVuc2l2ZVxuICAgICAgICAvLyB1bmZvcnR1bmF0ZWx5IFNhZmFyaSAxNyBoYXMgYSBidXQgYW5kIGNhbm5vdCBiZSBjb25zdHJhaW5lZCBieSBkZWZhdWx0XG4gICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcmVlblZpZGVvID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFja3NbMF0sIHVuZGVmaW5lZCwgZmFsc2UsIHtcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgfSk7XG4gICAgICBzY3JlZW5WaWRlby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICBpZiAob3B0aW9ucy5jb250ZW50SGludCkge1xuICAgICAgICBzY3JlZW5WaWRlby5tZWRpYVN0cmVhbVRyYWNrLmNvbnRlbnRIaW50ID0gb3B0aW9ucy5jb250ZW50SGludDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcbiAgICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQpO1xuICAgICAgICBjb25zdCBzY3JlZW5BdWRpbyA9IG5ldyBMb2NhbEF1ZGlvVHJhY2soc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sIHVuZGVmaW5lZCwgZmFsc2UsIHRoaXMuYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgdHJhY2sgdG8gdGhlIHJvb21cbiAgICogQHBhcmFtIHRyYWNrXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaE9yUmVwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIHB1Ymxpc2hPclJlcHVibGlzaFRyYWNrKHRyYWNrXzEsIG9wdGlvbnNfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICh0cmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBsZXQgaXNSZXB1Ymxpc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dChfdGhpczIuYXVkaW9Db250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCAoX2EgPSBfdGhpczIucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcbiAgICAgICAgaWYgKF90aGlzMi5yZXB1Ymxpc2hQcm9taXNlICYmICFpc1JlcHVibGlzaCkge1xuICAgICAgICAgIHlpZWxkIF90aGlzMi5yZXB1Ymxpc2hQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xvY2FsVHJhY2sodHJhY2spICYmIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLmhhcyh0cmFjaykpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5nZXQodHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0Q29uc3RyYWludHM7XG4gICAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIHdhbnQgdG8gYWNjZXNzIGNvbnN0cmFpbnRzIGRpcmVjdGx5IGFzIGB0cmFjay5tZWRpYVN0cmVhbVRyYWNrYFxuICAgICAgICAgIC8vIG1pZ2h0IGJlIHBvaW50aW5nIHRvIGEgbm9uLWRldmljZSB0cmFjayAoZS5nLiBwcm9jZXNzZWQgdHJhY2spIGFscmVhZHlcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5jb25zdHJhaW50cztcbiAgICAgICAgICBsZXQgZGV2aWNlS2luZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzd2l0Y2ggKHRyYWNrLnNvdXJjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgICAgICAgZGV2aWNlS2luZCA9ICdhdWRpb2lucHV0JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5DYW1lcmE6XG4gICAgICAgICAgICAgIGRldmljZUtpbmQgPSAndmlkZW9pbnB1dCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZXZpY2VLaW5kICYmIF90aGlzMi5hY3RpdmVEZXZpY2VNYXAuaGFzKGRldmljZUtpbmQpKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25zdHJhaW50cyksIHtcbiAgICAgICAgICAgICAgZGV2aWNlSWQ6IF90aGlzMi5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udmVydCByYXcgbWVkaWEgdHJhY2sgaW50byBhdWRpbyBvciB2aWRlbyB0cmFja1xuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgc3dpdGNoICh0cmFjay5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICAgIHRyYWNrID0gbmV3IExvY2FsQXVkaW9UcmFjayh0cmFjaywgZGVmYXVsdENvbnN0cmFpbnRzLCB0cnVlLCBfdGhpczIuYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiBfdGhpczIubG9nQ29udGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICAgIHRyYWNrID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFjaywgZGVmYXVsdENvbnN0cmFpbnRzLCB0cnVlLCB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiBfdGhpczIubG9nQ29udGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoXCJ1bnN1cHBvcnRlZCBNZWRpYVN0cmVhbVRyYWNrIGtpbmQgXCIuY29uY2F0KHRyYWNrLmtpbmQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhY2sudXBkYXRlTG9nZ2VyT3B0aW9ucyh7XG4gICAgICAgICAgICBsb2dnZXJOYW1lOiBfdGhpczIucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gX3RoaXMyLmxvZ0NvbnRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpcyBpdCBhbHJlYWR5IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgICAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgICAgX3RoaXMyLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IHB1YmxpY2F0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChleGlzdGluZ1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgX3RoaXMyLmxvZy53YXJuKCd0cmFjayBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCwgc2tpcHBpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1B1YmxpY2F0aW9uKSkpO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5yb29tT3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaXNTdGVyZW9JbnB1dCA9ICdjaGFubmVsQ291bnQnIGluIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKSAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjaGFubmVsQ291bnRgIG9uIGdldFNldHRpbmdzKCkgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBTYWZhcmksIGJ1dCBpcyBnZW5lcmFsbHkgdGhlIGJlc3Qgd2F5IHRvIGRldGVybWluZSBhIHN0ZXJlbyB0cmFjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja1NldHRpbmdzL2NoYW5uZWxDb3VudFxuICAgICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuY2hhbm5lbENvdW50ID09PSAyIHx8IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0Q29uc3RyYWludHMoKS5jaGFubmVsQ291bnQgPT09IDI7XG4gICAgICAgIGNvbnN0IGlzU3RlcmVvID0gKF9iID0gb3B0cy5mb3JjZVN0ZXJlbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaXNTdGVyZW9JbnB1dDtcbiAgICAgICAgLy8gZGlzYWJsZSBkdHggZm9yIHN0ZXJlbyB0cmFjayBpZiBub3QgZW5hYmxlZCBleHBsaWNpdGx5XG4gICAgICAgIGlmIChpc1N0ZXJlbykge1xuICAgICAgICAgIGlmIChvcHRzLmR0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oXCJPcHVzIERUWCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLlwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMucmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzMi5sb2cuaW5mbyhcIk9wdXMgUkVEIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoX2MgPSBvcHRzLmR0eCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogb3B0cy5kdHggPSBmYWxzZTtcbiAgICAgICAgICAoX2QgPSBvcHRzLnJlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3B0cy5yZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRTJFRVNpbXVsY2FzdFN1cHBvcnRlZCgpICYmIF90aGlzMi5yb29tT3B0aW9ucy5lMmVlKSB7XG4gICAgICAgICAgX3RoaXMyLmxvZy5pbmZvKFwiRW5kLXRvLWVuZCBlbmNyeXB0aW9uIGlzIHNldCB1cCwgc2ltdWxjYXN0IHB1Ymxpc2hpbmcgd2lsbCBiZSBkaXNhYmxlZCBvbiBTYWZhcmkgdmVyc2lvbnMgYW5kIGlPUyBicm93c2VycyBydW5uaW5nIGlPUyA8IHYxNy4yXCIsIE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSk7XG4gICAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5zb3VyY2UpIHtcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpczIsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZGVmZXJyaW5nIHRyYWNrIHB1YmxpY2F0aW9uIHVudGlsIHNpZ25hbCBpcyBjb25uZWN0ZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICB0cmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaylcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBsZXQgcHVibGljYXRpb25UaW1lZE91dCA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGljYXRpb25UaW1lZE91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ3B1Ymxpc2hpbmcgcmVqZWN0ZWQgYXMgZW5naW5lIG5vdCBjb25uZWN0ZWQgd2l0aGluIHRpbWVvdXQnLCA0MDgpKTtcbiAgICAgICAgICAgICAgfSwgMTUwMDApO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLndhaXRVbnRpbEVuZ2luZUNvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIGlmIChwdWJsaWNhdGlvblRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0geWllbGQgdGhpcy5wdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbyk7XG4gICAgICAgICAgICAgIHJlc29sdmUocHVibGljYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHRoaXMucHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocHVibGljYXRpb24pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5zZXQodHJhY2ssIHB1Ymxpc2hQcm9taXNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHB1Ymxpc2hQcm9taXNlO1xuICAgICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZGVsZXRlKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIHdhaXRVbnRpbEVuZ2luZUNvbm5lY3RlZCgpIHtcbiAgICBpZiAoIXRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKSB7XG4gICAgICB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlLnByb21pc2U7XG4gIH1cbiAgaGFzUGVybWlzc2lvbnNUb1B1Ymxpc2godHJhY2spIHtcbiAgICBpZiAoIXRoaXMucGVybWlzc2lvbnMpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ25vIHBlcm1pc3Npb25zIHByZXNlbnQgZm9yIHB1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhblB1Ymxpc2gsXG4gICAgICBjYW5QdWJsaXNoU291cmNlc1xuICAgIH0gPSB0aGlzLnBlcm1pc3Npb25zO1xuICAgIGlmIChjYW5QdWJsaXNoICYmIChjYW5QdWJsaXNoU291cmNlcy5sZW5ndGggPT09IDAgfHwgY2FuUHVibGlzaFNvdXJjZXMubWFwKHNvdXJjZSA9PiBnZXRUcmFja1NvdXJjZUZyb21Qcm90byhzb3VyY2UpKS5pbmNsdWRlcyh0cmFjay5zb3VyY2UpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMubG9nLndhcm4oJ2luc3VmZmljaWVudCBwZXJtaXNzaW9ucyB0byBwdWJsaXNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgICBpZiAoIXRoaXMuaGFzUGVybWlzc2lvbnNUb1B1Ymxpc2godHJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBQdWJsaXNoVHJhY2tFcnJvcignZmFpbGVkIHRvIHB1Ymxpc2ggdHJhY2ssIGluc3VmZmljaWVudCBwZXJtaXNzaW9ucycsIDQwMyk7XG4gICAgICB9XG4gICAgICBjb25zdCBleGlzdGluZ1RyYWNrT2ZTb3VyY2UgPSBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbmQocHVibGlzaGVkVHJhY2sgPT4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IHRyYWNrLnNvdXJjZSk7XG4gICAgICBpZiAoZXhpc3RpbmdUcmFja09mU291cmNlICYmIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlVua25vd24pIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcInB1Ymxpc2hpbmcgYSBzZWNvbmQgdHJhY2sgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiLmNvbmNhdCh0cmFjay5zb3VyY2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5zdG9wTWljVHJhY2tPbk11dGUgJiYgaXNBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICB0cmFjay5zdG9wT25NdXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiBpc0ZpcmVGb3goKSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHNpbXVsY2FzdGVkIHNjcmVlbiBzaGFyZVxuICAgICAgICAvLyB3ZSBmcmVxdWVudGx5IGdldCBubyBkYXRhIG9uIGxheWVyIDAgd2hlbiBlbmFibGVkXG4gICAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyByZXF1aXJlIGZ1bGwgQVYxL1ZQOSBTVkMgc3VwcG9ydCBwcmlvciB0byB1c2luZyBpdFxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ2F2MScgJiYgIXN1cHBvcnRzQVYxKCkpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ3ZwOScgJiYgIXN1cHBvcnRzVlA5KCkpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IGRlZmF1bHRWaWRlb0NvZGVjO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGEgc3VwcG9ydGVkIGNvZGVjIGlmIGl0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3Muc29tZShjID0+IG9wdHMudmlkZW9Db2RlYyA9PT0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcoYy5taW1lKSkpIHtcbiAgICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3NbMF0ubWltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRzLnZpZGVvQ29kZWM7XG4gICAgICAvLyBoYW5kbGUgdHJhY2sgYWN0aW9uc1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLm9uVHJhY2tVbm11dGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVwc3RyZWFtUmVzdW1lZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1SZXN1bWVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMub25UcmFja0ZlYXR1cmVVcGRhdGUpO1xuICAgICAgY29uc3QgYXVkaW9GZWF0dXJlcyA9IFtdO1xuICAgICAgY29uc3QgZGlzYWJsZUR0eCA9ICEoKF9hID0gb3B0cy5kdHgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpO1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5nZXRTb3VyY2VUcmFja1NldHRpbmdzKCk7XG4gICAgICBpZiAoc2V0dGluZ3MuYXV0b0dhaW5Db250cm9sKSB7XG4gICAgICAgIGF1ZGlvRmVhdHVyZXMucHVzaChBdWRpb1RyYWNrRmVhdHVyZS5URl9BVVRPX0dBSU5fQ09OVFJPTCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuZWNob0NhbmNlbGxhdGlvbikge1xuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfRUNIT19DQU5DRUxMQVRJT04pO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLm5vaXNlU3VwcHJlc3Npb24pIHtcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PSVNFX1NVUFBSRVNTSU9OKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy5jaGFubmVsQ291bnQgJiYgc2V0dGluZ3MuY2hhbm5lbENvdW50ID4gMSkge1xuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfU1RFUkVPKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlRHR4KSB7XG4gICAgICAgIGF1ZGlvRmVhdHVyZXMucHVzaChBdWRpb1RyYWNrRmVhdHVyZS5URl9OT19EVFgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSAmJiB0cmFjay5oYXNQcmVDb25uZWN0QnVmZmVyKSB7XG4gICAgICAgIGF1ZGlvRmVhdHVyZXMucHVzaChBdWRpb1RyYWNrRmVhdHVyZS5URl9QUkVDT05ORUNUX0JVRkZFUik7XG4gICAgICB9XG4gICAgICAvLyBjcmVhdGUgdHJhY2sgcHVibGljYXRpb24gZnJvbSB0cmFja1xuICAgICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XG4gICAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXG4gICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZCxcbiAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICAgIHNvdXJjZTogVHJhY2suc291cmNlVG9Qcm90byh0cmFjay5zb3VyY2UpLFxuICAgICAgICBkaXNhYmxlRHR4LFxuICAgICAgICBlbmNyeXB0aW9uOiB0aGlzLmVuY3J5cHRpb25UeXBlLFxuICAgICAgICBzdGVyZW86IGlzU3RlcmVvLFxuICAgICAgICBkaXNhYmxlUmVkOiB0aGlzLmlzRTJFRUVuYWJsZWQgfHwgISgoX2IgPSBvcHRzLnJlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSksXG4gICAgICAgIHN0cmVhbTogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnN0cmVhbSxcbiAgICAgICAgYmFja3VwQ29kZWNQb2xpY3k6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5iYWNrdXBDb2RlY1BvbGljeSxcbiAgICAgICAgYXVkaW9GZWF0dXJlc1xuICAgICAgfSk7XG4gICAgICAvLyBjb21wdXRlIGVuY29kaW5ncyBhbmQgbGF5ZXJzIGZvciB2aWRlb1xuICAgICAgbGV0IGVuY29kaW5ncztcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIGxldCBkaW1zID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRpbXMgPSB5aWVsZCB0cmFjay53YWl0Rm9yRGltZW5zaW9ucygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gdXNlIGRlZmF1bHRzLCBpdCdzIHF1aXRlIHBhaW5mdWwgZm9yIGNvbmdlc3Rpb24gY29udHJvbCB3aXRob3V0IHNpbXVsY2FzdFxuICAgICAgICAgIC8vIHNvIHVzaW5nIGRlZmF1bHQgZGltcyBhY2NvcmRpbmcgdG8gcHVibGlzaCBzZXR0aW5nc1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRSZXMgPSAoX2QgPSAoX2MgPSB0aGlzLnJvb21PcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzb2x1dGlvbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvbjtcbiAgICAgICAgICBkaW1zID0ge1xuICAgICAgICAgICAgd2lkdGg6IGRlZmF1bHRSZXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGRlZmF1bHRSZXMuaGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBsb2cgZmFpbHVyZVxuICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZGV0ZXJtaW5lIHRyYWNrIGRpbWVuc2lvbnMsIHVzaW5nIGRlZmF1bHRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSwge1xuICAgICAgICAgICAgZGltc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBiZSBkZWZpbmVkIGZvciB2aWRlb1xuICAgICAgICByZXEud2lkdGggPSBkaW1zLndpZHRoO1xuICAgICAgICByZXEuaGVpZ2h0ID0gZGltcy5oZWlnaHQ7XG4gICAgICAgIC8vIGZvciBzdmMgY29kZWNzLCBkaXNhYmxlIHNpbXVsY2FzdCBhbmQgdXNlIHZwOCBmb3IgYmFja3VwIGNvZGVjXG4gICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICBpZiAoaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgICAgIC8vIHZwOSBzdmMgd2l0aCBzY3JlZW5zaGFyZSBjYW5ub3QgZW5jb2RlIG11bHRpcGxlIHNwYXRpYWwgbGF5ZXJzXG4gICAgICAgICAgICAgIC8vIGRvaW5nIHNvIHJlZHVjZXMgcHVibGlzaCByZXNvbHV0aW9uIHRvIG1pbmltYWwgcmVzb2x1dGlvblxuICAgICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgICAgLy8gQ2hyb21lIGRvZXMgbm90IGFsbG93IG1vcmUgdGhhbiA1IGZwcyB3aXRoIEwxVDMsIGFuZCBpdCBoYXMgZW5jb2RpbmcgYnVncyB3aXRoIEwzVDNcbiAgICAgICAgICAgICAgLy8gSXQgaGFzIGEgZGlmZmVyZW50IHBhdGggZm9yIHNjcmVlbnNoYXJlIGhhbmRsaW5nIGFuZCBpdCBzZWVtcyB0byBiZSB1bnRlc3RlZC9idWdneVxuICAgICAgICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQsIHdlIGFyZSBzZXR0aW5nIGNvbnRlbnRIaW50IHRvIGZvcmNlIGl0IHRvIGdvIHRocm91Z2ggdGhlIHNhbWVcbiAgICAgICAgICAgICAgLy8gcGF0aCBhcyByZWd1bGFyIGNhbWVyYSB2aWRlby4gV2hpbGUgdGhpcyBpcyBub3Qgb3B0aW1hbCwgaXQgZGVsaXZlcnMgdGhlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgIC8vIHRoYXQgd2UgbmVlZFxuICAgICAgICAgICAgICBpZiAoJ2NvbnRlbnRIaW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5jb250ZW50SGludCA9ICdtb3Rpb24nO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ2ZvcmNpbmcgY29udGVudEhpbnQgdG8gbW90aW9uIGZvciBzY3JlZW5zaGFyZSB3aXRoIFNWQyBjb2RlY3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBzY2FsYWJpbGl0eU1vZGUgdG8gJ0wzVDNfS0VZJyBieSBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9IChfZSA9IG9wdHMuc2NhbGFiaWxpdHlNb2RlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnTDNUM19LRVknO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzID0gW25ldyBTaW11bGNhc3RDb2RlYyh7XG4gICAgICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxuICAgICAgICAgIH0pXTtcbiAgICAgICAgICAvLyBzZXQgdXAgYmFja3VwXG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9wdHMuYmFja3VwQ29kZWMgPSB7XG4gICAgICAgICAgICAgIGNvZGVjOiBkZWZhdWx0VmlkZW9Db2RlY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgJiYgdmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyAmJlxuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIGNvZGVjc1xuICAgICAgICAgIHJlcS5lbmNyeXB0aW9uID09PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSkge1xuICAgICAgICAgICAgLy8gbXVsdGktY29kZWMgc2ltdWxjYXN0IHJlcXVpcmVzIGR5bmFjYXN0XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5yb29tT3B0aW9ucy5keW5hY2FzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzLnB1c2gobmV3IFNpbXVsY2FzdENvZGVjKHtcbiAgICAgICAgICAgICAgY29kZWM6IG9wdHMuYmFja3VwQ29kZWMuY29kZWMsXG4gICAgICAgICAgICAgIGNpZDogJydcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCByZXEud2lkdGgsIHJlcS5oZWlnaHQsIG9wdHMpO1xuICAgICAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHJlcS53aWR0aCwgcmVxLmhlaWdodCwgZW5jb2RpbmdzLCBpc1NWQ0NvZGVjKG9wdHMudmlkZW9Db2RlYykpO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIGVuY29kaW5ncyA9IFt7XG4gICAgICAgICAgbWF4Qml0cmF0ZTogKF9mID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLm1heEJpdHJhdGUsXG4gICAgICAgICAgcHJpb3JpdHk6IChfaCA9IChfZyA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wcmlvcml0eSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogJ2hpZ2gnLFxuICAgICAgICAgIG5ldHdvcmtQcmlvcml0eTogKF9rID0gKF9qID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnByaW9yaXR5KSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiAnaGlnaCdcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjYW5ub3QgcHVibGlzaCB0cmFjayB3aGVuIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lZ290aWF0ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICghdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3BjTWFuYWdlciBpcyBub3QgcmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5zZW5kZXIgPSB5aWVsZCB0aGlzLmVuZ2luZS5jcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsU2VuZGVyQ3JlYXRlZCwgdHJhY2suc2VuZGVyLCB0cmFjayk7XG4gICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICAoX2EgPSBvcHRzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBnZXREZWZhdWx0RGVncmFkYXRpb25QcmVmZXJlbmNlKHRyYWNrKTtcbiAgICAgICAgICB0cmFjay5zZXREZWdyYWRhdGlvblByZWZlcmVuY2Uob3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICBpZiAoaXNGaXJlRm94KCkgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICAgICAgLyogUmVmZXIgdG8gUkZDIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzU4NyNzZWN0aW9uLTYuMSxcbiAgICAgICAgICAgICAgIGxpdmVraXQtc2VydmVyIHVzZXMgbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwIGluIHRoZSBhbnN3ZXIgc2RwIHRvIHBlcm1pdCBjbGllbnQgdG9cbiAgICAgICAgICAgICAgIHB1Ymxpc2ggaGlnaCBxdWFsaXR5IGF1ZGlvIHRyYWNrLiBCdXQgZmlyZWZveCBhbHdheXMgdXNlcyB0aGlzIHZhbHVlIGFzIHRoZSBhY3R1YWxcbiAgICAgICAgICAgICAgIGJpdHJhdGVzLCBjYXVzaW5nIHRoZSBhdWRpbyBiaXRyYXRlcyB0byByaXNlIHRvIDUxMEticHMgaW4gYW55IHN0ZXJlbyBjYXNlIHVuZXhwZWN0ZWRseS5cbiAgICAgICAgICAgICAgIFNvIHRoZSBjbGllbnQgbmVlZCB0byBtb2RpZnkgbWF4YXZlcnJhZ2ViaXRyYXRlcyBpbiBhbnN3ZXIgc2RwIHRvIHVzZXIgcHJvdmlkZWQgdmFsdWUgdG9cbiAgICAgICAgICAgICAgIGZpeCB0aGUgaXNzdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCB0cmFja1RyYW5zY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrLnNlbmRlcikge1xuICAgICAgICAgICAgICAgIHRyYWNrVHJhbnNjZWl2ZXIgPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXI6IHRyYWNrVHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICAgICAgY29kZWM6ICdvcHVzJyxcbiAgICAgICAgICAgICAgICBtYXhicjogKChfYiA9IGVuY29kaW5nc1swXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heEJpdHJhdGUpID8gZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwIDogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmNvZGVjICYmIGlzU1ZDQ29kZWModHJhY2suY29kZWMpICYmICgoX2MgPSBlbmNvZGluZ3NbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXhCaXRyYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XG4gICAgICAgICAgICAgIGNpZDogcmVxLmNpZCxcbiAgICAgICAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxuICAgICAgICAgICAgICBtYXhicjogZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGxldCB0aTtcbiAgICAgIGNvbnN0IGFkZFRyYWNrUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRpID0geWllbGQgdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKTtcbiAgICAgICAgICByZXNvbHZlKHRpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKHRyYWNrLnNlbmRlciAmJiAoKF9hID0gdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVibGlzaGVyKSkge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5yZW1vdmVUcmFjayh0cmFjay5zZW5kZXIpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCkuY2F0Y2gobmVnb3RpYXRlRXJyID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBuZWdvdGlhdGUgYWZ0ZXIgcmVtb3ZpbmcgdHJhY2sgZHVlIHRvIGZhaWxlZCBhZGQgdHJhY2sgcmVxdWVzdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmVnb3RpYXRlRXJyXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJldHMgPSB5aWVsZCBQcm9taXNlLmFsbChbYWRkVHJhY2tQcm9taXNlLCBuZWdvdGlhdGUoKV0pO1xuICAgICAgICB0aSA9IHJldHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aSA9IHlpZWxkIGFkZFRyYWNrUHJvbWlzZTtcbiAgICAgICAgLy8gc2VydmVyIG1pZ2h0IG5vdCBzdXBwb3J0IHRoZSBjb2RlYyB0aGUgY2xpZW50IGhhcyByZXF1ZXN0ZWQsIGluIHRoYXQgY2FzZSwgZmFsbGJhY2tcbiAgICAgICAgLy8gdG8gYSBzdXBwb3J0ZWQgY29kZWNcbiAgICAgICAgbGV0IHByaW1hcnlDb2RlY01pbWU7XG4gICAgICAgIHRpLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgICBpZiAocHJpbWFyeUNvZGVjTWltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcmltYXJ5Q29kZWNNaW1lID0gY29kZWMubWltZVR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHByaW1hcnlDb2RlY01pbWUpO1xuICAgICAgICAgIGlmICh1cGRhdGVkQ29kZWMgIT09IHZpZGVvQ29kZWMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdmYWxsaW5nIGJhY2sgdG8gc2VydmVyIHNlbGVjdGVkIGNvZGVjJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSwge1xuICAgICAgICAgICAgICBjb2RlYzogdXBkYXRlZENvZGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1cGRhdGVkQ29kZWM7XG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgZW5jb2RpbmdzIHNpbmNlIGJpdHJhdGVzL2V0YyBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgcmVxLndpZHRoLCByZXEuaGVpZ2h0LCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgbmVnb3RpYXRlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24odHJhY2sua2luZCwgdGksIHRyYWNrLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgIH0pO1xuICAgICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5DcHVDb25zdHJhaW5lZCwgY29uc3RyYWluZWRUcmFjayA9PiB0aGlzLm9uVHJhY2tDcHVDb25zdHJhaW5lZChjb25zdHJhaW5lZFRyYWNrLCBwdWJsaWNhdGlvbikpO1xuICAgICAgLy8gc2F2ZSBvcHRpb25zIGZvciB3aGVuIGl0IG5lZWRzIHRvIGJlIHJlcHVibGlzaGVkIGFnYWluXG4gICAgICBwdWJsaWNhdGlvbi5vcHRpb25zID0gb3B0cztcbiAgICAgIHRyYWNrLnNpZCA9IHRpLnNpZDtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaGluZyBcIi5jb25jYXQodHJhY2sua2luZCwgXCIgd2l0aCBlbmNvZGluZ3NcIiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgIHRyYWNrSW5mbzogdGlcbiAgICAgIH0pKTtcbiAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKHRoaXMuZW5naW5lLmNsaWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICB0cmFjay5zdGFydE1vbml0b3IoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICAvLyBzZW5kIGV2ZW50IGZvciBwdWJsaWNhdGlvblxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSAmJiB0aS5hdWRpb0ZlYXR1cmVzLmluY2x1ZGVzKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX1BSRUNPTk5FQ1RfQlVGRkVSKSkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB0cmFjay5nZXRQcmVDb25uZWN0QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gdHJhY2suZ2V0UHJlQ29ubmVjdEJ1ZmZlck1pbWVUeXBlKCk7XG4gICAgICAgIC8vIFRPRE86IHdlJ3JlIHJlZ2lzdGVyaW5nIHRoZSBsaXN0ZW5lciBhZnRlciBuZWdvdGlhdGlvbiwgc28gdGhlcmUgbWlnaHQgYmUgYSByYWNlXG4gICAgICAgIHRoaXMub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgcHViID0+IHtcbiAgICAgICAgICBpZiAocHViLnRyYWNrU2lkID09PSB0aS5zaWQpIHtcbiAgICAgICAgICAgIGlmICghdHJhY2suaGFzUHJlQ29ubmVjdEJ1ZmZlcikge1xuICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdzdWJzY3JpYmUgZXZlbnQgY2FtZSB0byBsYXRlLCBidWZmZXIgYWxyZWFkeSBjbG9zZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZmluaXNoZWQgcmVjb3JkaW5nIHByZWNvbm5lY3QgYnVmZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgdHJhY2suc3RvcFByZUNvbm5lY3RCdWZmZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyU3RyZWFtUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3dhaXRpbmcgZm9yIGFnZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgICBjb25zdCBhZ2VudEFjdGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdhZ2VudCBub3QgYWN0aXZlIHdpdGhpbiAxMCBzZWNvbmRzJykpO1xuICAgICAgICAgICAgICB9LCAxMDAwMCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFnZW50ID0geWllbGQgdGhpcy53YWl0VW50aWxBY3RpdmVBZ2VudFByZXNlbnQoKTtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFnZW50QWN0aXZlVGltZW91dCk7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIHByZWNvbm5lY3QgYnVmZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnN0cmVhbUJ5dGVzKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJlY29ubmVjdC1idWZmZXInLFxuICAgICAgICAgICAgICAgIG1pbWVUeXBlLFxuICAgICAgICAgICAgICAgIHRvcGljOiAnbGsuYWdlbnQucHJlLWNvbm5lY3QtYXVkaW8tYnVmZmVyJyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFthZ2VudC5pZGVudGl0eV0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgdHJhY2tJZDogcHVibGljYXRpb24udHJhY2tTaWQsXG4gICAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBTdHJpbmcoKF9kID0gc2V0dGluZ3Muc2FtcGxlUmF0ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJzQ4MDAwJyksXG4gICAgICAgICAgICAgICAgICBjaGFubmVsczogU3RyaW5nKChfZSA9IHNldHRpbmdzLmNoYW5uZWxDb3VudCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJzEnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1fMSA9IF9fYXN5bmNWYWx1ZXMoc3RyZWFtKSwgc3RyZWFtXzFfMTsgc3RyZWFtXzFfMSA9IHlpZWxkIHN0cmVhbV8xLm5leHQoKSwgX2EgPSBzdHJlYW1fMV8xLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBfYyA9IHN0cmVhbV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgIHlpZWxkIHdyaXRlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICAgICAgICAgIGVfMiA9IHtcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IHN0cmVhbV8xLnJldHVybikpIHlpZWxkIF9iLmNhbGwoc3RyZWFtXzEpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgYnVmZmVyU3RyZWFtUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwcmVjb25uZWN0IGJ1ZmZlciBzZW50IHN1Y2Nlc3NmdWxseScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciBzZW5kaW5nIHByZWNvbm5lY3QgYnVmZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSwge1xuICAgICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbFxuICAgKiBwdWJsaXNoIGFkZGl0aW9uYWwgY29kZWMgdG8gZXhpc3RpbmcgdHJhY2tcbiAgICovXG4gIHB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayh0cmFjaywgdmlkZW9Db2RlYywgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAvLyBUT0RPIHJlbW92ZSBvbmNlIGUyZWUgaXMgc3VwcG9ydGVkIGZvciBiYWNrdXAgdHJhY2tzXG4gICAgICBpZiAodGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaXMgaXQgbm90IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBleGlzdGluZ1B1YmxpY2F0aW9uID0gcHVibGljYXRpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFleGlzdGluZ1B1YmxpY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IHB1Ymxpc2hlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd0cmFjayBpcyBub3QgYSB2aWRlbyB0cmFjaycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1Ymxpc2hEZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgICAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRzKTtcbiAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJiYWNrdXAgY29kZWMgaGFzIGJlZW4gZGlzYWJsZWQsIGlnbm9yaW5nIHJlcXVlc3QgdG8gYWRkIGFkZGl0aW9uYWwgY29kZWMgZm9yIHRyYWNrXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2ltdWxjYXN0VHJhY2sgPSB0cmFjay5hZGRTaW11bGNhc3RUcmFjayh2aWRlb0NvZGVjLCBlbmNvZGluZ3MpO1xuICAgICAgaWYgKCFzaW11bGNhc3RUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcbiAgICAgICAgY2lkOiBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICAgIHNvdXJjZTogVHJhY2suc291cmNlVG9Qcm90byh0cmFjay5zb3VyY2UpLFxuICAgICAgICBzaWQ6IHRyYWNrLnNpZCxcbiAgICAgICAgc2ltdWxjYXN0Q29kZWNzOiBbe1xuICAgICAgICAgIGNvZGVjOiBvcHRzLnZpZGVvQ29kZWMsXG4gICAgICAgICAgY2lkOiBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIHJlcS5sYXllcnMgPSB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MocmVxLndpZHRoLCByZXEuaGVpZ2h0LCBlbmNvZGluZ3MpO1xuICAgICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWdvdGlhdGUgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNyZWF0ZVNpbXVsY2FzdFNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXRzID0geWllbGQgUHJvbWlzZS5hbGwoW3RoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSksIG5lZ290aWF0ZSgpXSk7XG4gICAgICBjb25zdCB0aSA9IHJldHNbMF07XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2hlZCBcIi5jb25jYXQodmlkZW9Db2RlYywgXCIgZm9yIHRyYWNrIFwiKS5jb25jYXQodHJhY2suc2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVuY29kaW5ncyxcbiAgICAgICAgdHJhY2tJbmZvOiB0aVxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIHVucHVibGlzaFRyYWNrKHRyYWNrLCBzdG9wT25VbnB1Ymxpc2gpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmIChpc0xvY2FsVHJhY2sodHJhY2spKSB7XG4gICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlID0gdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmdldCh0cmFjayk7XG4gICAgICAgIGlmIChwdWJsaXNoUHJvbWlzZSkge1xuICAgICAgICAgIHRoaXMubG9nLmluZm8oJ2F3YWl0aW5nIHB1Ymxpc2ggcHJvbWlzZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB1bnB1Ymxpc2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgeWllbGQgcHVibGlzaFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGxvb2sgdGhyb3VnaCBhbGwgcHVibGlzaGVkIHRyYWNrcyB0byBmaW5kIHRoZSByaWdodCBvbmVzXG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjayk7XG4gICAgICBjb25zdCBwdWJMb2dDb250ZXh0ID0gcHVibGljYXRpb24gPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpKTtcbiAgICAgIGlmICghcHVibGljYXRpb24gfHwgIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3RyYWNrIHdhcyBub3QgdW5wdWJsaXNoZWQgYmVjYXVzZSBubyBwdWJsaWNhdGlvbiB3YXMgZm91bmQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRyYWNrID0gcHVibGljYXRpb24udHJhY2s7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5vblRyYWNrVW5tdXRlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcy5vblRyYWNrRmVhdHVyZVVwZGF0ZSk7XG4gICAgICBpZiAoc3RvcE9uVW5wdWJsaXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RvcE9uVW5wdWJsaXNoID0gKF9iID0gKF9hID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcE9uVW5wdWJsaXNoKSB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrLnN0b3BNb25pdG9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgbmVnb3RpYXRpb25OZWVkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHRyYWNrU2VuZGVyID0gdHJhY2suc2VuZGVyO1xuICAgICAgdHJhY2suc2VuZGVyID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuZW5naW5lLnBjTWFuYWdlciAmJiB0aGlzLmVuZ2luZS5wY01hbmFnZXIuY3VycmVudFN0YXRlIDwgUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQgJiYgdHJhY2tTZW5kZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHNlbmRlciBpcyBub3QgY3VycmVudGx5IHNlbmRpbmcgKGFmdGVyIHJlcGxhY2VUcmFjayhudWxsKSlcbiAgICAgICAgICAgIC8vIHJlbW92ZVRyYWNrIHdvdWxkIGhhdmUgbm8gZWZmZWN0LlxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHdlIGVuZCB1cCBzdWNjZXNzZnVsbHkgcmVtb3ZpbmcgdGhlIHRyYWNrLCBtYW51YWxseSBzZXRcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2NlaXZlciB0byBpbmFjdGl2ZVxuICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRlciA9PT0gdHJhY2tTZW5kZXIpIHtcbiAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tTZW5kZXIpKSB7XG4gICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgdHJhY2tJbmZvXSBvZiB0cmFjay5zaW11bGNhc3RDb2RlY3MpIHtcbiAgICAgICAgICAgICAgaWYgKHRyYWNrSW5mby5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tJbmZvLnNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2tJbmZvLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2suc2ltdWxjYXN0Q29kZWNzLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHVucHVibGlzaCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBmcm9tIG91ciBtYXBzXG4gICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgICBpZiAobmVnb3RpYXRpb25OZWVkZWQpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfSk7XG4gIH1cbiAgdW5wdWJsaXNoVHJhY2tzKHRyYWNrcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0cmFjayA9PiB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrKSkpO1xuICAgICAgcmV0dXJuIHJlc3VsdHMuZmlsdGVyKHRyYWNrID0+ICEhdHJhY2spO1xuICAgIH0pO1xuICB9XG4gIHJlcHVibGlzaEFsbFRyYWNrcyhvcHRpb25zXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBsZXQgcmVzdGFydFRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoX3RoaXMzLnJlcHVibGlzaFByb21pc2UpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczMucmVwdWJsaXNoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczMucmVwdWJsaXNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpczMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFB1YnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHB1Yi5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWIub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFB1YnMucHVzaChwdWIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGxvY2FsUHVicy5tYXAocHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBwdWIudHJhY2s7XG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3RhcnRUcmFja3MgJiYgIXRyYWNrLmlzTXV0ZWQgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyAmJiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkgJiYgIXRyYWNrLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhbGx5IHdlIG5lZWQgdG8gcmVzdGFydCB0aGUgdHJhY2sgYmVmb3JlIHB1Ymxpc2hpbmcsIG9mdGVuIGEgZnVsbCByZWNvbm5lY3RcbiAgICAgICAgICAgICAgICAvLyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb21wdXRlciBoYWQgZ29uZSB0byBzbGVlcC5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBleGlzdGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICAgICAgdHJhY2s6IHB1Yi50cmFja1NpZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hPclJlcHVibGlzaFRyYWNrKHRyYWNrLCBwdWIub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnJlcHVibGlzaFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHlpZWxkIF90aGlzMy5yZXB1Ymxpc2hQcm9taXNlO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGEgbmV3IGRhdGEgcGF5bG9hZCB0byB0aGUgcm9vbS4gRGF0YSB3aWxsIGJlIGZvcndhcmRlZCB0byBlYWNoXG4gICAqIHBhcnRpY2lwYW50IGluIHRoZSByb29tIGlmIHRoZSBkZXN0aW5hdGlvbiBmaWVsZCBpbiBwdWJsaXNoT3B0aW9ucyBpcyBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBVaW50OEFycmF5IG9mIHRoZSBwYXlsb2FkLiBUbyBzZW5kIHN0cmluZyBkYXRhLCB1c2UgVGV4dEVuY29kZXIuZW5jb2RlXG4gICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbmFsbHkgc3BlY2lmeSBhIGByZWxpYWJsZWAsIGB0b3BpY2AgYW5kIGBkZXN0aW5hdGlvbmBcbiAgICovXG4gIHB1Ymxpc2hEYXRhKGRhdGFfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBraW5kID0gb3B0aW9ucy5yZWxpYWJsZSA/IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSA6IERhdGFQYWNrZXRfS2luZC5MT1NTWTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXM7XG4gICAgICAgIGNvbnN0IHRvcGljID0gb3B0aW9ucy50b3BpYztcbiAgICAgICAgbGV0IHVzZXJQYWNrZXQgPSBuZXcgVXNlclBhY2tldCh7XG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogX3RoaXM0LmlkZW50aXR5LFxuICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICAgIHRvcGljXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2FzZTogJ3VzZXInLFxuICAgICAgICAgICAgdmFsdWU6IHVzZXJQYWNrZXRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCBfdGhpczQuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCk7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggU0lQIERUTUYgbWVzc2FnZSB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogQHBhcmFtIGNvZGUgRFRNRiBjb2RlXG4gICAqIEBwYXJhbSBkaWdpdCBEVE1GIGRpZ2l0XG4gICAqL1xuICBwdWJsaXNoRHRtZihjb2RlLCBkaWdpdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAnc2lwRHRtZicsXG4gICAgICAgICAgdmFsdWU6IG5ldyBTaXBEVE1GKHtcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBkaWdpdDogZGlnaXRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQ29uc2lkZXIgbWlncmF0aW5nIHRvIHtAbGluayBzZW5kVGV4dH0gKi9cbiAgc2VuZENoYXRNZXNzYWdlKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgbWVzc2FnZTogdGV4dCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhdHRhY2hlZEZpbGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNobWVudHNcbiAgICAgIH07XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ2NoYXRNZXNzYWdlJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IENoYXRNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXNnKSwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKG1zZy50aW1lc3RhbXApXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZyk7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBDb25zaWRlciBtaWdyYXRpbmcgdG8ge0BsaW5rIHNlbmRUZXh0fSAqL1xuICBlZGl0Q2hhdE1lc3NhZ2UoZWRpdFRleHQsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBtc2cgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsTWVzc2FnZSksIHtcbiAgICAgICAgbWVzc2FnZTogZWRpdFRleHQsXG4gICAgICAgIGVkaXRUaW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdjaGF0TWVzc2FnZScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBDaGF0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1zZyksIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cudGltZXN0YW1wKSxcbiAgICAgICAgICAgIGVkaXRUaW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UobXNnLmVkaXRUaW1lc3RhbXApXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZyk7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB2aWEgdGhlIGRhdGEgY2hhbm5lbC5cbiAgICogRm9yIGxvbmdlciBtZXNzYWdlcywgY29uc2lkZXIgdXNpbmcge0BsaW5rIHN0cmVhbVRleHR9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHBheWxvYWRcbiAgICogQHBhcmFtIG9wdGlvbnMudG9waWMgVG9waWMgaWRlbnRpZmllciB1c2VkIHRvIHJvdXRlIHRoZSBzdHJlYW0gdG8gYXBwcm9wcmlhdGUgaGFuZGxlcnMuXG4gICAqL1xuICBzZW5kVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb21PdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyLnNlbmRUZXh0KHRleHQsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFRleHRTdHJlYW1Xcml0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gc3RyZWFtIHRleHQgaW5jcmVtZW50YWxseVxuICAgKiB0byBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gdmlhIHRoZSBkYXRhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvcGljIFRvcGljIGlkZW50aWZpZXIgdXNlZCB0byByb3V0ZSB0aGUgc3RyZWFtIHRvIGFwcHJvcHJpYXRlIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbCBDQVVUSU9OLCBtaWdodCBnZXQgcmVtb3ZlZCBpbiBhIG1pbm9yIHJlbGVhc2VcbiAgICovXG4gIHN0cmVhbVRleHQob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb29tT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlci5zdHJlYW1UZXh0KG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBTZW5kIGEgRmlsZSB0byBhbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHZpYSB0aGUgZGF0YSBjaGFubmVsLlxuICAgKiBAcGFyYW0gZmlsZSBUaGUgRmlsZSBvYmplY3QgcGF5bG9hZFxuICAgKiBAcGFyYW0gb3B0aW9ucy50b3BpYyBUb3BpYyBpZGVudGlmaWVyIHVzZWQgdG8gcm91dGUgdGhlIHN0cmVhbSB0byBhcHByb3ByaWF0ZSBoYW5kbGVycy5cbiAgICogQHBhcmFtIG9wdGlvbnMub25Qcm9ncmVzcyBBIGNhbGxiYWNrIGZ1bmN0aW9uIHVzZWQgdG8gbW9uaXRvciB0aGUgdXBsb2FkIHByb2dyZXNzIHBlcmNlbnRhZ2UuXG4gICAqL1xuICBzZW5kRmlsZShmaWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb21PdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyLnNlbmRGaWxlKGZpbGUsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdHJlYW0gYnl0ZXMgaW5jcmVtZW50YWxseSB0byBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gdmlhIHRoZSBkYXRhIGNoYW5uZWwuXG4gICAqIEZvciBzZW5kaW5nIGZpbGVzLCBjb25zaWRlciB1c2luZyB7QGxpbmsgc2VuZEZpbGV9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvcGljIFRvcGljIGlkZW50aWZpZXIgdXNlZCB0byByb3V0ZSB0aGUgc3RyZWFtIHRvIGFwcHJvcHJpYXRlIGhhbmRsZXJzLlxuICAgKi9cbiAgc3RyZWFtQnl0ZXMob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb29tT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlci5zdHJlYW1CeXRlcyhvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgYW4gUlBDIGNhbGwgdG8gYSByZW1vdGUgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIGluaXRpYXRpbmcgdGhlIFJQQyBjYWxsLCBzZWUge0BsaW5rIFBlcmZvcm1ScGNQYXJhbXN9XG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIHBheWxvYWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxuICAgKiBAdGhyb3dzIEVycm9yIG9uIGZhaWx1cmUuIERldGFpbHMgaW4gYG1lc3NhZ2VgLlxuICAgKi9cbiAgcGVyZm9ybVJwYyhfYSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICBsZXQge1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXR5LFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIHJlc3BvbnNlVGltZW91dCA9IDE1MDAwXG4gICAgICB9ID0gX3JlZjM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbWF4Um91bmRUcmlwTGF0ZW5jeSA9IDcwMDA7XG4gICAgICAgIGNvbnN0IG1pbkVmZmVjdGl2ZVRpbWVvdXQgPSBtYXhSb3VuZFRyaXBMYXRlbmN5ICsgMTAwMDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpczUsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aChwYXlsb2FkKSA+IE1BWF9QQVlMT0FEX0JZVEVTKSB7XG4gICAgICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRScpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLmVuZ2luZS5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKChfZCA9IChfYyA9IHRoaXMuZW5naW5lLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52ZXJzaW9uLCAnMS44LjAnKSA8IDApIHtcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9TRVJWRVInKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVRpbWVvdXQgPSBNYXRoLm1heChyZXNwb25zZVRpbWVvdXQsIG1pbkVmZmVjdGl2ZVRpbWVvdXQpO1xuICAgICAgICAgIGNvbnN0IGlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hScGNSZXF1ZXN0KGRlc3RpbmF0aW9uSWRlbnRpdHksIGlkLCBtZXRob2QsIHBheWxvYWQsIGVmZmVjdGl2ZVRpbWVvdXQpO1xuICAgICAgICAgIGNvbnN0IGFja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ0NPTk5FQ1RJT05fVElNRU9VVCcpKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3BvbnNlVGltZW91dElkKTtcbiAgICAgICAgICB9LCBtYXhSb3VuZFRyaXBMYXRlbmN5KTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLnNldChpZCwge1xuICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4ge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZW91dElkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBkZXN0aW5hdGlvbklkZW50aXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ1JFU1BPTlNFX1RJTUVPVVQnKSk7XG4gICAgICAgICAgfSwgcmVzcG9uc2VUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuc2V0KGlkLCB7XG4gICAgICAgICAgICByZXNvbHZlOiAocmVzcG9uc2VQYXlsb2FkLCByZXNwb25zZUVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdBY2tzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JQQyByZXNwb25zZSByZWNlaXZlZCBiZWZvcmUgYWNrJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZW91dElkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZUVycm9yKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlUGF5bG9hZCAhPT0gbnVsbCAmJiByZXNwb25zZVBheWxvYWQgIT09IHZvaWQgMCA/IHJlc3BvbnNlUGF5bG9hZCA6ICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IGRlc3RpbmF0aW9uSWRlbnRpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHJvb20ucmVnaXN0ZXJScGNNZXRob2RgIGluc3RlYWRcbiAgICovXG4gIHJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKFwieW91J3JlIG92ZXJyaWRpbmcgdGhlIFJQQyBoYW5kbGVyIGZvciBtZXRob2QgXCIuY29uY2F0KG1ldGhvZCwgXCIsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yXCIpKTtcbiAgICB9XG4gICAgdGhpcy5ycGNIYW5kbGVycy5zZXQobWV0aG9kLCBoYW5kbGVyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByb29tLnVucmVnaXN0ZXJScGNNZXRob2RgIGluc3RlYWRcbiAgICovXG4gIHVucmVnaXN0ZXJScGNNZXRob2QobWV0aG9kKSB7XG4gICAgdGhpcy5ycGNIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgfVxuICAvKipcbiAgICogQ29udHJvbCB3aG8gY2FuIHN1YnNjcmliZSB0byBMb2NhbFBhcnRpY2lwYW50J3MgcHVibGlzaGVkIHRyYWNrcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYWxsIHBhcnRpY2lwYW50cyBjYW4gc3Vic2NyaWJlLiBUaGlzIGFsbG93cyBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gICAqIHdobyBpcyBhYmxlIHRvIHN1YnNjcmliZSBhdCBhIHBhcnRpY2lwYW50IGFuZCB0cmFjayBsZXZlbC5cbiAgICpcbiAgICogTm90ZTogaWYgYWNjZXNzIGlzIGdpdmVuIGF0IGEgdHJhY2stbGV2ZWwgKGkuZS4gYm90aCBbYWxsUGFydGljaXBhbnRzQWxsb3dlZF0gYW5kXG4gICAqIFtQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi5hbGxUcmFja3NBbGxvd2VkXSBhcmUgZmFsc2UpLCBhbnkgbmV3ZXIgcHVibGlzaGVkIHRyYWNrc1xuICAgKiB3aWxsIG5vdCBncmFudCBwZXJtaXNzaW9ucyB0byBhbnkgcGFydGljaXBhbnRzIGFuZCB3aWxsIHJlcXVpcmUgYSBzdWJzZXF1ZW50XG4gICAqIHBlcm1pc3Npb25zIHVwZGF0ZSB0byBhbGxvdyBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIEFsbG93cyBhbGwgcGFydGljaXBhbnRzIHRvIHN1YnNjcmliZSBhbGwgdHJhY2tzLlxuICAgKiAgVGFrZXMgcHJlY2VkZW5jZSBvdmVyIFtbcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXV0gaWYgc2V0IHRvIHRydWUuXG4gICAqICBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHRydWUuXG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgRnVsbCBsaXN0IG9mIGluZGl2aWR1YWwgcGVybWlzc2lvbnMgcGVyXG4gICAqICBwYXJ0aWNpcGFudC90cmFjay4gQW55IG9taXR0ZWQgcGFydGljaXBhbnRzIHdpbGwgbm90IHJlY2VpdmUgYW55IHBlcm1pc3Npb25zLlxuICAgKi9cbiAgc2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHNBbGxvd2VkKSB7XG4gICAgbGV0IHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM7XG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkO1xuICAgIGlmICghdGhpcy5lbmdpbmUuY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlSW5jb21pbmdScGNBY2socmVxdWVzdElkKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ0Fja3MuZ2V0KHJlcXVlc3RJZCk7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUocmVxdWVzdElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignQWNrIHJlY2VpdmVkIGZvciB1bmV4cGVjdGVkIFJQQyByZXF1ZXN0JywgcmVxdWVzdElkKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlSW5jb21pbmdScGNSZXNwb25zZShyZXF1ZXN0SWQsIHBheWxvYWQsIGVycm9yKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5nZXQocmVxdWVzdElkKTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlci5yZXNvbHZlKHBheWxvYWQsIGVycm9yKTtcbiAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUocmVxdWVzdElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignUmVzcG9uc2UgcmVjZWl2ZWQgZm9yIHVuZXhwZWN0ZWQgUlBDIHJlcXVlc3QnLCByZXF1ZXN0SWQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHB1Ymxpc2hScGNSZXF1ZXN0KGRlc3RpbmF0aW9uSWRlbnRpdHksIHJlcXVlc3RJZCwgbWV0aG9kLCBwYXlsb2FkLCByZXNwb25zZVRpbWVvdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdycGNSZXF1ZXN0JyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY1JlcXVlc3Qoe1xuICAgICAgICAgICAgaWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICByZXNwb25zZVRpbWVvdXRNczogcmVzcG9uc2VUaW1lb3V0LFxuICAgICAgICAgICAgdmVyc2lvbjogMVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQocGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIGZvciAoY29uc3QgW2lkLCB7XG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwZW5kaW5nSWRlbnRpdHlcbiAgICB9XSBvZiB0aGlzLnBlbmRpbmdBY2tzKSB7XG4gICAgICBpZiAocGVuZGluZ0lkZW50aXR5ID09PSBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQsIHtcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBlbmRpbmdJZGVudGl0eSxcbiAgICAgIHJlc29sdmVcbiAgICB9XSBvZiB0aGlzLnBlbmRpbmdSZXNwb25zZXMpIHtcbiAgICAgIGlmIChwZW5kaW5nSWRlbnRpdHkgPT09IHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgICAgcmVzb2x2ZShudWxsLCBScGNFcnJvci5idWlsdEluKCdSRUNJUElFTlRfRElTQ09OTkVDVEVEJykpO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRFbmFibGVkUHVibGlzaENvZGVjcyhjb2RlY3MpIHtcbiAgICB0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MgPSBjb2RlY3MuZmlsdGVyKGMgPT4gYy5taW1lLnNwbGl0KCcvJylbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvJyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIG11dGUgc3RhdHVzLlxuICAgIC8vIGlmIHNlcnZlcidzIHRyYWNrIG11dGUgc3RhdHVzIGRvZXNuJ3QgbWF0Y2ggYWN0dWFsLCB3ZSdsbCBoYXZlIHRvIHVwZGF0ZVxuICAgIC8vIHRoZSBzZXJ2ZXIncyBjb3B5XG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQodGkuc2lkKTtcbiAgICAgIGlmIChwdWIpIHtcbiAgICAgICAgY29uc3QgbXV0ZWRPblNlcnZlciA9IHB1Yi5pc011dGVkIHx8ICgoX2IgPSAoX2EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Vwc3RyZWFtUGF1c2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XG4gICAgICAgIGlmIChtdXRlZE9uU2VydmVyICE9PSB0aS5tdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyBzZXJ2ZXIgbXV0ZSBzdGF0ZSBhZnRlciByZWNvbmNpbGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpKSwge1xuICAgICAgICAgICAgbXV0ZWRPblNlcnZlclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZE11dGVUcmFjayh0aS5zaWQsIG11dGVkT25TZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRBY3RpdmVBZ2VudChhZ2VudCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICB0aGlzLmZpcnN0QWN0aXZlQWdlbnQgPSBhZ2VudDtcbiAgICBpZiAoYWdlbnQgJiYgIXRoaXMuZmlyc3RBY3RpdmVBZ2VudCkge1xuICAgICAgdGhpcy5maXJzdEFjdGl2ZUFnZW50ID0gYWdlbnQ7XG4gICAgfVxuICAgIGlmIChhZ2VudCkge1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBhZ2VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIChfZCA9IChfYyA9IHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWplY3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBuZXcgRXJyb3IoJ0FnZW50IGRpc2Nvbm5lY3RlZCcpKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB3YWl0VW50aWxBY3RpdmVBZ2VudFByZXNlbnQoKSB7XG4gICAgaWYgKHRoaXMuZmlyc3RBY3RpdmVBZ2VudCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmZpcnN0QWN0aXZlQWdlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYWN0aXZlQWdlbnRGdXR1cmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlLnByb21pc2U7XG4gIH1cbiAgZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjaykge1xuICAgIGxldCBwdWJsaWNhdGlvbjtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVHJhY2sgPSBwdWIudHJhY2s7XG4gICAgICBpZiAoIWxvY2FsVHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBsb29rcyBvdmVybHkgY29tcGxpY2F0ZWQgZHVlIHRvIHRoaXMgb2JqZWN0IHRyZWVcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKGxvY2FsVHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKGxvY2FsVHJhY2spKSB7XG4gICAgICAgICAgaWYgKGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xuICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cbiAgd2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB3YWl0Rm9yUGVuZGluZ1RpbWVvdXQgPSAxMDAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IHN0YXJ0VGltZSArIHdhaXRGb3JQZW5kaW5nVGltZW91dCkge1xuICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZUVudHJ5ID0gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZW50cmllcygpKS5maW5kKF9yZWY0ID0+IHtcbiAgICAgICAgICBsZXQgW3BlbmRpbmdUcmFja10gPSBfcmVmNDtcbiAgICAgICAgICByZXR1cm4gcGVuZGluZ1RyYWNrLnNvdXJjZSA9PT0gc291cmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHB1Ymxpc2hQcm9taXNlRW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gcHVibGlzaFByb21pc2VFbnRyeVsxXTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBzbGVlcCgyMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgYXV0b1N1YnNjcmliZSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy50cmFjayA9IHVuZGVmaW5lZDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLnJlcXVlc3RlZERpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSB2aXNpYmxlID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiYWRhcHRpdmVzdHJlYW0gdmlkZW8gdmlzaWJpbGl0eSBcIi5jb25jYXQodGhpcy50cmFja1NpZCwgXCIsIHZpc2libGU9XCIpLmNvbmNhdCh2aXNpYmxlKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGU7XG4gICAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UgPSBkaW1lbnNpb25zID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiYWRhcHRpdmVzdHJlYW0gdmlkZW8gZGltZW5zaW9ucyBcIi5jb25jYXQoZGltZW5zaW9ucy53aWR0aCwgXCJ4XCIpLmNvbmNhdChkaW1lbnNpb25zLmhlaWdodCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9uc0FkYXB0aXZlU3RyZWFtID0gZGltZW5zaW9ucztcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBhdXRvU3Vic2NyaWJlO1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB0byB0aGlzIHJlbW90ZSB0cmFja1xuICAgKiBAcGFyYW0gc3Vic2NyaWJlZCB0cnVlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBmYWxzZSB0byB1bnN1YnNjcmliZVxuICAgKi9cbiAgc2V0U3Vic2NyaWJlZChzdWJzY3JpYmVkKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IHN1YnNjcmliZWQ7XG4gICAgLy8gcmVzZXQgYWxsb3dlZCBzdGF0dXMgd2hlbiBkZXNpcmVkIHN1YnNjcmlwdGlvbiBzdGF0ZSBjaGFuZ2VzXG4gICAgLy8gc2VydmVyIHdpbGwgbm90aWZ5IGNsaWVudCB2aWEgc2lnbmFsIG1lc3NhZ2UgaWYgaXQncyBub3QgYWxsb3dlZFxuICAgIGlmIChzdWJzY3JpYmVkKSB7XG4gICAgICB0aGlzLmFsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWIgPSBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgc3Vic2NyaWJlOiB0aGlzLnN1YnNjcmliZWQsXG4gICAgICBwYXJ0aWNpcGFudFRyYWNrczogW25ldyBQYXJ0aWNpcGFudFRyYWNrcyh7XG4gICAgICAgIC8vIHNlbmRpbmcgYW4gZW1wdHkgcGFydGljaXBhbnQgaWQgc2luY2UgVHJhY2tQdWJsaWNhdGlvbiBkb2Vzbid0IGtlZXAgaXRcbiAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgaW4gYnkgdGhlIHBhcnRpY2lwYW50IHRoYXQgcmVjZWl2ZXMgdGhpcyBtZXNzYWdlXG4gICAgICAgIHBhcnRpY2lwYW50U2lkOiAnJyxcbiAgICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF1cbiAgICAgIH0pXVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gIH1cbiAgZ2V0IHN1YnNjcmlwdGlvblN0YXR1cygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlVuc3Vic2NyaWJlZDtcbiAgICB9XG4gICAgaWYgKCFzdXBlci5pc1N1YnNjcmliZWQpIHtcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5EZXNpcmVkO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuU3Vic2NyaWJlZDtcbiAgfVxuICBnZXQgcGVybWlzc2lvblN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkID8gVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLkFsbG93ZWQgOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMuTm90QWxsb3dlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRyYWNrIGlzIHN1YnNjcmliZWQsIGFuZCByZWFkeSBmb3IgcGxheWJhY2tcbiAgICovXG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzU3Vic2NyaWJlZDtcbiAgfVxuICAvLyByZXR1cm5zIGNsaWVudCdzIGRlc2lyZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgYWxzbyB0cnVlIGlmIGF1dG9TdWJzY3JpYmUgaXMgZW5hYmxlZFxuICBnZXQgaXNEZXNpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQgIT09IGZhbHNlO1xuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdGVkRGlzYWJsZWQgIT09IHVuZGVmaW5lZCA/ICF0aGlzLnJlcXVlc3RlZERpc2FibGVkIDogdGhpcy5pc0FkYXB0aXZlU3RyZWFtID8gdGhpcy52aXNpYmxlIDogdHJ1ZTtcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIGRpc2FibGUgc2VydmVyIGZyb20gc2VuZGluZyBkb3duIGRhdGEgZm9yIHRoaXMgdHJhY2suIHRoaXMgaXMgdXNlZnVsIHdoZW5cbiAgICogdGhlIHBhcnRpY2lwYW50IGlzIG9mZiBzY3JlZW4sIHlvdSBtYXkgZGlzYWJsZSBzdHJlYW1pbmcgZG93biB0aGVpciB2aWRlb1xuICAgKiB0byByZWR1Y2UgYmFuZHdpZHRoIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0gZW5hYmxlZFxuICAgKi9cbiAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMucmVxdWVzdGVkRGlzYWJsZWQgPT09ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdGVkRGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBmb3IgdHJhY2tzIHRoYXQgc3VwcG9ydCBzaW11bGNhc3RpbmcsIGFkanVzdCBzdWJzY3JpYmVkIHF1YWxpdHlcbiAgICpcbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhlIGhpZ2hlc3QgcXVhbGl0eSB0aGUgY2xpZW50IGNhbiBhY2NlcHQuIGlmIG5ldHdvcmtcbiAgICogYmFuZHdpZHRoIGRvZXMgbm90IGFsbG93LCBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZHVjZSBxdWFsaXR5IHRvXG4gICAqIG9wdGltaXplIGZvciB1bmludGVycnVwdGVkIHZpZGVvXG4gICAqL1xuICBzZXRWaWRlb1F1YWxpdHkocXVhbGl0eSkge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLnJlcXVlc3RlZE1heFF1YWxpdHkgPT09IHF1YWxpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0ZWRNYXhRdWFsaXR5ID0gcXVhbGl0eTtcbiAgICB0aGlzLnJlcXVlc3RlZFZpZGVvRGltZW5zaW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBFeHBsaWNpdGx5IHNldCB0aGUgdmlkZW8gZGltZW5zaW9ucyBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogVGhpcyB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIGFkYXB0aXZlIHN0cmVhbSBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZGltZW5zaW9ucyBUaGUgdmlkZW8gZGltZW5zaW9ucyB0byBzZXQuXG4gICAqL1xuICBzZXRWaWRlb0RpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoKF9hID0gdGhpcy5yZXF1ZXN0ZWRWaWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgPT09IGRpbWVuc2lvbnMud2lkdGggJiYgKChfYiA9IHRoaXMucmVxdWVzdGVkVmlkZW9EaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSA9PT0gZGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVtb3RlVmlkZW9UcmFjayh0aGlzLnRyYWNrKSkge1xuICAgICAgdGhpcy5yZXF1ZXN0ZWRWaWRlb0RpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RlZE1heFF1YWxpdHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICBzZXRWaWRlb0ZQUyhmcHMpIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc1JlbW90ZVZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnBzID09PSBmcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcHMgPSBmcHM7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICBnZXQgdmlkZW9RdWFsaXR5KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yZXF1ZXN0ZWRNYXhRdWFsaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWaWRlb1F1YWxpdHkuSElHSDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZUcmFjayA9IHRoaXMudHJhY2s7XG4gICAgaWYgKHByZXZUcmFjayA9PT0gdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZUcmFjaykge1xuICAgICAgLy8gdW5yZWdpc3RlciBsaXN0ZW5lclxuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICBwcmV2VHJhY2suZGV0YWNoKCk7XG4gICAgICBwcmV2VHJhY2suc3RvcE1vbml0b3IoKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldlRyYWNrKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc2lkID0gdGhpcy50cmFja1NpZDtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2spO1xuICAgIH1cbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRBbGxvd2VkKGFsbG93ZWQpIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgdGhpcy5hbGxvd2VkID0gYWxsb3dlZDtcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRTdWJzY3JpcHRpb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgc3VwZXIudXBkYXRlSW5mbyhpbmZvKTtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGFNdXRlZCA9IHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBpbmZvLm11dGVkO1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLnNldE11dGVkKGluZm8ubXV0ZWQpO1xuICAgIH0gZWxzZSBpZiAocHJldk1ldGFkYXRhTXV0ZWQgIT09IGluZm8ubXV0ZWQpIHtcbiAgICAgIHRoaXMuZW1pdChpbmZvLm11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfVxuICB9XG4gIGVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNTdGF0dXMpIHtcbiAgICBjb25zdCBjdXJyZW50U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgaWYgKHByZXZpb3VzU3RhdHVzID09PSBjdXJyZW50U3RhdHVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIGN1cnJlbnRTdGF0dXMsIHByZXZpb3VzU3RhdHVzKTtcbiAgfVxuICBlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvblN0YXR1cyA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICBpZiAoY3VycmVudFBlcm1pc3Npb25TdGF0dXMgIT09IHByZXZpb3VzUGVybWlzc2lvblN0YXR1cykge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHRoaXMucGVybWlzc2lvblN0YXR1cywgcHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkge1xuICAgIGlmICghdGhpcy5pc0Rlc2lyZWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2Nhbm5vdCB1cGRhdGUgdHJhY2sgc2V0dGluZ3Mgd2hlbiBub3Qgc3Vic2NyaWJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBpc0FkYXB0aXZlU3RyZWFtKCkge1xuICAgIHJldHVybiBpc1JlbW90ZVZpZGVvVHJhY2sodGhpcy50cmFjaykgJiYgdGhpcy50cmFjay5pc0FkYXB0aXZlU3RyZWFtO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBlbWl0VHJhY2tVcGRhdGUoKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncyh7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIGRpc2FibGVkOiAhdGhpcy5pc0VuYWJsZWQsXG4gICAgICBmcHM6IHRoaXMuZnBzXG4gICAgfSk7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgbGV0IG1pbkRpbWVuc2lvbnMgPSB0aGlzLnJlcXVlc3RlZFZpZGVvRGltZW5zaW9ucztcbiAgICAgIGlmICh0aGlzLnZpZGVvRGltZW5zaW9uc0FkYXB0aXZlU3RyZWFtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG1pbkRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBhZGFwdGl2ZSBzdHJlYW0gZGltZW5zaW9ucyBhcmUgc21hbGxlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGltZW5zaW9ucyBhbmQgdXNlIHNtYWxsZXIgb25lXG4gICAgICAgICAgY29uc3Qgc21hbGxlckFkYXB0aXZlID0gYXJlRGltZW5zaW9uc1NtYWxsZXIodGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbSwgbWluRGltZW5zaW9ucyk7XG4gICAgICAgICAgaWYgKHNtYWxsZXJBZGFwdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGFkYXB0aXZlIHN0cmVhbSBkaW1lbnNpb25zIGluc3RlYWQgb2YgcmVxdWVzdGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB0aGlzLnZpZGVvRGltZW5zaW9uc0FkYXB0aXZlU3RyZWFtKSk7XG4gICAgICAgICAgICBtaW5EaW1lbnNpb25zID0gdGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0ZWRNYXhRdWFsaXR5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy50cmFja0luZm8pIHtcbiAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGFkYXB0aXZlIHN0cmVhbSBkaW1lbnNpb25zIGFyZSBzbWFsbGVyIHRoYW4gdGhlIG1heCBxdWFsaXR5IGxheWVyIGFuZCB1c2Ugc21hbGxlciBvbmVcbiAgICAgICAgICBjb25zdCBtYXhRdWFsaXR5TGF5ZXIgPSBsYXllckRpbWVuc2lvbnNGb3IodGhpcy50cmFja0luZm8sIHRoaXMucmVxdWVzdGVkTWF4UXVhbGl0eSk7XG4gICAgICAgICAgaWYgKG1heFF1YWxpdHlMYXllciAmJiBhcmVEaW1lbnNpb25zU21hbGxlcih0aGlzLnZpZGVvRGltZW5zaW9uc0FkYXB0aXZlU3RyZWFtLCBtYXhRdWFsaXR5TGF5ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYWRhcHRpdmUgc3RyZWFtIGRpbWVuc2lvbnMgaW5zdGVhZCBvZiBtYXggcXVhbGl0eSBsYXllcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgdGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbSkpO1xuICAgICAgICAgICAgbWluRGltZW5zaW9ucyA9IHRoaXMudmlkZW9EaW1lbnNpb25zQWRhcHRpdmVTdHJlYW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGFwdGl2ZSBzdHJlYW0gZGltZW5zaW9ucycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgdGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbSkpO1xuICAgICAgICAgIG1pbkRpbWVuc2lvbnMgPSB0aGlzLnZpZGVvRGltZW5zaW9uc0FkYXB0aXZlU3RyZWFtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWluRGltZW5zaW9ucykge1xuICAgICAgICBzZXR0aW5ncy53aWR0aCA9IE1hdGguY2VpbChtaW5EaW1lbnNpb25zLndpZHRoKTtcbiAgICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKG1pbkRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0ZWRNYXhRdWFsaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIHJlcXVlc3RlZCBtYXggcXVhbGl0eScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHF1YWxpdHk6IHRoaXMucmVxdWVzdGVkTWF4UXVhbGl0eVxuICAgICAgICB9KSk7XG4gICAgICAgIHNldHRpbmdzLnF1YWxpdHkgPSB0aGlzLnJlcXVlc3RlZE1heFF1YWxpdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgZGVmYXVsdCBxdWFsaXR5JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgcXVhbGl0eTogVmlkZW9RdWFsaXR5LkhJR0hcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBkZWZhdWx0cyB0byBoaWdoIHF1YWxpdHlcbiAgICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5ISUdIO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcGRhdGVTZXR0aW5ncywgc2V0dGluZ3MpO1xuICB9XG59XG5cbmNsYXNzIFJlbW90ZVBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBmcm9tUGFydGljaXBhbnRJbmZvKHNpZ25hbENsaWVudCwgcGksIGxvZ2dlck9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlbW90ZVBhcnRpY2lwYW50KHNpZ25hbENsaWVudCwgcGkuc2lkLCBwaS5pZGVudGl0eSwgcGkubmFtZSwgcGkubWV0YWRhdGEsIHBpLmF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMsIHBpLmtpbmQpO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLmxvZ0NvbnRleHQpLCB7XG4gICAgICBycElEOiB0aGlzLnNpZCxcbiAgICAgIHJlbW90ZVBhcnRpY2lwYW50OiB0aGlzLmlkZW50aXR5XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWduYWxDbGllbnQsIHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgbGV0IGtpbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IFBhcnRpY2lwYW50SW5mb19LaW5kLlNUQU5EQVJEO1xuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHkgfHwgJycsIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zLCBraW5kKTtcbiAgICB0aGlzLnNpZ25hbENsaWVudCA9IHNpZ25hbENsaWVudDtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52b2x1bWVNYXAgPSBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xuICAgIHN1cGVyLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgIC8vIHJlZ2lzdGVyIGFjdGlvbiBldmVudHNcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVNldHRpbmdzLCBzZXR0aW5ncyA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZCB1cGRhdGUgc2V0dGluZ3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpLCB7XG4gICAgICAgIHNldHRpbmdzXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIHN1YiA9PiB7XG4gICAgICBzdWIucGFydGljaXBhbnRUcmFja3MuZm9yRWFjaChwdCA9PiB7XG4gICAgICAgIHB0LnBhcnRpY2lwYW50U2lkID0gdGhpcy5zaWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBzdGF0dXMgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBzdGF0dXMgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWJsaWNhdGlvbiwgc3RhdHVzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmliZWQsIHRyYWNrID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldmlvdXNUcmFjayA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgcHJldmlvdXNUcmFjaywgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uRmFpbGVkLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgcHVibGljYXRpb24udHJhY2tTaWQsIGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSkge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgb24gdGhlIHBhcnRpY2lwYW50J3MgYXVkaW8gdHJhY2tcbiAgICogYnkgZGVmYXVsdCwgdGhpcyBhZmZlY3RzIHRoZSBtaWNyb3Bob25lIHB1YmxpY2F0aW9uXG4gICAqIGEgZGlmZmVyZW50IHNvdXJjZSBjYW4gYmUgcGFzc2VkIGluIGFzIGEgc2Vjb25kIGFyZ3VtZW50XG4gICAqIGlmIG5vIHRyYWNrIGV4aXN0cyB0aGUgdm9sdW1lIHdpbGwgYmUgYXBwbGllZCB3aGVuIHRoZSBtaWNyb3Bob25lIHRyYWNrIGlzIGFkZGVkXG4gICAqL1xuICBzZXRWb2x1bWUodm9sdW1lKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgdGhpcy52b2x1bWVNYXAuc2V0KHNvdXJjZSwgdm9sdW1lKTtcbiAgICBjb25zdCBhdWRpb1B1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgYXVkaW9QdWJsaWNhdGlvbi50cmFjay5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrXG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmIChhdWRpb1B1YmxpY2F0aW9uICYmIGF1ZGlvUHVibGljYXRpb24udHJhY2spIHtcbiAgICAgIHJldHVybiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrLmdldFZvbHVtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52b2x1bWVNYXAuZ2V0KHNvdXJjZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCBzaWQsIG1lZGlhU3RyZWFtLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncywgdHJpZXNMZWZ0KSB7XG4gICAgLy8gZmluZCB0aGUgdHJhY2sgcHVibGljYXRpb25cbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgbWVkaWEgdHJhY2sgdG8gYXJyaXZlIGJlZm9yZSBwYXJ0aWNpcGFudCBpbmZvXG4gICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQoc2lkKTtcbiAgICAvLyBpdCdzIGFsc28gcG9zc2libGUgdGhhdCB0aGUgYnJvd3NlciBkaWRuJ3QgaG9ub3Igb3VyIG9yaWdpbmFsIHRyYWNrIGlkXG4gICAgLy8gRmlyZUZveCB3b3VsZCB1c2UgaXRzIG93biBsb2NhbCB1dWlkIGluc3RlYWQgb2Ygc2VydmVyIHRyYWNrIGlkXG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgaWYgKCFzaWQuc3RhcnRzV2l0aCgnVFInKSkge1xuICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdHlwZVxuICAgICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgaWYgKCFwdWJsaWNhdGlvbiAmJiBtZWRpYVRyYWNrLmtpbmQgPT09IHAua2luZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2hlbiB3ZSBjb3VsZG4ndCBsb2NhdGUgdGhlIHRyYWNrLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIG1ldGFkYXRhIGhhc24ndFxuICAgIC8vIHlldCBhcnJpdmVkLiBXYWl0IGEgYml0IGxvbmdlciBmb3IgaXQgdG8gYXJyaXZlLCBvciBmaXJlIGFuIGVycm9yXG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gMCkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGZpbmQgcHVibGlzaGVkIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgdHJhY2tTaWQ6IHNpZFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSB1bmRlZmluZWQpIHRyaWVzTGVmdCA9IDIwO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCAtIDEpO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ3VuYWJsZSB0byBzdWJzY3JpYmUgYmVjYXVzZSBNZWRpYVN0cmVhbVRyYWNrIGlzIGVuZGVkLiBEbyBub3QgY2FsbCBNZWRpYVN0cmVhbVRyYWNrLnN0b3AoKScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1ZpZGVvID0gbWVkaWFUcmFjay5raW5kID09PSAndmlkZW8nO1xuICAgIGxldCB0cmFjaztcbiAgICBpZiAoaXNWaWRlbykge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVmlkZW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlQXVkaW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCB0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdWRpb091dHB1dCk7XG4gICAgfVxuICAgIC8vIHNldCB0cmFjayBpbmZvXG4gICAgdHJhY2suc291cmNlID0gcHVibGljYXRpb24uc291cmNlO1xuICAgIC8vIGtlZXAgcHVibGljYXRpb24ncyBtdXRlZCBzdGF0dXNcbiAgICB0cmFjay5pc011dGVkID0gcHVibGljYXRpb24uaXNNdXRlZDtcbiAgICB0cmFjay5zZXRNZWRpYVN0cmVhbShtZWRpYVN0cmVhbSk7XG4gICAgdHJhY2suc3RhcnQoKTtcbiAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh0cmFjayk7XG4gICAgLy8gc2V0IHBhcnRpY2lwYW50IHZvbHVtZXMgb24gbmV3IGF1ZGlvIHRyYWNrc1xuICAgIGlmICh0aGlzLnZvbHVtZU1hcC5oYXMocHVibGljYXRpb24uc291cmNlKSAmJiBpc1JlbW90ZVRyYWNrKHRyYWNrKSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICB0cmFjay5zZXRWb2x1bWUodGhpcy52b2x1bWVNYXAuZ2V0KHB1YmxpY2F0aW9uLnNvdXJjZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgaGFzTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wYXJ0aWNpcGFudEluZm87XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHNpZCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldChzaWQpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHdlIGFyZSBnZXR0aW5nIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIHRyYWNrcywgcmVjb25jaWxlIGluIGhlcmVcbiAgICAvLyBhbmQgc2VuZCBvdXQgZXZlbnRzIGZvciBjaGFuZ2VzXG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIHB1YmxpY2F0aW9ucywgcHVibGlzaCBldmVudHMgb25seSBpZiBtZXRhZGF0YSBpcyBhbHJlYWR5IHRoZXJlXG4gICAgLy8gaS5lLiBjaGFuZ2VzIHNpbmNlIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCBoYXMgam9pbmVkXG4gICAgY29uc3QgdmFsaWRUcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIGluZm8udHJhY2tzLmZvckVhY2godGkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHRpLnNpZCk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgIC8vIG5ldyBwdWJsaWNhdGlvblxuICAgICAgICBjb25zdCBraW5kID0gVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcbiAgICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uID0gbmV3IFJlbW90ZVRyYWNrUHVibGljYXRpb24oa2luZCwgdGksIChfYSA9IHRoaXMuc2lnbmFsQ2xpZW50LmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b1N1YnNjcmliZSwge1xuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIGxvZ2dlck5hbWU6IChfYiA9IHRoaXMubG9nZ2VyT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxvZ2dlck5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgICBuZXdUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrT2ZTb3VyY2UgPSBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbmQocHVibGlzaGVkVHJhY2sgPT4gcHVibGlzaGVkVHJhY2suc291cmNlID09PSAocHVibGljYXRpb24gPT09IG51bGwgfHwgcHVibGljYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1YmxpY2F0aW9uLnNvdXJjZSkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdUcmFja09mU291cmNlICYmIHB1YmxpY2F0aW9uLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlVua25vd24pIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY2VpdmVkIGEgc2Vjb25kIHRyYWNrIHB1YmxpY2F0aW9uIGZvciBcIi5jb25jYXQodGhpcy5pZGVudGl0eSwgXCIgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiKS5jb25jYXQocHVibGljYXRpb24uc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBvbGRUcmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1RyYWNrT2ZTb3VyY2UpLFxuICAgICAgICAgICAgbmV3VHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWJsaWNhdGlvbi51cGRhdGVJbmZvKHRpKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkVHJhY2tzLnNldCh0aS5zaWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICAvLyBkZXRlY3QgcmVtb3ZlZCB0cmFja3NcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgaWYgKCF2YWxpZFRyYWNrcy5oYXMocHVibGljYXRpb24udHJhY2tTaWQpKSB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdkZXRlY3RlZCByZW1vdmVkIHRyYWNrIG9uIHJlbW90ZSBwYXJ0aWNpcGFudCwgdW5wdWJsaXNoaW5nJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xuICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhbHdheXMgZW1pdCBldmVudHMgZm9yIG5ldyBwdWJsaWNhdGlvbnMsIFJvb20gd2lsbCBub3QgZm9yd2FyZCB0aGVtIHVubGVzcyBpdCdzIHJlYWR5XG4gICAgbmV3VHJhY2tzLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVucHVibGlzaFRyYWNrKHNpZCwgc2VuZFVucHVibGlzaCkge1xuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQoc2lkKTtcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFsc28gc2VuZCB1bnN1YnNjcmliZSwgaWYgdHJhY2sgaXMgYWN0aXZlbHkgc3Vic2NyaWJlZFxuICAgIGNvbnN0IHtcbiAgICAgIHRyYWNrXG4gICAgfSA9IHB1YmxpY2F0aW9uO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHRyYWNrIGZyb20gbWFwcyBvbmx5IGFmdGVyIHVuc3Vic2NyaWJlZCBoYXMgYmVlbiBmaXJlZFxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XG4gICAgLy8gcmVtb3ZlIGZyb20gdGhlIHJpZ2h0IHR5cGUgbWFwXG4gICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzZW5kVW5wdWJsaXNoKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvT3V0cHV0KG91dHB1dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmF1ZGlvT3V0cHV0ID0gb3V0cHV0O1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGlzQXVkaW9UcmFjayhwdWIudHJhY2spICYmIGlzUmVtb3RlVHJhY2socHViLnRyYWNrKSkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHViLnRyYWNrLnNldFNpbmtJZCgoX2EgPSBvdXRwdXQuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdkZWZhdWx0JykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdGhpcy5sb2cudHJhY2UoJ3BhcnRpY2lwYW50IGV2ZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBldmVudCxcbiAgICAgIGFyZ3NcbiAgICB9KSk7XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9XG59XG5cbnZhciBDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xuICBDb25uZWN0aW9uU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICBDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0aW5nXCJdID0gXCJjb25uZWN0aW5nXCI7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIlJlY29ubmVjdGluZ1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIlNpZ25hbFJlY29ubmVjdGluZ1wiXSA9IFwic2lnbmFsUmVjb25uZWN0aW5nXCI7XG59KShDb25uZWN0aW9uU3RhdGUgfHwgKENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG5jb25zdCBDT05ORUNUSU9OX1JFQ09OQ0lMRV9GUkVRVUVOQ1lfTVMgPSA0ICogMTAwMDtcbi8qKlxuICogSW4gTGl2ZUtpdCwgYSByb29tIGlzIHRoZSBsb2dpY2FsIGdyb3VwaW5nIGZvciBhIGxpc3Qgb2YgcGFydGljaXBhbnRzLlxuICogUGFydGljaXBhbnRzIGluIGEgcm9vbSBjYW4gcHVibGlzaCB0cmFja3MsIGFuZCBzdWJzY3JpYmUgdG8gb3RoZXJzJyB0cmFja3MuXG4gKlxuICogYSBSb29tIGZpcmVzIFtbUm9vbUV2ZW50IHwgUm9vbUV2ZW50c11dLlxuICpcbiAqIEBub0luaGVyaXREb2NcbiAqL1xuY2xhc3MgUm9vbSBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgZ2V0IGhhc0UyRUVTZXR1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5lMmVlTWFuYWdlciAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJvb20sIHRoZSBwcmltYXJ5IGNvbnN0cnVjdCBmb3IgYSBMaXZlS2l0IHNlc3Npb24uXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHN1cGVyKCk7XG4gICAgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgcGFydGljaXBhbnRzIHRoYXQgYXJlIGFjdGl2ZWx5IHNwZWFraW5nLiB3aGVuIHRoaXMgY2hhbmdlc1xuICAgICAqIGEgW1tSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXV0gZXZlbnQgaXMgZmlyZWRcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XG4gICAgLyoqIHJlZmxlY3RzIHRoZSBzZW5kZXIgZW5jcnlwdGlvbiBzdGF0dXMgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50ICovXG4gICAgdGhpcy5pc0UyRUVFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ycGNIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbm5lY3QgPSAodXJsLCB0b2tlbiwgb3B0cykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFpc0Jyb3dzZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJXZWJSVEMgaXNuJ3QgZGV0ZWN0ZWQsIGhhdmUgeW91IGNhbGxlZCByZWdpc3Rlckdsb2JhbHM/XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiTGl2ZUtpdCBkb2Vzbid0IHNlZW0gdG8gYmUgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4gVHJ5IHRvIHVwZGF0ZSB5b3VyIGJyb3dzZXIgYW5kIG1ha2Ugc3VyZSBubyBicm93c2VyIGV4dGVuc2lvbnMgYXJlIGRpc2FibGluZyB3ZWJSVEMuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJbiBjYXNlIGEgZGlzY29ubmVjdCBjYWxsZWQgaGFwcGVuZWQgcmlnaHQgYmVmb3JlIHRoZSBjb25uZWN0IGNhbGwsIG1ha2Ugc3VyZSB0aGUgZGlzY29ubmVjdCBpcyBjb21wbGV0ZWQgZmlyc3QgYnkgYXdhaXRpbmcgaXRzIGxvY2tcbiAgICAgIGNvbnN0IHVubG9ja0Rpc2Nvbm5lY3QgPSB5aWVsZCB0aGlzLmRpc2Nvbm5lY3RMb2NrLmxvY2soKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIC8vIHdoZW4gdGhlIHN0YXRlIGlzIHJlY29ubmVjdGluZyBvciBjb25uZWN0ZWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiYWxyZWFkeSBjb25uZWN0ZWQgdG8gcm9vbSBcIi5jb25jYXQodGhpcy5uYW1lKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nKTtcbiAgICAgIGlmICgoKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFNlcnZlclVybCgpLnRvU3RyaW5nKCkpICE9PSB1cmwpIHtcbiAgICAgICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHVybCkpKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIudXBkYXRlVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IGZldGNoIHdpdGhvdXQgd2FpdGluZyBmb3IgYSByZXNwb25zZVxuICAgICAgICAvLyBpZiBpbml0aWFsIGNvbm5lY3Rpb24gZmFpbHMsIHRoaXMgd2lsbCBzcGVlZCB1cCBwaWNraW5nIHJlZ2lvbmFsIHVybFxuICAgICAgICAvLyBvbiBzdWJzZXF1ZW50IHJ1bnNcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci5mZXRjaFJlZ2lvblNldHRpbmdzKCkudGhlbihzZXR0aW5ncyA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIChfYSA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRTZXJ2ZXJSZXBvcnRlZFJlZ2lvbnMoc2V0dGluZ3MpO1xuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25uZWN0Rm4gPSAocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBsaWNpdCBjcmVhdGlvbiBhcyBsb2NhbCB2YXIgbmVlZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIgd2hlbiBwYXNzaW5nIGl0IHRvIGBhdHRlbXB0Q29ubmVjdGlvbmAgZnVydGhlciBkb3duXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGludGVudGlvbiB0byBjb25uZWN0IGhhcyBiZWVuIHNpZ25hbGxlZCBzbyB3ZSBjYW4gYWxsb3cgY2FuY2VsbGluZyBvZiB0aGUgY29ubmVjdGlvbiB2aWEgZGlzY29ubmVjdCgpIGFnYWluXG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QgPT09IG51bGwgfHwgdW5sb2NrRGlzY29ubmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIEJhY2tPZmZTdHJhdGVneS5nZXRJbnN0YW5jZSgpLmdldEJhY2tPZmZQcm9taXNlKHVybCk7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcignQ29ubmVjdGlvbiBhdHRlbXB0IGFib3J0ZWQnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB1cmwsIHRva2VuLCBvcHRzLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciAmJiBlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgJiYgZXJyb3IucmVhc29uICE9PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xuICAgICAgICAgICAgbGV0IG5leHRVcmwgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0ZldGNoaW5nIG5leHQgcmVnaW9uJyk7XG4gICAgICAgICAgICAgIG5leHRVcmwgPSB5aWVsZCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKChfYSA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHJlZ2lvbkZldGNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKHJlZ2lvbkZldGNoRXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgKHJlZ2lvbkZldGNoRXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgcmVnaW9uRmV0Y2hFcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKTtcbiAgICAgICAgICAgICAgICByZWplY3QocmVnaW9uRmV0Y2hFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBtYWtpbmcgc3VyZSB3ZSBvbmx5IHJlZ2lzdGVyIGZhaWxlZCBhdHRlbXB0cyBvbiB0aGluZ3Mgd2UgYWN0dWFsbHkgY2FyZSBhYm91dFxuICAgICAgICAgICAgW0Nvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5UaW1lb3V0XS5pbmNsdWRlcyhlcnJvci5yZWFzb24pKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdBZGRpbmcgZmFpbGVkIGNvbm5lY3Rpb24gYXR0ZW1wdCB0byBiYWNrIG9mZicpO1xuICAgICAgICAgICAgICBCYWNrT2ZmU3RyYXRlZ3kuZ2V0SW5zdGFuY2UoKS5hZGRGYWlsZWRDb25uZWN0aW9uQXR0ZW1wdCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRVcmwgJiYgISgoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpZ25hbC5hYm9ydGVkKSkge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKFwiSW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZCB3aXRoIENvbm5lY3Rpb25FcnJvcjogXCIuY29uY2F0KGVycm9yLm1lc3NhZ2UsIFwiLiBSZXRyeWluZyB3aXRoIGFub3RoZXIgcmVnaW9uOiBcIikuY29uY2F0KG5leHRVcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgICAgICAgIHlpZWxkIGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIG5leHRVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlzY29ubmVjdFJlYXNvbiA9IERpc2Nvbm5lY3RSZWFzb24uVU5LTk9XTl9SRUFTT047XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgZGlzY29ubmVjdFJlYXNvbiA9IGdldERpc2Nvbm5lY3RSZWFzb25Gcm9tQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgZGlzY29ubmVjdFJlYXNvbik7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZWdpb25VcmwgPSB0aGlzLnJlZ2lvblVybDtcbiAgICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jb25uZWN0RnV0dXJlID0gbmV3IEZ1dHVyZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIHJlZ2lvblVybCk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uRnV0dXJlcygpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0U2lnbmFsID0gKHVybCwgdG9rZW4sIGVuZ2luZSwgY29ubmVjdE9wdGlvbnMsIHJvb21PcHRpb25zLCBhYm9ydENvbnRyb2xsZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0geWllbGQgZW5naW5lLmpvaW4odXJsLCB0b2tlbiwge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiBjb25uZWN0T3B0aW9ucy5hdXRvU3Vic2NyaWJlLFxuICAgICAgICBhZGFwdGl2ZVN0cmVhbTogdHlwZW9mIHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0JyA/IHRydWUgOiByb29tT3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSxcbiAgICAgICAgbWF4UmV0cmllczogY29ubmVjdE9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgICAgZTJlZUVuYWJsZWQ6ICEhdGhpcy5lMmVlTWFuYWdlcixcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogY29ubmVjdE9wdGlvbnMud2Vic29ja2V0VGltZW91dCxcbiAgICAgICAgc2luZ2xlUGVlckNvbm5lY3Rpb246IHJvb21PcHRpb25zLnNpbmdsZVBlZXJDb25uZWN0aW9uXG4gICAgICB9LCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGxldCBzZXJ2ZXJJbmZvID0gam9pblJlc3BvbnNlLnNlcnZlckluZm87XG4gICAgICBpZiAoIXNlcnZlckluZm8pIHtcbiAgICAgICAgc2VydmVySW5mbyA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbixcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmVySW5mbyA9IHNlcnZlckluZm87XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImNvbm5lY3RlZCB0byBMaXZla2l0IFNlcnZlciBcIi5jb25jYXQoT2JqZWN0LmVudHJpZXMoc2VydmVySW5mbykubWFwKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQodmFsdWUpO1xuICAgICAgfSkuam9pbignLCAnKSksIHtcbiAgICAgICAgcm9vbTogKF9hID0gam9pblJlc3BvbnNlLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lLFxuICAgICAgICByb29tU2lkOiAoX2IgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpZCxcbiAgICAgICAgaWRlbnRpdHk6IChfYyA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlkZW50aXR5XG4gICAgICB9KTtcbiAgICAgIGlmICghc2VydmVySW5mby52ZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFNlcnZlcigndW5rbm93biBzZXJ2ZXIgdmVyc2lvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHNlcnZlckluZm8udmVyc2lvbiA9PT0gJzAuMTUuMScgJiYgdGhpcy5vcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdkaXNhYmxpbmcgZHluYWNhc3QgZHVlIHRvIHNlcnZlciB2ZXJzaW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgLy8gZHluYWNhc3QgaGFzIGEgYnVnIGluIDAuMTUuMSwgc28gd2UgY2Fubm90IHVzZSBpdCB0aGVuXG4gICAgICAgIHJvb21PcHRpb25zLmR5bmFjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgcGkgPSBqb2luUmVzcG9uc2UucGFydGljaXBhbnQ7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkID0gcGkuc2lkO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0RW5hYmxlZFB1Ymxpc2hDb2RlY3Moam9pblJlc3BvbnNlLmVuYWJsZWRQdWJsaXNoQ29kZWNzKTtcbiAgICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRTaWZUcmFpbGVyKGpvaW5SZXNwb25zZS5zaWZUcmFpbGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLmVycm9yKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdDb3VsZCBub3Qgc2V0IFNpZlRyYWlsZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwb3B1bGF0ZSByZW1vdGUgcGFydGljaXBhbnRzLCB0aGVzZSBzaG91bGQgbm90IHRyaWdnZXIgbmV3IGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoW3BpLCAuLi5qb2luUmVzcG9uc2Uub3RoZXJQYXJ0aWNpcGFudHNdKTtcbiAgICAgIGlmIChqb2luUmVzcG9uc2Uucm9vbSkge1xuICAgICAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUoam9pblJlc3BvbnNlLnJvb20pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbiA9ICh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydENvbnRyb2xsZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCB0aGlzLmlzUmVzdW1pbmcgfHwgKChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVuZGluZ1JlY29ubmVjdCkpIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbygnUmVjb25uZWN0aW9uIGF0dGVtcHQgcmVwbGFjZWQgYnkgbmV3IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2IgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNDbG91ZCgpKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLnNldFJlZ2lvblVybFByb3ZpZGVyKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCk7XG4gICAgICB0aGlzLmNvbm5PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzKSwgb3B0cyk7XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWcpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucnRjQ29uZmlnID0gdGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNvbm5lY3RTaWduYWwodXJsLCB0b2tlbiwgdGhpcy5lbmdpbmUsIHRoaXMuY29ubk9wdGlvbnMsIHRoaXMub3B0aW9ucywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZShqb2luUmVzcG9uc2UpO1xuICAgICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgICB0aGlzLnNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIsIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCA/IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgOiBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpO1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5tZXNzYWdlID0gXCJcIi5jb25jYXQocmVzdWx0aW5nRXJyb3IubWVzc2FnZSwgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5yZWFzb24gPSBlcnIucmVhc29uO1xuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLnN0YXR1cyA9IGVyci5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJlcnJvciB0cnlpbmcgdG8gZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfSkpO1xuICAgICAgICB0aHJvdyByZXN1bHRpbmdFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiQ29ubmVjdGlvbiBhdHRlbXB0IGFib3J0ZWRcIiwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS53YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbih0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dCwgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgLy8gYWxzbyBob29rIHVubG9hZCBldmVudFxuICAgICAgaWYgKGlzV2ViKCkgJiYgdGhpcy5vcHRpb25zLmRpc2Nvbm5lY3RPblBhZ2VMZWF2ZSkge1xuICAgICAgICAvLyBjYXB0dXJpbmcgYm90aCAncGFnZWhpZGUnIGFuZCAnYmVmb3JldW5sb2FkJyB0byBjYXB0dXJlIGJyb2FkZXN0IHNldCBvZiBicm93c2VyIGJlaGF2aW9yc1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnJlZXplJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3RlZCk7XG4gICAgICBCYWNrT2ZmU3RyYXRlZ3kuZ2V0SW5zdGFuY2UoKS5yZXNldEZhaWxlZENvbm5lY3Rpb25BdHRlbXB0cyh1cmwpO1xuICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIC8vIE5vdGlmeSByZWdpb24gcHJvdmlkZXIgYWJvdXQgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLm5vdGlmeUNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxuICAgICAqL1xuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzXzEgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NfMVtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIFsuLi5hcmdzXzFdLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgIGxldCBzdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBfdGhpczIuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5sb2cuZGVidWcoJ2FscmVhZHkgZGlzY29ubmVjdGVkJywgX3RoaXMyLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oJ2Rpc2Nvbm5lY3QgZnJvbSByb29tJywgT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMyLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgICAgIGlmIChfdGhpczIuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8IF90aGlzMi5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCBfdGhpczIuaXNSZXN1bWluZykge1xuICAgICAgICAgICAgICAvLyB0cnkgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ0Fib3J0IGNvbm5lY3Rpb24gYXR0ZW1wdCBkdWUgdG8gdXNlciBpbml0aWF0ZWQgZGlzY29ubmVjdCc7XG4gICAgICAgICAgICAgIF90aGlzMi5sb2cud2Fybihtc2csIF90aGlzMi5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgKF9hID0gX3RoaXMyLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KG1zZyk7XG4gICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGFib3J0IGNvbnRyb2xsZXIgZGlkbid0IG1hbmFnZSB0byBjYW5jZWwgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCwgcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2UgZXhwbGljaXRseVxuICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfdGhpczIuY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIG5ldyBDb25uZWN0aW9uRXJyb3IoJ0NsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcbiAgICAgICAgICAgICAgX3RoaXMyLmNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbG9zZSBlbmdpbmUgKGFsc28gY2xvc2VzIGNsaWVudClcbiAgICAgICAgICAgIGlmIChfdGhpczIuZW5naW5lKSB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgbGVhdmVcbiAgICAgICAgICAgICAgaWYgKCFfdGhpczIuZW5naW5lLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzMi5lbmdpbmUuY2xpZW50LnNlbmRMZWF2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHlpZWxkIF90aGlzMi5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMi5oYW5kbGVEaXNjb25uZWN0KHN0b3BUcmFja3MsIERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCk7XG4gICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICBfdGhpczIuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5vblBhZ2VMZWF2ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmluZm8oJ1BhZ2UgbGVhdmUgZGV0ZWN0ZWQsIGRpc2Nvbm5lY3RpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xuICAgICAqIHNvbWUgZm9ybSBvZiB1c2VyIGludGVyYWN0aW9uIChjbGljay90YXAvZXRjKS5cbiAgICAgKiBJbiB0aG9zZSBjYXNlcywgYXVkaW8gd2lsbCBiZSBzaWxlbnQgdW50aWwgYSBjbGljay90YXAgdHJpZ2dlcmluZyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAqIC0gYHN0YXJ0QXVkaW9gXG4gICAgICogLSBgZ2V0VXNlck1lZGlhYFxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRBdWRpbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci5vcyA9PT0gJ2lPUycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlPUyBibG9ja3MgYXVkaW8gZWxlbWVudCBwbGF5YmFjayBpZlxuICAgICAgICAgKiAtIHVzZXIgaXMgbm90IHB1Ymxpc2hpbmcgYXVkaW8gdGhlbXNlbHZlcyBhbmRcbiAgICAgICAgICogLSBubyBvdGhlciBhdWRpbyBzb3VyY2UgaXMgcGxheWluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBhcyBhIHdvcmthcm91bmQsIHdlIGNyZWF0ZSBhbiBhdWRpbyBlbGVtZW50IHdpdGggYW4gZW1wdHkgdHJhY2ssIHNvIHRoYXRcbiAgICAgICAgICogc2lsZW50IGF1ZGlvIGlzIGFsd2F5cyBwbGF5aW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdWRpb0lkID0gJ2xpdmVraXQtZHVtbXktYXVkaW8tZWwnO1xuICAgICAgICBsZXQgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXVkaW9JZCk7XG4gICAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuaWQgPSBhdWRpb0lkO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHRoZSBzcmNPYmplY3QgdG8gbnVsbCBvbiBwYWdlIGhpZGUgaW4gb3JkZXIgdG8gcHJldmVudCBsb2NrIHNjcmVlbiBjb250cm9scyB0byBzaG93IHVwIGZvciBpdFxuICAgICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IGRvY3VtZW50LmhpZGRlbiA/IG51bGwgOiBzdHJlYW07XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncGFnZSB2aXNpYmxlIGFnYWluLCB0cmlnZ2VyaW5nIHN0YXJ0QXVkaW8gdG8gcmVzdW1lIHBsYXliYWNrIGFuZCB1cGRhdGUgcGxheWJhY2sgc3RhdHVzJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydEF1ZGlvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZHVtbXlBdWRpb0VsKTtcbiAgICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID09PSBudWxsIHx8IGR1bW15QXVkaW9FbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVtbXlBdWRpb0VsLnJlbW92ZSgpO1xuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGR1bW15QXVkaW9FbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAodC50cmFjaykge1xuICAgICAgICAgICAgdC50cmFjay5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCksIC4uLmVsZW1lbnRzLm1hcChlID0+IHtcbiAgICAgICAgICBlLm11dGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGUucGxheSgpO1xuICAgICAgICB9KV0pO1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXJ0VmlkZW8gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIHAudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gdHIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5pbmNsdWRlcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoZWxlbWVudHMubWFwKGVsID0+IGVsLnBsYXkoKSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdSZXN1bWluZyB2aWRlbyBwbGF5YmFjayBmYWlsZWQsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgc3RhcnRWaWRlb2AgZGlyZWN0bHkgaW4gYSB1c2VyIGdlc3R1cmUgaGFuZGxlcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUmVzdGFydGluZyA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAvLyBpbiBjYXNlIHdlIHdlbnQgZnJvbSByZXN1bWluZyB0byBmdWxsLXJlY29ubmVjdCwgbWFrZSBzdXJlIHRvIHJlZmxlY3QgaXQgb24gdGhlIGlzUmVzdW1pbmcgZmxhZ1xuICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXG4gICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwLmlkZW50aXR5LCBwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQgPSBqb2luUmVzcG9uc2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJzaWduYWwgcmVjb25uZWN0ZWQgdG8gc2VydmVyLCByZWdpb24gXCIuY29uY2F0KGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uXG4gICAgICB9KSk7XG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB1bnB1Ymxpc2ggJiByZXB1Ymxpc2ggdHJhY2tzXG4gICAgICAgIHlpZWxkIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclJlc3RhcnRlZCgpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImZ1bGx5IHJlY29ubmVjdGVkIHRvIHNlcnZlclwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gcmVjb25uZWN0aW9uIGZhaWxlZCwgaGFuZGxlRGlzY29ubmVjdCBpcyBiZWluZyBpbnZva2VkIGFscmVhZHksIGp1c3QgcmV0dXJuIGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgdGhpcy5lbWl0QnVmZmVyZWRFdmVudHMoKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyA9IHBhcnRpY2lwYW50SW5mb3MgPT4ge1xuICAgICAgLy8gaGFuZGxlIGNoYW5nZXMgdG8gcGFydGljaXBhbnQgc3RhdGUsIGFuZCBzZW5kIGV2ZW50c1xuICAgICAgcGFydGljaXBhbnRJbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGl2ZUtpdCBzZXJ2ZXIgZG9lc24ndCBzZW5kIGlkZW50aXR5IGluZm8gcHJpb3IgdG8gdmVyc2lvbiAxLjUuMiBpbiBkaXNjb25uZWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gc28gd2UgdHJ5IHRvIG1hcCBhbiBlbXB0eSBpZGVudGl0eSB0byBhbiBhbHJlYWR5IGtub3duIHNJRCBtYW51YWxseVxuICAgICAgICBpZiAoaW5mby5pZGVudGl0eSA9PT0gJycpIHtcbiAgICAgICAgICBpbmZvLmlkZW50aXR5ID0gKF9hID0gdGhpcy5zaWRUb0lkZW50aXR5LmdldChpbmZvLnNpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpbmZvLmlkZW50aXR5KTtcbiAgICAgICAgLy8gd2hlbiBpdCdzIGRpc2Nvbm5lY3RlZCwgc2VuZCB1cGRhdGVzXG4gICAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChpbmZvLmlkZW50aXR5LCByZW1vdGVQYXJ0aWNpcGFudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpbmZvLmlkZW50aXR5LCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcbiAgICB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gc3BlYWtlcnMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHNlZW5TaWRzID0ge307XG4gICAgICBzcGVha2Vycy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBzZWVuU2lkc1tzcGVha2VyLnNpZF0gPSB0cnVlO1xuICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldElzU3BlYWtpbmcodHJ1ZSk7XG4gICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc3BlYWtlci5zaWQpO1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgICAgcC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XG4gICAgICAgICAgcC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgICBwLnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgLy8gcHJvY2VzcyBsaXN0IG9mIGNoYW5nZWQgc3BlYWtlcnNcbiAgICB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCA9IHNwZWFrZXJVcGRhdGVzID0+IHtcbiAgICAgIGNvbnN0IGxhc3RTcGVha2VycyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQocC5pZGVudGl0eSk7XG4gICAgICAgIGlmIChyZW1vdGVQYXJ0aWNpcGFudCAmJiByZW1vdGVQYXJ0aWNpcGFudC5zaWQgIT09IHAuc2lkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTcGVha2Vycy5zZXQocC5zaWQsIHApO1xuICAgICAgfSk7XG4gICAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBsZXQgcCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzcGVha2VyLnNpZCk7XG4gICAgICAgIGlmIChzcGVha2VyLnNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHAuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XG4gICAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5zZXQoc3BlYWtlci5zaWQsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xuICAgICAgYWN0aXZlU3BlYWtlcnMuc29ydCgoYSwgYikgPT4gYi5hdWRpb0xldmVsIC0gYS5hdWRpb0xldmVsKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSA9IHN0cmVhbVN0YXRlVXBkYXRlID0+IHtcbiAgICAgIHN0cmVhbVN0YXRlVXBkYXRlLnN0cmVhbVN0YXRlcy5mb3JFYWNoKHN0cmVhbVN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc3RyZWFtU3RhdGUucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzdHJlYW1TdGF0ZS50cmFja1NpZCk7XG4gICAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RyZWFtU3RhdGUgPSBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byhzdHJlYW1TdGF0ZS5zdGF0ZSk7XG4gICAgICAgIHB1Yi50cmFjay5zZXRTdHJlYW1TdGF0ZShuZXdTdHJlYW1TdGF0ZSk7XG4gICAgICAgIGlmIChuZXdTdHJlYW1TdGF0ZSAhPT0gcHViLnRyYWNrLnN0cmVhbVN0YXRlKSB7XG4gICAgICAgICAgcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSk7XG4gICAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHVwZGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZCh1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHViLnNldEFsbG93ZWQodXBkYXRlLmFsbG93ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvciA9IHVwZGF0ZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQocCA9PiBwLnRyYWNrUHVibGljYXRpb25zLmhhcyh1cGRhdGUudHJhY2tTaWQpKTtcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIuc2V0U3Vic2NyaXB0aW9uRXJyb3IodXBkYXRlLmVycik7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURhdGFQYWNrZXQgPSAocGFja2V0LCBlbmNyeXB0aW9uVHlwZSkgPT4ge1xuICAgICAgLy8gZmluZCB0aGUgcGFydGljaXBhbnRcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVXNlclBhY2tldChwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlLCBwYWNrZXQua2luZCwgZW5jcnlwdGlvblR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3RyYW5zY3JpcHRpb24nKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNjcmlwdGlvbihwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzaXBEdG1mJykge1xuICAgICAgICB0aGlzLmhhbmRsZVNpcER0bWYocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnY2hhdE1lc3NhZ2UnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhdE1lc3NhZ2UocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnbWV0cmljcycpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVNZXRyaWNzKHBhY2tldC52YWx1ZS52YWx1ZSwgcGFydGljaXBhbnQpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbUhlYWRlcicgfHwgcGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1DaHVuaycgfHwgcGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1UcmFpbGVyJykge1xuICAgICAgICB0aGlzLmhhbmRsZURhdGFTdHJlYW0ocGFja2V0LCBlbmNyeXB0aW9uVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAncnBjUmVxdWVzdCcpIHtcbiAgICAgICAgY29uc3QgcnBjID0gcGFja2V0LnZhbHVlLnZhbHVlO1xuICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjUmVxdWVzdChwYWNrZXQucGFydGljaXBhbnRJZGVudGl0eSwgcnBjLmlkLCBycGMubWV0aG9kLCBycGMucGF5bG9hZCwgcnBjLnJlc3BvbnNlVGltZW91dE1zLCBycGMudmVyc2lvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVVzZXJQYWNrZXQgPSAocGFydGljaXBhbnQsIHVzZXJQYWNrZXQsIGtpbmQsIGVuY3J5cHRpb25UeXBlKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBwYXJ0aWNpcGFudCwga2luZCwgdXNlclBhY2tldC50b3BpYywgZW5jcnlwdGlvblR5cGUpO1xuICAgICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5EYXRhUmVjZWl2ZWQsIHVzZXJQYWNrZXQucGF5bG9hZCwga2luZCwgZW5jcnlwdGlvblR5cGUpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaXBEdG1mID0gKHBhcnRpY2lwYW50LCBkdG1mKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpcERUTUZSZWNlaXZlZCwgZHRtZiwgcGFydGljaXBhbnQpO1xuICAgICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5TaXBEVE1GUmVjZWl2ZWQsIGR0bWYpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVUcmFuc2NyaXB0aW9uID0gKF9yZW1vdGVQYXJ0aWNpcGFudCwgdHJhbnNjcmlwdGlvbikgPT4ge1xuICAgICAgLy8gZmluZCB0aGUgcGFydGljaXBhbnRcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdHJhbnNjcmlwdGlvbi50cmFuc2NyaWJlZFBhcnRpY2lwYW50SWRlbnRpdHkgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA/IHRoaXMubG9jYWxQYXJ0aWNpcGFudCA6IHRoaXMuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KHRyYW5zY3JpcHRpb24udHJhbnNjcmliZWRQYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmdldCh0cmFuc2NyaXB0aW9uLnRyYWNrSWQpO1xuICAgICAgY29uc3Qgc2VnbWVudHMgPSBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzKHRyYW5zY3JpcHRpb24sIHRoaXMudHJhbnNjcmlwdGlvblJlY2VpdmVkVGltZXMpO1xuICAgICAgcHVibGljYXRpb24gPT09IG51bGwgfHwgcHVibGljYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1YmxpY2F0aW9uLmVtaXQoVHJhY2tFdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzKTtcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkLCBzZWdtZW50cywgcHVibGljYXRpb24pO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzLCBwYXJ0aWNpcGFudCwgcHVibGljYXRpb24pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDaGF0TWVzc2FnZSA9IChwYXJ0aWNpcGFudCwgY2hhdE1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IG1zZyA9IGV4dHJhY3RDaGF0TWVzc2FnZShjaGF0TWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNoYXRNZXNzYWdlLCBtc2csIHBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlTWV0cmljcyA9IChtZXRyaWNzLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZXRyaWNzUmVjZWl2ZWQsIG1ldHJpY3MsIHBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGF0YVN0cmVhbSA9IChwYWNrZXQsIGVuY3J5cHRpb25UeXBlKSA9PiB7XG4gICAgICB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIuaGFuZGxlRGF0YVN0cmVhbVBhY2tldChwYWNrZXQsIGVuY3J5cHRpb25UeXBlKTtcbiAgICB9O1xuICAgIHRoaXMuYnVmZmVyZWRTZWdtZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCA9IGUgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHBsYXliYWNrIGF1ZGlvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9zKSAhPT0gJ2lPUycpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBkZXZpY2VzIGFyZSBub24gZGV0ZXJtaW5pc3RpYyBvbiBpT1MsIHNvIHdlIGRvbid0IGF0dGVtcHQgdG8gc2VsZWN0IHRoZW0gaGVyZVxuICAgICAgICB5aWVsZCB0aGlzLnNlbGVjdERlZmF1bHREZXZpY2VzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0NoYW5nZWQpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSA9IHJvb20gPT4ge1xuICAgICAgY29uc3Qgb2xkUm9vbSA9IHRoaXMucm9vbUluZm87XG4gICAgICB0aGlzLnJvb21JbmZvID0gcm9vbTtcbiAgICAgIGlmIChvbGRSb29tICYmIG9sZFJvb20ubWV0YWRhdGEgIT09IHJvb20ubWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUm9vbU1ldGFkYXRhQ2hhbmdlZCwgcm9vbS5tZXRhZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKG9sZFJvb20gPT09IG51bGwgfHwgb2xkUm9vbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkUm9vbS5hY3RpdmVSZWNvcmRpbmcpICE9PSByb29tLmFjdGl2ZVJlY29yZGluZykge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5SZWNvcmRpbmdTdGF0dXNDaGFuZ2VkLCByb29tLmFjdGl2ZVJlY29yZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgIGlmIChpbmZvLnBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKGluZm8ucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICBwYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gbWV0YWRhdGEgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gbmFtZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCA9IGNoYW5nZWRBdHRyaWJ1dGVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja011dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tQcm9jZXNzb3JVcGRhdGUgPSBwcm9jZXNzb3IgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gcHJvY2Vzc29yID09PSBudWxsIHx8IHByb2Nlc3NvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzc29yLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvY2Vzc29yLCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub24oVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSwgdGhpcy5vblRyYWNrUHJvY2Vzc29yVXBkYXRlKTtcbiAgICAgIChfYiA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uKFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCk7XG4gICAgICAoX2UgPSAoX2QgPSAoX2MgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRQcm9jZXNzb3IoKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrKSkge1xuICAgICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgcHViLnRyYWNrLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCwgcHViKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZGV2aWNlSWQgPSB5aWVsZCAoX2YgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5nZXREZXZpY2VJZChmYWxzZSk7XG4gICAgICBjb25zdCBkZXZpY2VLaW5kID0gc291cmNlVG9LaW5kKHB1Yi5zb3VyY2UpO1xuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHB1YiA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2ZmKFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XG4gICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vZmYoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMub25Mb2NhbFRyYWNrUmVzdGFydGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCA9IHRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRldmljZUlkID0geWllbGQgdHJhY2suZ2V0RGV2aWNlSWQoZmFsc2UpO1xuICAgICAgY29uc3QgZGV2aWNlS2luZCA9IHNvdXJjZVRvS2luZCh0cmFjay5zb3VyY2UpO1xuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwibG9jYWwgdHJhY2sgcmVzdGFydGVkLCBzZXR0aW5nIFwiLmNvbmNhdChkZXZpY2VLaW5kLCBcIiBcIikuY29uY2F0KGRldmljZUlkLCBcIiBhY3RpdmVcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gcXVhbGl0eSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25NZWRpYURldmljZXNFcnJvciA9IChlLCBraW5kKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlLCBraW5kKTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gcHJldlBlcm1pc3Npb25zID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCA9IG1zZyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNoYXRNZXNzYWdlLCBtc2csIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc2lkVG9JZGVudGl0eSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJvb21PcHRpb25EZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5Sb29tKTtcbiAgICB0aGlzLnRyYW5zY3JpcHRpb25SZWNlaXZlZFRpbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXVkaW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0RlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICB0aGlzLm9wdGlvbnMucHVibGlzaERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHVibGlzaERlZmF1bHRzKTtcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gICAgdGhpcy5pbmNvbWluZ0RhdGFTdHJlYW1NYW5hZ2VyID0gbmV3IEluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIoKTtcbiAgICB0aGlzLm91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIgPSBuZXcgT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlcih0aGlzLmVuZ2luZSwgdGhpcy5sb2cpO1xuICAgIHRoaXMuZGlzY29ubmVjdExvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCA9IG5ldyBMb2NhbFBhcnRpY2lwYW50KCcnLCAnJywgdGhpcy5lbmdpbmUsIHRoaXMub3B0aW9ucywgdGhpcy5ycGNIYW5kbGVycywgdGhpcy5vdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUgfHwgdGhpcy5vcHRpb25zLmVuY3J5cHRpb24pIHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFKCk7XG4gICAgfVxuICAgIHRoaXMuZW5naW5lLmUyZWVNYW5hZ2VyID0gdGhpcy5lMmVlTWFuYWdlcjtcbiAgICBpZiAodGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldCgndmlkZW9pbnB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KCdhdWRpb2lucHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpKTtcbiAgICB9XG4gICAgaWYgKChfYiA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldmljZUlkKSB7XG4gICAgICB0aGlzLnN3aXRjaEFjdGl2ZURldmljZSgnYXVkaW9vdXRwdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCkpLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihcIkNvdWxkIG5vdCBzZXQgYXVkaW8gb3V0cHV0OiBcIi5jb25jYXQoZS5tZXNzYWdlKSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAvLyBpbiBvcmRlciB0byBjYXRjaCBkZXZpY2UgY2hhbmdlcyBwcmlvciB0byByb29tIGNvbm5lY3Rpb24gd2UgbmVlZCB0byByZWdpc3RlciB0aGUgZXZlbnQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAoX2MgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UsIHtcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlmIChSb29tLmNsZWFudXBSZWdpc3RyeSkge1xuICAgICAgICBSb29tLmNsZWFudXBSZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spO1xuICB9XG4gIHVucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIudW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljKTtcbiAgfVxuICByZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIucmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spO1xuICB9XG4gIHVucmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIudW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljKTtcbiAgfVxuICAvKipcbiAgICogRXN0YWJsaXNoZXMgdGhlIHBhcnRpY2lwYW50IGFzIGEgcmVjZWl2ZXIgZm9yIGNhbGxzIG9mIHRoZSBzcGVjaWZpZWQgUlBDIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBpbmRpY2F0ZWQgUlBDIG1ldGhvZFxuICAgKiBAcGFyYW0gaGFuZGxlciAtIFdpbGwgYmUgaW52b2tlZCB3aGVuIGFuIFJQQyByZXF1ZXN0IGZvciB0aGlzIG1ldGhvZCBpcyByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtZXRob2QgaXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWRcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGEgaGFuZGxlciBmb3IgdGhpcyBtZXRob2QgaXMgYWxyZWFkeSByZWdpc3RlcmVkIChtdXN0IGNhbGwgdW5yZWdpc3RlclJwY01ldGhvZCBmaXJzdClcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiByb29tLmxvY2FsUGFydGljaXBhbnQ/LnJlZ2lzdGVyUnBjTWV0aG9kKFxuICAgKiAgICdncmVldCcsXG4gICAqICAgYXN5bmMgKGRhdGE6IFJwY0ludm9jYXRpb25EYXRhKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgZ3JlZXRpbmcgZnJvbSAke2RhdGEuY2FsbGVySWRlbnRpdHl9OiAke2RhdGEucGF5bG9hZH1gKTtcbiAgICogICAgIHJldHVybiBgSGVsbG8sICR7ZGF0YS5jYWxsZXJJZGVudGl0eX0hYDtcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgaGFuZGxlciBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxuICAgKiBJZiB1bmFibGUgdG8gcmVzcG9uZCB3aXRoaW4gYHJlc3BvbnNlVGltZW91dGAsIHRoZSByZXF1ZXN0IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIG9uIHRoZSBjYWxsZXIncyBzaWRlLlxuICAgKlxuICAgKiBZb3UgbWF5IHRocm93IGVycm9ycyBvZiB0eXBlIGBScGNFcnJvcmAgd2l0aCBhIHN0cmluZyBgbWVzc2FnZWAgaW4gdGhlIGhhbmRsZXIsXG4gICAqIGFuZCB0aGV5IHdpbGwgYmUgcmVjZWl2ZWQgb24gdGhlIGNhbGxlcidzIHNpZGUgd2l0aCB0aGUgbWVzc2FnZSBpbnRhY3QuXG4gICAqIE90aGVyIGVycm9ycyB0aHJvd24gaW4geW91ciBoYW5kbGVyIHdpbGwgbm90IGJlIHRyYW5zbWl0dGVkIGFzLWlzLCBhbmQgd2lsbCBpbnN0ZWFkIGFycml2ZSB0byB0aGUgY2FsbGVyIGFzIGAxNTAwYCAoXCJBcHBsaWNhdGlvbiBFcnJvclwiKS5cbiAgICovXG4gIHJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlJQQyBoYW5kbGVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbWV0aG9kIFwiLmNvbmNhdChtZXRob2QsIFwiLCB1bnJlZ2lzdGVyUnBjTWV0aG9kIGJlZm9yZSB0cnlpbmcgdG8gcmVnaXN0ZXIgYWdhaW5cIikpO1xuICAgIH1cbiAgICB0aGlzLnJwY0hhbmRsZXJzLnNldChtZXRob2QsIGhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVycyBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBSUEMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG5hbWUgb2YgdGhlIFJQQyBtZXRob2QgdG8gdW5yZWdpc3RlclxuICAgKi9cbiAgdW5yZWdpc3RlclJwY01ldGhvZChtZXRob2QpIHtcbiAgICB0aGlzLnJwY0hhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICB9XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRFMkVFRW5hYmxlZChlbmFibGVkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCldKTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2UyZWUgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBzZXQgZTJlZSBzZXR0aW5ncyB3aXRoaW4gdGhlIHJvb20gb3B0aW9ucycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldHVwRTJFRSgpIHtcbiAgICAvLyB3aGVuIGVuY3J5cHRpb24gaXMgZW5hYmxlZCB2aWEgYG9wdGlvbnMuZW5jcnlwdGlvbmAsIHdlIGVuYWJsZSBkYXRhIGNoYW5uZWwgZW5jcnlwdGlvblxuICAgIHZhciBfYTtcbiAgICBjb25zdCBkY0VuY3J5cHRpb25FbmFibGVkID0gISF0aGlzLm9wdGlvbnMuZW5jcnlwdGlvbjtcbiAgICBjb25zdCBlMmVlT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5lbmNyeXB0aW9uIHx8IHRoaXMub3B0aW9ucy5lMmVlO1xuICAgIGlmIChlMmVlT3B0aW9ucykge1xuICAgICAgaWYgKCdlMmVlTWFuYWdlcicgaW4gZTJlZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IGUyZWVPcHRpb25zLmUyZWVNYW5hZ2VyO1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLmlzRGF0YUNoYW5uZWxFbmNyeXB0aW9uRW5hYmxlZCA9IGRjRW5jcnlwdGlvbkVuYWJsZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyID0gbmV3IEUyRUVNYW5hZ2VyKGUyZWVPcHRpb25zLCBkY0VuY3J5cHRpb25FbmFibGVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIChlbmFibGVkLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBpZiAoaXNMb2NhbFBhcnRpY2lwYW50KHBhcnRpY2lwYW50KSkge1xuICAgICAgICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgKGVycm9yLCBwYXJ0aWNpcGFudElkZW50aXR5KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gcGFydGljaXBhbnRJZGVudGl0eSA/IHRoaXMuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KHBhcnRpY2lwYW50SWRlbnRpdHkpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXJyb3IsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pO1xuICAgICAgKF9hID0gdGhpcy5lMmVlTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldHVwKHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IHRoaXMubmFtZSxcbiAgICAgIHJvb21JRDogKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZCxcbiAgICAgIHBhcnRpY2lwYW50OiB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICBwSUQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBpZiB0aGUgY3VycmVudCByb29tIGhhcyBhIHBhcnRpY2lwYW50IHdpdGggYHJlY29yZGVyOiB0cnVlYCBpbiBpdHMgSldUIGdyYW50XG4gICAqKi9cbiAgZ2V0IGlzUmVjb3JkaW5nKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVSZWNvcmRpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBzZXJ2ZXIgYXNzaWduZWQgdW5pcXVlIHJvb20gaWQuXG4gICAqIHJldHVybnMgb25jZSBhIHNpZCBoYXMgYmVlbiBpc3N1ZWQgYnkgdGhlIHNlcnZlci5cbiAgICovXG4gIGdldFNpZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vbUluZm8gJiYgdGhpcy5yb29tSW5mby5zaWQgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb21JbmZvLnNpZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVJvb21VcGRhdGUgPSByb29tSW5mbyA9PiB7XG4gICAgICAgICAgaWYgKHJvb21JbmZvLnNpZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgICAgIHJlc29sdmUocm9vbUluZm8uc2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xuICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgICByZWplY3QoJ1Jvb20gZGlzY29ubmVjdGVkIGJlZm9yZSByb29tIHNlcnZlciBpZCB3YXMgYXZhaWxhYmxlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIHVzZXIgYXNzaWduZWQgbmFtZSwgZGVyaXZlZCBmcm9tIEpXVCB0b2tlbiAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gIH1cbiAgLyoqIHJvb20gbWV0YWRhdGEgKi9cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGFkYXRhO1xuICB9XG4gIGdldCBudW1QYXJ0aWNpcGFudHMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm51bVBhcnRpY2lwYW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgfVxuICBnZXQgbnVtUHVibGlzaGVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUHVibGlzaGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgfVxuICBtYXliZUNyZWF0ZUVuZ2luZSgpIHtcbiAgICBpZiAodGhpcy5lbmdpbmUgJiYgIXRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5naW5lID0gbmV3IFJUQ0VuZ2luZSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuZW5naW5lLmUyZWVNYW5hZ2VyID0gdGhpcy5lMmVlTWFuYWdlcjtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5QYXJ0aWNpcGFudFVwZGF0ZSwgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMpLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSkub24oRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCkub24oRW5naW5lRXZlbnQuU3RyZWFtU3RhdGVDaGFuZ2VkLCB0aGlzLmhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlKS5vbihFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkub24oRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uRXJyb3IpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkub24oRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCAobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikgPT4ge1xuICAgICAgdGhpcy5vblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcik7XG4gICAgfSkub24oRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCByZWFzb24pO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlKS5vbihFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIHRoaXMuaGFuZGxlRGF0YVBhY2tldCkub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICB0aGlzLmlzUmVzdW1pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5sb2cuaW5mbygnUmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuU2lnbmFsUmVjb25uZWN0aW5nKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbFJlY29ubmVjdGluZyk7XG4gICAgICB9XG4gICAgfSkub24oRW5naW5lRXZlbnQuUmVzdW1lZCwgKCkgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2cuaW5mbygnUmVzdW1lZCBzaWduYWwgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHRoaXMuZW1pdEJ1ZmZlcmVkRXZlbnRzKCk7XG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpKSB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0ZWQpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsICgpID0+IHtcbiAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZykge1xuICAgICAgICB0aGlzLnNlbmRTeW5jU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KS5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlc3RhcnRpbmcpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQpLm9uKEVuZ2luZUV2ZW50Lk9mZmxpbmUsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgKHN0YXR1cywga2luZCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIHN0YXR1cywga2luZCk7XG4gICAgfSkub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHN1YnNjcmliZWRTaWQgPT4ge1xuICAgICAgY29uc3QgdHJhY2tQdWJsaWNhdGlvbiA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpLmZpbmQoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHRyYWNrU2lkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHRyYWNrU2lkID09PSBzdWJzY3JpYmVkU2lkO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRyYWNrUHVibGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGZpbmQgbG9jYWwgdHJhY2sgc3Vic2NyaXB0aW9uIGZvciBzdWJzY3JpYmVkIGV2ZW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tQdWJsaWNhdGlvbik7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tQdWJsaWNhdGlvbiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5Sb29tTW92ZWQsIHJvb21Nb3ZlZCA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygncm9vbSBtb3ZlZCcsIHJvb21Nb3ZlZCk7XG4gICAgICBpZiAocm9vbU1vdmVkLnJvb20pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlKHJvb21Nb3ZlZC5yb29tKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50LCBpZGVudGl0eSkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGlkZW50aXR5LCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTW92ZWQsIHJvb21Nb3ZlZC5yb29tLm5hbWUpO1xuICAgICAgaWYgKHJvb21Nb3ZlZC5wYXJ0aWNpcGFudCkge1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyhbcm9vbU1vdmVkLnBhcnRpY2lwYW50LCAuLi5yb29tTW92ZWQub3RoZXJQYXJ0aWNpcGFudHNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKHJvb21Nb3ZlZC5vdGhlclBhcnRpY2lwYW50cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyKSB7XG4gICAgICB0aGlzLm91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogZ2V0TG9jYWxEZXZpY2VzIGFic3RyYWN0cyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0IHJlcXVlc3RzIGRldmljZSBwZXJtaXNzaW9ucyBieSBkZWZhdWx0IGlmIG5lZWRlZFxuICAgKiBhbmQgbWFrZXMgc3VyZSB0aGUgcmV0dXJuZWQgZGV2aWNlIGRvZXMgbm90IGNvbnNpc3Qgb2YgZHVtbXkgZGV2aWNlc1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGxvY2FsIGRldmljZXNcbiAgICovXG4gIHN0YXRpYyBnZXRMb2NhbERldmljZXMoa2luZCkge1xuICAgIGxldCByZXF1ZXN0UGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXREZXZpY2VzKGtpbmQsIHJlcXVlc3RQZXJtaXNzaW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIHByZXBhcmVDb25uZWN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyBsb2FkZWQsIGluIG9yZGVyXG4gICAqIHRvIHNwZWVkIHVwIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIFRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiAtIHBlcmZvcm0gRE5TIHJlc29sdXRpb24gYW5kIHByZS13YXJtIHRoZSBETlMgY2FjaGVcbiAgICogLSBlc3RhYmxpc2ggVExTIGNvbm5lY3Rpb24gYW5kIGNhY2hlIFRMUyBrZXlzXG4gICAqXG4gICAqIFdpdGggTGl2ZUtpdCBDbG91ZCwgaXQgd2lsbCBhbHNvIGRldGVybWluZSB0aGUgYmVzdCBlZGdlIGRhdGEgY2VudGVyIGZvclxuICAgKiB0aGUgY3VycmVudCBjbGllbnQgdG8gY29ubmVjdCB0byBpZiBhIHRva2VuIGlzIHByb3ZpZGVkLlxuICAgKi9cbiAgcHJlcGFyZUNvbm5lY3Rpb24odXJsLCB0b2tlbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByZXBhcmVDb25uZWN0aW9uIHRvIFwiLmNvbmNhdCh1cmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSAmJiB0b2tlbikge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICAgIC8vIHdlIHdpbGwgbm90IHJlcGxhY2UgdGhlIHJlZ2lvblVybCBpZiBhbiBhdHRlbXB0IGhhZCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgICAvLyB0byBhdm9pZCBvdmVycmlkaW5nIHJlZ2lvblVybCBhZnRlciBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgaGFkIHN0YXJ0ZWRcbiAgICAgICAgICBpZiAocmVnaW9uVXJsICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaW9uVXJsID0gcmVnaW9uVXJsO1xuICAgICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHJlZ2lvblVybCksIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlZCBjb25uZWN0aW9uIHRvIFwiLmNvbmNhdChyZWdpb25VcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBmZXRjaCh0b0h0dHBVcmwodXJsKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcHJlcGFyZSBjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXRyaWV2ZXMgYSBwYXJ0aWNpcGFudCBieSBpZGVudGl0eVxuICAgKiBAcGFyYW0gaWRlbnRpdHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFBhcnRpY2lwYW50QnlJZGVudGl0eShpZGVudGl0eSkge1xuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPT09IGlkZW50aXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb25GdXR1cmVzKCkge1xuICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIGZvciB0ZXN0aW5nXG4gICAqL1xuICBzaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvLCBhcmcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7fSk7XG4gICAgICBsZXQgcmVxO1xuICAgICAgc3dpdGNoIChzY2VuYXJpbykge1xuICAgICAgICBjYXNlICdzaWduYWwtcmVjb25uZWN0JzpcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZGlzY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzcGVha2VyJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc3BlYWtlclVwZGF0ZScsXG4gICAgICAgICAgICAgIHZhbHVlOiAzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25vZGUtZmFpbHVyZSc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ25vZGVGYWlsdXJlJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VydmVyLWxlYXZlJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc2VydmVyTGVhdmUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWdyYXRpb24nOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdtaWdyYXRpb24nLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXN1bWUtcmVjb25uZWN0JzpcbiAgICAgICAgICB0aGlzLmVuZ2luZS5mYWlsTmV4dCgpO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUnOlxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUtbm8tbWVzc2FnZXMnOlxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVOb01lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVsbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIHRoaXMuZW5naW5lLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSBmdWxsLXJlY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb3JjZS10Y3AnOlxuICAgICAgICBjYXNlICdmb3JjZS10bHMnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzd2l0Y2hDYW5kaWRhdGVQcm90b2NvbCcsXG4gICAgICAgICAgICAgIHZhbHVlOiBzY2VuYXJpbyA9PT0gJ2ZvcmNlLXRscycgPyAyIDogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvbkxlYXZlID0gdGhpcy5lbmdpbmUuY2xpZW50Lm9uTGVhdmU7XG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICAgICAgICBvbkxlYXZlKG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxuICAgICAgICAgICAgICAgIGFjdGlvbjogTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRUNPTk5FQ1RcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdWJzY3JpYmVyLWJhbmR3aWR0aCc6XG4gICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZXItYmFuZHdpZHRoIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzdWJzY3JpYmVyQmFuZHdpZHRoJyxcbiAgICAgICAgICAgICAgdmFsdWU6IG51bWJlclRvQmlnSW50KGFyZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVhdmUtZnVsbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdsZWF2ZVJlcXVlc3RGdWxsUmVjb25uZWN0JyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XG4gICAgICAgIHlpZWxkIHBvc3RBY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja0F1ZGlvKCkge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvRW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCkge1xuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xuICB9XG4gIGdldEFjdGl2ZURldmljZShraW5kKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBhbGwgYWN0aXZlIGRldmljZXMgdXNlZCBpbiB0aGlzIHJvb20gdG8gdGhlIGdpdmVuIGRldmljZS5cbiAgICpcbiAgICogTm90ZTogc2V0dGluZyBBdWRpb091dHB1dCBpcyBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMuIFNlZSBbc2V0U2lua0lkXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICAgKlxuICAgKiBAcGFyYW0ga2luZCB1c2UgYHZpZGVvaW5wdXRgIGZvciBjYW1lcmEgdHJhY2ssXG4gICAqICBgYXVkaW9pbnB1dGAgZm9yIG1pY3JvcGhvbmUgdHJhY2ssXG4gICAqICBgYXVkaW9vdXRwdXRgIHRvIHNldCBzcGVha2VyIGZvciBhbGwgaW5jb21pbmcgYXVkaW8gdHJhY2tzXG4gICAqIEBwYXJhbSBkZXZpY2VJZFxuICAgKi9cbiAgc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmRfMSwgZGV2aWNlSWRfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChraW5kLCBkZXZpY2VJZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBsZXQgZXhhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHZhciBfZztcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBsZXQgc2hvdWxkVHJpZ2dlckltbWVkaWF0ZURldmljZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkZXZpY2VDb25zdHJhaW50ID0gZXhhY3QgPyB7XG4gICAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICAgIH0gOiBkZXZpY2VJZDtcbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0Jykge1xuICAgICAgICAgIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNpemUgPT09IDA7XG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9hID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XG4gICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oX3RoaXMzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gKHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHQuYXVkaW9UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfSkpKS5ldmVyeSh2YWwgPT4gdmFsID09PSB0cnVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTXV0ZWQgPSB0cmFja3Muc29tZSh0ID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdC50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzTXV0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzdWNjZXNzICYmIGlzTXV0ZWQpIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICAgIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrUHVibGljYXRpb25zLnNpemUgPT09IDA7XG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9iID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XG4gICAgICAgICAgX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oX3RoaXMzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSAoeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdC52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF90aGlzMy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNNdXRlZCA9IHRyYWNrcy5zb21lKHQgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0LnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNNdXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgaXNNdXRlZCkgc2hvdWxkVHJpZ2dlckltbWVkaWF0ZURldmljZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuICAgICAgICAgIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoKSAmJiAhX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXggfHwgX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXggJiYgX3RoaXMzLmF1ZGlvQ29udGV4dCAmJiAhKCdzZXRTaW5rSWQnIGluIF90aGlzMy5hdWRpb0NvbnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggYXVkaW8gb3V0cHV0LCB0aGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgaXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBkZWZhdWx0YCBmb3Igd2ViIGF1ZGlvIG91dHB1dCBkb2Vzbid0IHdvcmssIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIHRoZSBpZCBiZWZvcmVcbiAgICAgICAgICAgIGRldmljZUlkID0gKF9jID0geWllbGQgRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKCdhdWRpb291dHB1dCcsIGRldmljZUlkKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIChfZCA9IChfZyA9IF90aGlzMy5vcHRpb25zKS5hdWRpb091dHB1dCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogX2cuYXVkaW9PdXRwdXQgPSB7fTtcbiAgICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSAoX2UgPSBfdGhpczMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXRTaW5rSWQgaXMgbm90IHlldCBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlIG9mIEF1ZGlvQ29udGV4dFxuICAgICAgICAgICAgICAoX2YgPSBfdGhpczMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsc28gc2V0IGF1ZGlvIG91dHB1dCBvbiBhbGwgYXVkaW8gZWxlbWVudHMsIGV2ZW4gaWYgd2ViQXVkaW9NaXggaXMgZW5hYmxlZCBpbiBvcmRlciB0byB3b3JrYXJvdW5kIGVjaG8gY2FuY2VsbGF0aW9uIG5vdCB3b3JraW5nIG9uIGNocm9tZSB3aXRoIG5vbi1kZWZhdWx0IG91dHB1dCBkZXZpY2VzXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MDI1MjkxMSNjb21tZW50N1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShfdGhpczMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5tYXAocCA9PiBwLnNldEF1ZGlvT3V0cHV0KHtcbiAgICAgICAgICAgICAgZGV2aWNlSWRcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkVHJpZ2dlckltbWVkaWF0ZURldmljZUNoYW5nZSkge1xuICAgICAgICAgIF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoa2luZCwgZGV2aWNlSWQpO1xuICAgICAgICAgIF90aGlzMy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBraW5kLCBkZXZpY2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCkge1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub24oUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCk7XG4gIH1cbiAgcmVjcmVhdGVFbmdpbmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgLy8gY2xlYXIgb3V0IGV4aXN0aW5nIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHNpbmNlIHRoZXkgbWF5IGhhdmUgYXR0YWNoZWRcbiAgICAvLyB0aGUgb2xkIGVuZ2luZVxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgfVxuICBvblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikge1xuICAgIC8vIGRvbid0IGZpcmUgb25TdWJzY3JpYmVkIHdoZW4gY29ubmVjdGluZ1xuICAgIC8vIFdlYlJUQyBmaXJlcyBvblRyYWNrIGFzIHNvb24gYXMgc2V0UmVtb3RlRGVzY3JpcHRpb24gaXMgY2FsbGVkIG9uIHRoZSBvZmZlclxuICAgIC8vIGF0IHRoYXQgdGltZSwgSUNFIGNvbm5lY3Rpdml0eSBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgc28gdGhlIHRyYWNrIGlzIG5vdFxuICAgIC8vIHRlY2huaWNhbGx5IHN1YnNjcmliZWQuXG4gICAgLy8gV2UnbGwgZGVmZXIgdGhlc2UgZXZlbnRzIHVudGlsIHdoZW4gdGhlIHJvb20gaXMgY29ubmVjdGVkIG9yIGV2ZW50dWFsbHkgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICBjb25zdCByZWNvbm5lY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdkZWZlcnJpbmcgb24gdHJhY2sgZm9yIGxhdGVyJywge1xuICAgICAgICAgIG1lZGlhVHJhY2tJZDogbWVkaWFUcmFjay5pZCxcbiAgICAgICAgICBtZWRpYVN0cmVhbUlkOiBzdHJlYW0uaWQsXG4gICAgICAgICAgdHJhY2tzSW5TdHJlYW06IHN0cmVhbS5nZXRUcmFja3MoKS5tYXAodHJhY2sgPT4gdHJhY2suaWQpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsIGNsZWFudXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5sb2cud2Fybignc2tpcHBpbmcgaW5jb21pbmcgdHJhY2sgYWZ0ZXIgUm9vbSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhcyBpdCBhbHJlYWR5IGVuZGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSB1bnBhY2tTdHJlYW1JZChzdHJlYW0uaWQpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50U2lkID0gcGFydHNbMF07XG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIC8vIGZpcmVmb3ggd2lsbCBnZXQgc3RyZWFtSWQgKHBJRHx0cmFja0lkKSBpbnN0ZWFkIG9mIChwSUR8c3RyZWFtSWQpIGFzIGl0IGRvZXNuJ3Qgc3VwcG9ydCBzeW5jIHRyYWNrcyBieSBzdHJlYW1cbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xuICAgIGlmIChwYXJ0aWNpcGFudFNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgdGhpcy5sb2cud2FybigndHJpZWQgdG8gY3JlYXRlIFJlbW90ZVBhcnRpY2lwYW50IGZvciBsb2NhbCBwYXJ0aWNpcGFudCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZChwID0+IHAuc2lkID09PSBwYXJ0aWNpcGFudFNpZCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXCJUcmllZCB0byBhZGQgYSB0cmFjayBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudFNpZCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGluIHNpbmdsZSBwZWVyIGNvbm5lY3Rpb24gY2FzZSwgdGhlIHRyYWNrSUQgaXMgbG9jYWxseSBnZW5lcmF0ZWQsXG4gICAgLy8gbm90IHRoZSBUUl8gcHJlZml4ZWQgb25lIGdlbmVyYXRlZCBieSB0aGUgc2VydmVyLFxuICAgIC8vIHVzZSBgbWlkYCB0byBmaW5kIHRoZSBhcHByb3ByaWF0ZSB0cmFjay5cbiAgICBpZiAoIXRyYWNrSWQuc3RhcnRzV2l0aCgnVFInKSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmVuZ2luZS5nZXRUcmFja0lkRm9yUmVjZWl2ZXIocmVjZWl2ZXIpO1xuICAgICAgaWYgKCFpZCkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIlRyaWVkIHRvIGFkZCBhIHRyYWNrIHdob3NlICdzaWQnIGNvdWxkIG5vdCBiZSBmb3VuZCBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudFNpZCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICB9XG4gICAgaWYgKCF0cmFja0lkLnN0YXJ0c1dpdGgoJ1RSJykpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oXCJUcmllZCB0byBhZGQgYSB0cmFjayB3aG9zZSAnc2lkJyBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZCBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudFNpZCwgXCIsIHN0cmVhbUlkOiBcIikuY29uY2F0KHN0cmVhbUlkLCBcIiwgdHJhY2tJZDogXCIpLmNvbmNhdCh0cmFja0lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHJwSUQ6IHBhcnRpY2lwYW50U2lkLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgdHJhY2tJZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBsZXQgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcbiAgICBpZiAodGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHVibGljYXRpb24gPSBwYXJ0aWNpcGFudC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCB0cmFja0lkLCBzdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgICBpZiAoKHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5pc0VuY3J5cHRlZCkgJiYgIXRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgXCIuY29uY2F0KHB1YmxpY2F0aW9uLnNvdXJjZSwgXCIgdHJhY2sgcmVjZWl2ZWQgZnJvbSBwYXJ0aWNpcGFudCBcIikuY29uY2F0KHBhcnRpY2lwYW50LnNpZCwgXCIsIGJ1dCByb29tIGRvZXMgbm90IGhhdmUgZW5jcnlwdGlvbiBlbmFibGVkIVwiKSkpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgIGxldCBzaG91bGRTdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIGxldCByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcy5jbGVhcigpO1xuICAgIHRoaXMuaW5jb21pbmdEYXRhU3RyZWFtTWFuYWdlci5jbGVhckNvbnRyb2xsZXJzKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgLy8gTm90aWZ5IHJlZ2lvbiBwcm92aWRlciBhYm91dCBkaXNjb25uZWN0IHRvIHBvdGVudGlhbGx5IHN0b3AgYXV0by1yZWZldGNoXG4gICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIubm90aWZ5RGlzY29ubmVjdGVkKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICBwLnVucHVibGlzaFRyYWNrKHB1Yi50cmFja1NpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayhwdWIudHJhY2ssIHNob3VsZFN0b3BUcmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTdG9wVHJhY2tzKSB7XG4gICAgICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV0YWNoKCk7XG4gICAgICAgICAgKF9iID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChfYyA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0b3BNb25pdG9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Lm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIHRoaXMub25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICAoX2EgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaWRlbnRpdHksIHBhcnRpY2lwYW50KSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIHJlbW92ZSBhbmQgc2VuZCBldmVudFxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmRlbGV0ZShpZGVudGl0eSk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIudmFsaWRhdGVQYXJ0aWNpcGFudEhhc05vQWN0aXZlRGF0YVN0cmVhbXMoaWRlbnRpdHkpO1xuICAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgcGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICBwYXJ0aWNpcGFudC5zZXREaXNjb25uZWN0ZWQoKTtcbiAgICAoX2EgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gIH1cbiAgaGFuZGxlSW5jb21pbmdScGNSZXF1ZXN0KGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIG1ldGhvZCwgcGF5bG9hZCwgcmVzcG9uc2VUaW1lb3V0LCB2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNBY2soY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCk7XG4gICAgICBpZiAodmVyc2lvbiAhPT0gMSkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjUmVzcG9uc2UoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgbnVsbCwgUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfVkVSU0lPTicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMucnBjSGFuZGxlcnMuZ2V0KG1ldGhvZCk7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUucHVibGlzaFJwY1Jlc3BvbnNlKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIG51bGwsIFJwY0Vycm9yLmJ1aWx0SW4oJ1VOU1VQUE9SVEVEX01FVEhPRCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3BvbnNlRXJyb3IgPSBudWxsO1xuICAgICAgbGV0IHJlc3BvbnNlUGF5bG9hZCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGhhbmRsZXIoe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBjYWxsZXJJZGVudGl0eSxcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgIHJlc3BvbnNlVGltZW91dFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGgocmVzcG9uc2UpID4gTUFYX1BBWUxPQURfQllURVMpIHtcbiAgICAgICAgICByZXNwb25zZUVycm9yID0gUnBjRXJyb3IuYnVpbHRJbignUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0UnKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJSUEMgUmVzcG9uc2UgcGF5bG9hZCB0b28gbGFyZ2UgZm9yIFwiLmNvbmNhdChtZXRob2QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNwb25zZVBheWxvYWQgPSByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUnBjRXJyb3IpIHtcbiAgICAgICAgICByZXNwb25zZUVycm9yID0gZXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgZXJyb3IgcmV0dXJuZWQgYnkgUlBDIGhhbmRsZXIgZm9yIFwiLmNvbmNhdChtZXRob2QsIFwiLiBSZXR1cm5pbmcgQVBQTElDQVRJT05fRVJST1IgaW5zdGVhZC5cIiksIGVycm9yKTtcbiAgICAgICAgICByZXNwb25zZUVycm9yID0gUnBjRXJyb3IuYnVpbHRJbignQVBQTElDQVRJT05fRVJST1InKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5lbmdpbmUucHVibGlzaFJwY1Jlc3BvbnNlKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIHJlc3BvbnNlUGF5bG9hZCwgcmVzcG9uc2VFcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGF0dGVtcHQgdG8gc2VsZWN0IHRoZSBkZWZhdWx0IGRldmljZXMgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgZGV2aWNlcyBhcmUgbm8gbG9uZ2VyIGF2YWlsYWJsZSBhZnRlciBhIGRldmljZSBjaGFuZ2UgZXZlbnRcbiAgICovXG4gIHNlbGVjdERlZmF1bHREZXZpY2VzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGNvbnN0IHByZXZpb3VzRGV2aWNlcyA9IERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5wcmV2aW91c0RldmljZXM7XG4gICAgICAvLyBjaGVjayBmb3IgYXZhaWxhYmxlIGRldmljZXMsIGJ1dCBkb24ndCByZXF1ZXN0IHBlcm1pc3Npb25zIGluIG9yZGVyIHRvIGF2b2lkIHByb21wdHMgZm9yIGtpbmRzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgYmVmb3JlXG4gICAgICBjb25zdCBhdmFpbGFibGVEZXZpY2VzID0geWllbGQgRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldERldmljZXModW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdDaHJvbWUnICYmIGJyb3dzZXIub3MgIT09ICdpT1MnKSB7XG4gICAgICAgIGZvciAobGV0IGF2YWlsYWJsZURldmljZSBvZiBhdmFpbGFibGVEZXZpY2VzKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNEZXZpY2UgPSBwcmV2aW91c0RldmljZXMuZmluZChpbmZvID0+IGluZm8uZGV2aWNlSWQgPT09IGF2YWlsYWJsZURldmljZS5kZXZpY2VJZCk7XG4gICAgICAgICAgaWYgKHByZXZpb3VzRGV2aWNlICYmIHByZXZpb3VzRGV2aWNlLmxhYmVsICE9PSAnJyAmJiBwcmV2aW91c0RldmljZS5raW5kID09PSBhdmFpbGFibGVEZXZpY2Uua2luZCAmJiBwcmV2aW91c0RldmljZS5sYWJlbCAhPT0gYXZhaWxhYmxlRGV2aWNlLmxhYmVsKSB7XG4gICAgICAgICAgICAvLyBsYWJlbCBoYXMgY2hhbmdlZCBvbiBkZXZpY2UgdGhlIHNhbWUgZGV2aWNlSWQsIGluZGljYXRpbmcgdGhhdCB0aGUgZGVmYXVsdCBkZXZpY2UgaGFzIGNoYW5nZWQgb24gdGhlIE9TIGxldmVsXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBY3RpdmVEZXZpY2UoYXZhaWxhYmxlRGV2aWNlLmtpbmQpID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgLy8gZW1pdCBhbiBhY3RpdmUgZGV2aWNlIGNoYW5nZSBldmVudCBvbmx5IGlmIHRoZSBzZWxlY3RlZCBvdXRwdXQgZGV2aWNlIGlzIGFjdHVhbGx5IG9uIGBkZWZhdWx0YFxuICAgICAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWQsIGF2YWlsYWJsZURldmljZS5raW5kLCBhdmFpbGFibGVEZXZpY2UuZGV2aWNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qga2luZHMgPSBbJ2F1ZGlvb3V0cHV0JywgJ2F1ZGlvaW5wdXQnLCAndmlkZW9pbnB1dCddO1xuICAgICAgZm9yIChsZXQga2luZCBvZiBraW5kcykge1xuICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBraW5kVG9Tb3VyY2Uoa2luZCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFB1YmxpY2F0aW9uID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24odGFyZ2V0U291cmNlKTtcbiAgICAgICAgaWYgKHRhcmdldFB1YmxpY2F0aW9uICYmICgoX2EgPSB0YXJnZXRQdWJsaWNhdGlvbi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXNlclByb3ZpZGVkKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSB0cmFjayBpcyB1c2VyIHByb3ZpZGVkLCB3ZSBkb24ndCB3YW50IHRvIHN3aXRjaCBkZXZpY2VzIG9uIGJlaGFsZiBvZiB0aGUgdXNlclxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldmljZXNPZktpbmQgPSBhdmFpbGFibGVEZXZpY2VzLmZpbHRlcihkID0+IGQua2luZCA9PT0ga2luZCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZURldmljZSA9IHRoaXMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpO1xuICAgICAgICBpZiAoYWN0aXZlRGV2aWNlID09PSAoKF9iID0gcHJldmlvdXNEZXZpY2VzLmZpbHRlcihpbmZvID0+IGluZm8ua2luZCA9PT0ga2luZClbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXZpY2VJZCkpIHtcbiAgICAgICAgICAvLyBpbiAgU2FmYXJpIHRoZSBmaXJzdCBkZXZpY2UgaXMgYWx3YXlzIHRoZSBkZWZhdWx0LCBzbyB3ZSBhc3N1bWUgYSB1c2VyIG9uIHRoZSBkZWZhdWx0IGRldmljZSB3b3VsZCBsaWtlIHRvIHN3aXRjaCB0byB0aGUgZGVmYXVsdCBvbmNlIGl0IGNoYW5nZXNcbiAgICAgICAgICAvLyBGRiBkb2Vzbid0IGVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgZGVmYXVsdCBkZXZpY2UgY2hhbmdlcywgc28gd2UgcGVyZm9ybSB0aGUgc2FtZSBiZXN0IGVmZm9ydCBhbmQgc3dpdGNoIHRvIHRoZSBuZXcgZGV2aWNlIG9uY2UgY29ubmVjdGVkIGFuZCBpZiBpdCdzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICBpZiAoZGV2aWNlc09mS2luZC5sZW5ndGggPiAwICYmICgoX2MgPSBkZXZpY2VzT2ZLaW5kWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGV2aWNlSWQpICE9PSBhY3RpdmVEZXZpY2UpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmQsIGRldmljZXNPZktpbmRbMF0uZGV2aWNlSWQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcgJiYgIWlzU2FmYXJpQmFzZWQoKSB8fCBraW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgICAgICAgICAvLyBhaXJwb2RzIG9uIFNhZmFyaSBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGF1ZGlvaW5wdXQgYXMgdGhlIHRyYWNrIGRvZXNuJ3QgZW5kIGFzIHNvb24gYXMgeW91IHRha2UgdGhlbSBvdXRcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2l0Y2ggdG8gZmlyc3QgYXZhaWxhYmxlIGRldmljZSBpZiBwcmV2aW91c2x5IGFjdGl2ZSBkZXZpY2UgaXMgbm90IGF2YWlsYWJsZSBhbnkgbW9yZVxuICAgICAgICBpZiAoZGV2aWNlc09mS2luZC5sZW5ndGggPiAwICYmICFkZXZpY2VzT2ZLaW5kLmZpbmQoZGV2aWNlSW5mbyA9PiBkZXZpY2VJbmZvLmRldmljZUlkID09PSB0aGlzLmdldEFjdGl2ZURldmljZShraW5kKSkgJiYgKFxuICAgICAgICAvLyBhdm9pZCBzd2l0Y2hpbmcgYXVkaW8gb3V0cHV0IG9uIHNhZmFyaSB3aXRob3V0IGV4cGxpY2l0IHVzZXIgYWN0aW9uIGFzIGl0IGxlYWRzIHRvIHNsb3dlZCBkb3duIGF1ZGlvIHBsYXliYWNrXG4gICAgICAgIGtpbmQgIT09ICdhdWRpb291dHB1dCcgfHwgIWlzU2FmYXJpQmFzZWQoKSkpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VzT2ZLaW5kWzBdLmRldmljZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFjcXVpcmVBdWRpb0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCAhPT0gJ2Jvb2xlYW4nICYmIHRoaXMub3B0aW9ucy53ZWJBdWRpb01peC5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgLy8gb3ZlcnJpZGUgYXVkaW8gY29udGV4dCB3aXRoIGN1c3RvbSBhdWRpbyBjb250ZXh0IGlmIHN1cHBsaWVkIGJ5IHVzZXJcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSB0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXguYXVkaW9Db250ZXh0O1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5hdWRpb0NvbnRleHQgfHwgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIC8vIGJ5IHVzaW5nIGFuIEF1ZGlvQ29udGV4dCwgaXQgcmVkdWNlcyBsYWcgb24gYXVkaW8gZWxlbWVudHNcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTgxMTQyOS9odG1sNS1hdWRpby10YWctb24tc2FmYXJpLWhhcy1hLWRlbGF5LzU0MTE5ODU0IzU0MTE5ODU0XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gKF9hID0gZ2V0TmV3QXVkaW9Db250ZXh0KCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiBwYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIHRoaXMuYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAvLyBmb3IgaU9TIGEgbmV3bHkgY3JlYXRlZCBBdWRpb0NvbnRleHQgaXMgYWx3YXlzIGluIGBzdXNwZW5kZWRgIHN0YXRlLlxuICAgICAgICAvLyB3ZSB0cnkgb3VyIGJlc3QgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGhlcmUsIGlmIHRoYXQgZG9lc24ndCB3b3JrLCB3ZSBqdXN0IGNvbnRpbnVlIHdpdGggcmVndWxhciBwcm9jZXNzaW5nXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFt0aGlzLmF1ZGlvQ29udGV4dC5yZXN1bWUoKSwgc2xlZXAoMjAwKV0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignQ291bGQgbm90IHJlc3VtZSBhdWRpbyBjb250ZXh0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q29udGV4dElzUnVubmluZyA9ICgoX2IgPSB0aGlzLmF1ZGlvQ29udGV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXRlKSA9PT0gJ3J1bm5pbmcnO1xuICAgICAgaWYgKG5ld0NvbnRleHRJc1J1bm5pbmcgIT09IHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IG5ld0NvbnRleHRJc1J1bm5pbmc7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIG5ld0NvbnRleHRJc1J1bm5pbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVBhcnRpY2lwYW50KGlkZW50aXR5LCBpbmZvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJ0aWNpcGFudDtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcGFydGljaXBhbnQgPSBSZW1vdGVQYXJ0aWNpcGFudC5mcm9tUGFydGljaXBhbnRJbmZvKHRoaXMuZW5naW5lLmNsaWVudCwgaW5mbywge1xuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IG5ldyBSZW1vdGVQYXJ0aWNpcGFudCh0aGlzLmVuZ2luZS5jbGllbnQsICcnLCBpZGVudGl0eSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XG4gICAgICBwYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoKF9hID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV2aWNlSWQpIHtcbiAgICAgIHBhcnRpY2lwYW50LnNldEF1ZGlvT3V0cHV0KHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkuY2F0Y2goZSA9PiB0aGlzLmxvZy53YXJuKFwiQ291bGQgbm90IHNldCBhdWRpbyBvdXRwdXQ6IFwiLmNvbmNhdChlLm1lc3NhZ2UpLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICB9XG4gIGdldE9yQ3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pIHtcbiAgICBpZiAodGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuaGFzKGlkZW50aXR5KSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJ0aWNpcGFudCA9IHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpZGVudGl0eSk7XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBjb25zdCB3YXNVcGRhdGVkID0gZXhpc3RpbmdQYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgICBpZiAod2FzVXBkYXRlZCkge1xuICAgICAgICAgIHRoaXMuc2lkVG9JZGVudGl0eS5zZXQoaW5mby5zaWQsIGluZm8uaWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhpc3RpbmdQYXJ0aWNpcGFudDtcbiAgICB9XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmNyZWF0ZVBhcnRpY2lwYW50KGlkZW50aXR5LCBpbmZvKTtcbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5zZXQoaWRlbnRpdHksIHBhcnRpY2lwYW50KTtcbiAgICB0aGlzLnNpZFRvSWRlbnRpdHkuc2V0KGluZm8uc2lkLCBpbmZvLmlkZW50aXR5KTtcbiAgICAvLyBpZiB3ZSBoYXZlIHZhbGlkIGluZm8gYW5kIHRoZSBwYXJ0aWNpcGFudCB3YXNuJ3QgaW4gdGhlIG1hcCBiZWZvcmUsIHdlIGNhbiBhc3N1bWUgdGhlIHBhcnRpY2lwYW50IGlzIG5ld1xuICAgIC8vIGZpcmluZyBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IGBQYXJ0aWNpcGFudENvbm5lY3RlZGAgZmlyZXMgYmVmb3JlIHRoZSBpbml0aWFsIHRyYWNrIGV2ZW50c1xuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgLy8gYWxzbyBmb3J3YXJkIGV2ZW50c1xuICAgIC8vIHRyYWNrUHVibGlzaGVkIGlzIG9ubHkgZmlyZWQgZm9yIHRyYWNrcyBhZGRlZCBhZnRlciBib3RoIGxvY2FsIHBhcnRpY2lwYW50XG4gICAgLy8gYW5kIHJlbW90ZSBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb21cbiAgICBwYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrUHVibGlzaGVkLCB0cmFja1B1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCB0cmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHVibGljYXRpb24pID0+IHtcbiAgICAgIC8vIG1vbml0b3IgcGxheWJhY2sgc3RhdHVzXG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKTtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5BdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHksIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHViLCBzdGF0dXMsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCAodHJhY2tTaWQsIGVycm9yKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCB0cmFja1NpZCwgcGFydGljaXBhbnQsIGVycm9yKTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgcHViLCBzdGF0dXMsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LkFjdGl2ZSwgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRBY3RpdmUsIHBhcnRpY2lwYW50KTtcbiAgICAgIGlmIChwYXJ0aWNpcGFudC5raW5kID09PSBQYXJ0aWNpcGFudEluZm9fS2luZC5BR0VOVCkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0QWN0aXZlQWdlbnQocGFydGljaXBhbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHVwZGF0ZSBpbmZvIGF0IHRoZSBlbmQgYWZ0ZXIgY2FsbGJhY2tzIGhhdmUgYmVlbiBzZXQgdXBcbiAgICBpZiAoaW5mbykge1xuICAgICAgcGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICB9XG4gIHNlbmRTeW5jU3RhdGUoKSB7XG4gICAgY29uc3QgcmVtb3RlVHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICBhY2MucHVzaCguLi5wYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIExvY2FsVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgdGhpcy5lbmdpbmUuc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3MsIGxvY2FsVHJhY2tzKTtcbiAgfVxuICAvKipcbiAgICogQWZ0ZXIgcmVzdW1pbmcsIHdlJ2xsIG5lZWQgdG8gbm90aWZ5IHRoZSBzZXJ2ZXIgb2YgdGhlIGN1cnJlbnRcbiAgICogc3Vic2NyaXB0aW9uIHNldHRpbmdzLlxuICAgKi9cbiAgdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgcHViIG9mIHAudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAocHViLmlzU3Vic2NyaWJlZCAmJiBpc1JlbW90ZVB1YihwdWIpKSB7XG4gICAgICAgICAgcHViLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc2lkKSB7XG4gICAgY29uc3QgaWRlbnRpdHkgPSB0aGlzLnNpZFRvSWRlbnRpdHkuZ2V0KHNpZCk7XG4gICAgaWYgKGlkZW50aXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgbGV0IGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gZW5zdXJlIHdlIGRpZG4ndCB0ZWFyIGl0IGRvd25cbiAgICAgICF0aGlzLmVuZ2luZSB8fFxuICAgICAgLy8gZW5naW5lIGRldGVjdGVkIGNsb3NlLCBidXQgUm9vbSBtaXNzZWQgaXRcbiAgICAgIHRoaXMuZW5naW5lLmlzQ2xvc2VkIHx8XG4gICAgICAvLyB0cmFuc3BvcnRzIGZhaWxlZCB3aXRob3V0IG5vdGlmeWluZyBlbmdpbmVcbiAgICAgICF0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSkge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzKys7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2RldGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUgbWlzbWF0Y2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBudW1GYWlsdXJlczogY29uc2VjdXRpdmVGYWlsdXJlcyxcbiAgICAgICAgICBlbmdpbmU6IHRoaXMuZW5naW5lID8ge1xuICAgICAgICAgICAgY2xvc2VkOiB0aGlzLmVuZ2luZS5pc0Nsb3NlZCxcbiAgICAgICAgICAgIHRyYW5zcG9ydHNDb25uZWN0ZWQ6IHRoaXMuZW5naW5lLnZlcmlmeVRyYW5zcG9ydCgpXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChjb25zZWN1dGl2ZUZhaWx1cmVzID49IDMpIHtcbiAgICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBEaXNjb25uZWN0UmVhc29uLlNUQVRFX01JU01BVENIKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICB9XG4gICAgfSwgQ09OTkVDVElPTl9SRUNPTkNJTEVfRlJFUVVFTkNZX01TKTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKTtcbiAgICB9XG4gIH1cbiAgc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgLy8gdW5jaGFuZ2VkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHRoaXMuc3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVtaXRCdWZmZXJlZEV2ZW50cygpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzLmZvckVhY2goX3JlZjMgPT4ge1xuICAgICAgbGV0IFtldiwgYXJnc10gPSBfcmVmMztcbiAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICB9XG4gIGVtaXRXaGVuQ29ubmVjdGVkKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZyB8fCAhdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUucGVuZGluZ1JlY29ubmVjdCkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgcm9vbSBpcyByZWNvbm5lY3RpbmcsIGJ1ZmZlciB0aGUgZXZlbnRzIGJ5IGZpcmluZyB0aGVtIGxhdGVyIGFmdGVyIGVtaXR0aW5nIFJvb21FdmVudC5SZWNvbm5lY3RlZFxuICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cy5wdXNoKFtldmVudCwgYXJnc10pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRvIHBvcHVsYXRlIGEgcm9vbSB3aXRoIHNpbXVsYXRlZCBwYXJ0aWNpcGFudHMuXG4gICAqIE5vIGFjdHVhbCBjb25uZWN0aW9uIHRvIGEgc2VydmVyIHdpbGwgYmUgZXN0YWJsaXNoZWQsIGFsbCBzdGF0ZSBpc1xuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzaW11bGF0ZVBhcnRpY2lwYW50cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBwdWJsaXNoT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zLnB1Ymxpc2gpO1xuICAgICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNvdW50OiA5LFxuICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICBhc3BlY3RSYXRpb3M6IFsxLjY2LCAxLjcsIDEuM11cbiAgICAgIH0sIG9wdGlvbnMucGFydGljaXBhbnRzKTtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tJDEoe1xuICAgICAgICBzaWQ6ICdSTV9TSU1VTEFURUQnLFxuICAgICAgICBuYW1lOiAnc2ltdWxhdGVkLXJvb20nLFxuICAgICAgICBlbXB0eVRpbWVvdXQ6IDAsXG4gICAgICAgIG1heFBhcnRpY2lwYW50czogMCxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBwcm90b0ludDY0LnBhcnNlKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSxcbiAgICAgICAgbWV0YWRhdGE6ICcnLFxuICAgICAgICBudW1QYXJ0aWNpcGFudHM6IDEsXG4gICAgICAgIG51bVB1Ymxpc2hlcnM6IDEsXG4gICAgICAgIHR1cm5QYXNzd29yZDogJycsXG4gICAgICAgIGVuYWJsZWRDb2RlY3M6IFtdLFxuICAgICAgICBhY3RpdmVSZWNvcmRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51cGRhdGVJbmZvKG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJ1xuICAgICAgfSkpO1xuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgIGlmIChwdWJsaXNoT3B0aW9ucy52aWRlbykge1xuICAgICAgICBjb25zdCBjYW1QdWIgPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKFRyYWNrLktpbmQuVmlkZW8sIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICAgIG5hbWU6ICd2aWRlby1kdW1teSdcbiAgICAgICAgfSksIG5ldyBMb2NhbFZpZGVvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH0pKS5nZXRWaWRlb1RyYWNrcygpWzBdIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKDE2MCAqICgoX2EgPSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSwgMTYwLCB0cnVlLCB0cnVlKSwgdW5kZWZpbmVkLCBmYWxzZSwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oY2FtUHViKTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBjYW1QdWIpO1xuICAgICAgfVxuICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgIGNvbnN0IGF1ZGlvUHViID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbihUcmFjay5LaW5kLkF1ZGlvLCBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgfSksIG5ldyBMb2NhbEF1ZGlvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgYXVkaW86IHRydWVcbiAgICAgICAgfSkpLmdldEF1ZGlvVHJhY2tzKClbMF0gOiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSwgdW5kZWZpbmVkLCBmYWxzZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KSwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hZGRUcmFja1B1YmxpY2F0aW9uKGF1ZGlvUHViKTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhdWRpb1B1Yik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2lwYW50T3B0aW9ucy5jb3VudCAtIDE7IGkgKz0gMSkge1xuICAgICAgICBsZXQgaW5mbyA9IG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgaWRlbnRpdHk6IFwic2ltdWxhdGVkLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICBzdGF0ZTogUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSxcbiAgICAgICAgICB0cmFja3M6IFtdLFxuICAgICAgICAgIGpvaW5lZEF0OiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uaWRlbnRpdHksIGluZm8pO1xuICAgICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlWaWRlbyA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygxNjAgKiAoKF9iID0gcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvc1tpICUgcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvcy5sZW5ndGhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxKSwgMTYwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5DQU1FUkEsXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVZpZGVvLCB2aWRlb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVZpZGVvXSksIG5ldyBSVENSdHBSZWNlaXZlcigpKTtcbiAgICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgdmlkZW9UcmFja107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy5hdWRpbykge1xuICAgICAgICAgIGNvbnN0IGR1bW15VHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gbmV3IFRyYWNrSW5mbyh7XG4gICAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVRyYWNrLCBhdWRpb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVRyYWNrXSksIG5ldyBSVENSdHBSZWNlaXZlcigpKTtcbiAgICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgYXVkaW9UcmFja107XG4gICAgICAgIH1cbiAgICAgICAgcC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIC8qKiBAaW50ZXJuYWwgKi9cbiAgZW1pdChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICAvLyBhY3RpdmUgc3BlYWtlciB1cGRhdGVzIGFyZSB0b28gc3BhbW15XG4gICAgaWYgKGV2ZW50ICE9PSBSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkICYmIGV2ZW50ICE9PSBSb29tRXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkKSB7XG4gICAgICAvLyBvbmx5IGV4dHJhY3QgbG9nQ29udGV4dCBmcm9tIGFyZ3VtZW50cyBpbiBvcmRlciB0byBhdm9pZCBsb2dnaW5nIHRoZSB3aG9sZSBvYmplY3QgdHJlZVxuICAgICAgY29uc3QgbWluaW1pemVkQXJncyA9IG1hcEFyZ3MoYXJncykuZmlsdGVyKGFyZyA9PiBhcmcgIT09IHVuZGVmaW5lZCk7XG4gICAgICBpZiAoZXZlbnQgPT09IFJvb21FdmVudC5UcmFja1N1YnNjcmliZWQgfHwgZXZlbnQgPT09IFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICB0aGlzLmxvZy50cmFjZShcInN1YnNjcmliZSB0cmFjZTogXCIuY29uY2F0KGV2ZW50KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgYXJnczogbWluaW1pemVkQXJnc1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJvb20gZXZlbnQgXCIuY29uY2F0KGV2ZW50KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBhcmdzOiBtaW5pbWl6ZWRBcmdzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuUm9vbS5jbGVhbnVwUmVnaXN0cnkgPSB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShjbGVhbnVwID0+IHtcbiAgY2xlYW51cCgpO1xufSk7XG5mdW5jdGlvbiBtYXBBcmdzKGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MubWFwKGFyZyA9PiB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgcmV0dXJuIG1hcEFyZ3MoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gJ2xvZ0NvbnRleHQnIGluIGFyZyA/IGFyZy5sb2dDb250ZXh0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9KTtcbn1cblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgZnJvbSBKU09OIFNjaGVtYSB1c2luZyBxdWlja3R5cGUsIGRvIG5vdCBtb2RpZnkgaXQgZGlyZWN0bHkuXG4vLyBUaGUgY29kZSBnZW5lcmF0aW9uIGxpdmVzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L2F0dHJpYnV0ZS1kZWZpbml0aW9uc1xuLy9cbi8vIFRvIHBhcnNlIHRoaXMgZGF0YTpcbi8vXG4vLyAgIGltcG9ydCB7IENvbnZlcnQsIEFnZW50QXR0cmlidXRlcywgVHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9maWxlXCI7XG4vL1xuLy8gICBjb25zdCBhZ2VudEF0dHJpYnV0ZXMgPSBDb252ZXJ0LnRvQWdlbnRBdHRyaWJ1dGVzKGpzb24pO1xuLy8gICBjb25zdCB0cmFuc2NyaXB0aW9uQXR0cmlidXRlcyA9IENvbnZlcnQudG9UcmFuc2NyaXB0aW9uQXR0cmlidXRlcyhqc29uKTtcbi8vIENvbnZlcnRzIEpTT04gc3RyaW5ncyB0by9mcm9tIHlvdXIgdHlwZXNcbmNsYXNzIENvbnZlcnQge1xuICBzdGF0aWMgdG9BZ2VudEF0dHJpYnV0ZXMoanNvbikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICB9XG4gIHN0YXRpYyBhZ2VudEF0dHJpYnV0ZXNUb0pzb24odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIHN0YXRpYyB0b1RyYW5zY3JpcHRpb25BdHRyaWJ1dGVzKGpzb24pIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgfVxuICBzdGF0aWMgdHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXNUb0pzb24odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRyaWJ1dGVUeXBpbmdzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIENvbnZlcnQ6IENvbnZlcnRcbn0pO1xuXG52YXIgQ2hlY2tTdGF0dXM7XG4oZnVuY3Rpb24gKENoZWNrU3RhdHVzKSB7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiUlVOTklOR1wiXSA9IDFdID0gXCJSVU5OSU5HXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU0tJUFBFRFwiXSA9IDJdID0gXCJTS0lQUEVEXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU1VDQ0VTU1wiXSA9IDNdID0gXCJTVUNDRVNTXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiRkFJTEVEXCJdID0gNF0gPSBcIkZBSUxFRFwiO1xufSkoQ2hlY2tTdGF0dXMgfHwgKENoZWNrU3RhdHVzID0ge30pKTtcbmNsYXNzIENoZWNrZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXR1cyA9IENoZWNrU3RhdHVzLklETEU7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJvb20gPSBuZXcgUm9vbShvcHRpb25zLnJvb21PcHRpb25zKTtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0aW9ucy5jb25uZWN0T3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHJ1bihvbkNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuSURMRSkge1xuICAgICAgICB0aHJvdyBFcnJvcignY2hlY2sgaXMgcnVubmluZyBhbHJlYWR5Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5SVU5OSU5HKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXJyb3JzQXNXYXJuaW5ncykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIC8vIHNsZWVwIGZvciBhIGJpdCB0byBlbnN1cmUgZGlzY29ubmVjdFxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5TS0lQUEVEKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHRoaXMuaXNTdWNjZXNzKCkgPyBDaGVja1N0YXR1cy5TVUNDRVNTIDogQ2hlY2tTdGF0dXMuRkFJTEVEKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldEluZm8oKTtcbiAgICB9KTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuICF0aGlzLmxvZ3Muc29tZShsID0+IGwubGV2ZWwgPT09ICdlcnJvcicpO1xuICB9XG4gIGNvbm5lY3QodXJsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnJvb20uc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vbTtcbiAgICAgIH1cbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHVybCA9IHRoaXMudXJsO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yb29tLmNvbm5lY3QodXJsLCB0aGlzLnRva2VuLCB0aGlzLmNvbm5lY3RPcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgfSk7XG4gIH1cbiAgZGlzY29ubmVjdCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucm9vbSAmJiB0aGlzLnJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yb29tLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgLy8gd2FpdCBmb3IgaXQgdG8gZ28gdGhyb3VnaFxuICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2tpcCgpIHtcbiAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5TS0lQUEVEKTtcbiAgfVxuICBzd2l0Y2hQcm90b2NvbChwcm90b2NvbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgaGFzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBsZXQgaGFzUmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCAoKSA9PiB7XG4gICAgICAgIGhhc1JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vbS5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICBoYXNSZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vbS5zaW11bGF0ZVNjZW5hcmlvKFwiZm9yY2UtXCIuY29uY2F0KHByb3RvY29sKSk7XG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgaWYgKCFoYXNSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byB3YWl0IGZvciByZWNvbm5lY3Rpb25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gd2FpdCBmb3IgMTAgc2Vjb25kcyBmb3IgcmVjb25uZWN0aW9uXG4gICAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArIDEwMDAwO1xuICAgICAgd2hpbGUgKERhdGUubm93KCkgPCB0aW1lb3V0KSB7XG4gICAgICAgIGlmIChoYXNSZWNvbm5lY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBzbGVlcCgxMDApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlY29ubmVjdCB1c2luZyBcIi5jb25jYXQocHJvdG9jb2wsIFwiIHByb3RvY29sIGFmdGVyIDEwIHNlY29uZHNcIikpO1xuICAgIH0pO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHRoaXMubG9ncy5wdXNoKHtcbiAgICAgIGxldmVsOiAnaW5mbycsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgYXBwZW5kV2FybmluZyhtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBhcHBlbmRFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgc2V0U3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIGdldCBlbmdpbmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmdpbmU7XG4gIH1cbiAgZ2V0SW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nczogdGhpcy5sb2dzLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBmb3IgY29ubmVjdGlvbnMgcXVhbGl0eSB0byBjbG9zZXN0cyBDbG91ZCByZWdpb25zIGFuZCBkZXRlcm1pbmluZyB0aGUgYmVzdCBxdWFsaXR5XG4gKi9cbmNsYXNzIENsb3VkUmVnaW9uQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ2xvdWQgcmVnaW9ucyc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVnaW9uUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodGhpcy51cmwsIHRoaXMudG9rZW4pO1xuICAgICAgaWYgKCFyZWdpb25Qcm92aWRlci5pc0Nsb3VkKCkpIHtcbiAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2lvblN0YXRzID0gW107XG4gICAgICBjb25zdCBzZWVuVXJscyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IHlpZWxkIHJlZ2lvblByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKCk7XG4gICAgICAgIGlmICghcmVnaW9uVXJsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZW5VcmxzLmhhcyhyZWdpb25VcmwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VlblVybHMuYWRkKHJlZ2lvblVybCk7XG4gICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5jaGVja0Nsb3VkUmVnaW9uKHJlZ2lvblVybCk7XG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIlwiLmNvbmNhdChzdGF0cy5yZWdpb24sIFwiIFJUVDogXCIpLmNvbmNhdChzdGF0cy5ydHQsIFwibXMsIGR1cmF0aW9uOiBcIikuY29uY2F0KHN0YXRzLmR1cmF0aW9uLCBcIm1zXCIpKTtcbiAgICAgICAgcmVnaW9uU3RhdHMucHVzaChzdGF0cyk7XG4gICAgICB9XG4gICAgICByZWdpb25TdGF0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiAoYS5kdXJhdGlvbiAtIGIuZHVyYXRpb24pICogMC41ICsgKGEucnR0IC0gYi5ydHQpICogMC41O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBiZXN0UmVnaW9uID0gcmVnaW9uU3RhdHNbMF07XG4gICAgICB0aGlzLmJlc3RTdGF0cyA9IGJlc3RSZWdpb247XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJiZXN0IENsb3VkIHJlZ2lvbjogXCIuY29uY2F0KGJlc3RSZWdpb24ucmVnaW9uKSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0SW5mbygpIHtcbiAgICBjb25zdCBpbmZvID0gc3VwZXIuZ2V0SW5mbygpO1xuICAgIGluZm8uZGF0YSA9IHRoaXMuYmVzdFN0YXRzO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG4gIGNoZWNrQ2xvdWRSZWdpb24odXJsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB5aWVsZCB0aGlzLmNvbm5lY3QodXJsKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvdG9jb2wgPT09ICd0Y3AnKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoUHJvdG9jb2woJ3RjcCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaW9uID0gKF9hID0gdGhpcy5yb29tLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWdpb247XG4gICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZ2lvbiBub3QgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdyaXRlciA9IHlpZWxkIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LnN0cmVhbVRleHQoe1xuICAgICAgICB0b3BpYzogJ3Rlc3QnXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEwMDA7IC8vIGVhY2ggY2h1bmsgaXMgYWJvdXQgMTAwMCBieXRlc1xuICAgICAgY29uc3QgdG90YWxTaXplID0gMTAwMDAwMDsgLy8gYXBwcm94aW1hdGVseSAxTUIgb2YgZGF0YVxuICAgICAgY29uc3QgbnVtQ2h1bmtzID0gdG90YWxTaXplIC8gY2h1bmtTaXplOyAvLyB3aWxsIHlpZWxkIDEwMDAgY2h1bmtzXG4gICAgICBjb25zdCBjaHVua0RhdGEgPSAnQScucmVwZWF0KGNodW5rU2l6ZSk7IC8vIGNyZWF0ZSBhIHN0cmluZyBvZiAxMDAwICdBJyBjaGFyYWN0ZXJzXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaHVua3M7IGkrKykge1xuICAgICAgICB5aWVsZCB3cml0ZXIud3JpdGUoY2h1bmtEYXRhKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYiA9IHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHVibGlzaGVyLmdldFN0YXRzKCk7XG4gICAgICBjb25zdCByZWdpb25TdGF0cyA9IHtcbiAgICAgICAgcmVnaW9uOiByZWdpb24sXG4gICAgICAgIHJ0dDogMTAwMDAsXG4gICAgICAgIGR1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lXG4gICAgICB9O1xuICAgICAgc3RhdHMgPT09IG51bGwgfHwgc3RhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicgJiYgc3RhdC5ub21pbmF0ZWQpIHtcbiAgICAgICAgICByZWdpb25TdGF0cy5ydHQgPSBzdGF0LmN1cnJlbnRSb3VuZFRyaXBUaW1lICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiByZWdpb25TdGF0cztcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBURVNUX0RVUkFUSU9OID0gMTAwMDA7XG5jbGFzcyBDb25uZWN0aW9uUHJvdG9jb2xDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDb25uZWN0aW9uIHZpYSBVRFAgdnMgVENQJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1ZHBTdGF0cyA9IHlpZWxkIHRoaXMuY2hlY2tDb25uZWN0aW9uUHJvdG9jb2woJ3VkcCcpO1xuICAgICAgY29uc3QgdGNwU3RhdHMgPSB5aWVsZCB0aGlzLmNoZWNrQ29ubmVjdGlvblByb3RvY29sKCd0Y3AnKTtcbiAgICAgIHRoaXMuYmVzdFN0YXRzID0gdWRwU3RhdHM7XG4gICAgICAvLyB1ZHAgc2hvdWxkIGlzIHRoZSBiZXR0ZXIgcHJvdG9jb2wgdHlwaWNhbGx5LiBob3dldmVyLCB3ZSdkIHByZWZlciBUQ1Agd2hlbiBlaXRoZXIgb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbiAgICAgIC8vIDEuIHRoZSBiYW5kd2lkdGggbGltaXRhdGlvbiBpcyB3b3JzZSBvbiBVRFAgYnkgNTAwbXNcbiAgICAgIC8vIDIuIHRoZSBwYWNrZXQgbG9zcyBpcyBoaWdoZXIgb24gVURQIGJ5IDElXG4gICAgICBpZiAodWRwU3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoIC0gdGNwU3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoID4gMC41IHx8ICh1ZHBTdGF0cy5wYWNrZXRzTG9zdCAtIHRjcFN0YXRzLnBhY2tldHNMb3N0KSAvIHVkcFN0YXRzLnBhY2tldHNTZW50ID4gMC4wMSkge1xuICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2Jlc3QgY29ubmVjdGlvbiBxdWFsaXR5IHZpYSB0Y3AnKTtcbiAgICAgICAgdGhpcy5iZXN0U3RhdHMgPSB0Y3BTdGF0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgnYmVzdCBjb25uZWN0aW9uIHF1YWxpdHkgdmlhIHVkcCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLmJlc3RTdGF0cztcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInVwc3RyZWFtIGJpdHJhdGU6IFwiLmNvbmNhdCgoc3RhdHMuYml0cmF0ZVRvdGFsIC8gc3RhdHMuY291bnQgLyAxMDAwIC8gMTAwMCkudG9GaXhlZCgyKSwgXCIgbWJwc1wiKSk7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJSVFQ6IFwiLmNvbmNhdCgoc3RhdHMucnR0VG90YWwgLyBzdGF0cy5jb3VudCAqIDEwMDApLnRvRml4ZWQoMiksIFwiIG1zXCIpKTtcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcImppdHRlcjogXCIuY29uY2F0KChzdGF0cy5qaXR0ZXJUb3RhbCAvIHN0YXRzLmNvdW50ICogMTAwMCkudG9GaXhlZCgyKSwgXCIgbXNcIikpO1xuICAgICAgaWYgKHN0YXRzLnBhY2tldHNMb3N0ID4gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJwYWNrZXRzIGxvc3Q6IFwiLmNvbmNhdCgoc3RhdHMucGFja2V0c0xvc3QgLyBzdGF0cy5wYWNrZXRzU2VudCAqIDEwMCkudG9GaXhlZCgyKSwgXCIlXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggPiAxKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImJhbmR3aWR0aCBsaW1pdGVkIFwiLmNvbmNhdCgoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoIC8gKFRFU1RfRFVSQVRJT04gLyAxMDAwKSAqIDEwMCkudG9GaXhlZCgyKSwgXCIlXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5jcHUgPiAwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImNwdSBsaW1pdGVkIFwiLmNvbmNhdCgoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuY3B1IC8gKFRFU1RfRFVSQVRJT04gLyAxMDAwKSAqIDEwMCkudG9GaXhlZCgyKSwgXCIlXCIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRJbmZvKCkge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRJbmZvKCk7XG4gICAgaW5mby5kYXRhID0gdGhpcy5iZXN0U3RhdHM7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cbiAgY2hlY2tDb25uZWN0aW9uUHJvdG9jb2wocHJvdG9jb2wpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBpZiAocHJvdG9jb2wgPT09ICd0Y3AnKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoUHJvdG9jb2woJ3RjcCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndWRwJyk7XG4gICAgICB9XG4gICAgICAvLyBjcmVhdGUgYSBjYW52YXMgd2l0aCBhbmltYXRlZCBjb250ZW50XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDEyODA7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gNzIwO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIGxldCBodWUgPSAwO1xuICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgaHVlID0gKGh1ZSArIDEpICUgMzYwO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJoc2woXCIuY29uY2F0KGh1ZSwgXCIsIDEwMCUsIDUwJSlcIik7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICB9O1xuICAgICAgYW5pbWF0ZSgpO1xuICAgICAgLy8gY3JlYXRlIHZpZGVvIHRyYWNrIGZyb20gY2FudmFzXG4gICAgICBjb25zdCBzdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgzMCk7IC8vIDMwZnBzXG4gICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAvLyBwdWJsaXNoIHRvIHJvb21cbiAgICAgIGNvbnN0IHB1YiA9IHlpZWxkIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh2aWRlb1RyYWNrLCB7XG4gICAgICAgIHNpbXVsY2FzdDogZmFsc2UsXG4gICAgICAgIGRlZ3JhZGF0aW9uUHJlZmVyZW5jZTogJ21haW50YWluLXJlc29sdXRpb24nLFxuICAgICAgICB2aWRlb0VuY29kaW5nOiB7XG4gICAgICAgICAgbWF4Qml0cmF0ZTogMjAwMDAwMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgY29uc3QgcHJvdG9jb2xTdGF0cyA9IHtcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBhY2tldHNMb3N0OiAwLFxuICAgICAgICBwYWNrZXRzU2VudDogMCxcbiAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM6IHt9LFxuICAgICAgICBydHRUb3RhbDogMCxcbiAgICAgICAgaml0dGVyVG90YWw6IDAsXG4gICAgICAgIGJpdHJhdGVUb3RhbDogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG4gICAgICAvLyBnYXRoZXIgc3RhdHMgb25jZSBhIHNlY29uZFxuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdHJhY2suZ2V0UlRDU3RhdHNSZXBvcnQoKTtcbiAgICAgICAgc3RhdHMgPT09IG51bGwgfHwgc3RhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucGFja2V0c1NlbnQgPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucyA9IHN0YXQucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLmJpdHJhdGVUb3RhbCArPSBzdGF0LnRhcmdldEJpdHJhdGU7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLmNvdW50Kys7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0LnR5cGUgPT09ICdyZW1vdGUtaW5ib3VuZC1ydHAnKSB7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnBhY2tldHNMb3N0ID0gc3RhdC5wYWNrZXRzTG9zdDtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucnR0VG90YWwgKz0gc3RhdC5yb3VuZFRyaXBUaW1lO1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5qaXR0ZXJUb3RhbCArPSBzdGF0LmppdHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksIDEwMDApO1xuICAgICAgLy8gd2FpdCBhIGJpdCB0byBnYXRoZXIgc3RhdHNcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBURVNUX0RVUkFUSU9OKSk7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgIHZpZGVvVHJhY2suc3RvcCgpO1xuICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gcHJvdG9jb2xTdGF0cztcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBQdWJsaXNoQXVkaW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCBhdWRpbyc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soKTtcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBkZXRlY3RTaWxlbmNlKHRyYWNrLCAxMDAwKTtcbiAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRldGVjdCBhdWRpbyBmcm9tIG1pY3JvcGhvbmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgnZGV0ZWN0ZWQgYXVkaW8gZnJvbSBtaWNyb3Bob25lJyk7XG4gICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAgIC8vIHdhaXQgZm9yIGEgZmV3IHNlY29uZHMgdG8gcHVibGlzaFxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcbiAgICAgIC8vIHZlcmlmeSBSVEMgc3RhdHMgdGhhdCBpdCdzIHB1Ymxpc2hpbmdcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgKF9hID0gdHJhY2suc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMoKTtcbiAgICAgIGlmICghc3RhdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XG4gICAgICB9XG4gICAgICBsZXQgbnVtUGFja2V0cyA9IDA7XG4gICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJiAoc3RhdC5raW5kID09PSAnYXVkaW8nIHx8ICFzdGF0LmtpbmQgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICdhdWRpbycpKSB7XG4gICAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInB1Ymxpc2hlZCBcIi5jb25jYXQobnVtUGFja2V0cywgXCIgYXVkaW8gcGFja2V0c1wiKSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUHVibGlzaFZpZGVvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggdmlkZW8nO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHJvb20gPSB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCk7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGZyb20gY2FtZXJhXG4gICAgICB5aWVsZCB0aGlzLmNoZWNrRm9yVmlkZW8odHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAgIC8vIHdhaXQgZm9yIGEgZmV3IHNlY29uZHMgdG8gcHVibGlzaFxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcbiAgICAgIC8vIHZlcmlmeSBSVEMgc3RhdHMgdGhhdCBpdCdzIHB1Ymxpc2hpbmdcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgKF9hID0gdHJhY2suc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMoKTtcbiAgICAgIGlmICghc3RhdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XG4gICAgICB9XG4gICAgICBsZXQgbnVtUGFja2V0cyA9IDA7XG4gICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJiAoc3RhdC5raW5kID09PSAndmlkZW8nIHx8ICFzdGF0LmtpbmQgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICd2aWRlbycpKSB7XG4gICAgICAgICAgbnVtUGFja2V0cyArPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChudW1QYWNrZXRzID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJwdWJsaXNoZWQgXCIuY29uY2F0KG51bVBhY2tldHMsIFwiIHZpZGVvIHBhY2tldHNcIikpO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrRm9yVmlkZW8odHJhY2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICBzdHJlYW0uYWRkVHJhY2sodHJhY2suY2xvbmUoKSk7XG4gICAgICAvLyBDcmVhdGUgdmlkZW8gZWxlbWVudCB0byBjaGVjayBmcmFtZXNcbiAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgIHZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgIHZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgIC8vIEZvciBpT1MgU2FmYXJpXG4gICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJ3RydWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodmlkZW8pO1xuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHZpZGVvLm9ucGxheSA9ICgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAoX2IgPSAoX2EgPSBzZXR0aW5ncy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmlkZW8udmlkZW9XaWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTI4MDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChfZCA9IChfYyA9IHNldHRpbmdzLmhlaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdmlkZW8udmlkZW9IZWlnaHQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDcyMDtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgLy8gRHJhdyB2aWRlbyBmcmFtZSB0byBjYW52YXNcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApO1xuICAgICAgICAgICAgLy8gR2V0IGltYWdlIGRhdGEgYW5kIGNoZWNrIGlmIGFsbCBwaXhlbHMgYXJlIGJsYWNrXG4gICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICBsZXQgaXNBbGxCbGFjayA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gIT09IDAgfHwgZGF0YVtpICsgMV0gIT09IDAgfHwgZGF0YVtpICsgMl0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBpc0FsbEJsYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FsbEJsYWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoJ2NhbWVyYSBhcHBlYXJzIHRvIGJlIHByb2R1Y2luZyBvbmx5IGJsYWNrIGZyYW1lcycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdyZWNlaXZlZCB2aWRlbyBmcmFtZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgfSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgIHZpZGVvLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFJlY29ubmVjdENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gYWZ0ZXIgaW50ZXJydXB0aW9uJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBsZXQgcmVjb25uZWN0aW5nVHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICBsZXQgcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGxldCByZWNvbm5lY3RSZXNvbHZlcjtcbiAgICAgIGNvbnN0IHJlY29ubmVjdFRpbWVvdXQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKTtcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBoYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IHRydWU7XG4gICAgICB9O1xuICAgICAgcm9vbS5vbihSb29tRXZlbnQuU2lnbmFsUmVjb25uZWN0aW5nLCBoYW5kbGVSZWNvbm5lY3RpbmcpLm9uKFJvb21FdmVudC5SZWNvbm5lY3RpbmcsIGhhbmRsZVJlY29ubmVjdGluZykub24oUm9vbUV2ZW50LlJlY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIChfYSA9IHJvb20uZW5naW5lLmNsaWVudC53cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICBjb25zdCBvbkNsb3NlID0gcm9vbS5lbmdpbmUuY2xpZW50Lm9uQ2xvc2U7XG4gICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICBvbkNsb3NlKCcnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHJlY29ubmVjdFRpbWVvdXQ7XG4gICAgICBpZiAoIXJlY29ubmVjdGluZ1RyaWdnZXJlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3QnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlY29ubmVjdGVkIHx8IHJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdyZWNvbm5lY3Rpb24gaXMgb25seSBwb3NzaWJsZSBpbiBSZWRpcy1iYXNlZCBjb25maWd1cmF0aW9ucycpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIHJlY29ubmVjdCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFRVUk5DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gY29ubmVjdCB2aWEgVFVSTic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHNpZ25hbENsaWVudCA9IG5ldyBTaWduYWxDbGllbnQoKTtcbiAgICAgIGNvbnN0IGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICAgICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICBzaW5nbGVQZWVyQ29ubmVjdGlvbjogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbGV0IGhhc1RMUyA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1RVUk4gPSBmYWxzZTtcbiAgICAgIGxldCBoYXNTVFVOID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpY2VTZXJ2ZXIgb2Ygam9pblJlcy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGZvciAobGV0IHVybCBvZiBpY2VTZXJ2ZXIudXJscykge1xuICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgndHVybjonKSkge1xuICAgICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuczonKSkge1xuICAgICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1RMUyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnc3R1bjonKSkge1xuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1NUVU4pIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBTVFVOIHNlcnZlcnMgY29uZmlndXJlZCBvbiBzZXJ2ZXIgc2lkZS4nKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzVFVSTiAmJiAhaGFzVExTKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnVFVSTiBpcyBjb25maWd1cmVkIHNlcnZlciBzaWRlLCBidXQgVFVSTi9UTFMgaXMgdW5hdmFpbGFibGUuJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCBzaWduYWxDbGllbnQuY2xvc2UoKTtcbiAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5jb25uZWN0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ0Y0NvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmljZVNlcnZlcnMpIHx8IGhhc1RVUk4pIHtcbiAgICAgICAgeWllbGQgdGhpcy5yb29tLmNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgICBydGNDb25maWc6IHtcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ3JlbGF5J1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFRVUk4gc2VydmVycyBjb25maWd1cmVkLicpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBXZWJSVENDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdFc3RhYmxpc2hpbmcgV2ViUlRDIGNvbm5lY3Rpb24nO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBoYXNUY3AgPSBmYWxzZTtcbiAgICAgIGxldCBoYXNJcHY0VWRwID0gZmFsc2U7XG4gICAgICB0aGlzLnJvb20ub24oUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHByZXZUcmlja2xlID0gdGhpcy5yb29tLmVuZ2luZS5jbGllbnQub25Ucmlja2xlO1xuICAgICAgICB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGUgPSAoc2QsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIGlmIChzZC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG5ldyBSVENJY2VDYW5kaWRhdGUoc2QpO1xuICAgICAgICAgICAgbGV0IHN0ciA9IFwiXCIuY29uY2F0KGNhbmRpZGF0ZS5wcm90b2NvbCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUuYWRkcmVzcywgXCI6XCIpLmNvbmNhdChjYW5kaWRhdGUucG9ydCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUudHlwZSk7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgaWYgKGlzSVBQcml2YXRlKGNhbmRpZGF0ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnIChwcml2YXRlKSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3RjcCcgJiYgY2FuZGlkYXRlLnRjcFR5cGUgPT09ICdwYXNzaXZlJykge1xuICAgICAgICAgICAgICAgICAgaGFzVGNwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnIChwYXNzaXZlKSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUucHJvdG9jb2wgPT09ICd1ZHAnKSB7XG4gICAgICAgICAgICAgICAgICBoYXNJcHY0VWRwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShzdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRyaWNrbGUpIHtcbiAgICAgICAgICAgIHByZXZUcmlja2xlKHNkLCB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaWJlcikge1xuICAgICAgICAgIHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGVFcnJvciA9IGV2ID0+IHtcbiAgICAgICAgICAgIGlmIChldiBpbnN0YW5jZW9mIFJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJlcnJvciB3aXRoIElDRSBjYW5kaWRhdGU6IFwiLmNvbmNhdChldi5lcnJvckNvZGUsIFwiIFwiKS5jb25jYXQoZXYuZXJyb3JUZXh0LCBcIiBcIikuY29uY2F0KGV2LnVybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbygnbm93IHRoZSByb29tIGlzIGNvbm5lY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncG9ydHMgbmVlZCB0byBiZSBvcGVuIG9uIGZpcmV3YWxsIGluIG9yZGVyIHRvIGNvbm5lY3QuJyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzVGNwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnU2VydmVyIGlzIG5vdCBjb25maWd1cmVkIGZvciBJQ0UvVENQJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0lwdjRVZHApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBwdWJsaWMgSVB2NCBVRFAgY2FuZGlkYXRlcyB3ZXJlIGZvdW5kLiBZb3VyIHNlcnZlciBpcyBsaWtlbHkgbm90IGNvbmZpZ3VyZWQgY29ycmVjdGx5Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSVBQcml2YXRlKGFkZHJlc3MpIHtcbiAgY29uc3QgcGFydHMgPSBhZGRyZXNzLnNwbGl0KCcuJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHtcbiAgICBpZiAocGFydHNbMF0gPT09ICcxMCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxOTInICYmIHBhcnRzWzFdID09PSAnMTY4Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJzE3MicpIHtcbiAgICAgIGNvbnN0IHNlY29uZCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICBpZiAoc2Vjb25kID49IDE2ICYmIHNlY29uZCA8PSAzMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBXZWJTb2NrZXRDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDb25uZWN0aW5nIHRvIHNpZ25hbCBjb25uZWN0aW9uIHZpYSBXZWJTb2NrZXQnO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgaWYgKHRoaXMudXJsLnN0YXJ0c1dpdGgoJ3dzOicpIHx8IHRoaXMudXJsLnN0YXJ0c1dpdGgoJ2h0dHA6JykpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgaW5zZWN1cmUsIGNsaWVudHMgbWF5IGJsb2NrIGNvbm5lY3Rpb25zIHRvIGl0Jyk7XG4gICAgICB9XG4gICAgICBsZXQgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xuICAgICAgY29uc3Qgam9pblJlcyA9IHlpZWxkIHNpZ25hbENsaWVudC5qb2luKHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IHRydWUsXG4gICAgICAgIG1heFJldHJpZXM6IDAsXG4gICAgICAgIGUyZWVFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogMTUwMDAsXG4gICAgICAgIHNpbmdsZVBlZXJDb25uZWN0aW9uOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJDb25uZWN0ZWQgdG8gc2VydmVyLCB2ZXJzaW9uIFwiLmNvbmNhdChqb2luUmVzLnNlcnZlclZlcnNpb24sIFwiLlwiKSk7XG4gICAgICBpZiAoKChfYSA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVkaXRpb24pID09PSBTZXJ2ZXJJbmZvX0VkaXRpb24uQ2xvdWQgJiYgKChfYiA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lvbikpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiTGl2ZUtpdCBDbG91ZDogXCIuY29uY2F0KChfYyA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlZ2lvbikpO1xuICAgICAgfVxuICAgICAgeWllbGQgc2lnbmFsQ2xpZW50LmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdGlvbkNoZWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0TmV4dENoZWNrSWQoKSB7XG4gICAgY29uc3QgbmV4dElkID0gdGhpcy5jaGVja1Jlc3VsdHMuc2l6ZTtcbiAgICB0aGlzLmNoZWNrUmVzdWx0cy5zZXQobmV4dElkLCB7XG4gICAgICBsb2dzOiBbXSxcbiAgICAgIHN0YXR1czogQ2hlY2tTdGF0dXMuSURMRSxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgZGVzY3JpcHRpb246ICcnXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHRJZDtcbiAgfVxuICB1cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKSB7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KGNoZWNrSWQsIGluZm8pO1xuICAgIHRoaXMuZW1pdCgnY2hlY2tVcGRhdGUnLCBjaGVja0lkLCBpbmZvKTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpLmV2ZXJ5KHIgPT4gci5zdGF0dXMgIT09IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gIH1cbiAgZ2V0UmVzdWx0cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoZWNrUmVzdWx0cy52YWx1ZXMoKSk7XG4gIH1cbiAgY3JlYXRlQW5kUnVuQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY2hlY2tJZCA9IHRoaXMuZ2V0TmV4dENoZWNrSWQoKTtcbiAgICAgIGNvbnN0IHRlc3QgPSBuZXcgY2hlY2sodGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMub3B0aW9ucyk7XG4gICAgICBjb25zdCBoYW5kbGVVcGRhdGUgPSBpbmZvID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKTtcbiAgICAgIH07XG4gICAgICB0ZXN0Lm9uKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGVzdC5ydW4oKTtcbiAgICAgIHRlc3Qub2ZmKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICBjaGVja1dlYnNvY2tldCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViU29ja2V0Q2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrV2ViUlRDKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJSVENDaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tUVVJOKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhUVVJOQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrUmVjb25uZWN0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhSZWNvbm5lY3RDaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tQdWJsaXNoQXVkaW8oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hBdWRpb0NoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1B1Ymxpc2hWaWRlbygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soUHVibGlzaFZpZGVvQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblByb3RvY29sKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBpbmZvID0geWllbGQgdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhDb25uZWN0aW9uUHJvdG9jb2xDaGVjayk7XG4gICAgICBpZiAoaW5mby5kYXRhICYmICdwcm90b2NvbCcgaW4gaW5mby5kYXRhKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gaW5mby5kYXRhO1xuICAgICAgICB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPSBzdGF0cy5wcm90b2NvbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrQ2xvdWRSZWdpb24oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKENsb3VkUmVnaW9uQ2hlY2spO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiBBIEZpeGVkIFRva2VuU291cmNlIGlzIGEgdG9rZW4gc291cmNlIHRoYXQgdGFrZXMgbm8gcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIGNvbXBsZXRlbHlcbiAqIGluZGVwZW5kZW50bHkgZGVyaXZlZCB2YWx1ZSBvbiBlYWNoIGZldGNoKCkgY2FsbC5cbiAqXG4gKiBUaGUgbW9zdCBjb21tb24gZG93bnN0cmVhbSBpbXBsZW1lbnRlciBpcyB7QGxpbmsgVG9rZW5Tb3VyY2VMaXRlcmFsfS5cbiAqL1xuY2xhc3MgVG9rZW5Tb3VyY2VGaXhlZCB7fVxuLyoqIEEgQ29uZmlndXJhYmxlIFRva2VuU291cmNlIGlzIGEgdG9rZW4gc291cmNlIHRoYXQgdGFrZXMgYVxuICoge0BsaW5rIFRva2VuU291cmNlRmV0Y2hPcHRpb25zfSBvYmplY3QgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBkZXRlcm1pbmlzdGljXG4gKiB7QGxpbmsgVG9rZW5Tb3VyY2VSZXNwb25zZU9iamVjdH0gb3V0cHV0IGJhc2VkIG9uIHRoZSBvcHRpb25zIHNwZWNpZmllZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgb3B0aW9ucy5wYXJ0aWNpcGFudE5hbWUgaXMgc2V0LCBpdCBzaG91bGQgYmUgZXhwZWN0ZWQgdGhhdFxuICogYWxsIHRva2VucyB0aGF0IGFyZSBnZW5lcmF0ZWQgd2lsbCBoYXZlIHBhcnRpY2lwYW50IG5hbWUgZmllbGQgc2V0IHRvIHRoZVxuICogcHJvdmlkZWQgdmFsdWUuXG4gKlxuICogQSBmZXcgY29tbW9uIGRvd25zdHJlYW0gaW1wbGVtZW50ZXJzIGFyZSB7QGxpbmsgVG9rZW5Tb3VyY2VFbmRwb2ludH1cbiAqIGFuZCB7QGxpbmsgVG9rZW5Tb3VyY2VDdXN0b219LlxuICovXG5jbGFzcyBUb2tlblNvdXJjZUNvbmZpZ3VyYWJsZSB7fVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cblxubmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChlbmNvZGVkKSB7XG4gIGlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KGVuY29kZWQpO1xuICB9XG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoZW5jb2RlZCk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICBpZiAoVWludDhBcnJheS5mcm9tQmFzZTY0KSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gaW5wdXQgOiBkZWNvZGVyLmRlY29kZShpbnB1dCksIHtcbiAgICAgIGFscGhhYmV0OiAnYmFzZTY0dXJsJ1xuICAgIH0pO1xuICB9XG4gIGxldCBlbmNvZGVkID0gaW5wdXQ7XG4gIGlmIChlbmNvZGVkIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGVuY29kZWQgPSBkZWNvZGVyLmRlY29kZShlbmNvZGVkKTtcbiAgfVxuICBlbmNvZGVkID0gZW5jb2RlZC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZUJhc2U2NChlbmNvZGVkKTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBpbnB1dCB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC4nKTtcbiAgfVxufVxuXG5jbGFzcyBKT1NFRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgX0Vycm9yJGNhcHR1cmVTdGFja1RyO1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KT1NFX0dFTkVSSUMnKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgKF9FcnJvciRjYXB0dXJlU3RhY2tUciA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSA9PT0gbnVsbCB8fCBfRXJyb3IkY2FwdHVyZVN0YWNrVHIgPT09IHZvaWQgMCB8fCBfRXJyb3IkY2FwdHVyZVN0YWNrVHIuY2FsbChFcnJvciwgdGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKT1NFRXJyb3IsIFwiY29kZVwiLCAnRVJSX0pPU0VfR0VORVJJQycpO1xuY2xhc3MgSldUQ2xhaW1WYWxpZGF0aW9uRmFpbGVkIGV4dGVuZHMgSk9TRUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF5bG9hZCkge1xuICAgIGxldCBjbGFpbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3Vuc3BlY2lmaWVkJztcbiAgICBsZXQgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAndW5zcGVjaWZpZWQnO1xuICAgIHN1cGVyKG1lc3NhZ2UsIHtcbiAgICAgIGNhdXNlOiB7XG4gICAgICAgIGNsYWltLFxuICAgICAgICByZWFzb24sXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSldUX0NMQUlNX1ZBTElEQVRJT05fRkFJTEVEJyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xhaW1cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFzb25cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXlsb2FkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jbGFpbSA9IGNsYWltO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV1RDbGFpbVZhbGlkYXRpb25GYWlsZWQsIFwiY29kZVwiLCAnRVJSX0pXVF9DTEFJTV9WQUxJREFUSU9OX0ZBSUxFRCcpO1xuY2xhc3MgSldURXhwaXJlZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBheWxvYWQpIHtcbiAgICBsZXQgY2xhaW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd1bnNwZWNpZmllZCc7XG4gICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJ3Vuc3BlY2lmaWVkJztcbiAgICBzdXBlcihtZXNzYWdlLCB7XG4gICAgICBjYXVzZToge1xuICAgICAgICBjbGFpbSxcbiAgICAgICAgcmVhc29uLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXVF9FWFBJUkVEJyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xhaW1cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFzb25cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXlsb2FkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jbGFpbSA9IGNsYWltO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV1RFeHBpcmVkLCBcImNvZGVcIiwgJ0VSUl9KV1RfRVhQSVJFRCcpO1xuY2xhc3MgSk9TRUFsZ05vdEFsbG93ZWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KT1NFX0FMR19OT1RfQUxMT1dFRCcpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSk9TRUFsZ05vdEFsbG93ZWQsIFwiY29kZVwiLCAnRVJSX0pPU0VfQUxHX05PVF9BTExPV0VEJyk7XG5jbGFzcyBKT1NFTm90U3VwcG9ydGVkIGV4dGVuZHMgSk9TRUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSk9TRV9OT1RfU1VQUE9SVEVEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKT1NFTm90U3VwcG9ydGVkLCBcImNvZGVcIiwgJ0VSUl9KT1NFX05PVF9TVVBQT1JURUQnKTtcbmNsYXNzIEpXRURlY3J5cHRpb25GYWlsZWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2RlY3J5cHRpb24gb3BlcmF0aW9uIGZhaWxlZCc7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSldFX0RFQ1JZUFRJT05fRkFJTEVEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV0VEZWNyeXB0aW9uRmFpbGVkLCBcImNvZGVcIiwgJ0VSUl9KV0VfREVDUllQVElPTl9GQUlMRUQnKTtcbmNsYXNzIEpXRUludmFsaWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV0VfSU5WQUxJRCcpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSldFSW52YWxpZCwgXCJjb2RlXCIsICdFUlJfSldFX0lOVkFMSUQnKTtcbmNsYXNzIEpXU0ludmFsaWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV1NfSU5WQUxJRCcpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSldTSW52YWxpZCwgXCJjb2RlXCIsICdFUlJfSldTX0lOVkFMSUQnKTtcbmNsYXNzIEpXVEludmFsaWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV1RfSU5WQUxJRCcpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSldUSW52YWxpZCwgXCJjb2RlXCIsICdFUlJfSldUX0lOVkFMSUQnKTtcbmNsYXNzIEpXS0ludmFsaWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV0tfSU5WQUxJRCcpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSldLSW52YWxpZCwgXCJjb2RlXCIsICdFUlJfSldLX0lOVkFMSUQnKTtcbmNsYXNzIEpXS1NJbnZhbGlkIGV4dGVuZHMgSk9TRUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSldLU19JTlZBTElEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV0tTSW52YWxpZCwgXCJjb2RlXCIsICdFUlJfSldLU19JTlZBTElEJyk7XG5jbGFzcyBKV0tTTm9NYXRjaGluZ0tleSBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnbm8gYXBwbGljYWJsZSBrZXkgZm91bmQgaW4gdGhlIEpTT04gV2ViIEtleSBTZXQnO1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXS1NfTk9fTUFUQ0hJTkdfS0VZJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV0tTTm9NYXRjaGluZ0tleSwgXCJjb2RlXCIsICdFUlJfSldLU19OT19NQVRDSElOR19LRVknKTtcbmNsYXNzIEpXS1NNdWx0aXBsZU1hdGNoaW5nS2V5cyBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnbXVsdGlwbGUgbWF0Y2hpbmcga2V5cyBmb3VuZCBpbiB0aGUgSlNPTiBXZWIgS2V5IFNldCc7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXS1NfTVVMVElQTEVfTUFUQ0hJTkdfS0VZUycpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSldLU011bHRpcGxlTWF0Y2hpbmdLZXlzLCBcImNvZGVcIiwgJ0VSUl9KV0tTX01VTFRJUExFX01BVENISU5HX0tFWVMnKTtcbmNsYXNzIEpXS1NUaW1lb3V0IGV4dGVuZHMgSk9TRUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdyZXF1ZXN0IHRpbWVkIG91dCc7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSldLU19USU1FT1VUJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV0tTVGltZW91dCwgXCJjb2RlXCIsICdFUlJfSldLU19USU1FT1VUJyk7XG5jbGFzcyBKV1NTaWduYXR1cmVWZXJpZmljYXRpb25GYWlsZWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkJztcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV1NfU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMRUQnKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpXU1NpZ25hdHVyZVZlcmlmaWNhdGlvbkZhaWxlZCwgXCJjb2RlXCIsICdFUlJfSldTX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTEVEJyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbnZhciBpc09iamVjdCA9IGlucHV0ID0+IHtcbiAgaWYgKCFpc09iamVjdExpa2UoaW5wdXQpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IHByb3RvID0gaW5wdXQ7XG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBwcm90bztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUp3dChqd3QpIHtcbiAgaWYgKHR5cGVvZiBqd3QgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgSldUSW52YWxpZCgnSldUcyBtdXN0IHVzZSBDb21wYWN0IEpXUyBzZXJpYWxpemF0aW9uLCBKV1QgbXVzdCBiZSBhIHN0cmluZycpO1xuICBjb25zdCB7XG4gICAgMTogcGF5bG9hZCxcbiAgICBsZW5ndGhcbiAgfSA9IGp3dC5zcGxpdCgnLicpO1xuICBpZiAobGVuZ3RoID09PSA1KSB0aHJvdyBuZXcgSldUSW52YWxpZCgnT25seSBKV1RzIHVzaW5nIENvbXBhY3QgSldTIHNlcmlhbGl6YXRpb24gY2FuIGJlIGRlY29kZWQnKTtcbiAgaWYgKGxlbmd0aCAhPT0gMykgdGhyb3cgbmV3IEpXVEludmFsaWQoJ0ludmFsaWQgSldUJyk7XG4gIGlmICghcGF5bG9hZCkgdGhyb3cgbmV3IEpXVEludmFsaWQoJ0pXVHMgbXVzdCBjb250YWluIGEgcGF5bG9hZCcpO1xuICBsZXQgZGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gZGVjb2RlKHBheWxvYWQpO1xuICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgdGhyb3cgbmV3IEpXVEludmFsaWQoJ0ZhaWxlZCB0byBiYXNlNjR1cmwgZGVjb2RlIHRoZSBwYXlsb2FkJyk7XG4gIH1cbiAgbGV0IHJlc3VsdDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKGRlY29kZWQpKTtcbiAgfSBjYXRjaCAoX3VudXNlZDIpIHtcbiAgICB0aHJvdyBuZXcgSldUSW52YWxpZCgnRmFpbGVkIHRvIHBhcnNlIHRoZSBkZWNvZGVkIHBheWxvYWQgYXMgSlNPTicpO1xuICB9XG4gIGlmICghaXNPYmplY3QocmVzdWx0KSkgdGhyb3cgbmV3IEpXVEludmFsaWQoJ0ludmFsaWQgSldUIENsYWltcyBTZXQnKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgT05FX1NFQ09ORF9JTl9NSUxMSVNFQ09ORFMgPSAxMDAwO1xuY29uc3QgT05FX01JTlVURV9JTl9NSUxMSVNFQ09ORFMgPSA2MCAqIE9ORV9TRUNPTkRfSU5fTUlMTElTRUNPTkRTO1xuZnVuY3Rpb24gaXNSZXNwb25zZVRva2VuVmFsaWQocmVzcG9uc2UpIHtcbiAgY29uc3Qgand0UGF5bG9hZCA9IGRlY29kZVRva2VuUGF5bG9hZChyZXNwb25zZS5wYXJ0aWNpcGFudFRva2VuKTtcbiAgaWYgKCEoand0UGF5bG9hZCA9PT0gbnVsbCB8fCBqd3RQYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBqd3RQYXlsb2FkLm5iZikgfHwgIShqd3RQYXlsb2FkID09PSBudWxsIHx8IGp3dFBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGp3dFBheWxvYWQuZXhwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IG5iZkluTWlsbGlzZWNvbmRzID0gand0UGF5bG9hZC5uYmYgKiBPTkVfU0VDT05EX0lOX01JTExJU0VDT05EUztcbiAgY29uc3QgbmJmRGF0ZSA9IG5ldyBEYXRlKG5iZkluTWlsbGlzZWNvbmRzKTtcbiAgY29uc3QgZXhwSW5NaWxsaXNlY29uZHMgPSBqd3RQYXlsb2FkLmV4cCAqIE9ORV9TRUNPTkRfSU5fTUlMTElTRUNPTkRTO1xuICBjb25zdCBleHBEYXRlID0gbmV3IERhdGUoZXhwSW5NaWxsaXNlY29uZHMgLSBPTkVfTUlOVVRFX0lOX01JTExJU0VDT05EUyk7XG4gIHJldHVybiBuYmZEYXRlIDw9IG5vdyAmJiBleHBEYXRlID4gbm93O1xufVxuLyoqIEdpdmVuIGEgTGl2ZUtpdCBnZW5lcmF0ZWQgcGFydGljaXBhbnQgdG9rZW4sIGRlY29kZXMgYW5kIHJldHVybnMgdGhlIGFzc29jaWF0ZWQge0BsaW5rIFRva2VuUGF5bG9hZH0gZGF0YS4gKi9cbmZ1bmN0aW9uIGRlY29kZVRva2VuUGF5bG9hZCh0b2tlbikge1xuICBjb25zdCBwYXlsb2FkID0gZGVjb2RlSnd0KHRva2VuKTtcbiAgY29uc3Qge1xuICAgICAgcm9vbUNvbmZpZ1xuICAgIH0gPSBwYXlsb2FkLFxuICAgIHJlc3QgPSBfX3Jlc3QocGF5bG9hZCwgW1wicm9vbUNvbmZpZ1wiXSk7XG4gIGNvbnN0IG1hcHBlZFBheWxvYWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7XG4gICAgcm9vbUNvbmZpZzogcGF5bG9hZC5yb29tQ29uZmlnID8gUm9vbUNvbmZpZ3VyYXRpb24uZnJvbUpzb24ocGF5bG9hZC5yb29tQ29uZmlnKSA6IHVuZGVmaW5lZFxuICB9KTtcbiAgcmV0dXJuIG1hcHBlZFBheWxvYWQ7XG59XG4vKiogR2l2ZW4gdHdvIFRva2VuU291cmNlRmV0Y2hPcHRpb25zIHZhbHVlcywgY2hlY2sgdG8gc2VlIGlmIHRoZXkgYXJlIGRlZXAgZXF1YWwuICovXG5mdW5jdGlvbiBhcmVUb2tlblNvdXJjZUZldGNoT3B0aW9uc0VxdWFsKGEsIGIpIHtcbiAgY29uc3QgYWxsS2V5c1NldCA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKGEpLCAuLi5PYmplY3Qua2V5cyhiKV0pO1xuICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzU2V0KSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ3Jvb21OYW1lJzpcbiAgICAgIGNhc2UgJ3BhcnRpY2lwYW50TmFtZSc6XG4gICAgICBjYXNlICdwYXJ0aWNpcGFudElkZW50aXR5JzpcbiAgICAgIGNhc2UgJ3BhcnRpY2lwYW50TWV0YWRhdGEnOlxuICAgICAgY2FzZSAncGFydGljaXBhbnRBdHRyaWJ1dGVzJzpcbiAgICAgIGNhc2UgJ2FnZW50TmFtZSc6XG4gICAgICBjYXNlICdhZ2VudE1ldGFkYXRhJzpcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gcmVmOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTgwMDk5OTJcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrZWRLZXkgPSBrZXk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbnMga2V5IFwiLmNvbmNhdChleGhhdXN0aXZlQ2hlY2tlZEtleSwgXCIgbm90IGJlaW5nIGNoZWNrZWQgZm9yIGVxdWFsaXR5IVwiKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiogQSBUb2tlblNvdXJjZUNhY2hlZCBpcyBhIFRva2VuU291cmNlIHdoaWNoIGNhY2hlcyB0aGUgbGFzdCB7QGxpbmsgVG9rZW5Tb3VyY2VSZXNwb25zZU9iamVjdH0gdmFsdWUgYW5kIHJldHVybnMgaXRcbiAqIHVudGlsIGEpIGl0IGV4cGlyZXMgb3IgYikgdGhlIHtAbGluayBUb2tlblNvdXJjZUZldGNoT3B0aW9uc30gcHJvdmlkZWQgdG8gLmZldGNoKC4uLikgY2hhbmdlLiAqL1xuY2xhc3MgVG9rZW5Tb3VyY2VDYWNoZWQgZXh0ZW5kcyBUb2tlblNvdXJjZUNvbmZpZ3VyYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYWNoZWRGZXRjaE9wdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuY2FjaGVkUmVzcG9uc2UgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hNdXRleCA9IG5ldyBfKCk7XG4gIH1cbiAgaXNTYW1lQXNDYWNoZWRGZXRjaE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYWNoZWRGZXRjaE9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5jYWNoZWRGZXRjaE9wdGlvbnMpKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdyb29tTmFtZSc6XG4gICAgICAgIGNhc2UgJ3BhcnRpY2lwYW50TmFtZSc6XG4gICAgICAgIGNhc2UgJ3BhcnRpY2lwYW50SWRlbnRpdHknOlxuICAgICAgICBjYXNlICdwYXJ0aWNpcGFudE1ldGFkYXRhJzpcbiAgICAgICAgY2FzZSAncGFydGljaXBhbnRBdHRyaWJ1dGVzJzpcbiAgICAgICAgY2FzZSAnYWdlbnROYW1lJzpcbiAgICAgICAgY2FzZSAnYWdlbnRNZXRhZGF0YSc6XG4gICAgICAgICAgaWYgKHRoaXMuY2FjaGVkRmV0Y2hPcHRpb25zW2tleV0gIT09IG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyByZWY6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81ODAwOTk5MlxuICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVja2VkS2V5ID0ga2V5O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbnMga2V5IFwiLmNvbmNhdChleGhhdXN0aXZlQ2hlY2tlZEtleSwgXCIgbm90IGJlaW5nIGNoZWNrZWQgZm9yIGVxdWFsaXR5IVwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNob3VsZFJldHVybkNhY2hlZFZhbHVlRnJvbUZldGNoKGZldGNoT3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYWNoZWRSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzUmVzcG9uc2VUb2tlblZhbGlkKHRoaXMuY2FjaGVkUmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2FtZUFzQ2FjaGVkRmV0Y2hPcHRpb25zKGZldGNoT3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0Q2FjaGVkUmVzcG9uc2VKd3RQYXlsb2FkKCkge1xuICAgIGlmICghdGhpcy5jYWNoZWRSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVUb2tlblBheWxvYWQodGhpcy5jYWNoZWRSZXNwb25zZS5wYXJ0aWNpcGFudFRva2VuKTtcbiAgfVxuICBmZXRjaChvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuZmV0Y2hNdXRleC5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRSZXR1cm5DYWNoZWRWYWx1ZUZyb21GZXRjaChvcHRpb25zKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFJlc3BvbnNlLnRvSnNvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVkRmV0Y2hPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNhY2hlZFJlc3BvbnNlID0gdG9rZW5SZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIHRva2VuUmVzcG9uc2UudG9Kc29uKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVG9rZW5Tb3VyY2VMaXRlcmFsIGV4dGVuZHMgVG9rZW5Tb3VyY2VGaXhlZCB7XG4gIGNvbnN0cnVjdG9yKGxpdGVyYWxPckZuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxpdGVyYWxPckZuID0gbGl0ZXJhbE9yRm47XG4gIH1cbiAgZmV0Y2goKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5saXRlcmFsT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsT3JGbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbE9yRm47XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFRva2VuU291cmNlQ3VzdG9tIGV4dGVuZHMgVG9rZW5Tb3VyY2VDYWNoZWQge1xuICBjb25zdHJ1Y3RvcihjdXN0b21Gbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdXN0b21GbiA9IGN1c3RvbUZuO1xuICB9XG4gIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdE1heWJlUHJvbWlzZSA9IHRoaXMuY3VzdG9tRm4ob3B0aW9ucyk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgaWYgKHJlc3VsdE1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmVzdWx0ID0geWllbGQgcmVzdWx0TWF5YmVQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0TWF5YmVQcm9taXNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuU291cmNlUmVzcG9uc2UuZnJvbUpzb24ocmVzdWx0LCB7XG4gICAgICAgIC8vIE5PVEU6IGl0IGNvdWxkIGJlIHBvc3NpYmxlIHRoYXQgdGhlIHJlc3BvbnNlIGJvZHkgY291bGQgY29udGFpbiBtb3JlIGZpZWxkcyB0aGFuIGp1c3RcbiAgICAgICAgLy8gd2hhdCdzIGluIFRva2VuU291cmNlUmVzcG9uc2UgZGVwZW5kaW5nIG9uIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZ25vcmVVbmtub3duRmllbGRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVG9rZW5Tb3VyY2VFbmRwb2ludCBleHRlbmRzIFRva2VuU291cmNlQ2FjaGVkIHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5lbmRwb2ludE9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGNyZWF0ZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBUb2tlblNvdXJjZVJlcXVlc3QoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAncm9vbU5hbWUnOlxuICAgICAgICBjYXNlICdwYXJ0aWNpcGFudE5hbWUnOlxuICAgICAgICBjYXNlICdwYXJ0aWNpcGFudElkZW50aXR5JzpcbiAgICAgICAgY2FzZSAncGFydGljaXBhbnRNZXRhZGF0YSc6XG4gICAgICAgICAgcmVxdWVzdFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwYXJ0aWNpcGFudEF0dHJpYnV0ZXMnOlxuICAgICAgICAgIHJlcXVlc3QucGFydGljaXBhbnRBdHRyaWJ1dGVzID0gKF9hID0gb3B0aW9ucy5wYXJ0aWNpcGFudEF0dHJpYnV0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhZ2VudE5hbWUnOlxuICAgICAgICAgIHJlcXVlc3Qucm9vbUNvbmZpZyA9IChfYiA9IHJlcXVlc3Qucm9vbUNvbmZpZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFJvb21Db25maWd1cmF0aW9uKCk7XG4gICAgICAgICAgaWYgKHJlcXVlc3Qucm9vbUNvbmZpZy5hZ2VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJvb21Db25maWcuYWdlbnRzLnB1c2gobmV3IFJvb21BZ2VudERpc3BhdGNoKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0LnJvb21Db25maWcuYWdlbnRzWzBdLmFnZW50TmFtZSA9IG9wdGlvbnMuYWdlbnROYW1lO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhZ2VudE1ldGFkYXRhJzpcbiAgICAgICAgICByZXF1ZXN0LnJvb21Db25maWcgPSAoX2MgPSByZXF1ZXN0LnJvb21Db25maWcpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBSb29tQ29uZmlndXJhdGlvbigpO1xuICAgICAgICAgIGlmIChyZXF1ZXN0LnJvb21Db25maWcuYWdlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVxdWVzdC5yb29tQ29uZmlnLmFnZW50cy5wdXNoKG5ldyBSb29tQWdlbnREaXNwYXRjaCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdC5yb29tQ29uZmlnLmFnZW50c1swXS5tZXRhZGF0YSA9IG9wdGlvbnMuYWdlbnRNZXRhZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyByZWY6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81ODAwOTk5MlxuICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVja2VkS2V5ID0ga2V5O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbnMga2V5IFwiLmNvbmNhdChleGhhdXN0aXZlQ2hlY2tlZEtleSwgXCIgbm90IGJlaW5nIGluY2x1ZGVkIGluIGZvcm1pbmcgcmVxdWVzdCFcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICB1cGRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0RnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHRoaXMudXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZW5kcG9pbnRPcHRpb25zKSwge1xuICAgICAgICBtZXRob2Q6IChfYSA9IHRoaXMuZW5kcG9pbnRPcHRpb25zLm1ldGhvZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sIHRoaXMuZW5kcG9pbnRPcHRpb25zLmhlYWRlcnMpLFxuICAgICAgICBib2R5OiByZXF1ZXN0LnRvSnNvblN0cmluZyh7XG4gICAgICAgICAgdXNlUHJvdG9GaWVsZE5hbWU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyB0b2tlbiBmcm9tIGVuZHBvaW50IFwiLmNvbmNhdCh0aGlzLnVybCwgXCI6IHJlY2VpdmVkIFwiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzLCBcIiAvIFwiKS5jb25jYXQoeWllbGQgcmVzcG9uc2UudGV4dCgpKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIFRva2VuU291cmNlUmVzcG9uc2UuZnJvbUpzb24oYm9keSwge1xuICAgICAgICAvLyBOT1RFOiBpdCBjb3VsZCBiZSBwb3NzaWJsZSB0aGF0IHRoZSByZXNwb25zZSBib2R5IGNvdWxkIGNvbnRhaW4gbW9yZSBmaWVsZHMgdGhhbiBqdXN0XG4gICAgICAgIC8vIHdoYXQncyBpbiBUb2tlblNvdXJjZVJlc3BvbnNlIGRlcGVuZGluZyBvbiB0aGUgaW1wbGVtZW50YXRpb24gKGllLCBTYW5kYm94VG9rZW5TZXJ2ZXIpXG4gICAgICAgIGlnbm9yZVVua25vd25GaWVsZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBUb2tlblNvdXJjZVNhbmRib3hUb2tlblNlcnZlciBleHRlbmRzIFRva2VuU291cmNlRW5kcG9pbnQge1xuICBjb25zdHJ1Y3RvcihzYW5kYm94SWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIGJhc2VVcmwgPSAnaHR0cHM6Ly9jbG91ZC1hcGkubGl2ZWtpdC5pbydcbiAgICAgIH0gPSBvcHRpb25zLFxuICAgICAgcmVzdCA9IF9fcmVzdChvcHRpb25zLCBbXCJiYXNlVXJsXCJdKTtcbiAgICBzdXBlcihcIlwiLmNvbmNhdChiYXNlVXJsLCBcIi9hcGkvdjIvc2FuZGJveC9jb25uZWN0aW9uLWRldGFpbHNcIiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtU2FuZGJveC1JRCc6IHNhbmRib3hJZFxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxufVxuY29uc3QgVG9rZW5Tb3VyY2UgPSB7XG4gIC8qKiBUb2tlblNvdXJjZS5saXRlcmFsIGNvbnRhaW5zIGEgc2luZ2xlLCBsaXRlcmFsIHNldCBvZiB7QGxpbmsgVG9rZW5Tb3VyY2VSZXNwb25zZU9iamVjdH1cbiAgICogY3JlZGVudGlhbHMsIGVpdGhlciBwcm92aWRlZCBkaXJlY3RseSBvciByZXR1cm5lZCBmcm9tIGEgcHJvdmlkZWQgZnVuY3Rpb24uICovXG4gIGxpdGVyYWwobGl0ZXJhbE9yRm4pIHtcbiAgICByZXR1cm4gbmV3IFRva2VuU291cmNlTGl0ZXJhbChsaXRlcmFsT3JGbik7XG4gIH0sXG4gIC8qKlxuICAgKiBUb2tlblNvdXJjZS5jdXN0b20gYWxsb3dzIGEgdXNlciB0byBkZWZpbmUgYSBtYW51YWwgZnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGVzIG5ld1xuICAgKiB7QGxpbmsgVG9rZW5Tb3VyY2VSZXNwb25zZU9iamVjdH0gdmFsdWVzIG9uIGRlbWFuZC5cbiAgICpcbiAgICogVXNlIHRoaXMgdG8gZ2V0IGNyZWRlbnRpYWxzIGZyb20gY3VzdG9tIGJhY2tlbmRzIC8gZXRjLlxuICAgKi9cbiAgY3VzdG9tKGN1c3RvbUZuKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlblNvdXJjZUN1c3RvbShjdXN0b21Gbik7XG4gIH0sXG4gIC8qKlxuICAgKiBUb2tlblNvdXJjZS5lbmRwb2ludCBjcmVhdGVzIGEgdG9rZW4gc291cmNlIHRoYXQgZmV0Y2hlcyBjcmVkZW50aWFscyBmcm9tIGEgZ2l2ZW4gVVJMIHVzaW5nXG4gICAqIHRoZSBzdGFuZGFyZCBlbmRwb2ludCBmb3JtYXQ6XG4gICAqIEZJWE1FOiBhZGQgZG9jcyBsaW5rIGhlcmUgaW4gdGhlIGZ1dHVyZSFcbiAgICovXG4gIGVuZHBvaW50KHVybCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gbmV3IFRva2VuU291cmNlRW5kcG9pbnQodXJsLCBvcHRpb25zKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRva2VuU291cmNlLnNhbmRib3hUb2tlblNlcnZlciBxdWVyaWVzIGEgc2FuZGJveCB0b2tlbiBzZXJ2ZXIgZm9yIGNyZWRlbnRpYWxzLFxuICAgKiB3aGljaCBzdXBwb3J0cyBxdWljayBwcm90b3R5cGluZyAvIGdldHRpbmcgc3RhcnRlZCB0eXBlcyBvZiB1c2UgY2FzZXMuXG4gICAqXG4gICAqIFRoaXMgdG9rZW4gcHJvdmlkZXIgaXMgSU5TRUNVUkUgYW5kIHNob3VsZCBOT1QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiBGb3IgbW9yZSBpbmZvOlxuICAgKiBAc2VlIGh0dHBzOi8vY2xvdWQubGl2ZWtpdC5pby9wcm9qZWN0cy9wXy9zYW5kYm94L3RlbXBsYXRlcy90b2tlbi1zZXJ2ZXJcbiAgICovXG4gIHNhbmRib3hUb2tlblNlcnZlcihzYW5kYm94SWQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIG5ldyBUb2tlblNvdXJjZVNhbmRib3hUb2tlblNlcnZlcihzYW5kYm94SWQsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIFRyeSB0byBhbmFseXplIHRoZSBsb2NhbCB0cmFjayB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlIG9mIGEgdHJhY2suXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZXJlIGlzIG5vIHByb3BlcnR5IHN1cHBvcnRlZCBieSBhbGwgYnJvd3NlcnMgdG8gZGV0ZWN0IHdoZXRoZXIgYSB2aWRlbyB0cmFjayBvcmlnaW5hdGVkIGZyb20gYSB1c2VyLSBvciBlbnZpcm9ubWVudC1mYWNpbmcgY2FtZXJhIGRldmljZS5cbiAqIEZvciB0aGlzIHJlYXNvbiwgd2UgdXNlIHRoZSBgZmFjaW5nTW9kZWAgcHJvcGVydHkgd2hlbiBhdmFpbGFibGUsIGJ1dCB3aWxsIGZhbGwgYmFjayBvbiBhIHN0cmluZy1iYXNlZCBhbmFseXNpcyBvZiB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKiBJZiBib3RoIG1ldGhvZHMgZmFpbCwgdGhlIGRlZmF1bHQgZmFjaW5nIG1vZGUgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHMvZmFjaW5nTW9kZSB8IE1ETiBkb2NzIG9uIGZhY2luZ01vZGV9XG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmZ1bmN0aW9uIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayhsb2NhbFRyYWNrKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9hO1xuICBjb25zdCB0cmFjayA9IGlzTG9jYWxUcmFjayhsb2NhbFRyYWNrKSA/IGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA6IGxvY2FsVHJhY2s7XG4gIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGZhY2luZ01vZGU6IChfYSA9IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1c2VyJyxcbiAgICBjb25maWRlbmNlOiAnbG93J1xuICB9O1xuICAvLyAxLiBUcnkgdG8gZ2V0IGZhY2luZ01vZGUgZnJvbSB0cmFjayBzZXR0aW5ncy5cbiAgaWYgKCdmYWNpbmdNb2RlJyBpbiB0cmFja1NldHRpbmdzKSB7XG4gICAgY29uc3QgcmF3RmFjaW5nTW9kZSA9IHRyYWNrU2V0dGluZ3MuZmFjaW5nTW9kZTtcbiAgICBsaXZla2l0TG9nZ2VyLnRyYWNlKCdyYXdGYWNpbmdNb2RlJywge1xuICAgICAgcmF3RmFjaW5nTW9kZVxuICAgIH0pO1xuICAgIGlmIChyYXdGYWNpbmdNb2RlICYmIHR5cGVvZiByYXdGYWNpbmdNb2RlID09PSAnc3RyaW5nJyAmJiBpc0ZhY2luZ01vZGVWYWx1ZShyYXdGYWNpbmdNb2RlKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBmYWNpbmdNb2RlOiByYXdGYWNpbmdNb2RlLFxuICAgICAgICBjb25maWRlbmNlOiAnaGlnaCdcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8vIDIuIElmIHdlIGRvbid0IGhhdmUgYSBoaWdoIGNvbmZpZGVuY2Ugd2UgdHJ5IHRvIGdldCB0aGUgZmFjaW5nIG1vZGUgZnJvbSB0aGUgZGV2aWNlIGxhYmVsLlxuICBpZiAoWydsb3cnLCAnbWVkaXVtJ10uaW5jbHVkZXMocmVzdWx0LmNvbmZpZGVuY2UpKSB7XG4gICAgbGl2ZWtpdExvZ2dlci50cmFjZShcIlRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6IChcIi5jb25jYXQodHJhY2subGFiZWwsIFwiKVwiKSk7XG4gICAgY29uc3QgbGFiZWxBbmFseXNpc1Jlc3VsdCA9IGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwodHJhY2subGFiZWwpO1xuICAgIGlmIChsYWJlbEFuYWx5c2lzUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IGxhYmVsQW5hbHlzaXNSZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXAoW1snb2JzIHZpcnR1YWwgY2FtZXJhJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV1dKTtcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXAoW1snaXBob25lJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV0sIFsnaXBhZCcsIHtcbiAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcbn1dXSk7XG4vKipcbiAqIEF0dGVtcHQgdG8gYW5hbHl6ZSB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKGRldmljZUxhYmVsKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFiZWwgPSBkZXZpY2VMYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gRW1wdHkgc3RyaW5nIGlzIGEgdmFsaWQgZGV2aWNlIGxhYmVsIGJ1dCB3ZSBjYW4ndCBpbmZlciBhbnl0aGluZyBmcm9tIGl0LlxuICBpZiAobGFiZWwgPT09ICcnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCB3aWRlbHkga25vd24gZGV2aWNlIGxhYmVscy5cbiAgaWYgKGtub3duRGV2aWNlTGFiZWxzLmhhcyhsYWJlbCkpIHtcbiAgICByZXR1cm4ga25vd25EZXZpY2VMYWJlbHMuZ2V0KGxhYmVsKTtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxuICByZXR1cm4gKF9hID0gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKF9yZWYgPT4ge1xuICAgIGxldCBbc2VjdGlvbl0gPSBfcmVmO1xuICAgIHJldHVybiBsYWJlbC5pbmNsdWRlcyhzZWN0aW9uKTtcbiAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcbn1cbmZ1bmN0aW9uIGlzRmFjaW5nTW9kZVZhbHVlKGl0ZW0pIHtcbiAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IFsndXNlcicsICdlbnZpcm9ubWVudCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQgfHwgYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyhpdGVtKTtcbn1cblxuZXhwb3J0IHsgQXVkaW9QcmVzZXRzLCBCYWNrdXBDb2RlY1BvbGljeSwgQmFzZUtleVByb3ZpZGVyLCBDaGVja1N0YXR1cywgQ2hlY2tlciwgQ29ubmVjdGlvbkNoZWNrLCBDb25uZWN0aW9uRXJyb3IsIENvbm5lY3Rpb25FcnJvclJlYXNvbiwgQ29ubmVjdGlvblF1YWxpdHksIENvbm5lY3Rpb25TdGF0ZSwgQ3JpdGljYWxUaW1lcnMsIENyeXB0b3JFcnJvciwgQ3J5cHRvckVycm9yUmVhc29uLCBDcnlwdG9yRXZlbnQsIERhdGFQYWNrZXRfS2luZCwgRGF0YVN0cmVhbUVycm9yLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24sIERlZmF1bHRSZWNvbm5lY3RQb2xpY3ksIERldmljZVVuc3VwcG9ydGVkRXJyb3IsIERpc2Nvbm5lY3RSZWFzb24sIEVuY3J5cHRpb25FdmVudCwgRW5jcnlwdGlvbl9UeXBlLCBFbmdpbmVFdmVudCwgRXh0ZXJuYWxFMkVFS2V5UHJvdmlkZXIsIEtleUhhbmRsZXJFdmVudCwgS2V5UHJvdmlkZXJFdmVudCwgTGl2ZWtpdEVycm9yLCBMb2NhbEF1ZGlvVHJhY2ssIExvY2FsUGFydGljaXBhbnQsIExvY2FsVHJhY2ssIExvY2FsVHJhY2tQdWJsaWNhdGlvbiwgTG9jYWxUcmFja1JlY29yZGVyLCBMb2NhbFZpZGVvVHJhY2ssIExvZ0xldmVsLCBMb2dnZXJOYW1lcywgTWVkaWFEZXZpY2VGYWlsdXJlLCBfIGFzIE11dGV4LCBOZWdvdGlhdGlvbkVycm9yLCBQYXJ0aWNpcGFudCwgUGFydGljaXBhbnRFdmVudCwgUGFydGljaXBhbnRJbmZvX0tpbmQgYXMgUGFydGljaXBhbnRLaW5kLCBQdWJsaXNoRGF0YUVycm9yLCBQdWJsaXNoVHJhY2tFcnJvciwgUmVtb3RlQXVkaW9UcmFjaywgUmVtb3RlUGFydGljaXBhbnQsIFJlbW90ZVRyYWNrLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLCBSZW1vdGVWaWRlb1RyYWNrLCBSb29tLCBSb29tRXZlbnQsIFJwY0Vycm9yLCBTY3JlZW5TaGFyZVByZXNldHMsIFNpZ25hbFJlcXVlc3RFcnJvciwgU3Vic2NyaXB0aW9uRXJyb3IsIFRva2VuU291cmNlLCBUb2tlblNvdXJjZUNvbmZpZ3VyYWJsZSwgVG9rZW5Tb3VyY2VGaXhlZCwgVHJhY2ssIFRyYWNrRXZlbnQsIFRyYWNrSW52YWxpZEVycm9yLCBUcmFja1B1YmxpY2F0aW9uLCBUcmFja1R5cGUsIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUsIFVuc3VwcG9ydGVkU2VydmVyLCBWaWRlb1ByZXNldCwgVmlkZW9QcmVzZXRzLCBWaWRlb1ByZXNldHM0MywgVmlkZW9RdWFsaXR5LCBhcmVUb2tlblNvdXJjZUZldGNoT3B0aW9uc0VxdWFsLCBhc0VuY3J5cHRhYmxlUGFja2V0LCBhdHRhY2hUb0VsZW1lbnQsIGF0dHJpYnV0ZVR5cGluZ3MgYXMgYXR0cmlidXRlcywgYXVkaW9Db2RlY3MsIGNvbXBhcmVWZXJzaW9ucywgY3JlYXRlQXVkaW9BbmFseXNlciwgY3JlYXRlRTJFRUtleSwgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyLCBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcsIGNyZWF0ZUxvY2FsQXVkaW9UcmFjaywgY3JlYXRlTG9jYWxTY3JlZW5UcmFja3MsIGNyZWF0ZUxvY2FsVHJhY2tzLCBjcmVhdGVMb2NhbFZpZGVvVHJhY2ssIGRlY29kZVRva2VuUGF5bG9hZCwgZGVyaXZlS2V5cywgZGV0YWNoVHJhY2ssIGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwsIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjaywgZ2V0QnJvd3NlciwgZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrLCBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2ssIGdldExvZ2dlciwgaW1wb3J0S2V5LCBpc0F1ZGlvQ29kZWMsIGlzQXVkaW9UcmFjaywgaXNCYWNrdXBDb2RlYywgaXNCYWNrdXBWaWRlb0NvZGVjLCBpc0Jyb3dzZXJTdXBwb3J0ZWQsIGlzRTJFRVN1cHBvcnRlZCwgaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkLCBpc0xvY2FsUGFydGljaXBhbnQsIGlzTG9jYWxUcmFjaywgaXNSZW1vdGVQYXJ0aWNpcGFudCwgaXNSZW1vdGVUcmFjaywgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQsIGlzVmlkZW9Db2RlYywgaXNWaWRlb0ZyYW1lLCBpc1ZpZGVvVHJhY2ssIG5lZWRzUmJzcFVuZXNjYXBpbmcsIHBhcnNlUmJzcCwgcHJvdG9jb2xWZXJzaW9uLCByYXRjaGV0LCBzZXRMb2dFeHRlbnNpb24sIHNldExvZ0xldmVsLCBzdXBwb3J0c0FWMSwgc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSwgc3VwcG9ydHNBdWRpb091dHB1dFNlbGVjdGlvbiwgc3VwcG9ydHNEeW5hY2FzdCwgc3VwcG9ydHNWUDksIHZlcnNpb24sIHZpZGVvQ29kZWNzLCB3cml0ZVJic3AgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdmVraXQtY2xpZW50LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOlsiX21lcmdlTmFtZXNwYWNlcyIsIm4iLCJtIiwiZm9yRWFjaCIsImUiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJoIiwiaSIsInMiLCJ0IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIm8iLCJfIiwiY29uc3RydWN0b3IiLCJfbG9ja2luZyIsIlByb21pc2UiLCJyZXNvbHZlIiwiX2xvY2tzIiwiaXNMb2NrZWQiLCJsb2NrIiwibCIsImMiLCJ0aGVuIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibXNnIiwiRXJyb3IiLCJGTE9BVDMyX01BWCIsIkZMT0FUMzJfTUlOIiwiVUlOVDMyX01BWCIsIklOVDMyX01BWCIsIklOVDMyX01JTiIsImFzc2VydEludDMyIiwiYXJnIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0VUludDMyIiwiYXNzZXJ0RmxvYXQzMiIsImlzRmluaXRlIiwiZW51bVR5cGVTeW1ib2wiLCJTeW1ib2wiLCJnZXRFbnVtVHlwZSIsImVudW1PYmplY3QiLCJzZXRFbnVtVHlwZSIsInR5cGVOYW1lIiwidmFsdWVzIiwib3B0IiwibWFrZUVudW1UeXBlIiwibWFwIiwidiIsIm5vIiwibmFtZSIsImxvY2FsTmFtZSIsIl9vcHQiLCJuYW1lcyIsImNyZWF0ZSIsIm51bWJlcnMiLCJub3JtYWxWYWx1ZXMiLCJub3JtYWxpemVFbnVtVmFsdWUiLCJwdXNoIiwiZmluZE5hbWUiLCJmaW5kTnVtYmVyIiwibWFrZUVudW0iLCJhc3NpZ24iLCJNZXNzYWdlIiwiZXF1YWxzIiwib3RoZXIiLCJnZXRUeXBlIiwicnVudGltZSIsInV0aWwiLCJjbG9uZSIsImZyb21CaW5hcnkiLCJieXRlcyIsIm9wdGlvbnMiLCJ0eXBlIiwiZm9ybWF0IiwiYmluIiwibWFrZVJlYWRPcHRpb25zIiwicmVhZE1lc3NhZ2UiLCJyZWFkZXJGYWN0b3J5IiwiYnl0ZUxlbmd0aCIsImZyb21Kc29uIiwianNvblZhbHVlIiwianNvbiIsImZyb21Kc29uU3RyaW5nIiwianNvblN0cmluZyIsIkpTT04iLCJwYXJzZSIsImNvbmNhdCIsIm1lc3NhZ2UiLCJTdHJpbmciLCJ0b0JpbmFyeSIsIm1ha2VXcml0ZU9wdGlvbnMiLCJ3cml0ZXIiLCJ3cml0ZXJGYWN0b3J5Iiwid3JpdGVNZXNzYWdlIiwiZmluaXNoIiwidG9Kc29uIiwidG9Kc29uU3RyaW5nIiwiX2EiLCJzdHJpbmdpZnkiLCJwcmV0dHlTcGFjZXMiLCJ0b0pTT04iLCJlbWl0RGVmYXVsdFZhbHVlcyIsImdldFByb3RvdHlwZU9mIiwibWFrZU1lc3NhZ2VUeXBlIiwiZmllbGRzIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJkYXRhIiwiaW5pdEZpZWxkcyIsImluaXRQYXJ0aWFsIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJuZXdGaWVsZExpc3QiLCJhIiwiYiIsInZhcmludDY0cmVhZCIsImxvd0JpdHMiLCJoaWdoQml0cyIsInNoaWZ0IiwiYnVmIiwicG9zIiwiYXNzZXJ0Qm91bmRzIiwibWlkZGxlQnl0ZSIsInZhcmludDY0d3JpdGUiLCJsbyIsImhpIiwiaGFzTmV4dCIsImJ5dGUiLCJzcGxpdEJpdHMiLCJoYXNNb3JlQml0cyIsIlRXT19QV1JfMzJfREJMIiwiaW50NjRGcm9tU3RyaW5nIiwiZGVjIiwibWludXMiLCJzbGljZSIsImJhc2UiLCJhZGQxZTZkaWdpdCIsImJlZ2luIiwiZW5kIiwiZGlnaXQxZTYiLCJuZWdhdGUiLCJuZXdCaXRzIiwiaW50NjRUb1N0cmluZyIsImJpdHMiLCJuZWdhdGl2ZSIsInJlc3VsdCIsInVJbnQ2NFRvU3RyaW5nIiwidG9VbnNpZ25lZCIsImxvdyIsIm1pZCIsImhpZ2giLCJkaWdpdEEiLCJkaWdpdEIiLCJkaWdpdEMiLCJNYXRoIiwiZmxvb3IiLCJ0b1N0cmluZyIsImRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyIsImRpZ2l0MWU3IiwicGFydGlhbCIsImxlbmd0aCIsInZhcmludDMyd3JpdGUiLCJ2YXJpbnQzMnJlYWQiLCJyZWFkQnl0ZXMiLCJtYWtlSW50NjRTdXBwb3J0IiwiZHYiLCJEYXRhVmlldyIsIkFycmF5QnVmZmVyIiwib2siLCJCaWdJbnQiLCJnZXRCaWdJbnQ2NCIsImdldEJpZ1VpbnQ2NCIsInNldEJpZ0ludDY0Iiwic2V0QmlnVWludDY0IiwicHJvY2VzcyIsImVudiIsIkJVRl9CSUdJTlRfRElTQUJMRSIsIk1JTiIsIk1BWCIsIlVNSU4iLCJVTUFYIiwiemVybyIsInN1cHBvcnRlZCIsImJpIiwidVBhcnNlIiwiZW5jIiwiZ2V0SW50MzIiLCJ1RW5jIiwic2V0SW50MzIiLCJ1RGVjIiwiYXNzZXJ0SW50NjRTdHJpbmciLCJ0ZXN0IiwiYXNzZXJ0VUludDY0U3RyaW5nIiwicHJvdG9JbnQ2NCIsIlNjYWxhclR5cGUiLCJMb25nVHlwZSIsInNjYWxhckVxdWFscyIsIkJZVEVTIiwiVWludDhBcnJheSIsIlVJTlQ2NCIsIkZJWEVENjQiLCJJTlQ2NCIsIlNGSVhFRDY0IiwiU0lOVDY0Iiwic2NhbGFyWmVyb1ZhbHVlIiwibG9uZ1R5cGUiLCJCT09MIiwiRE9VQkxFIiwiRkxPQVQiLCJTVFJJTkciLCJpc1NjYWxhclplcm9WYWx1ZSIsIldpcmVUeXBlIiwiQmluYXJ5V3JpdGVyIiwidGV4dEVuY29kZXIiLCJzdGFjayIsIlRleHRFbmNvZGVyIiwiY2h1bmtzIiwibGVuIiwib2Zmc2V0Iiwic2V0IiwiZm9yayIsImpvaW4iLCJjaHVuayIsInByZXYiLCJwb3AiLCJ1aW50MzIiLCJyYXciLCJ0YWciLCJmaWVsZE5vIiwiaW50MzIiLCJib29sIiwic3RyaW5nIiwiZW5jb2RlIiwiZmxvYXQiLCJidWZmZXIiLCJzZXRGbG9hdDMyIiwiZG91YmxlIiwic2V0RmxvYXQ2NCIsImZpeGVkMzIiLCJzZXRVaW50MzIiLCJzZml4ZWQzMiIsInNpbnQzMiIsInNmaXhlZDY0IiwidmlldyIsInRjIiwiZml4ZWQ2NCIsImludDY0Iiwic2ludDY0Iiwic2lnbiIsInVpbnQ2NCIsIkJpbmFyeVJlYWRlciIsInRleHREZWNvZGVyIiwidmFyaW50NjQiLCJieXRlT2Zmc2V0IiwiVGV4dERlY29kZXIiLCJ3aXJlVHlwZSIsInNraXAiLCJzdGFydCIsIlZhcmludCIsIkJpdDY0IiwiQml0MzIiLCJMZW5ndGhEZWxpbWl0ZWQiLCJTdGFydEdyb3VwIiwiZm4iLCJ3dCIsIkVuZEdyb3VwIiwidW5kZWZpbmVkIiwic3ViYXJyYXkiLCJSYW5nZUVycm9yIiwienplIiwiZ2V0VWludDMyIiwiZ2V0RmxvYXQzMiIsImdldEZsb2F0NjQiLCJkZWNvZGUiLCJtYWtlRXh0ZW5zaW9uIiwiZXh0ZW5kZWUiLCJmaWVsZCIsImZpIiwic3BsaXQiLCJqc29uTmFtZSIsImxpc3QiLCJjcmVhdGVFeHRlbnNpb25Db250YWluZXIiLCJleHRlbnNpb24iLCJjb250YWluZXIiLCJpbml0RXh0ZW5zaW9uRmllbGQiLCJleHQiLCJyZXBlYXRlZCIsImRlZmF1bHQiLCJraW5kIiwiVCIsIkwiLCJmaWVsZFdyYXBwZXIiLCJ1bndyYXBGaWVsZCIsImZpbHRlclVua25vd25GaWVsZHMiLCJ1bmtub3duRmllbGRzIiwiZmlsdGVyIiwidWYiLCJlbmNUYWJsZSIsImRlY1RhYmxlIiwiY2hhckNvZGVBdCIsImluZGV4T2YiLCJwcm90b0Jhc2U2NCIsImJhc2U2NFN0ciIsImVzIiwiYnl0ZVBvcyIsImdyb3VwUG9zIiwicCIsImJhc2U2NCIsImdldEV4dGVuc2lvbiIsImFzc2VydEV4dGVuZGVlIiwidWZzIiwibGlzdFVua25vd25GaWVsZHMiLCJyZWFkRmllbGQiLCJzZXRFeHRlbnNpb24iLCJyZWFkT3B0Iiwid3JpdGVPcHQiLCJoYXNFeHRlbnNpb24iLCJkaXNjYXJkVW5rbm93bkZpZWxkcyIsIm9uVW5rbm93bkZpZWxkIiwiZiIsIndyaXRlRmllbGQiLCJyZWFkZXIiLCJtZXNzYWdlVHlwZSIsImZpbmQiLCJpc0ZpZWxkU2V0IiwidGFyZ2V0Iiwib25lb2YiLCJjYXNlIiwicmVxIiwiY2xlYXJGaWVsZCIsImltcGxpY2l0UHJlc2VuY2UiLCJpc01lc3NhZ2UiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZXZlcnkiLCJhY3R1YWxUeXBlIiwid3JhcEZpZWxkIiwiSU5UMzIiLCJVSU5UMzIiLCJqc29uUmVhZERlZmF1bHRzIiwiaWdub3JlVW5rbm93bkZpZWxkcyIsImpzb25Xcml0ZURlZmF1bHRzIiwiZW51bUFzSW50ZWdlciIsInVzZVByb3RvRmllbGROYW1lIiwibWFrZVJlYWRPcHRpb25zJDEiLCJtYWtlV3JpdGVPcHRpb25zJDEiLCJ0b2tlbk51bGwiLCJ0b2tlbklnbm9yZWRVbmtub3duRW51bSIsIm1ha2VKc29uRm9ybWF0IiwiZGVidWdKc29uVmFsdWUiLCJvbmVvZlNlZW4iLCJNYXAiLCJyZWdpc3RyeSIsInR5cGVSZWdpc3RyeSIsImpzb25LZXkiLCJlbnRyaWVzIiwiZmluZEpzb25OYW1lIiwic2VlbiIsInJlYWRGaWVsZCQxIiwiZm91bmQiLCJmaW5kRXh0ZW5zaW9uIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiYnlOdW1iZXIiLCJjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUiLCJ3cml0ZUZpZWxkJDEiLCJmaW5kRXh0ZW5zaW9uRm9yIiwiciIsInJlYWRTY2FsYXIiLCJyZWFkU2NhbGFyJDEiLCJCSUdJTlQiLCJ3cml0ZVNjYWxhciIsIndyaXRlU2NhbGFyJDEiLCJkZWJ1ZyIsInBhcmVudFR5cGUiLCJ0YXJnZXRBcnJheSIsImpzb25JdGVtIiwiZW51bVZhbHVlIiwicmVhZEVudW0iLCJ0YXJnZXRNYXAiLCJqc29uTWFwS2V5IiwianNvbk1hcFZhbHVlIiwia2V5IiwicmVhZE1hcEtleSIsIksiLCJWIiwiY3VycmVudFZhbHVlIiwic2NhbGFyVmFsdWUiLCJudWxsQXNaZXJvVmFsdWUiLCJOYU4iLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwidHJpbSIsImlzTmFOIiwiRklYRUQzMiIsIlNGSVhFRDMyIiwiU0lOVDMyIiwibG9uZyIsInVMb25nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwianNvbk9iaiIsImVudHJ5S2V5IiwiZW50cnlWYWx1ZSIsImVudW1UeXBlIiwid3JpdGVFbnVtIiwianNvbkFyciIsInZhbCIsInVua25vd25GaWVsZHNTeW1ib2wiLCJyZWFkRGVmYXVsdHMiLCJyZWFkVW5rbm93bkZpZWxkcyIsIndyaXRlRGVmYXVsdHMiLCJ3cml0ZVVua25vd25GaWVsZHMiLCJtYWtlQmluYXJ5Rm9ybWF0IiwibGVuZ3RoT3JFbmRUYWdGaWVsZE5vIiwiZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nIiwic2NhbGFyVHlwZSIsInJlYWQiLCJyZWFkU2NhbGFyTFRTdHJpbmciLCJhcnIiLCJpc1BhY2tlZCIsInJlYWRNZXNzYWdlRmllbGQiLCJtYXBLZXkiLCJtYXBWYWwiLCJyZWFkTWFwRW50cnkiLCJkZWxpbWl0ZWQiLCJwYWNrZWQiLCJ3cml0ZVBhY2tlZCIsIml0ZW0iLCJ3cml0ZU1lc3NhZ2VGaWVsZCIsIndyaXRlTWFwRW50cnkiLCJrZXlWYWx1ZSIsInBhcnNlSW50IiwibWV0aG9kIiwic2NhbGFyVHlwZUluZm8iLCJ0b0xvd2VyQ2FzZSIsIm1ha2VVdGlsQ29tbW9uIiwic291cmNlIiwibWVtYmVyIiwiYnlNZW1iZXIiLCJzayIsInNvdXJjZUZpZWxkIiwiZmluZEZpZWxkIiwidG9VOEFyciIsImNvcHkiLCJtdCIsInZhIiwidmIiLCJhbnkiLCJjbG9uZVNpbmd1bGFyRmllbGQiLCJpbnB1dCIsIm1ha2VQcm90b1J1bnRpbWUiLCJzeW50YXgiLCJJbnRlcm5hbEZpZWxkTGlzdCIsIm5vcm1hbGl6ZXIiLCJfZmllbGRzIiwiX25vcm1hbGl6ZXIiLCJqc29uTmFtZXMiLCJhbGwiLCJudW1iZXJzQXNjIiwic29ydCIsIm1lbWJlcnMiLCJsb2NhbEZpZWxkTmFtZSIsInByb3RvTmFtZSIsImluT25lb2YiLCJwcm90b0NhbWVsQ2FzZSIsInNhZmVPYmplY3RQcm9wZXJ0eSIsInNhZmVNZXNzYWdlUHJvcGVydHkiLCJsb2NhbE9uZW9mTmFtZSIsImZpZWxkSnNvbk5hbWUiLCJzbmFrZUNhc2UiLCJjYXBOZXh0IiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJyZXNlcnZlZE9iamVjdFByb3BlcnRpZXMiLCJTZXQiLCJyZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzIiwiZmFsbGJhY2siLCJoYXMiLCJJbnRlcm5hbE9uZW9mSW5mbyIsImFkZEZpZWxkIiwiX2xvb2t1cCIsIm5vcm1hbGl6ZUZpZWxkSW5mb3MiLCJmaWVsZEluZm9zIiwicGFja2VkQnlEZWZhdWx0IiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIm9vbmFtZSIsInByb3RvMyIsIlRpbWVzdGFtcCIsInNlY29uZHMiLCJuYW5vcyIsIm1hdGNoZXMiLCJtYXRjaCIsIm1zIiwiRGF0ZSIsInJlcGVhdCIsInoiLCJuYW5vc1N0ciIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsInRvRGF0ZSIsImNlaWwiLCJub3ciLCJmcm9tRGF0ZSIsImRhdGUiLCJnZXRUaW1lIiwiTWV0cmljc0JhdGNoIiwiVGltZVNlcmllc01ldHJpYyIsIkV2ZW50TWV0cmljIiwiTWV0cmljU2FtcGxlIiwiQXVkaW9Db2RlYyIsIlZpZGVvQ29kZWMiLCJJbWFnZUNvZGVjIiwiQmFja3VwQ29kZWNQb2xpY3kkMSIsIlRyYWNrVHlwZSIsIlRyYWNrU291cmNlIiwiVmlkZW9RdWFsaXR5JDEiLCJDb25uZWN0aW9uUXVhbGl0eSQxIiwiQ2xpZW50Q29uZmlnU2V0dGluZyIsIkRpc2Nvbm5lY3RSZWFzb24iLCJSZWNvbm5lY3RSZWFzb24iLCJTdWJzY3JpcHRpb25FcnJvciIsIkF1ZGlvVHJhY2tGZWF0dXJlIiwiUm9vbSQxIiwiQ29kZWMiLCJUaW1lZFZlcnNpb24iLCJQYXJ0aWNpcGFudFBlcm1pc3Npb24iLCJQYXJ0aWNpcGFudEluZm8iLCJQYXJ0aWNpcGFudEluZm9fU3RhdGUiLCJUcmFja0luZm8iLCJQYXJ0aWNpcGFudEluZm9fS2luZCIsIlBhcnRpY2lwYW50SW5mb19LaW5kRGV0YWlsIiwiRW5jcnlwdGlvbl9UeXBlIiwiU2ltdWxjYXN0Q29kZWNJbmZvIiwiVmlkZW9MYXllciIsIlZpZGVvTGF5ZXJfTW9kZSIsIkRhdGFQYWNrZXQiLCJEYXRhUGFja2V0X0tpbmQiLCJVc2VyUGFja2V0IiwiQWN0aXZlU3BlYWtlclVwZGF0ZSIsIlNpcERUTUYiLCJUcmFuc2NyaXB0aW9uIiwiQ2hhdE1lc3NhZ2UiLCJScGNSZXF1ZXN0IiwiUnBjQWNrIiwiUnBjUmVzcG9uc2UiLCJEYXRhU3RyZWFtX0hlYWRlciIsIkRhdGFTdHJlYW1fQ2h1bmsiLCJEYXRhU3RyZWFtX1RyYWlsZXIiLCJFbmNyeXB0ZWRQYWNrZXQiLCJFbmNyeXB0ZWRQYWNrZXRQYXlsb2FkIiwiU3BlYWtlckluZm8iLCJUcmFuc2NyaXB0aW9uU2VnbWVudCIsIlJwY0Vycm9yJDEiLCJQYXJ0aWNpcGFudFRyYWNrcyIsIlNlcnZlckluZm8iLCJTZXJ2ZXJJbmZvX0VkaXRpb24iLCJDbGllbnRJbmZvIiwiQ2xpZW50SW5mb19TREsiLCJDbGllbnRDb25maWd1cmF0aW9uIiwiVmlkZW9Db25maWd1cmF0aW9uIiwiRGlzYWJsZWRDb2RlY3MiLCJEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUiLCJEYXRhU3RyZWFtX1RleHRIZWFkZXIiLCJEYXRhU3RyZWFtX0J5dGVIZWFkZXIiLCJGaWx0ZXJQYXJhbXMiLCJXZWJob29rQ29uZmlnIiwiU3Vic2NyaWJlZEF1ZGlvQ29kZWMiLCJSb29tQWdlbnREaXNwYXRjaCIsIkVuY29kZWRGaWxlVHlwZSIsIlNlZ21lbnRlZEZpbGVQcm90b2NvbCIsIlNlZ21lbnRlZEZpbGVTdWZmaXgiLCJJbWFnZUZpbGVTdWZmaXgiLCJTdHJlYW1Qcm90b2NvbCIsIkF1ZGlvTWl4aW5nIiwiRW5jb2RpbmdPcHRpb25zUHJlc2V0IiwiUm9vbUNvbXBvc2l0ZUVncmVzc1JlcXVlc3QiLCJFbmNvZGVkRmlsZU91dHB1dCIsIlN0cmVhbU91dHB1dCIsIlNlZ21lbnRlZEZpbGVPdXRwdXQiLCJFbmNvZGluZ09wdGlvbnMiLCJJbWFnZU91dHB1dCIsIlMzVXBsb2FkIiwiR0NQVXBsb2FkIiwiQXp1cmVCbG9iVXBsb2FkIiwiQWxpT1NTVXBsb2FkIiwiUHJveHlDb25maWciLCJBdXRvUGFydGljaXBhbnRFZ3Jlc3MiLCJBdXRvVHJhY2tFZ3Jlc3MiLCJSb29tRWdyZXNzIiwiUm9vbUNvbmZpZ3VyYXRpb24iLCJTaWduYWxUYXJnZXQiLCJTdHJlYW1TdGF0ZSIsIkNhbmRpZGF0ZVByb3RvY29sIiwiU2lnbmFsUmVxdWVzdCIsIlNlc3Npb25EZXNjcmlwdGlvbiIsIlRyaWNrbGVSZXF1ZXN0IiwiQWRkVHJhY2tSZXF1ZXN0IiwiTXV0ZVRyYWNrUmVxdWVzdCIsIlVwZGF0ZVN1YnNjcmlwdGlvbiIsIlVwZGF0ZVRyYWNrU2V0dGluZ3MiLCJMZWF2ZVJlcXVlc3QiLCJVcGRhdGVWaWRlb0xheWVycyIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb24iLCJTeW5jU3RhdGUiLCJTaW11bGF0ZVNjZW5hcmlvIiwiVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSIsIlBpbmciLCJVcGRhdGVMb2NhbEF1ZGlvVHJhY2siLCJVcGRhdGVMb2NhbFZpZGVvVHJhY2siLCJTaWduYWxSZXNwb25zZSIsIkpvaW5SZXNwb25zZSIsIlBhcnRpY2lwYW50VXBkYXRlIiwiVHJhY2tQdWJsaXNoZWRSZXNwb25zZSIsIlNwZWFrZXJzQ2hhbmdlZCIsIlJvb21VcGRhdGUiLCJDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSIsIlN0cmVhbVN0YXRlVXBkYXRlIiwiU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIiwiVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIiwiUmVjb25uZWN0UmVzcG9uc2UiLCJQb25nIiwiU3Vic2NyaXB0aW9uUmVzcG9uc2UiLCJSZXF1ZXN0UmVzcG9uc2UiLCJUcmFja1N1YnNjcmliZWQiLCJSb29tTW92ZWRSZXNwb25zZSIsIk1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudCIsIlN1YnNjcmliZWRBdWRpb0NvZGVjVXBkYXRlIiwiU2ltdWxjYXN0Q29kZWMiLCJJQ0VTZXJ2ZXIiLCJMZWF2ZVJlcXVlc3RfQWN0aW9uIiwiUmVnaW9uU2V0dGluZ3MiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8iLCJTdHJlYW1TdGF0ZUluZm8iLCJTdWJzY3JpYmVkUXVhbGl0eSIsIlN1YnNjcmliZWRDb2RlYyIsIlRyYWNrUGVybWlzc2lvbiIsIkRhdGFDaGFubmVsSW5mbyIsIkRhdGFDaGFubmVsUmVjZWl2ZVN0YXRlIiwiUmVnaW9uSW5mbyIsIlJlcXVlc3RSZXNwb25zZV9SZWFzb24iLCJDb25uZWN0aW9uU2V0dGluZ3MiLCJKb2luUmVxdWVzdCIsIldyYXBwZWRKb2luUmVxdWVzdCIsIldyYXBwZWRKb2luUmVxdWVzdF9Db21wcmVzc2lvbiIsIlRva2VuU291cmNlUmVxdWVzdCIsIlRva2VuU291cmNlUmVzcG9uc2UiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibG9nbGV2ZWwkMSIsImV4cG9ydHMiLCJsb2dsZXZlbCIsImhhc1JlcXVpcmVkTG9nbGV2ZWwiLCJyZXF1aXJlTG9nbGV2ZWwiLCJtb2R1bGUiLCJyb290IiwiZGVmaW5pdGlvbiIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImxvZ01ldGhvZHMiLCJfbG9nZ2Vyc0J5TmFtZSIsImRlZmF1bHRMb2dnZXIiLCJiaW5kTWV0aG9kIiwib2JqIiwibWV0aG9kTmFtZSIsImJpbmQiLCJGdW5jdGlvbiIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImdldExldmVsIiwibWV0aG9kRmFjdG9yeSIsImxldmVscyIsIlNJTEVOVCIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIl9sZXZlbCIsIl9sb2dnZXJOYW1lIiwiTG9nZ2VyIiwiZmFjdG9yeSIsInNlbGYiLCJpbmhlcml0ZWRMZXZlbCIsImRlZmF1bHRMZXZlbCIsInVzZXJMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJjb29raWVOYW1lIiwibG9jYXRpb24iLCJleGVjIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJub3JtYWxpemVMZXZlbCIsIlR5cGVFcnJvciIsInNldExldmVsIiwicGVyc2lzdCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJyZWJ1aWxkIiwiY2hpbGROYW1lIiwiaW5pdGlhbExldmVsIiwiZ2V0TG9nZ2VyIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIiwibG9nbGV2ZWxFeHBvcnRzIiwiTG9nTGV2ZWwiLCJMb2dnZXJOYW1lcyIsImxpdmVraXRMb2dnZXIiLCJsaXZla2l0TG9nZ2VycyIsImluZm8iLCJzZXRMb2dMZXZlbCIsImxvZ2dlck5hbWUiLCJzZXRMb2dFeHRlbnNpb24iLCJsb2dnZXJzIiwibG9nUiIsIm9yaWdpbmFsRmFjdG9yeSIsImNvbmZpZ0xldmVsIiwicmF3TWV0aG9kIiwibG9nTGV2ZWwiLCJuZWVkTG9nIiwic2lsZW50IiwiY29udGV4dCIsIndvcmtlckxvZ2dlciIsIm1heFJldHJ5RGVsYXkiLCJERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyIsIkRlZmF1bHRSZWNvbm5lY3RQb2xpY3kiLCJyZXRyeURlbGF5cyIsIl9yZXRyeURlbGF5cyIsIm5leHRSZXRyeURlbGF5SW5NcyIsInJldHJ5Q291bnQiLCJyZXRyeURlbGF5IiwicmFuZG9tIiwiX19yZXN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJkb25lIiwiX192YWx1ZXMiLCJpdGVyYXRvciIsIl9fYXN5bmNWYWx1ZXMiLCJhc3luY0l0ZXJhdG9yIiwidmVyYiIsInNldHRsZSIsIlN1cHByZXNzZWRFcnJvciIsImVycm9yIiwic3VwcHJlc3NlZCIsImV2ZW50cyIsImhhc1JlcXVpcmVkRXZlbnRzIiwicmVxdWlyZUV2ZW50cyIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwicmVjZWl2ZXIiLCJhcmdzIiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIndhcm4iLCJOdW1iZXJJc05hTiIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJvbmNlIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwiZG9FcnJvciIsImVyIiwiZXJyIiwiaGFuZGxlciIsImxpc3RlbmVycyIsImFycmF5Q2xvbmUiLCJfYWRkTGlzdGVuZXIiLCJwcmVwZW5kIiwiZXhpc3RpbmciLCJuZXdMaXN0ZW5lciIsInVuc2hpZnQiLCJ3YXJuZWQiLCJ3IiwiZW1pdHRlciIsImNvdW50IiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzcGxpY2VPbmUiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiaW5kZXgiLCJyZXQiLCJlcnJvckxpc3RlbmVyIiwicmVzb2x2ZXIiLCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIiLCJhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlciIsImZsYWdzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndyYXBMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudHNFeHBvcnRzIiwibG9nRGlzYWJsZWRfIiwiZGVwcmVjYXRpb25XYXJuaW5nc18iLCJleHRyYWN0VmVyc2lvbiIsInVhc3RyaW5nIiwiZXhwciIsInBhcnNlRmxvYXQiLCJ3cmFwUGVlckNvbm5lY3Rpb25FdmVudCIsImV2ZW50TmFtZVRvV3JhcCIsIndyYXBwZXIiLCJSVENQZWVyQ29ubmVjdGlvbiIsInByb3RvIiwibmF0aXZlQWRkRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50TmFtZSIsImNiIiwid3JhcHBlZENhbGxiYWNrIiwibW9kaWZpZWRFdmVudCIsImhhbmRsZUV2ZW50IiwiX2V2ZW50TWFwIiwibmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVud3JhcHBlZENiIiwiZGVsZXRlIiwic2l6ZSIsImRpc2FibGVMb2ciLCJkaXNhYmxlV2FybmluZ3MiLCJkZXByZWNhdGVkIiwib2xkTWV0aG9kIiwibmV3TWV0aG9kIiwiZGV0ZWN0QnJvd3NlciIsImJyb3dzZXIiLCJ2ZXJzaW9uIiwidXNlckFnZW50RGF0YSIsImJyYW5kcyIsImNocm9taXVtIiwiYnJhbmQiLCJtb3pHZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJpc1NlY3VyZUNvbnRleHQiLCJ3ZWJraXRSVENQZWVyQ29ubmVjdGlvbiIsInN1cHBvcnRzVW5pZmllZFBsYW4iLCJSVENSdHBUcmFuc2NlaXZlciIsIl9zYWZhcmlWZXJzaW9uIiwiaXNPYmplY3QkMSIsImNvbXBhY3RPYmplY3QiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImlzT2JqIiwiaXNFbXB0eU9iamVjdCIsIndhbGtTdGF0cyIsInN0YXRzIiwicmVzdWx0U2V0IiwiaWQiLCJmaWx0ZXJTdGF0cyIsInRyYWNrIiwib3V0Ym91bmQiLCJzdHJlYW1TdGF0c1R5cGUiLCJmaWx0ZXJlZFJlc3VsdCIsInRyYWNrU3RhdHMiLCJ0cmFja0lkZW50aWZpZXIiLCJ0cmFja1N0YXQiLCJ0cmFja0lkIiwibG9nZ2luZyIsInNoaW1HZXRVc2VyTWVkaWEkMiIsImJyb3dzZXJEZXRhaWxzIiwibWVkaWFEZXZpY2VzIiwiY29uc3RyYWludHNUb0Nocm9tZV8iLCJtYW5kYXRvcnkiLCJvcHRpb25hbCIsImNjIiwiaWRlYWwiLCJleGFjdCIsIm1pbiIsIm1heCIsIm9sZG5hbWVfIiwicHJlZml4Iiwib2MiLCJtaXgiLCJhZHZhbmNlZCIsInNoaW1Db25zdHJhaW50c18iLCJjb25zdHJhaW50cyIsImZ1bmMiLCJhdWRpbyIsInJlbWFwIiwidmlkZW8iLCJmYWNlIiwiZmFjaW5nTW9kZSIsImdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzIiwiZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMiLCJlbnVtZXJhdGVEZXZpY2VzIiwiZGV2aWNlcyIsImRldiIsInNvbWUiLCJsYWJlbCIsImluY2x1ZGVzIiwiZGV2aWNlSWQiLCJzaGltRXJyb3JfIiwiUGVybWlzc2lvbkRlbmllZEVycm9yIiwiUGVybWlzc2lvbkRpc21pc3NlZEVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJEZXZpY2VzTm90Rm91bmRFcnJvciIsIkNvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvciIsIlRyYWNrU3RhcnRFcnJvciIsIk1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93biIsIk1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uIiwiVGFiQ2FwdHVyZUVycm9yIiwiU2NyZWVuQ2FwdHVyZUVycm9yIiwiRGV2aWNlQ2FwdHVyZUVycm9yIiwiY29uc3RyYWludCIsImNvbnN0cmFpbnROYW1lIiwiZ2V0VXNlck1lZGlhXyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJnZXRVc2VyTWVkaWEiLCJvcmlnR2V0VXNlck1lZGlhIiwiY3MiLCJzdHJlYW0iLCJnZXRBdWRpb1RyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZ2V0VHJhY2tzIiwic3RvcCIsIkRPTUV4Y2VwdGlvbiIsInNoaW1NZWRpYVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwid2Via2l0TWVkaWFTdHJlYW0iLCJzaGltT25UcmFjayQxIiwiX29udHJhY2siLCJvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24iLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsIl9vbnRyYWNrcG9seSIsInRlIiwiZ2V0UmVjZWl2ZXJzIiwiZXZlbnQiLCJFdmVudCIsInRyYW5zY2VpdmVyIiwic3RyZWFtcyIsImRpc3BhdGNoRXZlbnQiLCJzaGltR2V0U2VuZGVyc1dpdGhEdG1mIiwic2hpbVNlbmRlcldpdGhEdG1mIiwicGMiLCJkdG1mIiwiX2R0bWYiLCJjcmVhdGVEVE1GU2VuZGVyIiwiX3BjIiwiZ2V0U2VuZGVycyIsIl9zZW5kZXJzIiwib3JpZ0FkZFRyYWNrIiwiYWRkVHJhY2siLCJzZW5kZXIiLCJvcmlnUmVtb3ZlVHJhY2siLCJyZW1vdmVUcmFjayIsImlkeCIsInNwbGljZSIsIm9yaWdBZGRTdHJlYW0iLCJhZGRTdHJlYW0iLCJvcmlnUmVtb3ZlU3RyZWFtIiwicmVtb3ZlU3RyZWFtIiwiUlRDUnRwU2VuZGVyIiwib3JpZ0dldFNlbmRlcnMiLCJzZW5kZXJzIiwic2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMiLCJSVENSdHBSZWNlaXZlciIsImdldFN0YXRzIiwib3JpZ0dldFJlY2VpdmVycyIsInJlY2VpdmVycyIsInNyY0VsZW1lbnQiLCJvcmlnR2V0U3RhdHMiLCJNZWRpYVN0cmVhbVRyYWNrIiwic2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlIiwiZ2V0TG9jYWxTdHJlYW1zIiwiX3NoaW1tZWRMb2NhbFN0cmVhbXMiLCJzdHJlYW1JZCIsImFscmVhZHlFeGlzdHMiLCJleGlzdGluZ1NlbmRlcnMiLCJuZXdTZW5kZXJzIiwibmV3U2VuZGVyIiwic2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2siLCJvcmlnR2V0TG9jYWxTdHJlYW1zIiwibmF0aXZlU3RyZWFtcyIsIl9yZXZlcnNlU3RyZWFtcyIsIl9zdHJlYW1zIiwibmV3U3RyZWFtIiwic2lnbmFsaW5nU3RhdGUiLCJvbGRTdHJlYW0iLCJyZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCIsImRlc2NyaXB0aW9uIiwic2RwIiwiaW50ZXJuYWxJZCIsImV4dGVybmFsU3RyZWFtIiwiaW50ZXJuYWxTdHJlYW0iLCJSZWdFeHAiLCJSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJyZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCIsIm5hdGl2ZU1ldGhvZCIsIm1ldGhvZE9iaiIsImlzTGVnYWN5Q2FsbCIsImRlc2MiLCJvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiIsInNldExvY2FsRGVzY3JpcHRpb24iLCJvcmlnTG9jYWxEZXNjcmlwdGlvbiIsImlzTG9jYWwiLCJzdHJlYW1pZCIsImhhc1RyYWNrIiwic2hpbVBlZXJDb25uZWN0aW9uJDEiLCJSVENJY2VDYW5kaWRhdGUiLCJmaXhOZWdvdGlhdGlvbk5lZWRlZCIsImdldENvbmZpZ3VyYXRpb24iLCJzZHBTZW1hbnRpY3MiLCJjaHJvbWVTaGltIiwiX19wcm90b19fIiwic2hpbUdldFVzZXJNZWRpYSIsInNoaW1PblRyYWNrIiwic2hpbVBlZXJDb25uZWN0aW9uIiwic2hpbUdldFVzZXJNZWRpYSQxIiwibmF0aXZlR2V0VXNlck1lZGlhIiwiZ2V0U2V0dGluZ3MiLCJuYXRpdmVHZXRTZXR0aW5ncyIsImFwcGx5Q29uc3RyYWludHMiLCJuYXRpdmVBcHBseUNvbnN0cmFpbnRzIiwic2hpbUdldERpc3BsYXlNZWRpYSIsInByZWZlcnJlZE1lZGlhU291cmNlIiwiZ2V0RGlzcGxheU1lZGlhIiwiY29kZSIsIm1lZGlhU291cmNlIiwiUlRDVHJhY2tFdmVudCIsIm1velJUQ1BlZXJDb25uZWN0aW9uIiwibW9kZXJuU3RhdHNUeXBlcyIsImluYm91bmRydHAiLCJvdXRib3VuZHJ0cCIsImNhbmRpZGF0ZXBhaXIiLCJsb2NhbGNhbmRpZGF0ZSIsInJlbW90ZWNhbmRpZGF0ZSIsIm5hdGl2ZUdldFN0YXRzIiwic2VsZWN0b3IiLCJvblN1Y2MiLCJvbkVyciIsInN0YXQiLCJzaGltU2VuZGVyR2V0U3RhdHMiLCJzaGltUmVjZWl2ZXJHZXRTdGF0cyIsInNoaW1SZW1vdmVTdHJlYW0iLCJzaGltUlRDRGF0YUNoYW5uZWwiLCJEYXRhQ2hhbm5lbCIsIlJUQ0RhdGFDaGFubmVsIiwic2hpbUFkZFRyYW5zY2VpdmVyIiwib3JpZ0FkZFRyYW5zY2VpdmVyIiwiYWRkVHJhbnNjZWl2ZXIiLCJzZXRQYXJhbWV0ZXJzUHJvbWlzZXMiLCJzZW5kRW5jb2RpbmdzIiwic2hvdWxkUGVyZm9ybUNoZWNrIiwiZW5jb2RpbmdQYXJhbSIsInJpZFJlZ2V4IiwicmlkIiwic2NhbGVSZXNvbHV0aW9uRG93bkJ5IiwibWF4RnJhbWVyYXRlIiwicGFyYW1zIiwiZ2V0UGFyYW1ldGVycyIsImVuY29kaW5ncyIsInNldFBhcmFtZXRlcnMiLCJjYXRjaCIsInNoaW1HZXRQYXJhbWV0ZXJzIiwib3JpZ0dldFBhcmFtZXRlcnMiLCJzaGltQ3JlYXRlT2ZmZXIiLCJvcmlnQ3JlYXRlT2ZmZXIiLCJjcmVhdGVPZmZlciIsImZpbmFsbHkiLCJzaGltQ3JlYXRlQW5zd2VyIiwib3JpZ0NyZWF0ZUFuc3dlciIsImNyZWF0ZUFuc3dlciIsImZpcmVmb3hTaGltIiwic2hpbUxvY2FsU3RyZWFtc0FQSSIsIl9sb2NhbFN0cmVhbXMiLCJfYWRkVHJhY2siLCJfbGVuIiwiX2tleSIsInRyYWNrcyIsInNoaW1SZW1vdGVTdHJlYW1zQVBJIiwiZ2V0UmVtb3RlU3RyZWFtcyIsIl9yZW1vdGVTdHJlYW1zIiwiX29uYWRkc3RyZWFtIiwiX29uYWRkc3RyZWFtcG9seSIsInNoaW1DYWxsYmFja3NBUEkiLCJhZGRJY2VDYW5kaWRhdGUiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJwcm9taXNlIiwid2l0aENhbGxiYWNrIiwiY2FuZGlkYXRlIiwiX2dldFVzZXJNZWRpYSIsInNoaW1Db25zdHJhaW50cyIsImVycmNiIiwic2hpbVJUQ0ljZVNlcnZlclVybHMiLCJPcmlnUGVlckNvbm5lY3Rpb24iLCJwY0NvbmZpZyIsInBjQ29uc3RyYWludHMiLCJpY2VTZXJ2ZXJzIiwibmV3SWNlU2VydmVycyIsInNlcnZlciIsInVybHMiLCJ1cmwiLCJnZW5lcmF0ZUNlcnRpZmljYXRlIiwic2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlciIsInNoaW1DcmVhdGVPZmZlckxlZ2FjeSIsIm9mZmVyT3B0aW9ucyIsIm9mZmVyVG9SZWNlaXZlQXVkaW8iLCJhdWRpb1RyYW5zY2VpdmVyIiwiZ2V0VHJhbnNjZWl2ZXJzIiwiZGlyZWN0aW9uIiwic2V0RGlyZWN0aW9uIiwib2ZmZXJUb1JlY2VpdmVWaWRlbyIsInZpZGVvVHJhbnNjZWl2ZXIiLCJzaGltQXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwic2FmYXJpU2hpbSIsInNkcCQxIiwiaGFzUmVxdWlyZWRTZHAiLCJyZXF1aXJlU2RwIiwiU0RQVXRpbHMiLCJnZW5lcmF0ZUlkZW50aWZpZXIiLCJsb2NhbENOYW1lIiwic3BsaXRMaW5lcyIsImJsb2IiLCJsaW5lIiwic3BsaXRTZWN0aW9ucyIsInBhcnRzIiwicGFydCIsImdldERlc2NyaXB0aW9uIiwic2VjdGlvbnMiLCJnZXRNZWRpYVNlY3Rpb25zIiwibWF0Y2hQcmVmaXgiLCJwYXJzZUNhbmRpZGF0ZSIsImZvdW5kYXRpb24iLCJjb21wb25lbnQiLCJwcm90b2NvbCIsInByaW9yaXR5IiwiaXAiLCJhZGRyZXNzIiwicG9ydCIsInJlbGF0ZWRBZGRyZXNzIiwicmVsYXRlZFBvcnQiLCJ0Y3BUeXBlIiwidWZyYWciLCJ1c2VybmFtZUZyYWdtZW50Iiwid3JpdGVDYW5kaWRhdGUiLCJwYXJzZUljZU9wdGlvbnMiLCJwYXJzZVJ0cE1hcCIsInBhcnNlZCIsInBheWxvYWRUeXBlIiwiY2xvY2tSYXRlIiwiY2hhbm5lbHMiLCJudW1DaGFubmVscyIsIndyaXRlUnRwTWFwIiwiY29kZWMiLCJwdCIsInByZWZlcnJlZFBheWxvYWRUeXBlIiwicGFyc2VFeHRtYXAiLCJ1cmkiLCJhdHRyaWJ1dGVzIiwid3JpdGVFeHRtYXAiLCJoZWFkZXJFeHRlbnNpb24iLCJwcmVmZXJyZWRJZCIsInBhcnNlRm10cCIsImt2IiwiaiIsIndyaXRlRm10cCIsInBhcmFtZXRlcnMiLCJwYXJhbSIsInBhcnNlUnRjcEZiIiwicGFyYW1ldGVyIiwid3JpdGVSdGNwRmIiLCJsaW5lcyIsInJ0Y3BGZWVkYmFjayIsImZiIiwicGFyc2VTc3JjTWVkaWEiLCJzcCIsInNzcmMiLCJjb2xvbiIsImF0dHJpYnV0ZSIsInBhcnNlU3NyY0dyb3VwIiwic2VtYW50aWNzIiwic3NyY3MiLCJnZXRNaWQiLCJtZWRpYVNlY3Rpb24iLCJwYXJzZUZpbmdlcnByaW50IiwiYWxnb3JpdGhtIiwiZ2V0RHRsc1BhcmFtZXRlcnMiLCJzZXNzaW9ucGFydCIsInJvbGUiLCJmaW5nZXJwcmludHMiLCJ3cml0ZUR0bHNQYXJhbWV0ZXJzIiwic2V0dXBUeXBlIiwiZnAiLCJwYXJzZUNyeXB0b0xpbmUiLCJjcnlwdG9TdWl0ZSIsImtleVBhcmFtcyIsInNlc3Npb25QYXJhbXMiLCJ3cml0ZUNyeXB0b0xpbmUiLCJ3cml0ZUNyeXB0b0tleVBhcmFtcyIsInBhcnNlQ3J5cHRvS2V5UGFyYW1zIiwia2V5TWV0aG9kIiwia2V5U2FsdCIsImxpZmVUaW1lIiwibWtpVmFsdWUiLCJta2lMZW5ndGgiLCJnZXRDcnlwdG9QYXJhbWV0ZXJzIiwiZ2V0SWNlUGFyYW1ldGVycyIsInB3ZCIsInBhc3N3b3JkIiwid3JpdGVJY2VQYXJhbWV0ZXJzIiwiaWNlTGl0ZSIsInBhcnNlUnRwUGFyYW1ldGVycyIsImNvZGVjcyIsImhlYWRlckV4dGVuc2lvbnMiLCJmZWNNZWNoYW5pc21zIiwicnRjcCIsIm1saW5lIiwicHJvZmlsZSIsInJ0cG1hcGxpbmUiLCJmbXRwcyIsIndpbGRjYXJkUnRjcEZiIiwiZHVwbGljYXRlIiwiZXhpc3RpbmdGZWVkYmFjayIsIndyaXRlUnRwRGVzY3JpcHRpb24iLCJjYXBzIiwibWF4cHRpbWUiLCJwYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyIsImVuY29kaW5nUGFyYW1ldGVycyIsImhhc1JlZCIsImhhc1VscGZlYyIsInByaW1hcnlTc3JjIiwic2Vjb25kYXJ5U3NyYyIsImZsb3dzIiwiYXB0IiwiZW5jUGFyYW0iLCJjb2RlY1BheWxvYWRUeXBlIiwicnR4IiwiZmVjIiwibWVjaGFuaXNtIiwiYmFuZHdpZHRoIiwibWF4Qml0cmF0ZSIsInBhcnNlUnRjcFBhcmFtZXRlcnMiLCJydGNwUGFyYW1ldGVycyIsInJlbW90ZVNzcmMiLCJjbmFtZSIsInJzaXplIiwicmVkdWNlZFNpemUiLCJjb21wb3VuZCIsIm11eCIsIndyaXRlUnRjcFBhcmFtZXRlcnMiLCJwYXJzZU1zaWQiLCJzcGVjIiwicGxhbkIiLCJtc2lkUGFydHMiLCJwYXJzZVNjdHBEZXNjcmlwdGlvbiIsInBhcnNlTUxpbmUiLCJtYXhTaXplTGluZSIsIm1heE1lc3NhZ2VTaXplIiwic2N0cFBvcnQiLCJmbXQiLCJzY3RwTWFwTGluZXMiLCJ3cml0ZVNjdHBEZXNjcmlwdGlvbiIsIm1lZGlhIiwic2N0cCIsIm91dHB1dCIsImdlbmVyYXRlU2Vzc2lvbklkIiwic3Vic3RyIiwid3JpdGVTZXNzaW9uQm9pbGVycGxhdGUiLCJzZXNzSWQiLCJzZXNzVmVyIiwic2Vzc1VzZXIiLCJzZXNzaW9uSWQiLCJ1c2VyIiwiZ2V0RGlyZWN0aW9uIiwiZ2V0S2luZCIsImlzUmVqZWN0ZWQiLCJwYXJzZU9MaW5lIiwidXNlcm5hbWUiLCJzZXNzaW9uVmVyc2lvbiIsIm5ldFR5cGUiLCJhZGRyZXNzVHlwZSIsImlzVmFsaWRTRFAiLCJzZHBFeHBvcnRzIiwic2hpbVJUQ0ljZUNhbmRpZGF0ZSIsIk5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSIsIm5hdGl2ZUNhbmRpZGF0ZSIsInBhcnNlZENhbmRpZGF0ZSIsInNkcE1pZCIsInNkcE1MaW5lSW5kZXgiLCJzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCIsInJlbGF5UHJvdG9jb2wiLCJzaGltTWF4TWVzc2FnZVNpemUiLCJfc2N0cCIsInNjdHBJbkRlc2NyaXB0aW9uIiwibUxpbmUiLCJnZXRSZW1vdGVGaXJlZm94VmVyc2lvbiIsImdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSIsInJlbW90ZUlzRmlyZWZveCIsImNhblNlbmRNYXhNZXNzYWdlU2l6ZSIsImdldE1heE1lc3NhZ2VTaXplIiwiaXNGaXJlZm94IiwiY2FuU2VuZE1NUyIsInJlbW90ZU1NUyIsInNoaW1TZW5kVGhyb3dUeXBlRXJyb3IiLCJ3cmFwRGNTZW5kIiwiZGMiLCJvcmlnRGF0YUNoYW5uZWxTZW5kIiwic2VuZCIsInJlYWR5U3RhdGUiLCJvcmlnQ3JlYXRlRGF0YUNoYW5uZWwiLCJjcmVhdGVEYXRhQ2hhbm5lbCIsImRhdGFDaGFubmVsIiwiY2hhbm5lbCIsInNoaW1Db25uZWN0aW9uU3RhdGUiLCJjb21wbGV0ZWQiLCJjaGVja2luZyIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9yaWdNZXRob2QiLCJfY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSIsIl9sYXN0Q29ubmVjdGlvblN0YXRlIiwiY29ubmVjdGlvblN0YXRlIiwibmV3RXZlbnQiLCJyZW1vdmVFeHRtYXBBbGxvd01peGVkIiwibmF0aXZlU1JEIiwic2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5IiwibmF0aXZlQWRkSWNlQ2FuZGlkYXRlIiwic2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uIiwibmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiIsImNvbW1vblNoaW0iLCJhZGFwdGVyRmFjdG9yeSIsInNoaW1DaHJvbWUiLCJzaGltRmlyZWZveCIsInNoaW1TYWZhcmkiLCJhZGFwdGVyIiwiYnJvd3NlclNoaW0iLCJFTkNSWVBUSU9OX0FMR09SSVRITSIsIkRFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UiLCJFMkVFX0ZMQUciLCJTQUxUIiwiS0VZX1BST1ZJREVSX0RFRkFVTFRTIiwic2hhcmVkS2V5IiwicmF0Y2hldFNhbHQiLCJyYXRjaGV0V2luZG93U2l6ZSIsImZhaWx1cmVUb2xlcmFuY2UiLCJrZXlyaW5nU2l6ZSIsIktleVByb3ZpZGVyRXZlbnQiLCJLZXlIYW5kbGVyRXZlbnQiLCJFbmNyeXB0aW9uRXZlbnQiLCJDcnlwdG9yRXZlbnQiLCJpc0UyRUVTdXBwb3J0ZWQiLCJpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQiLCJpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCIsIlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSIsImNyZWF0ZUVuY29kZWRTdHJlYW1zIiwiaXNWaWRlb0ZyYW1lIiwiZnJhbWUiLCJpbXBvcnRLZXkiLCJrZXlCeXRlc18xIiwia2V5Qnl0ZXMiLCJ1c2FnZSIsImNyeXB0byIsInN1YnRsZSIsImNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyIsImtleU1hdGVyaWFsIiwiY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyIiwiY3J5cHRvQnVmZmVyIiwiZ2V0QWxnb09wdGlvbnMiLCJhbGdvcml0aG1OYW1lIiwic2FsdCIsImVuY29kZWRTYWx0IiwiaGFzaCIsIml0ZXJhdGlvbnMiLCJkZXJpdmVLZXlzIiwibWF0ZXJpYWwiLCJhbGdvcml0aG1PcHRpb25zIiwiZW5jcnlwdGlvbktleSIsImRlcml2ZUtleSIsImNyZWF0ZUUyRUVLZXkiLCJnZXRSYW5kb21WYWx1ZXMiLCJyYXRjaGV0IiwiZGVyaXZlQml0cyIsIm5lZWRzUmJzcFVuZXNjYXBpbmciLCJmcmFtZURhdGEiLCJwYXJzZVJic3AiLCJkYXRhT3V0Iiwia1plcm9zSW5TdGFydFNlcXVlbmNlIiwia0VtdWxhdGlvbkJ5dGUiLCJ3cml0ZVJic3AiLCJkYXRhX2luIiwibnVtQ29uc2VjdXRpdmVaZXJvcyIsImFzRW5jcnlwdGFibGVQYWNrZXQiLCJwYWNrZXQiLCJCYXNlS2V5UHJvdmlkZXIiLCJvbktleVJhdGNoZXRlZCIsInJhdGNoZXRSZXN1bHQiLCJwYXJ0aWNpcGFudElkIiwia2V5SW5kZXgiLCJrZXlJbmZvTWFwIiwiS2V5UmF0Y2hldGVkIiwib25TZXRFbmNyeXB0aW9uS2V5IiwicGFydGljaXBhbnRJZGVudGl0eSIsImtleUluZm8iLCJTZXRLZXkiLCJnZXRLZXlzIiwiZnJvbSIsImdldE9wdGlvbnMiLCJyYXRjaGV0S2V5IiwiUmF0Y2hldFJlcXVlc3QiLCJFeHRlcm5hbEUyRUVLZXlQcm92aWRlciIsIm9wdHMiLCJzZXRLZXkiLCJkZXJpdmVkS2V5IiwiTGl2ZWtpdEVycm9yIiwiQ29ubmVjdGlvbkVycm9yUmVhc29uIiwiQ29ubmVjdGlvbkVycm9yIiwicmVhc29uIiwic3RhdHVzIiwicmVhc29uTmFtZSIsIkRldmljZVVuc3VwcG9ydGVkRXJyb3IiLCJUcmFja0ludmFsaWRFcnJvciIsIlVuc3VwcG9ydGVkU2VydmVyIiwiVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSIsIk5lZ290aWF0aW9uRXJyb3IiLCJQdWJsaXNoRGF0YUVycm9yIiwiUHVibGlzaFRyYWNrRXJyb3IiLCJTaWduYWxSZXF1ZXN0RXJyb3IiLCJEYXRhU3RyZWFtRXJyb3JSZWFzb24iLCJEYXRhU3RyZWFtRXJyb3IiLCJNZWRpYURldmljZUZhaWx1cmUiLCJnZXRGYWlsdXJlIiwiTm90Rm91bmQiLCJQZXJtaXNzaW9uRGVuaWVkIiwiRGV2aWNlSW5Vc2UiLCJPdGhlciIsIkNyeXB0b3JFcnJvclJlYXNvbiIsIkNyeXB0b3JFcnJvciIsIkludGVybmFsRXJyb3IiLCJSb29tRXZlbnQiLCJQYXJ0aWNpcGFudEV2ZW50IiwiRW5naW5lRXZlbnQiLCJUcmFja0V2ZW50IiwiY2xvbmVEZWVwIiwic3RydWN0dXJlZENsb25lIiwiY29tbW9uVmVyc2lvbklkZW50aWZpZXIiLCJnZXRCcm93c2VyIiwiZm9yY2UiLCJ1YSIsImJyb3dzZXJzTGlzdCIsIl9yZWYiLCJkZXNjcmliZSIsImdldE1hdGNoIiwib3MiLCJvc1ZlcnNpb24iLCJnZXRPU1ZlcnNpb24iLCJleHAiLCJ2ZXJzaW9uJDEiLCJwcm90b2NvbFZlcnNpb24iLCJDcml0aWNhbFRpbWVycyIsInNldFRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFyVGltZW91dCIsImNsZWFySW50ZXJ2YWwiLCJCQUNLR1JPVU5EX1JFQUNUSU9OX0RFTEFZIiwicmVjeWNsZWRFbGVtZW50cyIsIlZpZGVvUXVhbGl0eSIsIlRyYWNrIiwic3RyZWFtU3RhdGUiLCJfc3RyZWFtU3RhdGUiLCJzZXRTdHJlYW1TdGF0ZSIsIm1lZGlhVHJhY2siLCJsb2dnZXJPcHRpb25zIiwiYXR0YWNoZWRFbGVtZW50cyIsImlzTXV0ZWQiLCJBY3RpdmUiLCJpc0luQmFja2dyb3VuZCIsIl9jdXJyZW50Qml0cmF0ZSIsImFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIiLCJiYWNrZ3JvdW5kVGltZW91dCIsInZpc2liaWxpdHlTdGF0ZSIsImhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkIiwibG9nZ2VyQ29udGV4dENiIiwiX21lZGlhU3RyZWFtVHJhY2siLCJfbWVkaWFTdHJlYW1JRCIsIlNvdXJjZSIsIlVua25vd24iLCJsb2dDb250ZXh0IiwiZ2V0TG9nQ29udGV4dEZyb21UcmFjayIsImN1cnJlbnRCaXRyYXRlIiwibWVkaWFTdHJlYW1UcmFjayIsIm1lZGlhU3RyZWFtSUQiLCJhdHRhY2giLCJlbGVtZW50IiwiZWxlbWVudFR5cGUiLCJLaW5kIiwiVmlkZW8iLCJhZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIiLCJwYXJlbnRFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImF0dGFjaFRvRWxlbWVudCIsImFsbE1lZGlhU3RyZWFtVHJhY2tzIiwic3JjT2JqZWN0IiwiaGFzQXVkaW8iLCJ0ciIsInBsYXkiLCJBdWRpb1BsYXliYWNrU3RhcnRlZCIsIlZpZGVvUGxheWJhY2tTdGFydGVkIiwiQXVkaW9QbGF5YmFja0ZhaWxlZCIsIlZpZGVvUGxheWJhY2tGYWlsZWQiLCJtdXRlZCIsIkVsZW1lbnRBdHRhY2hlZCIsImRldGFjaCIsImRldGFjaFRyYWNrIiwicmVjeWNsZUVsZW1lbnQiLCJFbGVtZW50RGV0YWNoZWQiLCJkZXRhY2hlZCIsImVsbSIsInJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInN0b3BNb25pdG9yIiwiZW5hYmxlIiwiZW5hYmxlZCIsImRpc2FibGUiLCJtb25pdG9ySW50ZXJ2YWwiLCJ0aW1lU3luY0hhbmRsZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlTG9nZ2VyT3B0aW9ucyIsIkhUTUxBdWRpb0VsZW1lbnQiLCJzaG91bGRDYWNoZSIsInBhdXNlIiwiZWwiLCJpc1dlYiIsIm1lZGlhU3RyZWFtIiwiZXhpc3RpbmdUcmFja3MiLCJldCIsImlzU2FmYXJpIiwiSFRNTFZpZGVvRWxlbWVudCIsImF1dG9wbGF5IiwicGxheXNJbmxpbmUiLCJpc0ZpcmVGb3giLCJTdHJlYW1TdGF0ZSQxIiwia2luZFRvUHJvdG8iLCJBdWRpbyIsIkFVRElPIiwiVklERU8iLCJEQVRBIiwia2luZEZyb21Qcm90byIsInNvdXJjZVRvUHJvdG8iLCJDYW1lcmEiLCJDQU1FUkEiLCJNaWNyb3Bob25lIiwiTUlDUk9QSE9ORSIsIlNjcmVlblNoYXJlIiwiU0NSRUVOX1NIQVJFIiwiU2NyZWVuU2hhcmVBdWRpbyIsIlNDUkVFTl9TSEFSRV9BVURJTyIsIlVOS05PV04iLCJzb3VyY2VGcm9tUHJvdG8iLCJzdHJlYW1TdGF0ZUZyb21Qcm90byIsIkFDVElWRSIsIlBBVVNFRCIsIlBhdXNlZCIsIlZpZGVvUHJlc2V0Iiwid2lkdGhPck9wdGlvbnMiLCJoZWlnaHQiLCJ3aWR0aCIsImFzcGVjdFJhdGlvIiwiZW5jb2RpbmciLCJyZXNvbHV0aW9uIiwiZnJhbWVSYXRlIiwiYXVkaW9Db2RlY3MiLCJiYWNrdXBWaWRlb0NvZGVjcyIsInZpZGVvQ29kZWNzIiwiaXNCYWNrdXBWaWRlb0NvZGVjIiwiYmFja3VwIiwiaXNCYWNrdXBDb2RlYyIsIkJhY2t1cENvZGVjUG9saWN5IiwiQXVkaW9QcmVzZXRzIiwidGVsZXBob25lIiwic3BlZWNoIiwibXVzaWMiLCJtdXNpY1N0ZXJlbyIsIm11c2ljSGlnaFF1YWxpdHkiLCJtdXNpY0hpZ2hRdWFsaXR5U3RlcmVvIiwiVmlkZW9QcmVzZXRzIiwiaDkwIiwiaDE4MCIsImgyMTYiLCJoMzYwIiwiaDU0MCIsImg3MjAiLCJoMTA4MCIsImgxNDQwIiwiaDIxNjAiLCJWaWRlb1ByZXNldHM0MyIsImgxMjAiLCJoMjQwIiwiaDQ4MCIsIlNjcmVlblNoYXJlUHJlc2V0cyIsImgzNjBmcHMzIiwiaDM2MGZwczE1IiwiaDcyMGZwczUiLCJoNzIwZnBzMTUiLCJoNzIwZnBzMzAiLCJoMTA4MGZwczE1IiwiaDEwODBmcHMzMCIsIm9yaWdpbmFsIiwic2VwYXJhdG9yIiwiZGRFeHRlbnNpb25VUkkiLCJ1bnBhY2tTdHJlYW1JZCIsInNsZWVwIiwiZHVyYXRpb24iLCJzdXBwb3J0c1RyYW5zY2VpdmVyIiwic3VwcG9ydHNBZGRUcmFjayIsInN1cHBvcnRzQWRhcHRpdmVTdHJlYW0iLCJSZXNpemVPYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwic3VwcG9ydHNEeW5hY2FzdCIsInN1cHBvcnRzQVYxIiwiY2FwYWJpbGl0aWVzIiwiZ2V0Q2FwYWJpbGl0aWVzIiwiaGFzQVYxIiwibWltZVR5cGUiLCJzdXBwb3J0c1ZQOSIsImNvbXBhcmVWZXJzaW9ucyIsImhhc1ZQOSIsImlzU1ZDQ29kZWMiLCJzdXBwb3J0c1NldFNpbmtJZCIsImlzU2FmYXJpQmFzZWQiLCJzdXBwb3J0c0F1ZGlvT3V0cHV0U2VsZWN0aW9uIiwiaXNCcm93c2VyU3VwcG9ydGVkIiwiaXNDaHJvbWl1bUJhc2VkIiwiaXNTYWZhcmkxN0Jhc2VkIiwiaXNTYWZhcmlTdmNBcGkiLCJpc01vYmlsZSIsIm1vYmlsZSIsImlzRTJFRVNpbXVsY2FzdFN1cHBvcnRlZCIsInN1cHBvcnRlZFNhZmFyaVZlcnNpb24iLCJpc1JlYWN0TmF0aXZlIiwicHJvZHVjdCIsImlzQ2xvdWQiLCJzZXJ2ZXJVcmwiLCJob3N0bmFtZSIsImV4dHJhY3RQcm9qZWN0RnJvbVVybCIsImdldExLUmVhY3ROYXRpdmVJbmZvIiwiZ2xvYmFsIiwiTGl2ZUtpdFJlYWN0TmF0aXZlR2xvYmFsIiwiZ2V0UmVhY3ROYXRpdmVPcyIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJ2MSIsInYyIiwicGFydHMxIiwicGFydHMyIiwicDEiLCJwMiIsInJvRGlzcGF0Y2hDYWxsYmFjayIsImVudHJ5IiwiaGFuZGxlUmVzaXplIiwiaW9EaXNwYXRjaENhbGxiYWNrIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQiLCJyZXNpemVPYnNlcnZlciIsImdldFJlc2l6ZU9ic2VydmVyIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJnZXRJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3RNYXJnaW4iLCJnZXRDbGllbnRJbmZvIiwic2RrIiwiSlMiLCJlbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2siLCJwYWludENvbnRlbnQiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsImZpbGwiLCJkdW1teVN0cmVhbSIsImNhcHR1cmVTdHJlYW0iLCJkdW1teVRyYWNrIiwiZW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwiZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwib3NjaWxsYXRvciIsImNyZWF0ZU9zY2lsbGF0b3IiLCJnYWluIiwiY3JlYXRlR2FpbiIsInNldFZhbHVlQXRUaW1lIiwiZHN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsImNvbm5lY3QiLCJGdXR1cmUiLCJpc1Jlc29sdmVkIiwiX2lzUmVzb2x2ZWQiLCJmdXR1cmVCYXNlIiwib25GaW5hbGx5IiwiY3JlYXRlQXVkaW9BbmFseXNlciIsImNsb25lVHJhY2siLCJmZnRTaXplIiwic21vb3RoaW5nVGltZUNvbnN0YW50IiwibWluRGVjaWJlbHMiLCJtYXhEZWNpYmVscyIsImF1ZGlvQ29udGV4dCIsImdldE5ld0F1ZGlvQ29udGV4dCIsInN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1Tb3VyY2UiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsImFuYWx5c2VyIiwiY3JlYXRlQW5hbHlzZXIiLCJkYXRhQXJyYXkiLCJmcmVxdWVuY3lCaW5Db3VudCIsImNhbGN1bGF0ZVZvbHVtZSIsImdldEJ5dGVGcmVxdWVuY3lEYXRhIiwic3VtIiwiYW1wbGl0dWRlIiwicG93Iiwidm9sdW1lIiwic3FydCIsImNsZWFudXAiLCJjbG9zZSIsImlzQXVkaW9Db2RlYyIsIm1heWJlQ29kZWMiLCJpc1ZpZGVvQ29kZWMiLCJ1bndyYXBDb25zdHJhaW50IiwidG9XZWJzb2NrZXRVcmwiLCJ0b0h0dHBVcmwiLCJleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzIiwidHJhbnNjcmlwdGlvbiIsImZpcnN0UmVjZWl2ZWRUaW1lc01hcCIsInNlZ21lbnRzIiwidGV4dCIsImxhbmd1YWdlIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImZpbmFsIiwiZmlyc3RSZWNlaXZlZFRpbWUiLCJsYXN0UmVjZWl2ZWRUaW1lIiwiZXh0cmFjdENoYXRNZXNzYWdlIiwidGltZXN0YW1wIiwiZWRpdFRpbWVzdGFtcCIsImdldERpc2Nvbm5lY3RSZWFzb25Gcm9tQ29ubmVjdGlvbkVycm9yIiwiQ2FuY2VsbGVkIiwiQ0xJRU5UX0lOSVRJQVRFRCIsIk5vdEFsbG93ZWQiLCJVU0VSX1JFSkVDVEVEIiwiU2VydmVyVW5yZWFjaGFibGUiLCJKT0lOX0ZBSUxVUkUiLCJVTktOT1dOX1JFQVNPTiIsImJpZ0ludFRvTnVtYmVyIiwibnVtYmVyVG9CaWdJbnQiLCJpc0xvY2FsVHJhY2siLCJpc0F1ZGlvVHJhY2siLCJpc1ZpZGVvVHJhY2siLCJpc0xvY2FsVmlkZW9UcmFjayIsImlzTG9jYWxBdWRpb1RyYWNrIiwiaXNSZW1vdGVUcmFjayIsImlzUmVtb3RlUHViIiwicHViIiwiaXNSZW1vdGVWaWRlb1RyYWNrIiwiaXNMb2NhbFBhcnRpY2lwYW50IiwiaXNSZW1vdGVQYXJ0aWNpcGFudCIsInNwbGl0VXRmOCIsImVuY29kZWQiLCJleHRyYWN0TWF4QWdlRnJvbVJlcXVlc3RIZWFkZXJzIiwiaGVhZGVycyIsImNhY2hlQ29udHJvbCIsIm1heEFnZSIsIm1lcmdlRGVmYXVsdE9wdGlvbnMiLCJhdWRpb0RlZmF1bHRzIiwidmlkZW9EZWZhdWx0cyIsIm9wdGlvbnNXaXRob3V0UHJvY2Vzc29yIiwiYXVkaW9Qcm9jZXNzb3IiLCJ2aWRlb1Byb2Nlc3NvciIsImV4dHJhY3RQcm9jZXNzb3JzRnJvbU9wdGlvbnMiLCJkZWZhdWx0QXVkaW9Qcm9jZXNzb3IiLCJwcm9jZXNzb3IiLCJkZWZhdWx0VmlkZW9Qcm9jZXNzb3IiLCJjbG9uZWRPcHRpb25zIiwibWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmciLCJtYWluT2JqZWN0Iiwib2JqZWN0VG9NZXJnZSIsImNvbnN0cmFpbnRzRm9yT3B0aW9ucyIsInZpZGVvT3B0aW9ucyIsImRldGVjdFNpbGVuY2UiLCJ0cmFja18xIiwidGltZU9mZnNldCIsImJ1ZmZlckxlbmd0aCIsImdldEJ5dGVUaW1lRG9tYWluRGF0YSIsInNvbWVOb2lzZSIsInNhbXBsZSIsImxhdGVuY3lIaW50IiwiYm9keSIsImhhbmRsZVJlc3VtZSIsInJlc3VtZSIsImtpbmRUb1NvdXJjZSIsInNvdXJjZVRvS2luZCIsInNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwiY29udHJvbGxlciIsInNlbGZCcm93c2VyU3VyZmFjZSIsInN1cmZhY2VTd2l0Y2hpbmciLCJzeXN0ZW1BdWRpbyIsInByZWZlckN1cnJlbnRUYWIiLCJtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyIsImdldFRyYWNrUHVibGljYXRpb25JbmZvIiwiaW5mb3MiLCJjaWQiLCJ0cmFja0luZm8iLCJ0cmFja0lEIiwic2lkIiwic3RyZWFtSUQiLCJzdHJlYW1UcmFja0lEIiwidHJhY2tTaWQiLCJpc0VuYWJsZWQiLCJ0cmFja05hbWUiLCJlbmNyeXB0ZWQiLCJpc0VuY3J5cHRlZCIsInN1cHBvcnRzU3luY2hyb25pemF0aW9uU291cmNlcyIsImRpZmZBdHRyaWJ1dGVzIiwib2xkVmFsdWVzIiwibmV3VmFsdWVzIiwiYWxsS2V5cyIsImRpZmYiLCJuZXdPcHRpb25zIiwiZ2V0VHJhY2tTb3VyY2VGcm9tUHJvdG8iLCJhcmVEaW1lbnNpb25zU21hbGxlciIsImxheWVyRGltZW5zaW9uc0ZvciIsInF1YWxpdHkiLCJsYXllcnMiLCJFMkVFTWFuYWdlciIsImRjRW5jcnlwdGlvbkVuYWJsZWQiLCJkZWNyeXB0RGF0YVJlcXVlc3RzIiwiZW5jcnlwdERhdGFSZXF1ZXN0cyIsIm9uV29ya2VyTWVzc2FnZSIsImV2IiwidXVpZCIsImRlY3J5cHRGdXR1cmUiLCJlbmNyeXB0RnV0dXJlIiwiRW5jcnlwdGlvbkVycm9yIiwia2V5UHJvdmlkZXIiLCJwb3N0S2V5IiwiZW5jcnlwdGlvbkVuYWJsZWQiLCJyb29tIiwibG9jYWxQYXJ0aWNpcGFudCIsImlkZW50aXR5IiwiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCIsInBhcnRpY2lwYW50IiwiZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5Iiwib25Xb3JrZXJFcnJvciIsIndvcmtlciIsImRhdGFDaGFubmVsRW5jcnlwdGlvbkVuYWJsZWQiLCJpc0RhdGFDaGFubmVsRW5jcnlwdGlvbkVuYWJsZWQiLCJzZXR1cCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJrZXlQcm92aWRlck9wdGlvbnMiLCJvbm1lc3NhZ2UiLCJvbmVycm9yIiwicG9zdE1lc3NhZ2UiLCJzZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkIiwicG9zdEVuYWJsZSIsInNldFNpZlRyYWlsZXIiLCJ0cmFpbGVyIiwicG9zdFNpZlRyYWlsZXIiLCJzZXR1cEVuZ2luZSIsImVuZ2luZSIsIlJUUFZpZGVvTWFwVXBkYXRlIiwicnRwTWFwIiwicG9zdFJUUE1hcCIsIlRyYWNrUHVibGlzaGVkIiwiZW5jcnlwdGlvbiIsIk5PTkUiLCJDb25uZWN0aW9uU3RhdGVDaGFuZ2VkIiwiQ29ubmVjdGlvblN0YXRlIiwiQ29ubmVjdGVkIiwicmVtb3RlUGFydGljaXBhbnRzIiwidHJhY2tQdWJsaWNhdGlvbnMiLCJUcmFja1Vuc3Vic2NyaWJlZCIsInNldHVwRTJFRVJlY2VpdmVyIiwiU2lnbmFsQ29ubmVjdGVkIiwiaXNFMkVFRW5hYmxlZCIsIkxvY2FsU2VuZGVyQ3JlYXRlZCIsInNldHVwRTJFRVNlbmRlciIsIkxvY2FsVHJhY2tQdWJsaXNoZWQiLCJwdWJsaWNhdGlvbiIsInBvc3RSYXRjaGV0UmVxdWVzdCIsImVuY3J5cHREYXRhIiwicmFuZG9tVVVJRCIsInBheWxvYWQiLCJmdXR1cmUiLCJoYW5kbGVFbmNyeXB0ZWREYXRhIiwiaXYiLCJpc1B1Ymxpc2hlciIsImVuYWJsZU1zZyIsIlJlZmVyZW5jZUVycm9yIiwicmVtb3RlSWQiLCJoYW5kbGVSZWNlaXZlciIsImhhbmRsZVNlbmRlciIsInRyYW5zZm9ybSIsIndyaXRhYmxlU3RyZWFtIiwicmVhZGFibGUiLCJyZWFkYWJsZVN0cmVhbSIsInJlY2VpdmVyU3RyZWFtcyIsImlzUmV1c2UiLCJzZW5kZXJTdHJlYW1zIiwiQ09OTkVDVElPTl9CQUNLT0ZGX01JTl9NUyIsIkNPTk5FQ1RJT05fQkFDS09GRl9NQVhfTVMiLCJCYWNrT2ZmU3RyYXRlZ3kiLCJmYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHMiLCJiYWNrT2ZmUHJvbWlzZXMiLCJnZXRJbnN0YW5jZSIsIl9pbnN0YW5jZSIsImFkZEZhaWxlZENvbm5lY3Rpb25BdHRlbXB0IiwidXJsU3RyaW5nIiwiVVJMIiwicHJvamVjdE5hbWUiLCJmYWlsdXJlQ291bnQiLCJnZXRCYWNrT2ZmUHJvbWlzZSIsImJhY2tvZmZQcm9taXNlIiwicmVzZXRGYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHMiLCJyZXNldEFsbCIsImNsZWFyIiwiZGVmYXVsdElkIiwiRGV2aWNlTWFuYWdlciIsIl9wcmV2aW91c0RldmljZXMiLCJpbnN0YW5jZSIsInByZXZpb3VzRGV2aWNlcyIsImdldERldmljZXMiLCJraW5kXzEiLCJfdGhpcyIsInJlcXVlc3RQZXJtaXNzaW9ucyIsInVzZXJNZWRpYVByb21pc2VNYXAiLCJoYXNEZXZpY2VJblVzZSIsImlzRHVtbXlEZXZpY2VPckVtcHR5IiwiZGV2aWNlIiwibm9MYWJlbCIsImlzUmVsZXZhbnQiLCJwZXJtaXNzaW9uc1RvQWNxdWlyZSIsIm5vcm1hbGl6ZURldmljZUlkIiwiZ3JvdXBJZCIsImRlZmF1bHREZXZpY2UiLCJtZWRpYURldmljZUtpbmRzIiwiUXVldWVUYXNrU3RhdHVzIiwiQXN5bmNRdWV1ZSIsInBlbmRpbmdUYXNrcyIsInRhc2tNdXRleCIsIm5leHRUYXNrSW5kZXgiLCJydW4iLCJ0YXNrIiwidGFza0luZm8iLCJlbnF1ZXVlZEF0IiwiV0FJVElORyIsInVubG9jayIsImV4ZWN1dGVkQXQiLCJSVU5OSU5HIiwiQ09NUExFVEVEIiwiZmx1c2giLCJzbmFwc2hvdCIsIldlYlNvY2tldFN0cmVhbSIsIndzIiwic2lnbmFsIiwiYWJvcnRlZCIsIldlYlNvY2tldCIsInByb3RvY29scyIsImJpbmFyeVR5cGUiLCJjbG9zZVdpdGhJbmZvIiwiY2xvc2VDb2RlIiwib3BlbmVkIiwib25vcGVuIiwiUmVhZGFibGVTdHJlYW0iLCJlbnF1ZXVlIiwiY2FuY2VsIiwiV3JpdGFibGVTdHJlYW0iLCJ3cml0ZSIsImFib3J0IiwiZXh0ZW5zaW9ucyIsImNsb3NlZCIsInJlamVjdEhhbmRsZXIiLCJjbG9zZVByb21pc2UiLCJyZXMiLCJDTE9TRUQiLCJjbG9zZUV2IiwicmFjZSIsIm9uY2xvc2UiLCJfcmVmMiIsIm9uYWJvcnQiLCJjcmVhdGVSdGNVcmwiLCJzZWFyY2hQYXJhbXMiLCJ1cmxPYmoiLCJhcHBlbmRVcmxQYXRoIiwiY3JlYXRlVmFsaWRhdGVVcmwiLCJydGNXc1VybCIsImVuc3VyZVRyYWlsaW5nU2xhc2giLCJwYXRoIiwicGF0aG5hbWUiLCJwYXJzZVNpZ25hbFJlc3BvbnNlIiwiZ2V0QWJvcnRSZWFzb25Bc1N0cmluZyIsImRlZmF1bHRNZXNzYWdlIiwiQWJvcnRTaWduYWwiLCJwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyIsImNhblBhc3NUaHJvdWdoUXVldWUiLCJjYW5QYXNzIiwiU2lnbmFsQ29ubmVjdGlvblN0YXRlIiwiTUFYX1dTX0NMT1NFX1RJTUUiLCJTaWduYWxDbGllbnQiLCJjdXJyZW50U3RhdGUiLCJpc0Rpc2Nvbm5lY3RlZCIsIkRJU0NPTk5FQ1RJTkciLCJESVNDT05ORUNURUQiLCJpc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24iLCJDT05ORUNUSU5HIiwiUkVDT05ORUNUSU5HIiwiZ2V0TmV4dFJlcXVlc3RJZCIsIl9yZXF1ZXN0SWQiLCJ1c2VKU09OIiwicnR0IiwicmVzZXRDYWxsYmFja3MiLCJvbkFuc3dlciIsIm9uTGVhdmUiLCJvbkxvY2FsVHJhY2tQdWJsaXNoZWQiLCJvbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsIm9uTmVnb3RpYXRlUmVxdWVzdGVkIiwib25PZmZlciIsIm9uUmVtb3RlTXV0ZUNoYW5nZWQiLCJvblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIiwib25Ub2tlblJlZnJlc2giLCJvblRyaWNrbGUiLCJvbkNsb3NlIiwib25NZWRpYVNlY3Rpb25zUmVxdWlyZW1lbnQiLCJTaWduYWwiLCJyZXF1ZXN0UXVldWUiLCJxdWV1ZWRSZXF1ZXN0cyIsImNsb3NpbmdMb2NrIiwiY29ubmVjdGlvbkxvY2siLCJ0b2tlbiIsImFib3J0U2lnbmFsIiwicmVjb25uZWN0IiwiY2xlYXJQaW5nSW50ZXJ2YWwiLCJyZWNvbm5lY3RSZWFzb24iLCJjb25uZWN0T3B0aW9ucyIsImNsaWVudEluZm8iLCJzaW5nbGVQZWVyQ29ubmVjdGlvbiIsImNyZWF0ZUpvaW5SZXF1ZXN0Q29ubmVjdGlvblBhcmFtcyIsImNyZWF0ZUNvbm5lY3Rpb25QYXJhbXMiLCJydGNVcmwiLCJ2YWxpZGF0ZVVybCIsImFscmVhZHlBYm9ydGVkIiwiYWJvcnRIYW5kbGVyIiwiZXZlbnRPckVycm9yIiwiY3VycmVudFRhcmdldCIsInN0cmVhbVdyaXRlciIsInNlbmRMZWF2ZSIsImNsZWFudXBBYm9ydEhhbmRsZXJzIiwid3NUaW1lb3V0Iiwid2Vic29ja2V0VGltZW91dCIsImhhbmRsZVNpZ25hbENvbm5lY3RlZCIsImNvbm5lY3Rpb24iLCJmaXJzdE1lc3NhZ2UiLCJyZWRhY3RlZFVybCIsImNsb3NlSW5mbyIsIndhc0NsZWFuIiwiQ09OTkVDVEVEIiwiaGFuZGxlT25DbG9zZSIsImhhbmRsZUNvbm5lY3Rpb25FcnJvciIsImhhbmRsZVdTRXJyb3IiLCJzaWduYWxSZWFkZXIiLCJnZXRSZWFkZXIiLCJnZXRXcml0ZXIiLCJyZWxlYXNlTG9jayIsImZpcnN0U2lnbmFsUmVzcG9uc2UiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVGaXJzdE1lc3NhZ2UiLCJpc1ZhbGlkIiwicGluZ1RpbWVvdXREdXJhdGlvbiIsInBpbmdUaW1lb3V0IiwicGluZ0ludGVydmFsRHVyYXRpb24iLCJwaW5nSW50ZXJ2YWwiLCJ0aW1lb3V0IiwiaW50ZXJ2YWwiLCJmaXJzdE1lc3NhZ2VUb1Byb2Nlc3MiLCJzaG91bGRQcm9jZXNzRmlyc3RNZXNzYWdlIiwicmVzcG9uc2UiLCJzdGFydFJlYWRpbmdMb29wIiwiaGFuZGxlU2lnbmFsUmVzcG9uc2UiLCJzaWduYWxMYXRlbmN5IiwicmVzcCIsInVwZGF0ZVN0YXRlIiwic2VuZE9mZmVyIiwib2ZmZXIiLCJvZmZlcklkIiwib2ZmZXJTZHAiLCJzZW5kUmVxdWVzdCIsInRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24iLCJzZW5kQW5zd2VyIiwiYW5zd2VyIiwiYW5zd2VyU2RwIiwic2VuZEljZUNhbmRpZGF0ZSIsImNhbmRpZGF0ZUluaXQiLCJzZW5kTXV0ZVRyYWNrIiwic2VuZEFkZFRyYWNrIiwic2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEiLCJtZXRhZGF0YV8xIiwibmFtZV8xIiwibWV0YWRhdGEiLCJfdGhpczIiLCJyZXF1ZXN0SWQiLCJzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyIsInNldHRpbmdzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvbiIsInN1YiIsInNlbmRTeW5jU3RhdGUiLCJzeW5jIiwic2VuZFVwZGF0ZVZpZGVvTGF5ZXJzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwiYWxsUGFydGljaXBhbnRzIiwidHJhY2tQZXJtaXNzaW9ucyIsInNlbmRTaW11bGF0ZVNjZW5hcmlvIiwic2NlbmFyaW8iLCJzZW5kUGluZyIsInNlbmRVcGRhdGVMb2NhbEF1ZGlvVHJhY2siLCJmZWF0dXJlcyIsImFjdGlvbiIsIkRJU0NPTk5FQ1QiLCJtZXNzYWdlXzEiLCJfdGhpczMiLCJmcm9tUXVldWUiLCJjYW5RdWV1ZSIsInBpbmdIYW5kbGVkIiwic2QiLCJmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24iLCJtaWRUb1RyYWNrSWQiLCJvblBhcnRpY2lwYW50VXBkYXRlIiwicGFydGljaXBhbnRzIiwib25TcGVha2Vyc0NoYW5nZWQiLCJzcGVha2VycyIsIm9uUm9vbVVwZGF0ZSIsIm9uQ29ubmVjdGlvblF1YWxpdHkiLCJvblN0cmVhbVN0YXRlVXBkYXRlIiwib25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIiwib25TdWJzY3JpcHRpb25FcnJvciIsImxhc3RQaW5nVGltZXN0YW1wIiwicmVzZXRQaW5nVGltZW91dCIsIm9uUmVxdWVzdFJlc3BvbnNlIiwib25Mb2NhbFRyYWNrU3Vic2NyaWJlZCIsIm9uUm9vbU1vdmVkIiwibXNnQ2FzZSIsInNldFJlY29ubmVjdGVkIiwib25DbG9zZUNhbGxiYWNrIiwiY2xlYXJQaW5nVGltZW91dCIsInRvVVRDU3RyaW5nIiwic3RhcnRQaW5nSW50ZXJ2YWwiLCJ0aW1lb3V0SGFuZGxlIiwiaXNSZWNvbm5lY3QiLCJmZXRjaCIsInRvRml4ZWQiLCJyc2QiLCJVUkxTZWFyY2hQYXJhbXMiLCJhdXRvU3Vic2NyaWJlIiwiZGV2aWNlTW9kZWwiLCJicm93c2VyVmVyc2lvbiIsImFkYXB0aXZlU3RyZWFtIiwiam9pblJlcXVlc3QiLCJjb25uZWN0aW9uU2V0dGluZ3MiLCJwYXJ0aWNpcGFudFNpZCIsIndyYXBwZWRKb2luUmVxdWVzdCIsImJ0b2EiLCJEYXRhUGFja2V0QnVmZmVyIiwiX3RvdGFsU2l6ZSIsImdldEFsbCIsInBvcFRvU2VxdWVuY2UiLCJzZXF1ZW5jZSIsImZpcnN0IiwiYWxpZ25CdWZmZXJlZEFtb3VudCIsImJ1ZmZlcmVkQW1vdW50IiwiVFRMTWFwIiwidHRsIiwiX21hcCIsIl9sYXN0Q2xlYW51cCIsImV4cGlyZXNBdCIsImNhbGxiYWNrIiwiYXNWYWx1ZU1hcCIsInZhbHVlTWFwIiwibGliIiwicGFyc2VyIiwiZ3JhbW1hciIsImhhc1JlcXVpcmVkR3JhbW1hciIsInJlcXVpcmVHcmFtbWFyIiwiZ3JhbW1hciQxIiwicmVnIiwidSIsInJhdGUiLCJzdWJ0eXBlIiwiY29uZmlnIiwic2Vzc2lvbkNvbmZpZyIsInN0ciIsInJhZGRyIiwidGNwdHlwZSIsImdlbmVyYXRpb24iLCJkaXIyIiwiY2xrc3JjRXh0IiwibWVkaWFDbG9ja1ZhbHVlIiwicmF0ZU51bWVyYXRvciIsInJhdGVEZW5vbWluYXRvciIsIm9ianMiLCJoYXNSZXF1aXJlZFBhcnNlciIsInJlcXVpcmVQYXJzZXIiLCJleHBvcnRzJDEiLCJ0b0ludElmSW50IiwiYXR0YWNoUHJvcGVydGllcyIsInJhd05hbWUiLCJwYXJzZVJlZyIsImNvbnRlbnQiLCJuZWVkc0JsYW5rIiwia2V5TG9jYXRpb24iLCJ2YWxpZExpbmUiLCJzZXNzaW9uIiwicnRwIiwiZm10cCIsInBhcmFtUmVkdWNlciIsImFjYyIsInBhcnNlUGFyYW1zIiwicGFyc2VGbXRwQ29uZmlnIiwicGFyc2VQYXlsb2FkcyIsInBhcnNlUmVtb3RlQ2FuZGlkYXRlcyIsImNhbmRpZGF0ZXMiLCJwYXJzZUltYWdlQXR0cmlidXRlcyIsInBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCIsInNjaWQiLCJwYXVzZWQiLCJoYXNSZXF1aXJlZFdyaXRlciIsInJlcXVpcmVXcml0ZXIiLCJmb3JtYXRSZWdFeHAiLCJmb3JtYXRTdHIiLCJtYWtlTGluZSIsImRlZmF1bHRPdXRlck9yZGVyIiwiZGVmYXVsdElubmVyT3JkZXIiLCJwYXlsb2FkcyIsIm91dGVyT3JkZXIiLCJpbm5lck9yZGVyIiwiaGFzUmVxdWlyZWRMaWIiLCJyZXF1aXJlTGliIiwibGliRXhwb3J0cyIsImlzSW1tZWRpYXRlIiwibWF4V2FpdCIsInN0YXJ0Qml0cmF0ZUZvclNWQyIsImRlYm91bmNlSW50ZXJ2YWwiLCJQQ0V2ZW50cyIsIk5lZ290aWF0aW9uU3RhcnRlZCIsIk5lZ290aWF0aW9uQ29tcGxldGUiLCJSVFBWaWRlb1BheWxvYWRUeXBlcyIsIlBDVHJhbnNwb3J0IiwiY3JlYXRlUEMiLCJkZEV4dElEIiwibGF0ZXN0T2ZmZXJJZCIsInBlbmRpbmdDYW5kaWRhdGVzIiwicmVzdGFydGluZ0ljZSIsInJlbmVnb3RpYXRlIiwidHJhY2tCaXRyYXRlcyIsInJlbW90ZVN0ZXJlb01pZHMiLCJyZW1vdGVOYWNrTWlkcyIsIm5lZ290aWF0ZSIsImNyZWF0ZUFuZFNlbmRPZmZlciIsIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlIiwib25kYXRhY2hhbm5lbCIsIm9ubmVnb3RpYXRpb25uZWVkZWQiLCJvbnNpZ25hbGluZ3N0YXRlY2hhbmdlIiwib25pY2VjYW5kaWRhdGUiLCJvbnRyYWNrIiwib2ZmZXJMb2NrIiwib25JY2VDYW5kaWRhdGUiLCJvbmljZWNhbmRpZGF0ZWVycm9yIiwib25JY2VDYW5kaWRhdGVFcnJvciIsIm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwib25TaWduYWxpbmdTdGF0ZWNoYW5nZSIsIm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwib25EYXRhQ2hhbm5lbCIsIm9uVHJhY2siLCJpc0lDRUNvbm5lY3RlZCIsInJlbW90ZURlc2NyaXB0aW9uIiwibXVuZ2VkU0RQIiwic3RlcmVvTWlkcyIsIm5hY2tNaWRzIiwiZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlciIsInNkcFBhcnNlZCIsImdldE1pZFN0cmluZyIsInRyYWNrYnIiLCJjb2RlY1BheWxvYWQiLCJmbXRwRm91bmQiLCJhdHRyIiwibWF4YnIiLCJzZXRNdW5nZWRTRFAiLCJpY2VSZXN0YXJ0IiwiY3VycmVudFNEIiwiZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uIiwiZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvIiwibXNpZCIsImVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMiLCJzdGFydEJpdHJhdGUiLCJyb3VuZCIsImNyZWF0ZUFuZFNldEFuc3dlciIsImRhdGFDaGFubmVsRGljdCIsInRyYW5zY2VpdmVySW5pdCIsImFkZFRyYW5zY2VpdmVyT2ZLaW5kIiwic2V0VHJhY2tDb2RlY0JpdHJhdGUiLCJzZXRDb25maWd1cmF0aW9uIiwicnRjQ29uZmlnIiwiY2FuUmVtb3ZlVHJhY2siLCJnZXRDb25uZWN0aW9uU3RhdGUiLCJnZXRJQ0VDb25uZWN0aW9uU3RhdGUiLCJnZXRTaWduYWxsaW5nU3RhdGUiLCJnZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImdldFJlbW90ZURlc2NyaXB0aW9uIiwiZ2V0Q29ubmVjdGVkQWRkcmVzcyIsInNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkIiwiY2FuZGlkYXRlUGFpcnMiLCJzZWxlY3RlZCIsInNlbGVjdGVkSUQiLCJyZW1vdGVDYW5kaWRhdGVJZCIsIm11bmdlZCIsInJlbW90ZSIsIm9yaWdpbmFsU2RwIiwicmVtb3RlU2RwIiwiZGRGb3VuZCIsIm1heElEIiwib3B1c1BheWxvYWQiLCJydGNwRmIiLCJpc1Y2IiwiZGVmYXVsdFZpZGVvQ29kZWMiLCJwdWJsaXNoRGVmYXVsdHMiLCJhdWRpb1ByZXNldCIsImR0eCIsInJlZCIsImZvcmNlU3RlcmVvIiwic2ltdWxjYXN0Iiwic2NyZWVuU2hhcmVFbmNvZGluZyIsInN0b3BNaWNUcmFja09uTXV0ZSIsInZpZGVvQ29kZWMiLCJiYWNrdXBDb2RlYyIsInByZUNvbm5lY3RCdWZmZXIiLCJhdXRvR2FpbkNvbnRyb2wiLCJlY2hvQ2FuY2VsbGF0aW9uIiwibm9pc2VTdXBwcmVzc2lvbiIsInZvaWNlSXNvbGF0aW9uIiwicm9vbU9wdGlvbkRlZmF1bHRzIiwiZHluYWNhc3QiLCJzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoIiwicmVjb25uZWN0UG9saWN5IiwiZGlzY29ubmVjdE9uUGFnZUxlYXZlIiwid2ViQXVkaW9NaXgiLCJyb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzIiwibWF4UmV0cmllcyIsInBlZXJDb25uZWN0aW9uVGltZW91dCIsIlBDVHJhbnNwb3J0U3RhdGUiLCJQQ1RyYW5zcG9ydE1hbmFnZXIiLCJuZWVkc1B1Ymxpc2hlciIsImlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkIiwibmVlZHNTdWJzY3JpYmVyIiwiaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkIiwibW9kZSIsInByZXZpb3VzU3RhdGUiLCJjb25uZWN0aW9uU3RhdGVzIiwicmVxdWlyZWRUcmFuc3BvcnRzIiwic3QiLCJGQUlMRUQiLCJDTE9TSU5HIiwiTkVXIiwib25TdGF0ZUNoYW5nZSIsInB1Ymxpc2hlciIsInN1YnNjcmliZXIiLCJQQ01hbmFnZXIiLCJTVUJTQ1JJQkVSIiwiUFVCTElTSEVSIiwib25QdWJsaXNoZXJPZmZlciIsInJlbW90ZU9mZmVyTG9jayIsInJlcXVpcmVQdWJsaXNoZXIiLCJyZXF1aXJlIiwiY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyIiwic2V0UHVibGlzaGVyQW5zd2VyIiwidHJpZ2dlckljZVJlc3RhcnQiLCJjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyIiwiUlRDU2RwVHlwZSIsInN1Y2Nlc3MiLCJ1cGRhdGVDb25maWd1cmF0aW9uIiwiZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uIiwiYWJvcnRDb250cm9sbGVyIiwidHJhbnNwb3J0IiwiZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkIiwibmVnb3RpYXRpb25UaW1lb3V0IiwiYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIiLCJhZGRQdWJsaXNoZXJUcmFuc2NlaXZlck9mS2luZCIsImdldE1pZEZvclJlY2VpdmVyIiwidHJhbnNjZWl2ZXJzIiwibWF0Y2hpbmdUcmFuc2NlaXZlciIsImFkZFB1Ymxpc2hlclRyYWNrIiwiY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwiLCJ0cmFuc3BvcnRzIiwicGNUcmFuc3BvcnRfMSIsImFib3J0Q29udHJvbGxlcl8xIiwicGNUcmFuc3BvcnQiLCJjb25uZWN0VGltZW91dCIsIkRFRkFVTFRfTUFYX0FHRV9NUyIsIlNUT1BfUkVGRVRDSF9ERUxBWV9NUyIsIlJlZ2lvblVybFByb3ZpZGVyIiwiZmV0Y2hSZWdpb25TZXR0aW5ncyIsImZldGNoTG9jayIsInJlZ2lvblNldHRpbmdzUmVzcG9uc2UiLCJnZXRDbG91ZENvbmZpZ1VybCIsImF1dGhvcml6YXRpb24iLCJtYXhBZ2VJbk1zIiwicmVnaW9uU2V0dGluZ3MiLCJ1cGRhdGVkQXRJbk1zIiwic3RhdHVzVGV4dCIsInNjaGVkdWxlUmVmZXRjaCIsInNldHRpbmdzVGltZW91dHMiLCJuZXdTZXR0aW5ncyIsInVwZGF0ZUNhY2hlZFJlZ2lvblNldHRpbmdzIiwiY2FjaGUiLCJzdG9wUmVmZXRjaCIsInNjaGVkdWxlQ2xlYW51cCIsInRyYWNrZXIiLCJjb25uZWN0aW9uVHJhY2tlcnMiLCJjbGVhbnVwVGltZW91dCIsImN1cnJlbnRUcmFja2VyIiwiY29ubmVjdGlvbkNvdW50IiwiY2FuY2VsQ2xlYW51cCIsIm5vdGlmeUNvbm5lY3RlZCIsIm5vdGlmeURpc2Nvbm5lY3RlZCIsImF0dGVtcHRlZFJlZ2lvbnMiLCJ1cGRhdGVUb2tlbiIsImdldFNlcnZlclVybCIsImdldE5leHRCZXN0UmVnaW9uVXJsIiwiY2FjaGVkU2V0dGluZ3MiLCJyZWdpb25zTGVmdCIsInJlZ2lvbnMiLCJyZWdpb24iLCJhdHRlbXB0ZWQiLCJuZXh0UmVnaW9uIiwicmVzZXRBdHRlbXB0cyIsInNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyIsImhvc3QiLCJScGNFcnJvciIsInRydW5jYXRlQnl0ZXMiLCJNQVhfTUVTU0FHRV9CWVRFUyIsIk1BWF9EQVRBX0JZVEVTIiwiZnJvbVByb3RvIiwidG9Qcm90byIsImJ1aWx0SW4iLCJFcnJvckNvZGUiLCJFcnJvck1lc3NhZ2UiLCJBUFBMSUNBVElPTl9FUlJPUiIsIkNPTk5FQ1RJT05fVElNRU9VVCIsIlJFU1BPTlNFX1RJTUVPVVQiLCJSRUNJUElFTlRfRElTQ09OTkVDVEVEIiwiUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0UiLCJTRU5EX0ZBSUxFRCIsIlVOU1VQUE9SVEVEX01FVEhPRCIsIlJFQ0lQSUVOVF9OT1RfRk9VTkQiLCJSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFIiwiVU5TVVBQT1JURURfU0VSVkVSIiwiVU5TVVBQT1JURURfVkVSU0lPTiIsIk1BWF9QQVlMT0FEX0JZVEVTIiwiZW5jb2RlciIsIm1heEJ5dGVzIiwibW9uaXRvckZyZXF1ZW5jeSIsImNvbXB1dGVCaXRyYXRlIiwiY3VycmVudFN0YXRzIiwicHJldlN0YXRzIiwiYnl0ZXNOb3ciLCJieXRlc1ByZXYiLCJieXRlc1JlY2VpdmVkIiwiYnl0ZXNTZW50IiwiaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlIiwiTWVkaWFSZWNvcmRlciIsIkZhbGxiYWNrUmVjb3JkZXIiLCJSZWNvcmRlckJhc2UiLCJMb2NhbFRyYWNrUmVjb3JkZXIiLCJkYXRhTGlzdGVuZXIiLCJzdHJlYW1Db250cm9sbGVyIiwiaXNDbG9zZWQiLCJvblN0b3AiLCJieXRlU3RyZWFtIiwiYXJyYXlCdWZmZXIiLCJieXRlQXJyYXkiLCJpc1JlY29yZGluZ1N1cHBvcnRlZCIsIkRFRkFVTFRfRElNRU5TSU9OU19USU1FT1VUIiwiUFJFX0NPTk5FQ1RfQlVGRkVSX1RJTUVPVVQiLCJMb2NhbFRyYWNrIiwiX3NlbmRlciIsIl9jb25zdHJhaW50cyIsImhhc1ByZUNvbm5lY3RCdWZmZXIiLCJsb2NhbFRyYWNrUmVjb3JkZXIiLCJ1c2VyUHJvdmlkZWRUcmFjayIsIm1hbnVhbGx5U3RvcHBlZCIsIl9pc1Vwc3RyZWFtUGF1c2VkIiwiaGFuZGxlVHJhY2tNdXRlRXZlbnQiLCJkZWJvdW5jZWRUcmFja011dGVIYW5kbGVyIiwicGF1c2VVcHN0cmVhbSIsImhhbmRsZVRyYWNrVW5tdXRlRXZlbnQiLCJyZXN1bWVVcHN0cmVhbSIsImhhbmRsZUVuZGVkIiwicmVhY3F1aXJlVHJhY2siLCJFbmRlZCIsInByb3ZpZGVkQnlVc2VyIiwibXV0ZUxvY2siLCJwYXVzZVVwc3RyZWFtTG9jayIsInRyYWNrQ2hhbmdlTG9jayIsInNldE1lZGlhU3RyZWFtVHJhY2siLCJnZXRDb25zdHJhaW50cyIsImRpbWVuc2lvbnMiLCJpc1Vwc3RyZWFtUGF1c2VkIiwiaXNVc2VyUHJvdmlkZWQiLCJwcm9jZXNzZWRUcmFjayIsImdldFNvdXJjZVRyYWNrU2V0dGluZ3MiLCJuZXdUcmFjayIsInByb2Nlc3NvckVsZW1lbnQiLCJyZXN0YXJ0IiwicmVwbGFjZVRyYWNrIiwid2FpdEZvckRpbWVuc2lvbnMiLCJzdGFydGVkIiwiZGltcyIsInNldERldmljZUlkIiwicmVzdGFydFRyYWNrIiwiZ2V0RGV2aWNlSWQiLCJub3JtYWxpemUiLCJtdXRlIiwic2V0VHJhY2tNdXRlZCIsInVubXV0ZSIsInVzZXJQcm92aWRlZE9yT3B0aW9ucyIsInN0b3BQcm9jZXNzb3IiLCJpbnRlcm5hbFN0b3BQcm9jZXNzb3IiLCJvdGhlckNvbnN0cmFpbnRzIiwic3RyZWFtQ29uc3RyYWludHMiLCJSZXN0YXJ0ZWQiLCJNdXRlZCIsIlVubXV0ZWQiLCJuZWVkc1JlQWNxdWlzaXRpb24iLCJfc3VwZXIiLCJkZXN0cm95IiwiVXBzdHJlYW1QYXVzZWQiLCJVcHN0cmVhbVJlc3VtZWQiLCJnZXRSVENTdGF0c1JlcG9ydCIsInN0YXRzUmVwb3J0Iiwic2V0UHJvY2Vzc29yIiwicHJvY2Vzc29yXzEiLCJzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSIsInByb2Nlc3Nvck9wdGlvbnMiLCJUcmFja1Byb2Nlc3NvclVwZGF0ZSIsImdldFByb2Nlc3NvciIsIl90aGlzNCIsImtlZXBFbGVtZW50IiwiX3RoaXM1IiwicmVtb3ZlIiwic3RhcnRQcmVDb25uZWN0QnVmZmVyIiwidGltZXNsaWNlIiwiaXNUeXBlU3VwcG9ydGVkIiwiYXV0b1N0b3BQcmVDb25uZWN0QnVmZmVyIiwic3RvcFByZUNvbm5lY3RCdWZmZXIiLCJnZXRQcmVDb25uZWN0QnVmZmVyIiwiZ2V0UHJlQ29ubmVjdEJ1ZmZlck1pbWVUeXBlIiwiTG9jYWxBdWRpb1RyYWNrIiwiZW5oYW5jZWROb2lzZUNhbmNlbGxhdGlvbiIsImlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQiLCJzdG9wT25NdXRlIiwibW9uaXRvclNlbmRlciIsImdldFNlbmRlclN0YXRzIiwiaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckVuYWJsZSIsIkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlIiwiVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OIiwiaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUiLCJjaGVja0ZvclNpbGVuY2UiLCJkZXZpY2VIYXNDaGFuZ2VkIiwic3RhcnRNb25pdG9yIiwic2V0QXVkaW9Db250ZXh0IiwiYXVkaW9TdGF0cyIsInBhY2tldHNTZW50IiwicGFja2V0c0xvc3QiLCJyb3VuZFRyaXBUaW1lIiwiaml0dGVyIiwidHJhY2tJc1NpbGVudCIsIkF1ZGlvU2lsZW5jZURldGVjdGVkIiwibWVkaWFUcmFja1RvTG9jYWxUcmFjayIsIkxvY2FsVmlkZW9UcmFjayIsInByZXNldHMxNjkiLCJwcmVzZXRzNDMiLCJwcmVzZXRzU2NyZWVuU2hhcmUiLCJkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSIsImRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDMiLCJjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyIsImZyb21QcmVzZXQiLCJmcHMiLCJ2aWRlb1JpZHMiLCJjb21wdXRlVmlkZW9FbmNvZGluZ3MiLCJpc1NjcmVlblNoYXJlIiwidmlkZW9FbmNvZGluZyIsInVzZVNpbXVsY2FzdCIsInNjYWxhYmlsaXR5TW9kZSIsImRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmciLCJzb3VyY2VGcmFtZXJhdGUiLCJzbSIsIlNjYWxhYmlsaXR5TW9kZSIsInNwYXRpYWwiLCJiaXRyYXRlc1JhdGlvIiwic3VmZml4IiwicmVxdWlyZVNjYWxlIiwibmV0d29ya1ByaW9yaXR5IiwicHJlc2V0cyIsInNvcnRQcmVzZXRzIiwic2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMiLCJkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzIiwidmlkZW9TaW11bGNhc3RMYXllcnMiLCJtaWRQcmVzZXQiLCJsb3dQcmVzZXQiLCJlbmNvZGluZ3NGcm9tUHJlc2V0cyIsImNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyIsInNlcnZlclJlcXVlc3RlZCIsInByZXNldHNGb3JSZXNvbHV0aW9uIiwicHJlc2V0IiwiYXNwZWN0IiwiYWJzIiwiY2FuU2V0UHJpb3JpdHkiLCJ0b3BGcmFtZXJhdGUiLCJub3RpZnlPbmNlIiwiYUVuYyIsImJFbmMiLCJyZXN1bHRzIiwidGVtcG9yYWwiLCJnZXREZWZhdWx0RGVncmFkYXRpb25QcmVmZXJlbmNlIiwicmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMiLCJkZWdyYWRhdGlvblByZWZlcmVuY2UiLCJzZXREZWdyYWRhdGlvblByZWZlcmVuY2UiLCJzaW11bGNhc3RDb2RlY3MiLCJpc0NwdUNvbnN0cmFpbmVkIiwib3B0aW1pemVGb3JQZXJmb3JtYW5jZSIsInN0YXRzTWFwIiwicXVhbGl0eUxpbWl0YXRpb25SZWFzb24iLCJDcHVDb25zdHJhaW5lZCIsInRvdGFsQml0cmF0ZSIsInNlbmRlckxvY2siLCJpc1NpbXVsY2FzdCIsInNpZ25hbENsaWVudCIsImVfMSIsIl9nIiwic2MiLCJlXzFfMSIsInJldHVybiIsImVfMiIsImVfMl8xIiwiaXRlbXMiLCJ2cyIsImZyYW1lSGVpZ2h0IiwiZnJhbWVXaWR0aCIsImZyYW1lc1BlclNlY29uZCIsImZyYW1lc1NlbnQiLCJmaXJDb3VudCIsInBsaUNvdW50IiwibmFja0NvdW50IiwicXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMiLCJxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzIiwicmV0cmFuc21pdHRlZFBhY2tldHNTZW50IiwidGFyZ2V0Qml0cmF0ZSIsInNldFB1Ymxpc2hpbmdRdWFsaXR5IiwibWF4UXVhbGl0eSIsInF1YWxpdGllcyIsInEiLCJMT1ciLCJISUdIIiwic2V0UHVibGlzaGluZ0xheWVycyIsImVfMyIsImVfM18xIiwiZV80IiwiX2giLCJlXzRfMSIsInByZWZlcmVuY2UiLCJhZGRTaW11bGNhc3RUcmFjayIsInNpbXVsY2FzdENvZGVjSW5mbyIsInNldFNpbXVsY2FzdFRyYWNrU2VuZGVyIiwic3Vic2NyaWJlZENvZGVjcyIsInNldFB1Ymxpc2hpbmdDb2RlY3MiLCJjb2RlY3NfMSIsImNvZGVjc18xXzEiLCJlXzUiLCJjdXJyZW50Q29kZWMiLCJuZXdDb2RlY3MiLCJzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyIiwiZV81XzEiLCJpc1N2YyIsInByaW9yaXRpemVQZXJmb3JtYW5jZSIsImFjdGl2ZSIsInNlbmRlckVuY29kaW5ncyIsImlzU1ZDIiwiaGFzQ2hhbmdlZCIsImNsb3NhYmxlU3BhdGlhbCIsImhhc0VuYWJsZWRFbmNvZGluZyIsInZpZGVvUXVhbGl0eUZvclJpZCIsInN1YnNjcmliZWRRdWFsaXR5IiwibWF4RnJhbWVSYXRlIiwiTUVESVVNIiwidmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzIiwic3ZjIiwiYml0cmF0ZSIsImVuY29kaW5nU00iLCJyZXNSYXRpbyIsInNjYWxlIiwibG9zc3lEYXRhQ2hhbm5lbCIsInJlbGlhYmxlRGF0YUNoYW5uZWwiLCJtaW5SZWNvbm5lY3RXYWl0IiwibGVhdmVSZWNvbm5lY3QiLCJyZWxpYWJlUmVjZWl2ZVN0YXRlVFRMIiwiUENTdGF0ZSIsIlJUQ0VuZ2luZSIsIl9pc0Nsb3NlZCIsInBlbmRpbmdSZWNvbm5lY3QiLCJyZWNvbm5lY3RUaW1lb3V0IiwiZnVsbFJlY29ubmVjdE9uTmV4dCIsImxhdGVzdFJlbW90ZU9mZmVySWQiLCJzdWJzY3JpYmVyUHJpbWFyeSIsInBjU3RhdGUiLCJOZXciLCJwZW5kaW5nVHJhY2tSZXNvbHZlcnMiLCJyZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdFN0YXJ0IiwiYXR0ZW1wdGluZ1JlY29ubmVjdCIsImpvaW5BdHRlbXB0cyIsIm1heEpvaW5BdHRlbXB0cyIsInNob3VsZEZhaWxOZXh0IiwicmVsaWFibGVEYXRhU2VxdWVuY2UiLCJyZWxpYWJsZU1lc3NhZ2VCdWZmZXIiLCJyZWxpYWJsZVJlY2VpdmVkU3RhdGUiLCJpc1dhaXRpbmdGb3JOZXR3b3JrUmVjb25uZWN0IiwiaGFuZGxlRGF0YUNoYW5uZWwiLCJyZWxpYWJsZURDU3ViIiwibG9zc3lEQ1N1YiIsImhhbmRsZURhdGFNZXNzYWdlIiwiZGF0YVByb2Nlc3NMb2NrIiwiQmxvYiIsImRwIiwibGFzdFNlcSIsIkFjdGl2ZVNwZWFrZXJzVXBkYXRlIiwiZTJlZU1hbmFnZXIiLCJkZWNyeXB0ZWREYXRhIiwiZW5jcnlwdGVkVmFsdWUiLCJkZWNyeXB0ZWRQYWNrZXQiLCJuZXdEcCIsImFwcGx5VXNlckRhdGFDb21wYXQiLCJEYXRhUGFja2V0UmVjZWl2ZWQiLCJlbmNyeXB0aW9uVHlwZSIsImhhbmRsZURhdGFFcnJvciIsImNoYW5uZWxLaW5kIiwibWF4UmV0cmFuc21pdHMiLCJFcnJvckV2ZW50IiwiaGFuZGxlQnVmZmVyZWRBbW91bnRMb3ciLCJMT1NTWSIsIlJFTElBQkxFIiwidXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzIiwiaGFuZGxlRGlzY29ubmVjdCIsImRpc2Nvbm5lY3RSZWFzb24iLCJkaXNjb25uZWN0IiwiRGlzY29ubmVjdGVkIiwiZGVsYXkiLCJnZXROZXh0UmV0cnlEZWxheSIsImVsYXBzZWRNcyIsImNsZWFyUmVjb25uZWN0VGltZW91dCIsInJlZ2lvblVybFByb3ZpZGVyIiwiYXR0ZW1wdFJlY29ubmVjdCIsIndhaXRGb3JSZXN0YXJ0ZWQiLCJvblJlc3RhcnRlZCIsIm9uRGlzY29ubmVjdGVkIiwiZGF0YUNoYW5uZWxGb3JLaW5kIiwiaXNCdWZmZXJTdGF0dXNMb3ciLCJkY0J1ZmZlclN0YXR1cyIsIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCIsImJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkIiwiaGFuZGxlQnJvd3Nlck9uTGluZSIsImhhc05ldHdvcmtDb25uZWN0aW9uIiwiY2xpZW50IiwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRCIsImhhbmRsZUJyb3dzZXJPZmZsaW5lIiwib25MaW5lIiwiRW5naW5lIiwiZXhwU2lnbmFsTGF0ZW5jeSIsInVwZGF0ZXMiLCJ1cGRhdGUiLCJTdHJlYW1TdGF0ZUNoYW5nZWQiLCJTaWduYWxSZXF1ZXN0UmVzcG9uc2UiLCJsYXRlc3RKb2luUmVzcG9uc2UiLCJyb29tSUQiLCJwSUQiLCJzaWduYWxPcHRzIiwic2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MiLCJqb2luUmVzcG9uc2UiLCJwY01hbmFnZXIiLCJjb25maWd1cmUiLCJmYXN0UHVibGlzaCIsInJlZ2lzdGVyT25MaW5lTGlzdGVuZXIiLCJjbGllbnRDb25maWd1cmF0aW9uIiwiQ2xvc2luZyIsImRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lciIsImNsZWFyUGVuZGluZ1JlY29ubmVjdCIsImNsZWFudXBQZWVyQ29ubmVjdGlvbnMiLCJjbGVhbnVwQ2xpZW50IiwiZGNDbGVhbnVwIiwib25idWZmZXJlZGFtb3VudGxvdyIsIm9uY2xvc2luZyIsImxvc3N5REMiLCJyZWxpYWJsZURDIiwicHVibGljYXRpb25UaW1lb3V0IiwiVGltZW91dCIsInVwZGF0ZU11dGVTdGF0dXMiLCJkYXRhU3Vic2NyaWJlclJlYWR5U3RhdGUiLCJnZXRDb25uZWN0ZWRTZXJ2ZXJBZGRyZXNzIiwic2V0UmVnaW9uVXJsUHJvdmlkZXIiLCJwcm92aWRlciIsIm1ha2VSVENDb25maWd1cmF0aW9uIiwiVHJhbnNwb3J0c0NyZWF0ZWQiLCJwdWJsaXNoZXJTdGF0ZSIsInN1YnNjcmliZXJTdGF0ZSIsInB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlIiwic2hvdWxkRW1pdCIsIlJlY29ubmVjdGluZyIsIlJSX1NVQlNDUklCRVJfRkFJTEVEIiwiUlJfUFVCTElTSEVSX0ZBSUxFRCIsImlzU2lnbmFsU2V2ZXJlZCIsImlzUENTZXZlcmVkIiwiT2ZmbGluZSIsIk1lZGlhVHJhY2tBZGRlZCIsInN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsIiwic2VydmVySW5mbyIsImNyZWF0ZURhdGFDaGFubmVscyIsIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsIkxvY2FsVHJhY2tTdWJzY3JpYmVkIiwiUmVtb3RlTXV0ZSIsIlJvb21Nb3ZlZCIsInJlcXVpcmVtZW50IiwibnVtQXVkaW9zIiwibnVtVmlkZW9zIiwibGVhdmUiLCJSRUNPTk5FQ1QiLCJSRVNVTUUiLCJzZXJ2ZXJSZXNwb25zZSIsImUyZWVFbmFibGVkIiwiZW5jb2RlZEluc2VydGFibGVTdHJlYW1zIiwicnRjSWNlU2VydmVycyIsImljZVNlcnZlciIsInJ0Y0ljZVNlcnZlciIsImNyZWRlbnRpYWwiLCJmb3JjZVJlbGF5IiwiRU5BQkxFRCIsImljZVRyYW5zcG9ydFBvbGljeSIsImNvbnRpbnVhbEdhdGhlcmluZ1BvbGljeSIsIm9yZGVyZWQiLCJjcmVhdGVTZW5kZXIiLCJjcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlciIsImNyZWF0ZVJUQ1J0cFNlbmRlciIsImNyZWF0ZVNpbXVsY2FzdFNlbmRlciIsInNpbXVsY2FzdFRyYWNrIiwiY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIiLCJyZXN1bWVDb25uZWN0aW9uIiwiRElTQUJMRUQiLCJyZXN0YXJ0Q29ubmVjdGlvbiIsInJlY292ZXJhYmxlIiwiU2lnbmFsUmVjb25uZWN0RXJyb3IiLCJSUl9VTktOT1dOIiwicmVnaW9uVXJsIiwiUmVzdGFydGluZyIsIlNpZ25hbFJlc3RhcnRlZCIsIndhaXRGb3JQQ1JlY29ubmVjdGVkIiwibmV4dFJlZ2lvblVybCIsIlJlc3VtaW5nIiwiU2lnbmFsUmVzdW1lZCIsImxhc3RNZXNzYWdlU2VxIiwicmVzZW5kUmVsaWFibGVNZXNzYWdlc0ZvclJlc3VtZSIsIlJlc3VtZWQiLCJ3YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbiIsInB1Ymxpc2hScGNSZXNwb25zZSIsImRlc3RpbmF0aW9uSWRlbnRpdHkiLCJkZXN0aW5hdGlvbklkZW50aXRpZXMiLCJzZW5kRGF0YVBhY2tldCIsInB1Ymxpc2hScGNBY2siLCJlbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQiLCJlbmNyeXB0YWJsZVBhY2tldCIsImVuY3J5cHRlZERhdGEiLCJ3YWl0Rm9yQnVmZmVyU3RhdHVzTG93Iiwib25DbG9zaW5nIiwiZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZCIsInRyYW5zcG9ydE5hbWUiLCJuZWVkTmVnb3RpYXRpb24iLCJ0YXJnZXRDaGFubmVsIiwidmVyaWZ5VHJhbnNwb3J0IiwiQWJvcnRDb250cm9sbGVyIiwiaGFuZGxlQ2xvc2VkIiwicnRwVHlwZXMiLCJyZW1vdGVUcmFja3MiLCJsb2NhbFRyYWNrcyIsInByZXZpb3VzUHVibGlzaGVyT2ZmZXIiLCJwcmV2aW91c1B1Ymxpc2hlckFuc3dlciIsInByZXZpb3VzU3Vic2NyaWJlck9mZmVyIiwicHJldmlvdXNTdWJzY3JpYmVyQW5zd2VyIiwidHJhY2tTaWRzIiwidHJhY2tTaWRzRGlzYWJsZWQiLCJpc0Rlc2lyZWQiLCJzdWJzY3JpcHRpb24iLCJzdWJzY3JpYmUiLCJwYXJ0aWNpcGFudFRyYWNrcyIsInB1Ymxpc2hUcmFja3MiLCJkYXRhQ2hhbm5lbHMiLCJkYXRhQ2hhbm5lbHNJbmZvIiwiZGF0YWNoYW5uZWxSZWNlaXZlU3RhdGVzIiwic2VxIiwicHVibGlzaGVyU2lkIiwiZmFpbE5leHQiLCJnZXRJbmZvIiwiZ2V0VHJhY2tJZEZvclJlY2VpdmVyIiwibmV3T2JqIiwib2xkT2JqIiwiQmFzZVN0cmVhbVJlYWRlciIsIl9pbmZvIiwidmFsaWRhdGVCeXRlc1JlY2VpdmVkIiwiZG9uZVJlY2VpdmluZyIsInRvdGFsQnl0ZVNpemUiLCJJbmNvbXBsZXRlIiwiTGVuZ3RoRXhjZWVkZWQiLCJvdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlIiwiQnl0ZVN0cmVhbVJlYWRlciIsImhhbmRsZUNodW5rUmVjZWl2ZWQiLCJjdXJyZW50UHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwicmVqZWN0aW5nU2lnbmFsRnV0dXJlIiwiYWN0aXZlU2lnbmFsIiwib25BYm9ydCIsIndpdGhBYm9ydFNpZ25hbCIsInJlYWRBbGwiLCJpdGVyYXRvcl8xIiwiaXRlcmF0b3JfMV8xIiwiYWRkIiwiVGV4dFN0cmVhbVJlYWRlciIsInRvdGFsQ2h1bmtDb3VudCIsInJlY2VpdmVkQ2h1bmtzIiwiY2h1bmtJbmRleCIsInByZXZpb3VzQ2h1bmtBdEluZGV4IiwiZGVjb2RlciIsImZhdGFsIiwiZGVjb2RlZFJlc3VsdCIsIkRlY29kZUZhaWxlZCIsImZpbmFsU3RyaW5nIiwiaXRlcmF0b3JfMiIsIml0ZXJhdG9yXzJfMSIsIkluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIiLCJieXRlU3RyZWFtQ29udHJvbGxlcnMiLCJ0ZXh0U3RyZWFtQ29udHJvbGxlcnMiLCJieXRlU3RyZWFtSGFuZGxlcnMiLCJ0ZXh0U3RyZWFtSGFuZGxlcnMiLCJyZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyIiwidG9waWMiLCJIYW5kbGVyQWxyZWFkeVJlZ2lzdGVyZWQiLCJ1bnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIiLCJyZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyIiwidW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyIiwiY2xlYXJDb250cm9sbGVycyIsInZhbGlkYXRlUGFydGljaXBhbnRIYXNOb0FjdGl2ZURhdGFTdHJlYW1zIiwidGV4dFN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudCIsInNlbmRpbmdQYXJ0aWNpcGFudElkZW50aXR5IiwiYnl0ZVN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudCIsImFibm9ybWFsRW5kRXJyb3IiLCJBYm5vcm1hbEVuZCIsImhhbmRsZURhdGFTdHJlYW1QYWNrZXQiLCJoYW5kbGVTdHJlYW1IZWFkZXIiLCJoYW5kbGVTdHJlYW1DaHVuayIsImhhbmRsZVN0cmVhbVRyYWlsZXIiLCJzdHJlYW1IZWFkZXIiLCJjb250ZW50SGVhZGVyIiwic3RyZWFtSGFuZGxlckNhbGxiYWNrIiwidG90YWxMZW5ndGgiLCJBbHJlYWR5T3BlbmVkIiwiZmlsZUJ1ZmZlciIsIkVuY3J5cHRpb25UeXBlTWlzbWF0Y2giLCJ0ZXh0QnVmZmVyIiwiQmFzZVN0cmVhbVdyaXRlciIsImRlZmF1bHRXcml0ZXIiLCJUZXh0U3RyZWFtV3JpdGVyIiwiQnl0ZVN0cmVhbVdyaXRlciIsIlNUUkVBTV9DSFVOS19TSVpFIiwiT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlciIsInNlbmRUZXh0IiwidGV4dEluQnl0ZXMiLCJ0b3RhbFRleHRMZW5ndGgiLCJmaWxlSWRzIiwiYXR0YWNobWVudHMiLCJwcm9ncmVzc2VzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInRvdGFsUHJvZ3Jlc3MiLCJzdHJlYW1UZXh0IiwidG90YWxTaXplIiwiYXR0YWNoZWRTdHJlYW1JZHMiLCJmaWxlIiwiX3NlbmRGaWxlIiwiR0NNIiwiaGVhZGVyIiwicmVwbHlUb1N0cmVhbUlkIiwib3BlcmF0aW9uVHlwZSIsIlVQREFURSIsIkNSRUFURSIsImNodW5rSWQiLCJ0ZXh0Qnl0ZUNodW5rIiwiY2h1bmtQYWNrZXQiLCJ0cmFpbGVyUGFja2V0Iiwib25FbmdpbmVDbG9zZSIsInNlbmRGaWxlIiwic3RyZWFtQnl0ZXMiLCJ3cml0ZU11dGV4IiwibG9nTG9jYWwiLCJzdWJDaHVuayIsImJ5dGVXcml0ZXIiLCJSZW1vdGVUcmFjayIsInNldE11dGVkIiwic2V0TWVkaWFTdHJlYW0iLCJvblJlbW92ZVRyYWNrIiwicGxheW91dERlbGF5SGludCIsInNldFBsYXlvdXREZWxheSIsImRlbGF5SW5TZWNvbmRzIiwiZ2V0UGxheW91dERlbGF5IiwibW9uaXRvclJlY2VpdmVyIiwicmVnaXN0ZXJUaW1lU3luY1VwZGF0ZSIsImxvb3AiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzb3VyY2VzIiwiZ2V0U3luY2hyb25pemF0aW9uU291cmNlcyIsInJ0cFRpbWVzdGFtcCIsIlRpbWVTeW5jVXBkYXRlIiwiUmVtb3RlQXVkaW9UcmFjayIsImF1ZGlvT3V0cHV0IiwiZ2V0UmVjZWl2ZXJTdGF0cyIsIndlYkF1ZGlvUGx1Z2luTm9kZXMiLCJzaW5rSWQiLCJzZXRWb2x1bWUiLCJnYWluTm9kZSIsInNldFRhcmdldEF0VGltZSIsIl9zZXRWb2x1bWUiLCJlbGVtZW50Vm9sdW1lIiwiZ2V0Vm9sdW1lIiwiaGlnaGVzdFZvbHVtZSIsInNldFNpbmtJZCIsIm5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uIiwiY29ubmVjdFdlYkF1ZGlvIiwiZGlzY29ubmVjdFdlYkF1ZGlvIiwic2V0V2ViQXVkaW9QbHVnaW5zIiwibm9kZXMiLCJzb3VyY2VOb2RlIiwibGFzdE5vZGUiLCJub2RlIiwiZGVzdGluYXRpb24iLCJyZWNlaXZlclN0YXRzIiwiY29uY2VhbGVkU2FtcGxlcyIsImNvbmNlYWxtZW50RXZlbnRzIiwic2lsZW50Q29uY2VhbGVkU2FtcGxlcyIsInNpbGVudENvbmNlYWxtZW50RXZlbnRzIiwidG90YWxBdWRpb0VuZXJneSIsInRvdGFsU2FtcGxlc0R1cmF0aW9uIiwiUkVBQ1RJT05fREVMQVkiLCJSZW1vdGVWaWRlb1RyYWNrIiwiYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyIsImVsZW1lbnRJbmZvcyIsImRlYm91bmNlZEhhbmRsZVJlc2l6ZSIsInVwZGF0ZURpbWVuc2lvbnMiLCJpc0FkYXB0aXZlU3RyZWFtIiwidXBkYXRlVmlzaWJpbGl0eSIsImVsZW1lbnRJbmZvIiwiSFRNTEVsZW1lbnRJbmZvIiwib2JzZXJ2ZUVsZW1lbnRJbmZvIiwib2JzZXJ2ZSIsInN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyIsInN0b3BFbGVtZW50SW5mb3MiLCJzdG9wT2JzZXJ2aW5nIiwiZGV0YWNoZWRFbGVtZW50cyIsInN0b3BPYnNlcnZpbmdFbGVtZW50IiwiZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uIiwiZGVjb2RlckltcGxlbWVudGF0aW9uIiwiY29kZWNJRCIsImNvZGVjSWQiLCJmcmFtZXNEZWNvZGVkIiwiZnJhbWVzRHJvcHBlZCIsImZyYW1lc1JlY2VpdmVkIiwicGFja2V0c1JlY2VpdmVkIiwiZm9yY2VFbWl0IiwibGFzdFZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmlsaXR5Q2hhbmdlZEF0IiwiYmFja2dyb3VuZFBhdXNlIiwicGF1c2VWaWRlb0luQmFja2dyb3VuZCIsImlzUGlQTW9kZSIsInBpY3R1cmVJblBpY3R1cmUiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwibGFzdFZpc2libGUiLCJWaXNpYmlsaXR5Q2hhbmdlZCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwicGl4ZWxEZW5zaXR5IiwiZ2V0UGl4ZWxEZW5zaXR5IiwiY3VycmVudEVsZW1lbnRXaWR0aCIsImN1cnJlbnRFbGVtZW50SGVpZ2h0IiwibGFzdERpbWVuc2lvbnMiLCJWaWRlb0RpbWVuc2lvbnNDaGFuZ2VkIiwiaXNQaVAiLCJpc0ludGVyc2VjdGluZyIsIm9uVmlzaWJpbGl0eUNoYW5nZWQiLCJpc0VsZW1lbnRJblBpUCIsIm9uRW50ZXJQaVAiLCJkb2N1bWVudFBpY3R1cmVJblBpY3R1cmUiLCJvbkxlYXZlUGlQIiwiaXNFbGVtZW50SW5WaWV3cG9ydCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidW5vYnNlcnZlIiwicGljdHVyZUluUGljdHVyZUVsZW1lbnQiLCJ3aW4iLCJ2aWV3cG9ydFdpbmRvdyIsInRvcCIsIm9mZnNldFRvcCIsImxlZnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJoaWRkZW4iLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9mZnNldFBhcmVudCIsInBhZ2VZT2Zmc2V0IiwiaW5uZXJIZWlnaHQiLCJwYWdlWE9mZnNldCIsImlubmVyV2lkdGgiLCJUcmFja1B1YmxpY2F0aW9uIiwibWV0YWRhdGFNdXRlZCIsImhhbmRsZU11dGVkIiwiaGFuZGxlVW5tdXRlZCIsIlB1YmxpY2F0aW9uIiwic2V0VHJhY2siLCJpc1N1YnNjcmliZWQiLCJhdWRpb1RyYWNrIiwidmlkZW9UcmFjayIsInVwZGF0ZUluZm8iLCJzaW11bGNhc3RlZCIsIlN1YnNjcmlwdGlvblN0YXR1cyIsIlBlcm1pc3Npb25TdGF0dXMiLCJMb2NhbFRyYWNrUHVibGljYXRpb24iLCJ0aSIsImhhbmRsZVRyYWNrRW5kZWQiLCJoYW5kbGVDcHVDb25zdHJhaW5lZCIsImdldFRyYWNrRmVhdHVyZXMiLCJURl9BVVRPX0dBSU5fQ09OVFJPTCIsIlRGX0VDSE9fQ0FOQ0VMTEFUSU9OIiwiVEZfTk9JU0VfU1VQUFJFU1NJT04iLCJjaGFubmVsQ291bnQiLCJURl9TVEVSRU8iLCJURl9OT19EVFgiLCJjcmVhdGVMb2NhbFRyYWNrcyIsImF0dGVtcHRFeGFjdE1hdGNoIiwiaW50ZXJuYWxPcHRpb25zIiwicmV0cnlBdWRpb09wdGlvbnMiLCJyZXRyeVZpZGVvT3B0aW9ucyIsIm1lZGlhUHJvbWlzZSIsImlzQXVkaW8iLCJ0cmFja09wdGlvbnMiLCJ0cmFja0NvbnN0cmFpbnRzIiwiY29uT3JCb29sIiwibmV3RGV2aWNlSWQiLCJjcmVhdGVMb2NhbFZpZGVvVHJhY2siLCJjcmVhdGVMb2NhbEF1ZGlvVHJhY2siLCJjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyIsInNjcmVlblZpZGVvIiwic2NyZWVuQXVkaW8iLCJDb25uZWN0aW9uUXVhbGl0eSIsInF1YWxpdHlGcm9tUHJvdG8iLCJFWENFTExFTlQiLCJFeGNlbGxlbnQiLCJHT09EIiwiR29vZCIsIlBPT1IiLCJQb29yIiwiTE9TVCIsIkxvc3QiLCJQYXJ0aWNpcGFudCIsImlzQWdlbnQiLCJwZXJtaXNzaW9ucyIsImFnZW50IiwiQUdFTlQiLCJpc0FjdGl2ZSIsInBhcnRpY2lwYW50SW5mbyIsIl9raW5kIiwiX2F0dHJpYnV0ZXMiLCJTVEFOREFSRCIsImF1ZGlvTGV2ZWwiLCJpc1NwZWFraW5nIiwiX2Nvbm5lY3Rpb25RdWFsaXR5IiwiYXVkaW9UcmFja1B1YmxpY2F0aW9ucyIsInZpZGVvVHJhY2tQdWJsaWNhdGlvbnMiLCJnZXRUcmFja1B1YmxpY2F0aW9ucyIsImdldFRyYWNrUHVibGljYXRpb24iLCJnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lIiwid2FpdFVudGlsQWN0aXZlIiwiYWN0aXZlRnV0dXJlIiwiY29ubmVjdGlvblF1YWxpdHkiLCJpc0NhbWVyYUVuYWJsZWQiLCJpc01pY3JvcGhvbmVFbmFibGVkIiwiaXNTY3JlZW5TaGFyZUVuYWJsZWQiLCJqb2luZWRBdCIsIl9zZXROYW1lIiwiX3NldE1ldGFkYXRhIiwiX3NldEF0dHJpYnV0ZXMiLCJwZXJtaXNzaW9uIiwic2V0UGVybWlzc2lvbnMiLCJtZCIsImNoYW5nZWQiLCJwcmV2TWV0YWRhdGEiLCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCIsIlBhcnRpY2lwYW50TmFtZUNoYW5nZWQiLCJBdHRyaWJ1dGVzQ2hhbmdlZCIsInByZXZQZXJtaXNzaW9ucyIsImNhblB1Ymxpc2giLCJjYW5TdWJzY3JpYmUiLCJjYW5QdWJsaXNoRGF0YSIsInJlY29yZGVyIiwiY2FuUHVibGlzaFNvdXJjZXMiLCJjYW5TdWJzY3JpYmVNZXRyaWNzIiwiUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQiLCJzZXRJc1NwZWFraW5nIiwic3BlYWtpbmciLCJsYXN0U3Bva2VBdCIsIklzU3BlYWtpbmdDaGFuZ2VkIiwic2V0Q29ubmVjdGlvblF1YWxpdHkiLCJwcmV2UXVhbGl0eSIsIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsInNldERpc2Nvbm5lY3RlZCIsImFkZFRyYWNrUHVibGljYXRpb24iLCJUcmFja011dGVkIiwiVHJhY2tVbm11dGVkIiwidHJhY2tQZXJtaXNzaW9uVG9Qcm90byIsInBlcm1zIiwiYWxsVHJhY2tzIiwiYWxsb3dBbGwiLCJhbGxvd2VkVHJhY2tTaWRzIiwiTG9jYWxQYXJ0aWNpcGFudCIsInJvb21ScGNIYW5kbGVycyIsInJvb21PdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyIiwicGVuZGluZ1B1Ymxpc2hpbmciLCJwZW5kaW5nUHVibGlzaFByb21pc2VzIiwicGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zIiwiYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlIiwiZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcyIsInBlbmRpbmdBY2tzIiwicGVuZGluZ1Jlc3BvbnNlcyIsImhhbmRsZVJlY29ubmVjdGluZyIsInJlY29ubmVjdEZ1dHVyZSIsImhhbmRsZVJlY29ubmVjdGVkIiwidXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsImhhbmRsZUNsb3NpbmciLCJzaWduYWxDb25uZWN0ZWRGdXR1cmUiLCJhY3RpdmVBZ2VudEZ1dHVyZSIsImZpcnN0QWN0aXZlQWdlbnQiLCJoYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UiLCJ0YXJnZXRSZXF1ZXN0IiwicGVuZGluZ1NpZ25hbFJlcXVlc3RzIiwiT0siLCJoYW5kbGVEYXRhUGFja2V0IiwicnBjUmVzcG9uc2UiLCJoYW5kbGVJbmNvbWluZ1JwY1Jlc3BvbnNlIiwicnBjQWNrIiwiaGFuZGxlSW5jb21pbmdScGNBY2siLCJhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIiwib25UcmFja1VubXV0ZWQiLCJvblRyYWNrTXV0ZWQiLCJvblRyYWNrVXBzdHJlYW1QYXVzZWQiLCJvblRyYWNrVXBzdHJlYW1SZXN1bWVkIiwib25UcmFja0ZlYXR1cmVVcGRhdGUiLCJvblRyYWNrQ3B1Q29uc3RyYWluZWQiLCJMb2NhbFRyYWNrQ3B1Q29uc3RyYWluZWQiLCJoYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsInJvb21PcHRpb25zIiwibmV3Q29kZWNzXzEiLCJuZXdDb2RlY3NfMV8xIiwicHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrIiwiaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkIiwidW5wdWJsaXNoZWQiLCJ1bnB1Ymxpc2hUcmFjayIsImN1cnJlbnRQZXJtaXNzaW9ucyIsInF1ZXJ5Iiwib25jaGFuZ2UiLCJhY3RpdmVEZXZpY2VNYXAiLCJycGNIYW5kbGVycyIsImxhc3RDYW1lcmFFcnJvciIsImNhbWVyYUVycm9yIiwibGFzdE1pY3JvcGhvbmVFcnJvciIsIm1pY3JvcGhvbmVFcnJvciIsInNldE1ldGFkYXRhIiwicmVxdWVzdE1ldGFkYXRhVXBkYXRlIiwic2V0TmFtZSIsInNldEF0dHJpYnV0ZXMiLCJwZXJmb3JtYW5jZSIsInNldENhbWVyYUVuYWJsZWQiLCJwdWJsaXNoT3B0aW9ucyIsInNldFRyYWNrRW5hYmxlZCIsInNldE1pY3JvcGhvbmVFbmFibGVkIiwic2V0U2NyZWVuU2hhcmVFbmFibGVkIiwic2V0RTJFRUVuYWJsZWQiLCJyZXB1Ymxpc2hBbGxUcmFja3MiLCJyZXB1Ymxpc2hQcm9taXNlIiwicGVuZGluZ1RyYWNrIiwid2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlIiwiY3JlYXRlVHJhY2tzIiwiY3JlYXRlU2NyZWVuVHJhY2tzIiwiTWVkaWFEZXZpY2VzRXJyb3IiLCJsb2NhbFRyYWNrIiwicHVibGlzaFByb21pc2VzIiwicHVibGlzaFRyYWNrIiwicHVibGlzaGVkVHJhY2tzIiwic2NyZWVuQXVkaW9UcmFjayIsImVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUiLCJtZXJnZWRPcHRpb25zV2l0aFByb2Nlc3NvcnMiLCJhdWRpb0NhcHR1cmVEZWZhdWx0cyIsInZpZGVvQ2FwdHVyZURlZmF1bHRzIiwiQXVkaW9TdHJlYW1BY3F1aXJlZCIsImNvbnRlbnRIaW50IiwicHVibGlzaE9yUmVwdWJsaXNoVHJhY2siLCJvcHRpb25zXzEiLCJpc1JlcHVibGlzaCIsImRlZmF1bHRDb25zdHJhaW50cyIsImRldmljZUtpbmQiLCJleGlzdGluZ1B1YmxpY2F0aW9uIiwiaXNTdGVyZW9JbnB1dCIsImlzU3RlcmVvIiwiZTJlZSIsInB1Ymxpc2hQcm9taXNlIiwicHVibGljYXRpb25UaW1lZE91dCIsIndhaXRVbnRpbEVuZ2luZUNvbm5lY3RlZCIsInB1Ymxpc2giLCJoYXNQZXJtaXNzaW9uc1RvUHVibGlzaCIsIl9qIiwiX2siLCJleGlzdGluZ1RyYWNrT2ZTb3VyY2UiLCJwdWJsaXNoZWRUcmFjayIsIm1pbWUiLCJhdWRpb0ZlYXR1cmVzIiwiZGlzYWJsZUR0eCIsIlRGX1BSRUNPTk5FQ1RfQlVGRkVSIiwic3RlcmVvIiwiZGlzYWJsZVJlZCIsImJhY2t1cENvZGVjUG9saWN5IiwiZGVmYXVsdFJlcyIsInRyYWNrVHJhbnNjZWl2ZXIiLCJhZGRUcmFja1Byb21pc2UiLCJuZWdvdGlhdGVFcnIiLCJyZXRzIiwicHJpbWFyeUNvZGVjTWltZSIsInVwZGF0ZWRDb2RlYyIsImNvbnN0cmFpbmVkVHJhY2siLCJidWZmZXJTdHJlYW1Qcm9taXNlIiwiYWdlbnRBY3RpdmVUaW1lb3V0Iiwid2FpdFVudGlsQWN0aXZlQWdlbnRQcmVzZW50Iiwic2FtcGxlUmF0ZSIsInN0cmVhbV8xIiwic3RyZWFtXzFfMSIsInN0b3BPblVucHVibGlzaCIsImdldFB1YmxpY2F0aW9uRm9yVHJhY2siLCJwdWJMb2dDb250ZXh0IiwibmVnb3RpYXRpb25OZWVkZWQiLCJ0cmFja1NlbmRlciIsInVucHVibGlzaFRyYWNrcyIsInJlc3RhcnRUcmFja3MiLCJsb2NhbFB1YnMiLCJwdWJsaXNoRGF0YSIsImRhdGFfMSIsInJlbGlhYmxlIiwidXNlclBhY2tldCIsInB1Ymxpc2hEdG1mIiwiZGlnaXQiLCJzZW5kQ2hhdE1lc3NhZ2UiLCJhdHRhY2hlZEZpbGVzIiwiZWRpdENoYXRNZXNzYWdlIiwiZWRpdFRleHQiLCJvcmlnaW5hbE1lc3NhZ2UiLCJwZXJmb3JtUnBjIiwiX3JlZjMiLCJyZXNwb25zZVRpbWVvdXQiLCJtYXhSb3VuZFRyaXBMYXRlbmN5IiwibWluRWZmZWN0aXZlVGltZW91dCIsImVmZmVjdGl2ZVRpbWVvdXQiLCJwdWJsaXNoUnBjUmVxdWVzdCIsImFja1RpbWVvdXRJZCIsInJlc3BvbnNlVGltZW91dElkIiwicmVzcG9uc2VQYXlsb2FkIiwicmVzcG9uc2VFcnJvciIsInJlZ2lzdGVyUnBjTWV0aG9kIiwidW5yZWdpc3RlclJwY01ldGhvZCIsInNldFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJyZXNwb25zZVRpbWVvdXRNcyIsImhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkIiwicGVuZGluZ0lkZW50aXR5Iiwic2V0RW5hYmxlZFB1Ymxpc2hDb2RlY3MiLCJtdXRlZE9uU2VydmVyIiwic2V0QWN0aXZlQWdlbnQiLCJ3YWl0Rm9yUGVuZGluZ1RpbWVvdXQiLCJwdWJsaXNoUHJvbWlzZUVudHJ5IiwiX3JlZjQiLCJSZW1vdGVUcmFja1B1YmxpY2F0aW9uIiwiYWxsb3dlZCIsInJlcXVlc3RlZERpc2FibGVkIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImVtaXRUcmFja1VwZGF0ZSIsImhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSIsInZpZGVvRGltZW5zaW9uc0FkYXB0aXZlU3RyZWFtIiwic3Vic2NyaWJlZCIsInNldFN1YnNjcmliZWQiLCJwcmV2U3RhdHVzIiwic3Vic2NyaXB0aW9uU3RhdHVzIiwicHJldlBlcm1pc3Npb24iLCJwZXJtaXNzaW9uU3RhdHVzIiwiZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZCIsImVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkIiwiVW5zdWJzY3JpYmVkIiwiRGVzaXJlZCIsIlN1YnNjcmliZWQiLCJBbGxvd2VkIiwic2V0RW5hYmxlZCIsImlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCIsInNldFZpZGVvUXVhbGl0eSIsInJlcXVlc3RlZE1heFF1YWxpdHkiLCJyZXF1ZXN0ZWRWaWRlb0RpbWVuc2lvbnMiLCJzZXRWaWRlb0RpbWVuc2lvbnMiLCJzZXRWaWRlb0ZQUyIsInZpZGVvUXVhbGl0eSIsInByZXZUcmFjayIsInNldEFsbG93ZWQiLCJzZXRTdWJzY3JpcHRpb25FcnJvciIsIlN1YnNjcmlwdGlvbkZhaWxlZCIsInByZXZNZXRhZGF0YU11dGVkIiwicHJldmlvdXNTdGF0dXMiLCJjdXJyZW50U3RhdHVzIiwiU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCIsInByZXZpb3VzUGVybWlzc2lvblN0YXR1cyIsImN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQiLCJkaXNhYmxlZCIsIm1pbkRpbWVuc2lvbnMiLCJzbWFsbGVyQWRhcHRpdmUiLCJtYXhRdWFsaXR5TGF5ZXIiLCJVcGRhdGVTZXR0aW5ncyIsIlJlbW90ZVBhcnRpY2lwYW50IiwiZnJvbVBhcnRpY2lwYW50SW5mbyIsInBpIiwicnBJRCIsInJlbW90ZVBhcnRpY2lwYW50Iiwidm9sdW1lTWFwIiwiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCIsIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCIsInByZXZpb3VzVHJhY2siLCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZCIsImF1ZGlvUHVibGljYXRpb24iLCJhZGRTdWJzY3JpYmVkTWVkaWFUcmFjayIsInRyaWVzTGVmdCIsImdldFRyYWNrUHVibGljYXRpb25CeVNpZCIsImlzVmlkZW8iLCJoYXNNZXRhZGF0YSIsInZhbGlkVHJhY2tzIiwibmV3VHJhY2tzIiwib2xkVHJhY2siLCJzZW5kVW5wdWJsaXNoIiwiVHJhY2tVbnB1Ymxpc2hlZCIsInNldEF1ZGlvT3V0cHV0IiwicHJvbWlzZXMiLCJDT05ORUNUSU9OX1JFQ09OQ0lMRV9GUkVRVUVOQ1lfTVMiLCJSb29tIiwiaGFzRTJFRVNldHVwIiwiYWN0aXZlU3BlYWtlcnMiLCJhdWRpb0VuYWJsZWQiLCJpc1ZpZGVvUGxheWJhY2tCbG9ja2VkIiwiYnVmZmVyZWRFdmVudHMiLCJpc1Jlc3VtaW5nIiwidW5sb2NrRGlzY29ubmVjdCIsImRpc2Nvbm5lY3RMb2NrIiwiY29ubmVjdEZ1dHVyZSIsInNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUiLCJDb25uZWN0aW5nIiwiY29ubmVjdEZuIiwiYXR0ZW1wdENvbm5lY3Rpb24iLCJuZXh0VXJsIiwicmVnaW9uRmV0Y2hFcnJvciIsInJlY3JlYXRlRW5naW5lIiwiY2xlYXJDb25uZWN0aW9uRnV0dXJlcyIsImNvbm5lY3RTaWduYWwiLCJzZXJ2ZXJWZXJzaW9uIiwic2VydmVyUmVnaW9uIiwicm9vbVNpZCIsImFwcGx5Sm9pblJlc3BvbnNlIiwiZW5hYmxlZFB1Ymxpc2hDb2RlY3MiLCJzaWZUcmFpbGVyIiwiaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzIiwib3RoZXJQYXJ0aWNpcGFudHMiLCJoYW5kbGVSb29tVXBkYXRlIiwibWF5YmVDcmVhdGVFbmdpbmUiLCJhY3F1aXJlQXVkaW9Db250ZXh0IiwiY29ubk9wdGlvbnMiLCJzZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMiLCJyZXN1bHRpbmdFcnJvciIsIm9uUGFnZUxlYXZlIiwicmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlIiwiYXJnc18xIiwic3RvcFRyYWNrcyIsInN0YXJ0QXVkaW8iLCJlbGVtZW50cyIsImF1ZGlvSWQiLCJkdW1teUF1ZGlvRWwiLCJnZXRFbGVtZW50QnlJZCIsImFwcGVuZCIsImhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkIiwiaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCIsInN0YXJ0VmlkZW8iLCJoYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCIsImhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQiLCJoYW5kbGVSZXN0YXJ0aW5nIiwiY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlIiwiaGFuZGxlU2lnbmFsUmVzdGFydGVkIiwiUmVjb25uZWN0ZWQiLCJlbWl0QnVmZmVyZWRFdmVudHMiLCJwYXJ0aWNpcGFudEluZm9zIiwic2lkVG9JZGVudGl0eSIsImdldE9yQ3JlYXRlUGFydGljaXBhbnQiLCJoYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSIsInNlZW5TaWRzIiwic3BlYWtlciIsImdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQiLCJlbWl0V2hlbkNvbm5lY3RlZCIsIkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCIsImhhbmRsZVNwZWFrZXJzQ2hhbmdlZCIsInNwZWFrZXJVcGRhdGVzIiwibGFzdFNwZWFrZXJzIiwiaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUiLCJzdHJlYW1TdGF0ZVVwZGF0ZSIsInN0cmVhbVN0YXRlcyIsIm5ld1N0cmVhbVN0YXRlIiwiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQiLCJoYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIiwiaGFuZGxlU3Vic2NyaXB0aW9uRXJyb3IiLCJoYW5kbGVVc2VyUGFja2V0IiwiaGFuZGxlVHJhbnNjcmlwdGlvbiIsImhhbmRsZVNpcER0bWYiLCJoYW5kbGVDaGF0TWVzc2FnZSIsImhhbmRsZU1ldHJpY3MiLCJoYW5kbGVEYXRhU3RyZWFtIiwicnBjIiwiaGFuZGxlSW5jb21pbmdScGNSZXF1ZXN0IiwiRGF0YVJlY2VpdmVkIiwiU2lwRFRNRlJlY2VpdmVkIiwiX3JlbW90ZVBhcnRpY2lwYW50IiwidHJhbnNjcmliZWRQYXJ0aWNpcGFudElkZW50aXR5IiwidHJhbnNjcmlwdGlvblJlY2VpdmVkVGltZXMiLCJUcmFuc2NyaXB0aW9uUmVjZWl2ZWQiLCJjaGF0TWVzc2FnZSIsIm1ldHJpY3MiLCJNZXRyaWNzUmVjZWl2ZWQiLCJpbmNvbWluZ0RhdGFTdHJlYW1NYW5hZ2VyIiwiYnVmZmVyZWRTZWdtZW50cyIsImNhblBsYXliYWNrQXVkaW8iLCJBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCIsIlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkIiwiaGFuZGxlRGV2aWNlQ2hhbmdlIiwic2VsZWN0RGVmYXVsdERldmljZXMiLCJNZWRpYURldmljZXNDaGFuZ2VkIiwib2xkUm9vbSIsInJvb21JbmZvIiwiUm9vbU1ldGFkYXRhQ2hhbmdlZCIsImFjdGl2ZVJlY29yZGluZyIsIlJlY29yZGluZ1N0YXR1c0NoYW5nZWQiLCJoYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSIsIm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCIsIm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkIiwib25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJQYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkIiwib25Mb2NhbFRyYWNrTXV0ZWQiLCJvbkxvY2FsVHJhY2tVbm11dGVkIiwib25UcmFja1Byb2Nlc3NvclVwZGF0ZSIsIm9uUHVibGlzaCIsIm9uTG9jYWxUcmFja1Jlc3RhcnRlZCIsIkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQiLCJBY3RpdmVEZXZpY2VDaGFuZ2VkIiwib25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsIm9uTWVkaWFEZXZpY2VzRXJyb3IiLCJvbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQiLCJvbkxvY2FsQ2hhdE1lc3NhZ2VTZW50Iiwib3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlciIsInNldHVwRTJFRSIsInN3aXRjaEFjdGl2ZURldmljZSIsImNsZWFudXBSZWdpc3RyeSIsInJlZ2lzdGVyIiwiZTJlZU9wdGlvbnMiLCJpc1JlY29yZGluZyIsImdldFNpZCIsIm51bVBhcnRpY2lwYW50cyIsIm51bVB1Ymxpc2hlcnMiLCJvblRyYWNrQWRkZWQiLCJTaWduYWxSZWNvbm5lY3RpbmciLCJ1cGRhdGVTdWJzY3JpcHRpb25zIiwic3Vic2NyaWJlZFNpZCIsInRyYWNrUHVibGljYXRpb24iLCJyb29tTW92ZWQiLCJNb3ZlZCIsImdldExvY2FsRGV2aWNlcyIsInByZXBhcmVDb25uZWN0aW9uIiwic2ltdWxhdGVTY2VuYXJpbyIsInBvc3RBY3Rpb24iLCJjYW5QbGF5YmFja1ZpZGVvIiwiZ2V0QWN0aXZlRGV2aWNlIiwiZGV2aWNlSWRfMSIsInNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UiLCJkZXZpY2VDb25zdHJhaW50IiwicHJldkRldmljZUlkIiwicmVjb25uZWN0ZWRIYW5kbGVyIiwibWVkaWFUcmFja0lkIiwibWVkaWFTdHJlYW1JZCIsInRyYWNrc0luU3RyZWFtIiwic2hvdWxkU3RvcFRyYWNrcyIsIlBhcnRpY2lwYW50RGlzY29ubmVjdGVkIiwiY2FsbGVySWRlbnRpdHkiLCJhdmFpbGFibGVEZXZpY2VzIiwiYXZhaWxhYmxlRGV2aWNlIiwicHJldmlvdXNEZXZpY2UiLCJraW5kcyIsInRhcmdldFNvdXJjZSIsInRhcmdldFB1YmxpY2F0aW9uIiwiZGV2aWNlc09mS2luZCIsImFjdGl2ZURldmljZSIsImRldmljZUluZm8iLCJuZXdDb250ZXh0SXNSdW5uaW5nIiwiY3JlYXRlUGFydGljaXBhbnQiLCJleGlzdGluZ1BhcnRpY2lwYW50Iiwid2FzVXBkYXRlZCIsIlBhcnRpY2lwYW50Q29ubmVjdGVkIiwiUGFydGljaXBhbnRBY3RpdmUiLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsIiwibnVtRmFpbHVyZXMiLCJ0cmFuc3BvcnRzQ29ubmVjdGVkIiwiU1RBVEVfTUlTTUFUQ0giLCJfbGVuMiIsIl9rZXkyIiwic2ltdWxhdGVQYXJ0aWNpcGFudHMiLCJ1c2VSZWFsVHJhY2tzIiwicGFydGljaXBhbnRPcHRpb25zIiwiYXNwZWN0UmF0aW9zIiwiZW1wdHlUaW1lb3V0IiwibWF4UGFydGljaXBhbnRzIiwiY3JlYXRpb25UaW1lIiwidHVyblBhc3N3b3JkIiwiZW5hYmxlZENvZGVjcyIsImNhbVB1YiIsImF1ZGlvUHViIiwiZHVtbXlWaWRlbyIsIl9sZW4zIiwiX2tleTMiLCJtaW5pbWl6ZWRBcmdzIiwibWFwQXJncyIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiQ29udmVydCIsInRvQWdlbnRBdHRyaWJ1dGVzIiwiYWdlbnRBdHRyaWJ1dGVzVG9Kc29uIiwidG9UcmFuc2NyaXB0aW9uQXR0cmlidXRlcyIsInRyYW5zY3JpcHRpb25BdHRyaWJ1dGVzVG9Kc29uIiwiYXR0cmlidXRlVHlwaW5ncyIsIkNoZWNrU3RhdHVzIiwiQ2hlY2tlciIsIklETEUiLCJsb2dzIiwib25Db21wbGV0ZSIsInNldFN0YXR1cyIsInBlcmZvcm0iLCJlcnJvcnNBc1dhcm5pbmdzIiwiYXBwZW5kV2FybmluZyIsImFwcGVuZEVycm9yIiwiU0tJUFBFRCIsImlzU3VjY2VzcyIsIlNVQ0NFU1MiLCJzd2l0Y2hQcm90b2NvbCIsImhhc1JlY29ubmVjdGluZyIsImhhc1JlY29ubmVjdGVkIiwiYXBwZW5kTWVzc2FnZSIsIkNsb3VkUmVnaW9uQ2hlY2siLCJyZWdpb25Qcm92aWRlciIsInJlZ2lvblN0YXRzIiwic2VlblVybHMiLCJjaGVja0Nsb3VkUmVnaW9uIiwiYmVzdFJlZ2lvbiIsImJlc3RTdGF0cyIsImNodW5rU2l6ZSIsIm51bUNodW5rcyIsImNodW5rRGF0YSIsIm5vbWluYXRlZCIsImN1cnJlbnRSb3VuZFRyaXBUaW1lIiwiVEVTVF9EVVJBVElPTiIsIkNvbm5lY3Rpb25Qcm90b2NvbENoZWNrIiwidWRwU3RhdHMiLCJjaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCIsInRjcFN0YXRzIiwiYml0cmF0ZVRvdGFsIiwicnR0VG90YWwiLCJqaXR0ZXJUb3RhbCIsImNwdSIsImh1ZSIsImFuaW1hdGUiLCJwcm90b2NvbFN0YXRzIiwiUHVibGlzaEF1ZGlvQ2hlY2siLCJudW1QYWNrZXRzIiwibWVkaWFUeXBlIiwiUHVibGlzaFZpZGVvQ2hlY2siLCJjaGVja0ZvclZpZGVvIiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJvbnBsYXkiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJpc0FsbEJsYWNrIiwiUmVjb25uZWN0Q2hlY2siLCJyZWNvbm5lY3RpbmdUcmlnZ2VyZWQiLCJyZWNvbm5lY3RlZCIsInJlY29ubmVjdFJlc29sdmVyIiwiVFVSTkNoZWNrIiwiam9pblJlcyIsImhhc1RMUyIsImhhc1RVUk4iLCJoYXNTVFVOIiwiV2ViUlRDQ2hlY2siLCJoYXNUY3AiLCJoYXNJcHY0VWRwIiwicHJldlRyaWNrbGUiLCJpc0lQUHJpdmF0ZSIsIlJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCIsImVycm9yQ29kZSIsImVycm9yVGV4dCIsInNlY29uZCIsIldlYlNvY2tldENoZWNrIiwiZWRpdGlvbiIsIkNsb3VkIiwiQ29ubmVjdGlvbkNoZWNrIiwiY2hlY2tSZXN1bHRzIiwiZ2V0TmV4dENoZWNrSWQiLCJuZXh0SWQiLCJ1cGRhdGVDaGVjayIsImNoZWNrSWQiLCJnZXRSZXN1bHRzIiwiY3JlYXRlQW5kUnVuQ2hlY2siLCJjaGVjayIsImhhbmRsZVVwZGF0ZSIsImNoZWNrV2Vic29ja2V0IiwiY2hlY2tXZWJSVEMiLCJjaGVja1RVUk4iLCJjaGVja1JlY29ubmVjdCIsImNoZWNrUHVibGlzaEF1ZGlvIiwiY2hlY2tQdWJsaXNoVmlkZW8iLCJUb2tlblNvdXJjZUZpeGVkIiwiVG9rZW5Tb3VyY2VDb25maWd1cmFibGUiLCJfZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiZGVjb2RlQmFzZTY0IiwiZnJvbUJhc2U2NCIsImJpbmFyeSIsImF0b2IiLCJhbHBoYWJldCIsIl91bnVzZWQiLCJKT1NFRXJyb3IiLCJfRXJyb3IkY2FwdHVyZVN0YWNrVHIiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkpXVENsYWltVmFsaWRhdGlvbkZhaWxlZCIsImNsYWltIiwiY2F1c2UiLCJKV1RFeHBpcmVkIiwiSk9TRUFsZ05vdEFsbG93ZWQiLCJKT1NFTm90U3VwcG9ydGVkIiwiSldFRGVjcnlwdGlvbkZhaWxlZCIsIkpXRUludmFsaWQiLCJKV1NJbnZhbGlkIiwiSldUSW52YWxpZCIsIkpXS0ludmFsaWQiLCJKV0tTSW52YWxpZCIsIkpXS1NOb01hdGNoaW5nS2V5IiwiSldLU011bHRpcGxlTWF0Y2hpbmdLZXlzIiwiSldLU1RpbWVvdXQiLCJKV1NTaWduYXR1cmVWZXJpZmljYXRpb25GYWlsZWQiLCJpc09iamVjdExpa2UiLCJpc09iamVjdCIsImRlY29kZUp3dCIsImp3dCIsImRlY29kZWQiLCJfdW51c2VkMiIsIk9ORV9TRUNPTkRfSU5fTUlMTElTRUNPTkRTIiwiT05FX01JTlVURV9JTl9NSUxMSVNFQ09ORFMiLCJpc1Jlc3BvbnNlVG9rZW5WYWxpZCIsImp3dFBheWxvYWQiLCJkZWNvZGVUb2tlblBheWxvYWQiLCJwYXJ0aWNpcGFudFRva2VuIiwibmJmIiwibmJmSW5NaWxsaXNlY29uZHMiLCJuYmZEYXRlIiwiZXhwSW5NaWxsaXNlY29uZHMiLCJleHBEYXRlIiwicm9vbUNvbmZpZyIsInJlc3QiLCJtYXBwZWRQYXlsb2FkIiwiYXJlVG9rZW5Tb3VyY2VGZXRjaE9wdGlvbnNFcXVhbCIsImFsbEtleXNTZXQiLCJleGhhdXN0aXZlQ2hlY2tlZEtleSIsIlRva2VuU291cmNlQ2FjaGVkIiwiY2FjaGVkRmV0Y2hPcHRpb25zIiwiY2FjaGVkUmVzcG9uc2UiLCJmZXRjaE11dGV4IiwiaXNTYW1lQXNDYWNoZWRGZXRjaE9wdGlvbnMiLCJzaG91bGRSZXR1cm5DYWNoZWRWYWx1ZUZyb21GZXRjaCIsImZldGNoT3B0aW9ucyIsImdldENhY2hlZFJlc3BvbnNlSnd0UGF5bG9hZCIsInRva2VuUmVzcG9uc2UiLCJUb2tlblNvdXJjZUxpdGVyYWwiLCJsaXRlcmFsT3JGbiIsIlRva2VuU291cmNlQ3VzdG9tIiwiY3VzdG9tRm4iLCJyZXN1bHRNYXliZVByb21pc2UiLCJUb2tlblNvdXJjZUVuZHBvaW50IiwiZW5kcG9pbnRPcHRpb25zIiwiY3JlYXRlUmVxdWVzdEZyb21PcHRpb25zIiwicmVxdWVzdCIsInBhcnRpY2lwYW50QXR0cmlidXRlcyIsImFnZW50cyIsImFnZW50TmFtZSIsImFnZW50TWV0YWRhdGEiLCJUb2tlblNvdXJjZVNhbmRib3hUb2tlblNlcnZlciIsInNhbmRib3hJZCIsImJhc2VVcmwiLCJUb2tlblNvdXJjZSIsImxpdGVyYWwiLCJjdXN0b20iLCJlbmRwb2ludCIsInNhbmRib3hUb2tlblNlcnZlciIsImZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayIsInRyYWNrU2V0dGluZ3MiLCJkZWZhdWx0RmFjaW5nTW9kZSIsImNvbmZpZGVuY2UiLCJyYXdGYWNpbmdNb2RlIiwiaXNGYWNpbmdNb2RlVmFsdWUiLCJsYWJlbEFuYWx5c2lzUmVzdWx0IiwiZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCIsImtub3duRGV2aWNlTGFiZWxzIiwia25vd25EZXZpY2VMYWJlbFNlY3Rpb25zIiwiZGV2aWNlTGFiZWwiLCJzZWN0aW9uIiwiYWxsb3dlZFZhbHVlcyIsIk11dGV4IiwiUGFydGljaXBhbnRLaW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/livekit-client@2.16.0_@types+dom-mediacapture-record@1.0.22/node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;