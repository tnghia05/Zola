"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/call/page",{

/***/ "(app-pages-browser)/../../packages/app/hooks/useWebRTC.js":
/*!*********************************************!*\
  !*** ../../packages/app/hooks/useWebRTC.js ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWebRTC: function() { return /* binding */ useWebRTC; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.0.4_@babel+core@7.2_e51c94e397bd2e219e1912d446a17ff6/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../socket */ \"(app-pages-browser)/../../packages/app/socket.js\");\nvar _s = $RefreshSig$();\n\n\nconst FILTER_CONFIG = {\n    none: {\n        label: \"Gốc\",\n        emoji: \"\\uD83D\\uDE42\"\n    },\n    beauty: {\n        label: \"Mịn\",\n        emoji: \"✨\",\n        cssFilter: \"brightness(1.08) contrast(1.05) saturate(1.25)\"\n    },\n    warm: {\n        label: \"Ấm\",\n        emoji: \"\\uD83C\\uDF05\",\n        cssFilter: \"brightness(1.05) saturate(1.25) hue-rotate(-5deg)\"\n    },\n    cool: {\n        label: \"M\\xe1t\",\n        emoji: \"❄️\",\n        cssFilter: \"brightness(1.08) saturate(1.15) hue-rotate(185deg)\"\n    },\n    party: {\n        label: \"Party\",\n        emoji: \"\\uD83C\\uDF89\",\n        cssFilter: \"brightness(1.05) saturate(1.25)\",\n        overlay: (ctx, width, height, time)=>{\n            ctx.save();\n            ctx.globalAlpha = 0.35;\n            for(let i = 0; i < 20; i += 1){\n                const x = (i * 73 + time / 12 % width) % width;\n                const y = (i * 41 + time / 18 % height) % height;\n                const size = 12 + i % 5 * 3;\n                ctx.fillStyle = [\n                    \"#ff6b6b\",\n                    \"#ffd93d\",\n                    \"#6bc2ff\",\n                    \"#b070ff\"\n                ][i % 4];\n                ctx.beginPath();\n                ctx.arc(x, y, size, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            ctx.restore();\n        }\n    },\n    birthday: {\n        label: \"Sinh nhật\",\n        emoji: \"\\uD83C\\uDF82\",\n        cssFilter: \"brightness(1.05) saturate(1.15)\",\n        overlay: (ctx, width, height)=>{\n            ctx.save();\n            // Balloons\n            const balloonColors = [\n                \"#ff7eb6\",\n                \"#7dbbff\",\n                \"#ffd966\"\n            ];\n            balloonColors.forEach((color, index)=>{\n                const bx = index === 0 ? width * 0.15 : index === 1 ? width * 0.85 : width * 0.5;\n                const by = index === 2 ? height * 0.2 : height * 0.15;\n                const radius = index === 2 ? 80 : 70;\n                const gradient = ctx.createRadialGradient(bx - 20, by - 30, 20, bx, by, radius);\n                gradient.addColorStop(0, \"#ffffff\");\n                gradient.addColorStop(0.2, \"#ffffff\");\n                gradient.addColorStop(1, color);\n                ctx.fillStyle = gradient;\n                ctx.beginPath();\n                ctx.ellipse(bx, by, radius * 0.75, radius, 0, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.strokeStyle = \"#ffffff\";\n                ctx.lineWidth = 2;\n                ctx.beginPath();\n                ctx.moveTo(bx, by + radius);\n                ctx.quadraticCurveTo(bx - 10, by + radius + 60, bx, by + radius + 110);\n                ctx.stroke();\n            });\n            // Party hat\n            ctx.fillStyle = \"#ff8ce6\";\n            ctx.beginPath();\n            ctx.moveTo(width / 2, height * 0.02);\n            ctx.lineTo(width / 2 - 80, height * 0.28);\n            ctx.lineTo(width / 2 + 80, height * 0.28);\n            ctx.closePath();\n            ctx.fill();\n            ctx.fillStyle = \"rgba(255,255,255,0.45)\";\n            for(let i = -60; i <= 60; i += 30){\n                ctx.beginPath();\n                ctx.arc(width / 2 + i, height * 0.18, 18, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            // Cake base\n            const cakeHeight = 90;\n            ctx.fillStyle = \"#ffd1dc\";\n            ctx.fillRect(width * 0.2, height - cakeHeight - 20, width * 0.6, cakeHeight);\n            ctx.fillStyle = \"#ff9ebe\";\n            ctx.fillRect(width * 0.2, height - cakeHeight - 20, width * 0.6, 25);\n            // Candles\n            for(let i = -1; i <= 1; i++){\n                const cx = width / 2 + i * 35;\n                ctx.fillStyle = \"#5dade2\";\n                ctx.fillRect(cx - 6, height - cakeHeight - 60, 12, 40);\n                ctx.fillStyle = \"#ffd966\";\n                ctx.beginPath();\n                ctx.ellipse(cx, height - cakeHeight - 68, 7, 10, 0, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            ctx.restore();\n        }\n    }\n};\nconst ICE_SERVERS = [\n    {\n        urls: \"stun:stun.l.google.com:19302\"\n    },\n    {\n        urls: \"stun:stun1.l.google.com:19302\"\n    },\n    {\n        urls: \"stun:stun2.l.google.com:19302\"\n    },\n    {\n        urls: \"stun:stun3.l.google.com:19302\"\n    },\n    {\n        urls: \"stun:stun4.l.google.com:19302\"\n    },\n    // Free TURN servers from Open Relay Project\n    {\n        urls: \"turn:openrelay.metered.ca:80\",\n        username: \"openrelayproject\",\n        credential: \"openrelayproject\"\n    },\n    {\n        urls: \"turn:openrelay.metered.ca:443\",\n        username: \"openrelayproject\",\n        credential: \"openrelayproject\"\n    },\n    {\n        urls: \"turn:openrelay.metered.ca:443?transport=tcp\",\n        username: \"openrelayproject\",\n        credential: \"openrelayproject\"\n    }\n];\nfunction useWebRTC(param) {\n    let { callId, conversationId: _conversationId, isInitiator, localUserId: _localUserId, remoteUserId, videoDeviceId, audioDeviceId } = param;\n    _s();\n    const [localStream, setLocalStream] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [remoteStream, setRemoteStream] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isVideoEnabled, setIsVideoEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [isAudioEnabled, setIsAudioEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [currentFilter, setCurrentFilter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"none\");\n    const [isScreenSharing, setIsScreenSharing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const peerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((0,_socket__WEBPACK_IMPORTED_MODULE_1__.getSocket)());\n    const localVideoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const remoteVideoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Queue for ICE candidates received before remote description is set\n    const iceCandidateQueueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const hasReceivedOfferRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const offerRetryTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const rawCameraStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const screenShareStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processedFilterStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const filterCanvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const filterVideoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const filterAnimationFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const currentFilterRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"none\");\n    // Refs to store latest functions for use in socket handlers (will be set after functions are defined)\n    const initPeerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const getUserMediaRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Sync socketRef with current socket - poll every 500ms until connected\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const syncSocket = ()=>{\n            const currentSocket = (0,_socket__WEBPACK_IMPORTED_MODULE_1__.getSocket)();\n            if (currentSocket && currentSocket.connected) {\n                socketRef.current = currentSocket;\n                console.log(\"[useWebRTC] Socket synced, connected:\", currentSocket.id);\n            } else if (!socketRef.current || !socketRef.current.connected) {\n                socketRef.current = currentSocket;\n            }\n        };\n        // Initial sync\n        syncSocket();\n        // Poll for socket connection\n        const interval = setInterval(syncSocket, 500);\n        return ()=>clearInterval(interval);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        currentFilterRef.current = currentFilter;\n    }, [\n        currentFilter\n    ]);\n    const replaceVideoTrack = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (track)=>{\n        if (!track) return;\n        const pc = peerConnectionRef.current;\n        if (!pc) return;\n        const sender = pc.getSenders().find((s)=>s.track && s.track.kind === \"video\");\n        if (sender) {\n            await sender.replaceTrack(track);\n        }\n    }, []);\n    const stopFilterProcessing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (filterAnimationFrameRef.current) {\n            cancelAnimationFrame(filterAnimationFrameRef.current);\n            filterAnimationFrameRef.current = null;\n        }\n        if (processedFilterStreamRef.current) {\n            processedFilterStreamRef.current.getTracks().forEach((track)=>track.stop());\n            processedFilterStreamRef.current = null;\n        }\n        if (filterVideoRef.current) {\n            try {\n                filterVideoRef.current.pause();\n            } catch (err) {\n            // ignore\n            }\n            filterVideoRef.current.srcObject = null;\n            filterVideoRef.current = null;\n        }\n        filterCanvasRef.current = null;\n    }, []);\n    const startFilterProcessing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((filter)=>{\n        const rawStream = rawCameraStreamRef.current;\n        if (!rawStream) return;\n        stopFilterProcessing();\n        const videoEl = document.createElement(\"video\");\n        videoEl.srcObject = rawStream;\n        videoEl.muted = true;\n        videoEl.playsInline = true;\n        videoEl.autoplay = true;\n        videoEl.play().catch(()=>{});\n        filterVideoRef.current = videoEl;\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) {\n            console.error(\"[Filter] Canvas context unavailable\");\n            return;\n        }\n        filterCanvasRef.current = canvas;\n        const render = ()=>{\n            if (!filterVideoRef.current) {\n                return;\n            }\n            const video = filterVideoRef.current;\n            const width = video.videoWidth || 640;\n            const height = video.videoHeight || 480;\n            if (width === 0 || height === 0) {\n                filterAnimationFrameRef.current = requestAnimationFrame(render);\n                return;\n            }\n            if (canvas.width !== width || canvas.height !== height) {\n                canvas.width = width;\n                canvas.height = height;\n            }\n            ctx.clearRect(0, 0, width, height);\n            const config = FILTER_CONFIG[filter];\n            ctx.filter = config.cssFilter || \"none\";\n            ctx.drawImage(video, 0, 0, width, height);\n            ctx.filter = \"none\";\n            if (config.overlay) {\n                config.overlay(ctx, width, height, performance.now());\n            }\n            filterAnimationFrameRef.current = requestAnimationFrame(render);\n        };\n        render();\n        const processedStream = canvas.captureStream(30);\n        processedFilterStreamRef.current = processedStream;\n        const processedTrack = processedStream.getVideoTracks()[0];\n        replaceVideoTrack(processedTrack);\n        setLocalStream(processedStream);\n    }, [\n        replaceVideoTrack,\n        stopFilterProcessing\n    ]);\n    const stopScreenShare = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!screenShareStreamRef.current) return;\n        screenShareStreamRef.current.getTracks().forEach((track)=>track.stop());\n        screenShareStreamRef.current = null;\n        setIsScreenSharing(false);\n        const cameraStream = rawCameraStreamRef.current;\n        if (!cameraStream) return;\n        if (currentFilterRef.current !== \"none\") {\n            startFilterProcessing(currentFilterRef.current);\n        } else {\n            const cameraTrack = cameraStream.getVideoTracks()[0];\n            await replaceVideoTrack(cameraTrack);\n            setLocalStream(cameraStream);\n        }\n    }, [\n        replaceVideoTrack,\n        startFilterProcessing\n    ]);\n    const startScreenShare = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isScreenSharing) return;\n        try {\n            var _navigator_mediaDevices;\n            const electronAPI =  true ? window.electronAPI : 0;\n            let shareStream = null;\n            if (electronAPI === null || electronAPI === void 0 ? void 0 : electronAPI.selectScreenSource) {\n                const sourceId = await electronAPI.selectScreenSource();\n                if (!sourceId) {\n                    setError(\"Kh\\xf4ng t\\xecm thấy m\\xe0n h\\xecnh để chia sẻ.\");\n                    return;\n                }\n                const electronConstraints = {\n                    audio: false,\n                    video: {\n                        mandatory: {\n                            chromeMediaSource: \"desktop\",\n                            chromeMediaSourceId: sourceId,\n                            maxFrameRate: 30,\n                            minFrameRate: 5\n                        }\n                    }\n                };\n                shareStream = await navigator.mediaDevices.getUserMedia(electronConstraints);\n            } else if ((_navigator_mediaDevices = navigator.mediaDevices) === null || _navigator_mediaDevices === void 0 ? void 0 : _navigator_mediaDevices.getDisplayMedia) {\n                shareStream = await navigator.mediaDevices.getDisplayMedia({\n                    video: {\n                        frameRate: 30,\n                        width: {\n                            ideal: 1920\n                        },\n                        height: {\n                            ideal: 1080\n                        },\n                        displaySurface: \"monitor\"\n                    },\n                    audio: false\n                });\n            } else {\n                throw new Error(\"SCREEN_SHARE_NOT_SUPPORTED\");\n            }\n            screenShareStreamRef.current = shareStream;\n            const track = shareStream.getVideoTracks()[0];\n            track.onended = ()=>{\n                stopScreenShare().catch(()=>{});\n            };\n            stopFilterProcessing();\n            setLocalStream(shareStream);\n            await replaceVideoTrack(track);\n            setIsScreenSharing(true);\n        } catch (err) {\n            console.error(\"[ScreenShare] Error starting screen share:\", err);\n            if ((err === null || err === void 0 ? void 0 : err.name) === \"NotAllowedError\") {\n                setError(\"Bạn đ\\xe3 từ chối quyền chia sẻ m\\xe0n h\\xecnh.\");\n            } else if ((err === null || err === void 0 ? void 0 : err.name) === \"NotFoundError\") {\n                setError(\"Kh\\xf4ng t\\xecm thấy m\\xe0n h\\xecnh ph\\xf9 hợp để chia sẻ.\");\n            } else {\n                setError(\"Chia sẻ m\\xe0n h\\xecnh chưa được hỗ trợ trong m\\xf4i trường n\\xe0y.\");\n            }\n            throw err;\n        }\n    }, [\n        isScreenSharing,\n        replaceVideoTrack,\n        stopFilterProcessing,\n        stopScreenShare\n    ]);\n    const applyFilter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (filter)=>{\n        setCurrentFilter(filter);\n        if (isScreenSharing) {\n            console.warn(\"[Filter] Cannot apply filter while sharing screen\");\n            return;\n        }\n        if (!rawCameraStreamRef.current) return;\n        if (filter === \"none\") {\n            stopFilterProcessing();\n            const cameraTrack = rawCameraStreamRef.current.getVideoTracks()[0];\n            await replaceVideoTrack(cameraTrack);\n            setLocalStream(rawCameraStreamRef.current);\n            return;\n        }\n        startFilterProcessing(filter);\n    }, [\n        isScreenSharing,\n        replaceVideoTrack,\n        startFilterProcessing,\n        stopFilterProcessing\n    ]);\n    // ============================================================================\n    // ERROR HANDLING HELPERS\n    // ============================================================================\n    const handleGetUserMediaError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((err)=>{\n        const timestamp = new Date().toISOString();\n        console.error(\"[getUserMedia ERROR] \".concat(timestamp));\n        console.error(\"[getUserMedia ERROR] Error name: \".concat(err.name));\n        console.error(\"[getUserMedia ERROR] Error message: \".concat(err.message));\n        console.error(\"[getUserMedia ERROR] Full error:\", err);\n        switch(err.name){\n            case \"NotAllowedError\":\n                console.error(\"[getUserMedia ERROR] NotAllowedError: Permission denied by user or system\");\n                return \"Camera/microphone permission denied. Please allow access in Windows Settings (Privacy → Camera/Microphone).\";\n            case \"NotFoundError\":\n                console.error(\"[getUserMedia ERROR] NotFoundError: No media device found\");\n                return \"No camera/microphone found. Please connect a device.\";\n            case \"NotReadableError\":\n                console.error(\"[getUserMedia ERROR] NotReadableError: Device is already in use\");\n                return \"Camera/microphone is already in use by another application.\";\n            case \"OverconstrainedError\":\n                console.error(\"[getUserMedia ERROR] OverconstrainedError: Constraints cannot be satisfied\");\n                return \"Camera/microphone constraints cannot be satisfied. Please try different settings.\";\n            case \"SecurityError\":\n                console.error(\"[getUserMedia ERROR] SecurityError: Not in secure context\");\n                return \"Security error: App must run in secure context.\";\n            case \"TypeError\":\n                console.error(\"[getUserMedia ERROR] TypeError: Invalid constraints or API not available\");\n                return \"Invalid media constraints or API not available.\";\n            default:\n                console.error(\"[getUserMedia ERROR] Unknown error: \".concat(err.name));\n                return err.message || \"Failed to access camera/microphone.\";\n        }\n    }, []);\n    // ============================================================================\n    // GET USER MEDIA WITH DETAILED ERROR HANDLING\n    // ============================================================================\n    const getUserMedia = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (video, audio)=>{\n        const timestamp = new Date().toISOString();\n        console.log(\"[getUserMedia] \".concat(timestamp, \" - Starting request\"));\n        console.log(\"[getUserMedia] Video: \".concat(video, \", Audio: \").concat(audio));\n        // Check if mediaDevices API is available\n        if (!navigator.mediaDevices) {\n            const errorMsg = \"MediaDevices API is not available in this browser.\";\n            console.error(\"[getUserMedia ERROR] \".concat(errorMsg));\n            throw new Error(errorMsg);\n        }\n        if (!navigator.mediaDevices.getUserMedia) {\n            const errorMsg = \"getUserMedia is not supported in this browser.\";\n            console.error(\"[getUserMedia ERROR] \".concat(errorMsg));\n            throw new Error(errorMsg);\n        }\n        // Log environment info\n        console.log(\"[getUserMedia] Environment info:\");\n        console.log(\"[getUserMedia] Origin: \".concat(window.location.origin));\n        console.log(\"[getUserMedia] URL: \".concat(window.location.href));\n        console.log(\"[getUserMedia] Is secure context: \".concat(window.isSecureContext));\n        console.log(\"[getUserMedia] MediaDevices available: \".concat(!!navigator.mediaDevices));\n        // Prepare constraints with device selection\n        const constraints = {\n            video: video ? videoDeviceId ? {\n                deviceId: {\n                    exact: videoDeviceId\n                },\n                width: {\n                    ideal: 1280\n                },\n                height: {\n                    ideal: 720\n                }\n            } : {\n                width: {\n                    ideal: 1280\n                },\n                height: {\n                    ideal: 720\n                },\n                facingMode: \"user\"\n            } : false,\n            audio: audio ? audioDeviceId ? {\n                deviceId: {\n                    exact: audioDeviceId\n                },\n                echoCancellation: true,\n                noiseSuppression: true,\n                autoGainControl: true\n            } : {\n                echoCancellation: true,\n                noiseSuppression: true,\n                autoGainControl: true\n            } : false\n        };\n        if (videoDeviceId) {\n            console.log(\"[getUserMedia] Using selected video device: \".concat(videoDeviceId));\n        }\n        if (audioDeviceId) {\n            console.log(\"[getUserMedia] Using selected audio device: \".concat(audioDeviceId));\n        }\n        console.log(\"[getUserMedia] Constraints:\", JSON.stringify(constraints, null, 2));\n        try {\n            console.log(\"[getUserMedia] Calling navigator.mediaDevices.getUserMedia...\");\n            const stream = await navigator.mediaDevices.getUserMedia(constraints);\n            console.log(\"[getUserMedia] ✅ Success! Stream obtained\");\n            console.log(\"[getUserMedia] Stream ID: \".concat(stream.id));\n            console.log(\"[getUserMedia] Stream active: \".concat(stream.active));\n            console.log(\"[getUserMedia] Tracks:\", stream.getTracks().map((track)=>({\n                    kind: track.kind,\n                    id: track.id,\n                    label: track.label,\n                    enabled: track.enabled,\n                    muted: track.muted,\n                    readyState: track.readyState\n                })));\n            if (rawCameraStreamRef.current && rawCameraStreamRef.current !== stream) {\n                rawCameraStreamRef.current.getTracks().forEach((track)=>track.stop());\n            }\n            rawCameraStreamRef.current = stream;\n            if (!isScreenSharing && currentFilterRef.current === \"none\") {\n                setLocalStream(stream);\n            }\n            setError(null);\n            // Add tracks to peer connection if it exists\n            if (peerConnectionRef.current) {\n                stream.getTracks().forEach((track)=>{\n                    var _peerConnectionRef_current;\n                    console.log(\"[getUserMedia] Adding \".concat(track.kind, \" track to peer connection\"));\n                    (_peerConnectionRef_current = peerConnectionRef.current) === null || _peerConnectionRef_current === void 0 ? void 0 : _peerConnectionRef_current.addTrack(track, stream);\n                });\n            }\n            if (!isScreenSharing && currentFilterRef.current !== \"none\") {\n                startFilterProcessing(currentFilterRef.current);\n            }\n            return stream;\n        } catch (err) {\n            const errorMessage = handleGetUserMediaError(err);\n            setError(errorMessage);\n            throw err;\n        }\n    }, [\n        handleGetUserMediaError,\n        isScreenSharing,\n        startFilterProcessing\n    ]);\n    // Update getUserMedia ref\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        getUserMediaRef.current = getUserMedia;\n    }, [\n        getUserMedia\n    ]);\n    // ============================================================================\n    // INITIALIZE PEER CONNECTION\n    // ============================================================================\n    const initPeerConnection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"[PeerConnection] Initializing...\");\n        if (peerConnectionRef.current) {\n            console.log(\"[PeerConnection] Closing existing connection\");\n            peerConnectionRef.current.close();\n        }\n        const pc = new RTCPeerConnection({\n            iceServers: ICE_SERVERS\n        });\n        console.log(\"[PeerConnection] Created new RTCPeerConnection\");\n        // Handle ICE candidates\n        pc.onicecandidate = (event)=>{\n            if (event.candidate) {\n                console.log(\"[PeerConnection] ICE candidate:\", event.candidate);\n                const socket = socketRef.current;\n                if (socket) {\n                    socket.emit(\"webrtc:ice-candidate\", {\n                        callId,\n                        candidate: event.candidate,\n                        targetUserId: remoteUserId\n                    });\n                }\n            } else {\n                console.log(\"[PeerConnection] ICE gathering complete\");\n            }\n        };\n        // Handle connection state changes\n        pc.onconnectionstatechange = ()=>{\n            const state = pc.connectionState;\n            console.log(\"[PeerConnection] Connection state: \".concat(state));\n            if (state === \"connected\") {\n                setIsConnected(true);\n                setError(null);\n            } else if (state === \"disconnected\" || state === \"failed\" || state === \"closed\") {\n                setIsConnected(false);\n            }\n        };\n        // Handle remote stream\n        pc.ontrack = (event)=>{\n            console.log(\"[PeerConnection] Received remote track:\", event.track.kind);\n            if (event.streams && event.streams[0]) {\n                console.log(\"[PeerConnection] Setting remote stream\");\n                setRemoteStream(event.streams[0]);\n            }\n        };\n        // Handle ICE connection state\n        pc.oniceconnectionstatechange = ()=>{\n            const state = pc.iceConnectionState;\n            console.log(\"[PeerConnection] ICE connection state: \".concat(state));\n            if (state === \"failed\") {\n                console.error(\"[PeerConnection] ICE connection failed\");\n                setError(\"Connection failed. Please try again.\");\n            }\n        };\n        peerConnectionRef.current = pc;\n        return pc;\n    }, [\n        callId,\n        remoteUserId\n    ]);\n    // Update initPeerConnection ref\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        initPeerConnectionRef.current = initPeerConnection;\n    }, [\n        initPeerConnection\n    ]);\n    const requestOffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((reason)=>{\n        const socket = socketRef.current;\n        if (!socket) {\n            console.warn(\"[Socket] Cannot request offer - socket not available\");\n            return;\n        }\n        console.log(\"[Socket] Requesting offer (\".concat(reason, \") for callId \").concat(callId));\n        socket.emit(\"webrtc:request-offer\", {\n            callId,\n            fromUserId: _localUserId,\n            targetUserId: remoteUserId\n        });\n    }, [\n        callId,\n        _localUserId,\n        remoteUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (offerRetryTimerRef.current) {\n                clearInterval(offerRetryTimerRef.current);\n                offerRetryTimerRef.current = null;\n            }\n        };\n    }, []);\n    // ============================================================================\n    // START CALL\n    // ============================================================================\n    const startCall = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const timestamp = new Date().toISOString();\n        console.log(\"[startCall] \".concat(timestamp, \" - Starting call\"));\n        console.log(\"[startCall] Call ID: \".concat(callId));\n        console.log(\"[startCall] Is initiator: \".concat(isInitiator));\n        try {\n            setError(null);\n            const socket = socketRef.current;\n            if (!socket) {\n                throw new Error(\"Socket not connected\");\n            }\n            // Initialize peer connection\n            const pc = initPeerConnection();\n            // Get user media (both initiator and non-initiator need this)\n            console.log(\"[startCall] Requesting user media...\");\n            await getUserMedia(isVideoEnabled, isAudioEnabled);\n            if (isInitiator) {\n                var _offer_sdp;\n                // Initiator: Create and send offer\n                console.log(\"[startCall] Creating offer...\");\n                console.log(\"[startCall] Initiator details:\", {\n                    callId,\n                    remoteUserId,\n                    socketConnected: socket.connected,\n                    socketId: socket.id\n                });\n                const offer = await pc.createOffer();\n                console.log(\"[startCall] Offer created:\", {\n                    type: offer.type,\n                    sdpLength: (_offer_sdp = offer.sdp) === null || _offer_sdp === void 0 ? void 0 : _offer_sdp.length\n                });\n                await pc.setLocalDescription(offer);\n                console.log(\"[startCall] Local description set, signalingState:\", pc.signalingState);\n                // Send offer\n                console.log(\"[startCall] Sending offer via socket...\");\n                const offerData = {\n                    callId,\n                    offer: offer,\n                    targetUserId: remoteUserId\n                };\n                console.log(\"[startCall] Offer data to send:\", {\n                    callId: offerData.callId,\n                    targetUserId: offerData.targetUserId,\n                    offerType: offerData.offer.type\n                });\n                socket.emit(\"webrtc:offer\", offerData);\n                console.log(\"[startCall] ✅ Offer emitted to socket\");\n                // Verify socket is connected\n                if (!socket.connected) {\n                    console.error(\"[startCall] ⚠️ Socket not connected when sending offer!\");\n                }\n            } else {\n                // Non-initiator: Just setup peer connection and wait for offer\n                // The offer handler will create answer when offer is received\n                console.log(\"[startCall] Non-initiator: Peer connection ready, waiting for offer...\");\n                console.log(\"[startCall] Socket listeners should be set up to receive offer\");\n                hasReceivedOfferRef.current = false;\n                requestOffer(\"start\");\n                if (offerRetryTimerRef.current) {\n                    clearInterval(offerRetryTimerRef.current);\n                }\n                offerRetryTimerRef.current = setInterval(()=>{\n                    if (hasReceivedOfferRef.current) {\n                        if (offerRetryTimerRef.current) {\n                            clearInterval(offerRetryTimerRef.current);\n                            offerRetryTimerRef.current = null;\n                        }\n                        return;\n                    }\n                    requestOffer(\"retry\");\n                }, 2000);\n            }\n        } catch (err) {\n            console.error(\"[startCall] Error:\", err);\n            const errorMessage = err.message || \"Failed to start call\";\n            setError(errorMessage);\n        }\n    }, [\n        callId,\n        isInitiator,\n        remoteUserId,\n        isVideoEnabled,\n        isAudioEnabled,\n        initPeerConnection,\n        getUserMedia,\n        requestOffer\n    ]);\n    // ============================================================================\n    // END CALL\n    // ============================================================================\n    const endCall = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"[endCall] Ending call...\");\n        stopFilterProcessing();\n        stopScreenShare().catch(()=>{});\n        // Stop local stream tracks\n        if (localStream) {\n            console.log(\"[endCall] Stopping local stream tracks\");\n            localStream.getTracks().forEach((track)=>{\n                track.stop();\n                console.log(\"[endCall] Stopped \".concat(track.kind, \" track\"));\n            });\n            setLocalStream(null);\n        }\n        if (rawCameraStreamRef.current) {\n            rawCameraStreamRef.current.getTracks().forEach((track)=>track.stop());\n            rawCameraStreamRef.current = null;\n        }\n        // Stop remote stream tracks\n        if (remoteStream) {\n            console.log(\"[endCall] Stopping remote stream tracks\");\n            remoteStream.getTracks().forEach((track)=>{\n                track.stop();\n            });\n            setRemoteStream(null);\n        }\n        // Close peer connection\n        if (peerConnectionRef.current) {\n            console.log(\"[endCall] Closing peer connection\");\n            peerConnectionRef.current.close();\n            peerConnectionRef.current = null;\n        }\n        setIsConnected(false);\n        setError(null);\n        console.log(\"[endCall] Call ended\");\n    }, [\n        localStream,\n        remoteStream,\n        stopFilterProcessing,\n        stopScreenShare\n    ]);\n    // ============================================================================\n    // TOGGLE VIDEO/AUDIO\n    // ============================================================================\n    const toggleVideo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"[toggleVideo] Current state: \".concat(isVideoEnabled, \", toggling...\"));\n        setIsVideoEnabled(!isVideoEnabled);\n        if (localStream) {\n            const videoTracks = localStream.getVideoTracks();\n            videoTracks.forEach((track)=>{\n                track.enabled = !isVideoEnabled;\n                console.log(\"[toggleVideo] Video track \".concat(track.id, \" enabled: \").concat(track.enabled));\n            });\n        }\n    }, [\n        isVideoEnabled,\n        localStream\n    ]);\n    const toggleAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"[toggleAudio] Current state: \".concat(isAudioEnabled, \", toggling...\"));\n        setIsAudioEnabled(!isAudioEnabled);\n        if (localStream) {\n            const audioTracks = localStream.getAudioTracks();\n            audioTracks.forEach((track)=>{\n                track.enabled = !isAudioEnabled;\n                console.log(\"[toggleAudio] Audio track \".concat(track.id, \" enabled: \").concat(track.enabled));\n            });\n        }\n    }, [\n        isAudioEnabled,\n        localStream\n    ]);\n    // ============================================================================\n    // SETUP SOCKET LISTENERS\n    // ============================================================================\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const socket = socketRef.current;\n        if (!socket) {\n            console.log(\"[Socket] Socket not available, skipping listener setup\");\n            return;\n        }\n        // Setup listeners even if peer connection not ready yet\n        // Peer connection will be created in startCall()\n        console.log(\"[Socket] Setting up WebRTC listeners for callId:\", callId);\n        const handleOffer = async (data)=>{\n            var _data_offer, _data_offer_sdp, _data_offer1;\n            console.log(\"[Socket] ===== OFFER RECEIVED =====\");\n            console.log(\"[Socket] Offer data:\", {\n                callId: data.callId,\n                expectedCallId: callId,\n                fromUserId: data.fromUserId,\n                offerType: (_data_offer = data.offer) === null || _data_offer === void 0 ? void 0 : _data_offer.type,\n                offerSdpLength: (_data_offer1 = data.offer) === null || _data_offer1 === void 0 ? void 0 : (_data_offer_sdp = _data_offer1.sdp) === null || _data_offer_sdp === void 0 ? void 0 : _data_offer_sdp.length\n            });\n            hasReceivedOfferRef.current = true;\n            if (offerRetryTimerRef.current) {\n                clearInterval(offerRetryTimerRef.current);\n                offerRetryTimerRef.current = null;\n            }\n            if (data.callId !== callId) {\n                console.log(\"[Socket] ❌ Offer callId mismatch:\", data.callId, \"expected:\", callId);\n                return;\n            }\n            console.log(\"[Socket] ✅ Offer callId matches, processing...\");\n            try {\n                let pc = peerConnectionRef.current;\n                // If peer connection doesn't exist or is closed, create a new one\n                const isClosed = !pc || pc.signalingState === \"closed\" || pc.connectionState === \"closed\";\n                if (isClosed) {\n                    console.log(\"[Socket] Peer connection not found or closed, creating new one...\");\n                    if (!initPeerConnectionRef.current) {\n                        console.error(\"[Socket] initPeerConnection not available\");\n                        return;\n                    }\n                    pc = initPeerConnectionRef.current();\n                    // Get user media if not already obtained\n                    if (!localStream) {\n                        console.log(\"[Socket] Getting user media for answer...\");\n                        if (!getUserMediaRef.current) {\n                            console.error(\"[Socket] getUserMedia not available\");\n                            return;\n                        }\n                        await getUserMediaRef.current(isVideoEnabled, isAudioEnabled);\n                    }\n                    // Double check after creating - if still closed, something went wrong\n                    if (pc.signalingState === \"closed\" || pc.connectionState === \"closed\") {\n                        console.error(\"[Socket] Peer connection was closed immediately after creation\");\n                        return;\n                    }\n                }\n                // Final check - ensure pc is not null\n                if (!pc) {\n                    console.error(\"[Socket] Peer connection is null after creation\");\n                    return;\n                }\n                // Final check signaling state before setting remote description\n                if (pc.signalingState === \"closed\" || pc.connectionState === \"closed\") {\n                    console.error(\"[Socket] Cannot set remote description: peer connection is closed\");\n                    console.error(\"[Socket] Signaling state:\", pc.signalingState, \"Connection state:\", pc.connectionState);\n                    return;\n                }\n                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));\n                console.log(\"[Socket] Remote description set\");\n                // Process queued ICE candidates now that remote description is set\n                if (iceCandidateQueueRef.current.length > 0) {\n                    console.log(\"[Socket] Processing \".concat(iceCandidateQueueRef.current.length, \" queued ICE candidates\"));\n                    for (const candidate of iceCandidateQueueRef.current){\n                        try {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"[Socket] Queued ICE candidate added\");\n                        } catch (err) {\n                            console.error(\"[Socket] Error adding queued ICE candidate:\", err);\n                        }\n                    }\n                    iceCandidateQueueRef.current = [];\n                }\n                const answer = await pc.createAnswer();\n                await pc.setLocalDescription(answer);\n                console.log(\"[Socket] Answer created and set, signalingState:\", pc.signalingState);\n                const answerData = {\n                    callId,\n                    answer: answer,\n                    targetUserId: data.fromUserId\n                };\n                console.log(\"[Socket] Sending answer:\", {\n                    callId: answerData.callId,\n                    targetUserId: answerData.targetUserId,\n                    answerType: answerData.answer.type,\n                    socketConnected: socket.connected,\n                    socketId: socket.id\n                });\n                socket.emit(\"webrtc:answer\", answerData);\n                console.log(\"[Socket] ✅ Answer emitted to socket\");\n                // Verify socket is connected\n                if (!socket.connected) {\n                    console.error(\"[Socket] ⚠️ Socket not connected when sending answer!\");\n                }\n            } catch (err) {\n                console.error(\"[Socket] Error handling offer:\", err);\n                setError(\"Failed to handle incoming call\");\n            }\n        };\n        const handleAnswer = async (data)=>{\n            var _data_answer, _data_answer_sdp, _data_answer1;\n            console.log(\"[Socket] ===== ANSWER RECEIVED =====\");\n            console.log(\"[Socket] Answer data:\", {\n                callId: data.callId,\n                expectedCallId: callId,\n                fromUserId: data.fromUserId,\n                answerType: (_data_answer = data.answer) === null || _data_answer === void 0 ? void 0 : _data_answer.type,\n                answerSdpLength: (_data_answer1 = data.answer) === null || _data_answer1 === void 0 ? void 0 : (_data_answer_sdp = _data_answer1.sdp) === null || _data_answer_sdp === void 0 ? void 0 : _data_answer_sdp.length\n            });\n            if (data.callId !== callId) {\n                console.log(\"[Socket] ❌ Answer callId mismatch:\", data.callId, \"expected:\", callId);\n                return;\n            }\n            console.log(\"[Socket] ✅ Answer callId matches, processing...\");\n            try {\n                const pc = peerConnectionRef.current;\n                if (!pc) return;\n                await pc.setRemoteDescription(new RTCSessionDescription(data.answer));\n                console.log(\"[Socket] Remote description set from answer\");\n                // Process queued ICE candidates now that remote description is set\n                if (iceCandidateQueueRef.current.length > 0) {\n                    console.log(\"[Socket] Processing \".concat(iceCandidateQueueRef.current.length, \" queued ICE candidates\"));\n                    for (const candidate of iceCandidateQueueRef.current){\n                        try {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"[Socket] Queued ICE candidate added\");\n                        } catch (err) {\n                            console.error(\"[Socket] Error adding queued ICE candidate:\", err);\n                        }\n                    }\n                    iceCandidateQueueRef.current = [];\n                }\n            } catch (err) {\n                console.error(\"[Socket] Error handling answer:\", err);\n                setError(\"Failed to handle call answer\");\n            }\n        };\n        const handleIceCandidate = async (data)=>{\n            if (data.callId !== callId) return;\n            console.log(\"[Socket] Received ICE candidate:\", data);\n            try {\n                const pc = peerConnectionRef.current;\n                if (!pc) {\n                    console.log(\"[Socket] Peer connection not ready, queueing ICE candidate\");\n                    iceCandidateQueueRef.current.push(data.candidate);\n                    return;\n                }\n                // Check if remote description is set\n                if (!pc.remoteDescription) {\n                    console.log(\"[Socket] Remote description not set yet, queueing ICE candidate\");\n                    iceCandidateQueueRef.current.push(data.candidate);\n                    return;\n                }\n                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));\n                console.log(\"[Socket] ICE candidate added\");\n            } catch (err) {\n                // If error is because remote description is null, queue it\n                if (err instanceof Error && err.message.includes(\"remote description\")) {\n                    console.log(\"[Socket] Remote description not set, queueing ICE candidate\");\n                    iceCandidateQueueRef.current.push(data.candidate);\n                } else {\n                    console.error(\"[Socket] Error handling ICE candidate:\", err);\n                }\n            }\n        };\n        socket.on(\"webrtc:offer\", handleOffer);\n        socket.on(\"webrtc:answer\", handleAnswer);\n        socket.on(\"webrtc:ice-candidate\", handleIceCandidate);\n        return ()=>{\n            console.log(\"[Socket] Cleaning up WebRTC listeners\");\n            socket.off(\"webrtc:offer\", handleOffer);\n            socket.off(\"webrtc:answer\", handleAnswer);\n            socket.off(\"webrtc:ice-candidate\", handleIceCandidate);\n        };\n    // Note: We intentionally don't include initPeerConnection, getUserMedia, etc. in deps\n    // to avoid re-setting up listeners. These functions are stable (useCallback).\n    // The handlers use refs/current values when needed.\n    }, [\n        callId\n    ]);\n    // ============================================================================\n    // ATTACH STREAMS TO VIDEO ELEMENTS\n    // ============================================================================\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (localVideoRef.current && localStream) {\n            console.log(\"[Video] Attaching local stream to video element\");\n            localVideoRef.current.srcObject = localStream;\n        }\n    }, [\n        localStream\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (remoteVideoRef.current && remoteStream) {\n            console.log(\"[Video] Attaching remote stream to video element\");\n            remoteVideoRef.current.srcObject = remoteStream;\n        }\n    }, [\n        remoteStream\n    ]);\n    // ============================================================================\n    // CLEANUP ON UNMOUNT\n    // ============================================================================\n    // Use ref to store latest endCall function to avoid cleanup re-running\n    const endCallRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(endCall);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        endCallRef.current = endCall;\n    }, [\n        endCall\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            console.log(\"[Cleanup] Component unmounting, cleaning up...\");\n            // Use ref to call latest endCall without triggering re-runs\n            endCallRef.current();\n        };\n    // Empty deps - only run on unmount\n    }, []);\n    return {\n        localStream,\n        remoteStream,\n        isConnected,\n        error,\n        startCall,\n        endCall,\n        toggleVideo,\n        toggleAudio,\n        isVideoEnabled,\n        isAudioEnabled,\n        applyFilter,\n        currentFilter,\n        startScreenShare,\n        stopScreenShare,\n        isScreenSharing,\n        localVideoRef,\n        remoteVideoRef\n    };\n}\n_s(useWebRTC, \"Hjm9vgxVM5aNXpqTOIvzpdXvo20=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9wYWNrYWdlcy9hcHAvaG9va3MvdXNlV2ViUlRDLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlFO0FBQzNCO0FBQ3RDLE1BQU1LLGdCQUFnQjtJQUNsQkMsTUFBTTtRQUFFQyxPQUFPO1FBQU9DLE9BQU87SUFBSztJQUNsQ0MsUUFBUTtRQUNKRixPQUFPO1FBQ1BDLE9BQU87UUFDUEUsV0FBVztJQUNmO0lBQ0FDLE1BQU07UUFDRkosT0FBTztRQUNQQyxPQUFPO1FBQ1BFLFdBQVc7SUFDZjtJQUNBRSxNQUFNO1FBQ0ZMLE9BQU87UUFDUEMsT0FBTztRQUNQRSxXQUFXO0lBQ2Y7SUFDQUcsT0FBTztRQUNITixPQUFPO1FBQ1BDLE9BQU87UUFDUEUsV0FBVztRQUNYSSxTQUFTLENBQUNDLEtBQUtDLE9BQU9DLFFBQVFDO1lBQzFCSCxJQUFJSSxJQUFJO1lBQ1JKLElBQUlLLFdBQVcsR0FBRztZQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLLEVBQUc7Z0JBQzVCLE1BQU1DLElBQUksQ0FBQ0QsSUFBSSxLQUFLLE9BQVEsS0FBTUwsS0FBSSxJQUFLQTtnQkFDM0MsTUFBTU8sSUFBSSxDQUFDRixJQUFJLEtBQUssT0FBUSxLQUFNSixNQUFLLElBQUtBO2dCQUM1QyxNQUFNTyxPQUFPLEtBQUssSUFBSyxJQUFLO2dCQUM1QlQsSUFBSVUsU0FBUyxHQUFHO29CQUFDO29CQUFXO29CQUFXO29CQUFXO2lCQUFVLENBQUNKLElBQUksRUFBRTtnQkFDbkVOLElBQUlXLFNBQVM7Z0JBQ2JYLElBQUlZLEdBQUcsQ0FBQ0wsR0FBR0MsR0FBR0MsTUFBTSxHQUFHSSxLQUFLQyxFQUFFLEdBQUc7Z0JBQ2pDZCxJQUFJZSxJQUFJO1lBQ1o7WUFDQWYsSUFBSWdCLE9BQU87UUFDZjtJQUNKO0lBQ0FDLFVBQVU7UUFDTnpCLE9BQU87UUFDUEMsT0FBTztRQUNQRSxXQUFXO1FBQ1hJLFNBQVMsQ0FBQ0MsS0FB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QU9vRCxHQUFHLENBQUMsd0JBQXdCTDtRQUN2QztJQUNBLHNGQUFzRjtJQUN0Riw4RUFBOEU7SUFDOUUsb0RBQW9EO0lBQ3hELEdBQUc7UUFBQzNNO0tBQU87SUFDWCwrRUFBK0U7SUFDL0UsbUNBQW1DO0lBQ25DLCtFQUErRTtJQUMvRTNELGdEQUFTQSxDQUFDO1FBQ04sSUFBSXNGLGNBQWNpQixPQUFPLElBQUluQyxhQUFhO1lBQ3RDb0MsUUFBUUMsR0FBRyxDQUFDO1lBQ1puQixjQUFjaUIsT0FBTyxDQUFDc0IsU0FBUyxHQUFHekQ7UUFDdEM7SUFDSixHQUFHO1FBQUNBO0tBQVk7SUFDaEJwRSxnREFBU0EsQ0FBQztRQUNOLElBQUl1RixlQUFlZ0IsT0FBTyxJQUFJakMsY0FBYztZQUN4Q2tDLFFBQVFDLEdBQUcsQ0FBQztZQUNabEIsZUFBZWdCLE9BQU8sQ0FBQ3NCLFNBQVMsR0FBR3ZEO1FBQ3ZDO0lBQ0osR0FBRztRQUFDQTtLQUFhO0lBQ2pCLCtFQUErRTtJQUMvRSxxQkFBcUI7SUFDckIsK0VBQStFO0lBQy9FLHVFQUF1RTtJQUN2RSxNQUFNc00sYUFBYTNRLDZDQUFNQSxDQUFDZ1A7SUFDMUJqUCxnREFBU0EsQ0FBQztRQUNONFEsV0FBV3JLLE9BQU8sR0FBRzBJO0lBQ3pCLEdBQUc7UUFBQ0E7S0FBUTtJQUNaalAsZ0RBQVNBLENBQUM7UUFDTixPQUFPO1lBQ0h3RyxRQUFRQyxHQUFHLENBQUM7WUFDWiw0REFBNEQ7WUFDNURtSyxXQUFXckssT0FBTztRQUN0QjtJQUNBLG1DQUFtQztJQUN2QyxHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQ0huQztRQUNBRTtRQUNBRTtRQUNBRTtRQUNBMEo7UUFDQWE7UUFDQUM7UUFDQUU7UUFDQXhLO1FBQ0FFO1FBQ0FzRztRQUNBcEc7UUFDQTRFO1FBQ0FIO1FBQ0F2RTtRQUNBSTtRQUNBQztJQUNKO0FBQ0o7R0ExMEJnQjdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy9hcHAvaG9va3MvdXNlV2ViUlRDLmpzP2E2MzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldFNvY2tldCB9IGZyb20gJy4uL3NvY2tldCc7XG5jb25zdCBGSUxURVJfQ09ORklHID0ge1xuICAgIG5vbmU6IHsgbGFiZWw6ICdH4buRYycsIGVtb2ppOiAn8J+ZgicgfSxcbiAgICBiZWF1dHk6IHtcbiAgICAgICAgbGFiZWw6ICdN4buLbicsXG4gICAgICAgIGVtb2ppOiAn4pyoJyxcbiAgICAgICAgY3NzRmlsdGVyOiAnYnJpZ2h0bmVzcygxLjA4KSBjb250cmFzdCgxLjA1KSBzYXR1cmF0ZSgxLjI1KScsXG4gICAgfSxcbiAgICB3YXJtOiB7XG4gICAgICAgIGxhYmVsOiAn4bqkbScsXG4gICAgICAgIGVtb2ppOiAn8J+MhScsXG4gICAgICAgIGNzc0ZpbHRlcjogJ2JyaWdodG5lc3MoMS4wNSkgc2F0dXJhdGUoMS4yNSkgaHVlLXJvdGF0ZSgtNWRlZyknLFxuICAgIH0sXG4gICAgY29vbDoge1xuICAgICAgICBsYWJlbDogJ03DoXQnLFxuICAgICAgICBlbW9qaTogJ+KdhO+4jycsXG4gICAgICAgIGNzc0ZpbHRlcjogJ2JyaWdodG5lc3MoMS4wOCkgc2F0dXJhdGUoMS4xNSkgaHVlLXJvdGF0ZSgxODVkZWcpJyxcbiAgICB9LFxuICAgIHBhcnR5OiB7XG4gICAgICAgIGxhYmVsOiAnUGFydHknLFxuICAgICAgICBlbW9qaTogJ/CfjoknLFxuICAgICAgICBjc3NGaWx0ZXI6ICdicmlnaHRuZXNzKDEuMDUpIHNhdHVyYXRlKDEuMjUpJyxcbiAgICAgICAgb3ZlcmxheTogKGN0eCwgd2lkdGgsIGhlaWdodCwgdGltZSkgPT4ge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMzU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gKGkgKiA3MyArICh0aW1lIC8gMTIpICUgd2lkdGgpICUgd2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IChpICogNDEgKyAodGltZSAvIDE4KSAlIGhlaWdodCkgJSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IDEyICsgKGkgJSA1KSAqIDM7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFsnI2ZmNmI2YicsICcjZmZkOTNkJywgJyM2YmMyZmYnLCAnI2IwNzBmZiddW2kgJSA0XTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaXplLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBiaXJ0aGRheToge1xuICAgICAgICBsYWJlbDogJ1Npbmggbmjhuq10JyxcbiAgICAgICAgZW1vamk6ICfwn46CJyxcbiAgICAgICAgY3NzRmlsdGVyOiAnYnJpZ2h0bmVzcygxLjA1KSBzYXR1cmF0ZSgxLjE1KScsXG4gICAgICAgIG92ZXJsYXk6IChjdHgsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBCYWxsb29uc1xuICAgICAgICAgICAgY29uc3QgYmFsbG9vbkNvbG9ycyA9IFsnI2ZmN2ViNicsICcjN2RiYmZmJywgJyNmZmQ5NjYnXTtcbiAgICAgICAgICAgIGJhbGxvb25Db2xvcnMuZm9yRWFjaCgoY29sb3IsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnggPSBpbmRleCA9PT0gMCA/IHdpZHRoICogMC4xNSA6IGluZGV4ID09PSAxID8gd2lkdGggKiAwLjg1IDogd2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgICAgY29uc3QgYnkgPSBpbmRleCA9PT0gMiA/IGhlaWdodCAqIDAuMiA6IGhlaWdodCAqIDAuMTU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gaW5kZXggPT09IDIgPyA4MCA6IDcwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGJ4IC0gMjAsIGJ5IC0gMzAsIDIwLCBieCwgYnksIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjZmZmZmZmJyk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuMiwgJyNmZmZmZmYnKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgY29sb3IpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmVsbGlwc2UoYngsIGJ5LCByYWRpdXMgKiAwLjc1LCByYWRpdXMsIDAsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmZmZmJztcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhieCwgYnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGJ4IC0gMTAsIGJ5ICsgcmFkaXVzICsgNjAsIGJ4LCBieSArIHJhZGl1cyArIDExMCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBQYXJ0eSBoYXRcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmOGNlNic7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHdpZHRoIC8gMiwgaGVpZ2h0ICogMC4wMik7XG4gICAgICAgICAgICBjdHgubGluZVRvKHdpZHRoIC8gMiAtIDgwLCBoZWlnaHQgKiAwLjI4KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8od2lkdGggLyAyICsgODAsIGhlaWdodCAqIDAuMjgpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjQ1KSc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gLTYwOyBpIDw9IDYwOyBpICs9IDMwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMod2lkdGggLyAyICsgaSwgaGVpZ2h0ICogMC4xOCwgMTgsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FrZSBiYXNlXG4gICAgICAgICAgICBjb25zdCBjYWtlSGVpZ2h0ID0gOTA7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmQxZGMnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHdpZHRoICogMC4yLCBoZWlnaHQgLSBjYWtlSGVpZ2h0IC0gMjAsIHdpZHRoICogMC42LCBjYWtlSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmOWViZSc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3Qod2lkdGggKiAwLjIsIGhlaWdodCAtIGNha2VIZWlnaHQgLSAyMCwgd2lkdGggKiAwLjYsIDI1KTtcbiAgICAgICAgICAgIC8vIENhbmRsZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAtMTsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjeCA9IHdpZHRoIC8gMiArIGkgKiAzNTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM1ZGFkZTInO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjeCAtIDYsIGhlaWdodCAtIGNha2VIZWlnaHQgLSA2MCwgMTIsIDQwKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmQ5NjYnO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZWxsaXBzZShjeCwgaGVpZ2h0IC0gY2FrZUhlaWdodCAtIDY4LCA3LCAxMCwgMCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuY29uc3QgSUNFX1NFUlZFUlMgPSBbXG4gICAgeyB1cmxzOiAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcbiAgICB7IHVybHM6ICdzdHVuOnN0dW4xLmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcbiAgICB7IHVybHM6ICdzdHVuOnN0dW4yLmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcbiAgICB7IHVybHM6ICdzdHVuOnN0dW4zLmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcbiAgICB7IHVybHM6ICdzdHVuOnN0dW40LmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcbiAgICAvLyBGcmVlIFRVUk4gc2VydmVycyBmcm9tIE9wZW4gUmVsYXkgUHJvamVjdFxuICAgIHtcbiAgICAgICAgdXJsczogJ3R1cm46b3BlbnJlbGF5Lm1ldGVyZWQuY2E6ODAnLFxuICAgICAgICB1c2VybmFtZTogJ29wZW5yZWxheXByb2plY3QnLFxuICAgICAgICBjcmVkZW50aWFsOiAnb3BlbnJlbGF5cHJvamVjdCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHVybHM6ICd0dXJuOm9wZW5yZWxheS5tZXRlcmVkLmNhOjQ0MycsXG4gICAgICAgIHVzZXJuYW1lOiAnb3BlbnJlbGF5cHJvamVjdCcsXG4gICAgICAgIGNyZWRlbnRpYWw6ICdvcGVucmVsYXlwcm9qZWN0JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdXJsczogJ3R1cm46b3BlbnJlbGF5Lm1ldGVyZWQuY2E6NDQzP3RyYW5zcG9ydD10Y3AnLFxuICAgICAgICB1c2VybmFtZTogJ29wZW5yZWxheXByb2plY3QnLFxuICAgICAgICBjcmVkZW50aWFsOiAnb3BlbnJlbGF5cHJvamVjdCcsXG4gICAgfSxcbl07XG5leHBvcnQgZnVuY3Rpb24gdXNlV2ViUlRDKHsgY2FsbElkLCBjb252ZXJzYXRpb25JZDogX2NvbnZlcnNhdGlvbklkLCBpc0luaXRpYXRvciwgbG9jYWxVc2VySWQ6IF9sb2NhbFVzZXJJZCwgcmVtb3RlVXNlcklkLCB2aWRlb0RldmljZUlkLCBhdWRpb0RldmljZUlkLCB9KSB7XG4gICAgY29uc3QgW2xvY2FsU3RyZWFtLCBzZXRMb2NhbFN0cmVhbV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbcmVtb3RlU3RyZWFtLCBzZXRSZW1vdGVTdHJlYW1dID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbaXNWaWRlb0VuYWJsZWQsIHNldElzVmlkZW9FbmFibGVkXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtpc0F1ZGlvRW5hYmxlZCwgc2V0SXNBdWRpb0VuYWJsZWRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgW2N1cnJlbnRGaWx0ZXIsIHNldEN1cnJlbnRGaWx0ZXJdID0gdXNlU3RhdGUoJ25vbmUnKTtcbiAgICBjb25zdCBbaXNTY3JlZW5TaGFyaW5nLCBzZXRJc1NjcmVlblNoYXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZihnZXRTb2NrZXQoKSk7XG4gICAgY29uc3QgbG9jYWxWaWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCByZW1vdGVWaWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgICAvLyBRdWV1ZSBmb3IgSUNFIGNhbmRpZGF0ZXMgcmVjZWl2ZWQgYmVmb3JlIHJlbW90ZSBkZXNjcmlwdGlvbiBpcyBzZXRcbiAgICBjb25zdCBpY2VDYW5kaWRhdGVRdWV1ZVJlZiA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgaGFzUmVjZWl2ZWRPZmZlclJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgb2ZmZXJSZXRyeVRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHJhd0NhbWVyYVN0cmVhbVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzY3JlZW5TaGFyZVN0cmVhbVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwcm9jZXNzZWRGaWx0ZXJTdHJlYW1SZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZmlsdGVyQ2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGZpbHRlclZpZGVvUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGZpbHRlckFuaW1hdGlvbkZyYW1lUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJSZWYgPSB1c2VSZWYoJ25vbmUnKTtcbiAgICAvLyBSZWZzIHRvIHN0b3JlIGxhdGVzdCBmdW5jdGlvbnMgZm9yIHVzZSBpbiBzb2NrZXQgaGFuZGxlcnMgKHdpbGwgYmUgc2V0IGFmdGVyIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZClcbiAgICBjb25zdCBpbml0UGVlckNvbm5lY3Rpb25SZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZ2V0VXNlck1lZGlhUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIC8vIFN5bmMgc29ja2V0UmVmIHdpdGggY3VycmVudCBzb2NrZXQgLSBwb2xsIGV2ZXJ5IDUwMG1zIHVudGlsIGNvbm5lY3RlZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U29ja2V0ID0gZ2V0U29ja2V0KCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNvY2tldCAmJiBjdXJyZW50U29ja2V0LmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gY3VycmVudFNvY2tldDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdlYlJUQ10gU29ja2V0IHN5bmNlZCwgY29ubmVjdGVkOicsIGN1cnJlbnRTb2NrZXQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNvY2tldFJlZi5jdXJyZW50IHx8ICFzb2NrZXRSZWYuY3VycmVudC5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IGN1cnJlbnRTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluaXRpYWwgc3luY1xuICAgICAgICBzeW5jU29ja2V0KCk7XG4gICAgICAgIC8vIFBvbGwgZm9yIHNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoc3luY1NvY2tldCwgNTAwKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjdXJyZW50RmlsdGVyUmVmLmN1cnJlbnQgPSBjdXJyZW50RmlsdGVyO1xuICAgIH0sIFtjdXJyZW50RmlsdGVyXSk7XG4gICAgY29uc3QgcmVwbGFjZVZpZGVvVHJhY2sgPSB1c2VDYWxsYmFjayhhc3luYyAodHJhY2spID0+IHtcbiAgICAgICAgaWYgKCF0cmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGMgPSBwZWVyQ29ubmVjdGlvblJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXBjKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBwYy5nZXRTZW5kZXJzKCkuZmluZCgocykgPT4gcy50cmFjayAmJiBzLnRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgICBhd2FpdCBzZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzdG9wRmlsdGVyUHJvY2Vzc2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGZpbHRlckFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZpbHRlckFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgZmlsdGVyQW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3NlZEZpbHRlclN0cmVhbVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRGaWx0ZXJTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICAgIHByb2Nlc3NlZEZpbHRlclN0cmVhbVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyVmlkZW9SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJWaWRlb1JlZi5jdXJyZW50LnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXJWaWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICBmaWx0ZXJWaWRlb1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJDYW52YXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHN0YXJ0RmlsdGVyUHJvY2Vzc2luZyA9IHVzZUNhbGxiYWNrKChmaWx0ZXIpID0+IHtcbiAgICAgICAgY29uc3QgcmF3U3RyZWFtID0gcmF3Q2FtZXJhU3RyZWFtUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghcmF3U3RyZWFtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdG9wRmlsdGVyUHJvY2Vzc2luZygpO1xuICAgICAgICBjb25zdCB2aWRlb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdmlkZW9FbC5zcmNPYmplY3QgPSByYXdTdHJlYW07XG4gICAgICAgIHZpZGVvRWwubXV0ZWQgPSB0cnVlO1xuICAgICAgICB2aWRlb0VsLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdmlkZW9FbC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIHZpZGVvRWwucGxheSgpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIGZpbHRlclZpZGVvUmVmLmN1cnJlbnQgPSB2aWRlb0VsO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsdGVyXSBDYW52YXMgY29udGV4dCB1bmF2YWlsYWJsZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlckNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzO1xuICAgICAgICBjb25zdCByZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlclZpZGVvUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aWRlbyA9IGZpbHRlclZpZGVvUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbHRlckFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IEZJTFRFUl9DT05GSUdbZmlsdGVyXTtcbiAgICAgICAgICAgIGN0eC5maWx0ZXIgPSBjb25maWcuY3NzRmlsdGVyIHx8ICdub25lJztcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmZpbHRlciA9ICdub25lJztcbiAgICAgICAgICAgIGlmIChjb25maWcub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5vdmVybGF5KGN0eCwgd2lkdGgsIGhlaWdodCwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyQW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkU3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oMzApO1xuICAgICAgICBwcm9jZXNzZWRGaWx0ZXJTdHJlYW1SZWYuY3VycmVudCA9IHByb2Nlc3NlZFN0cmVhbTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkVHJhY2sgPSBwcm9jZXNzZWRTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgcmVwbGFjZVZpZGVvVHJhY2socHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICBzZXRMb2NhbFN0cmVhbShwcm9jZXNzZWRTdHJlYW0pO1xuICAgIH0sIFtyZXBsYWNlVmlkZW9UcmFjaywgc3RvcEZpbHRlclByb2Nlc3NpbmddKTtcbiAgICBjb25zdCBzdG9wU2NyZWVuU2hhcmUgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghc2NyZWVuU2hhcmVTdHJlYW1SZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NyZWVuU2hhcmVTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgc2NyZWVuU2hhcmVTdHJlYW1SZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHNldElzU2NyZWVuU2hhcmluZyhmYWxzZSk7XG4gICAgICAgIGNvbnN0IGNhbWVyYVN0cmVhbSA9IHJhd0NhbWVyYVN0cmVhbVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNhbWVyYVN0cmVhbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGN1cnJlbnRGaWx0ZXJSZWYuY3VycmVudCAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBzdGFydEZpbHRlclByb2Nlc3NpbmcoY3VycmVudEZpbHRlclJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYVRyYWNrID0gY2FtZXJhU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgICBhd2FpdCByZXBsYWNlVmlkZW9UcmFjayhjYW1lcmFUcmFjayk7XG4gICAgICAgICAgICBzZXRMb2NhbFN0cmVhbShjYW1lcmFTdHJlYW0pO1xuICAgICAgICB9XG4gICAgfSwgW3JlcGxhY2VWaWRlb1RyYWNrLCBzdGFydEZpbHRlclByb2Nlc3NpbmddKTtcbiAgICBjb25zdCBzdGFydFNjcmVlblNoYXJlID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoaXNTY3JlZW5TaGFyaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZWxlY3Ryb25BUEkgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5lbGVjdHJvbkFQSSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBzaGFyZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZWxlY3Ryb25BUEk/LnNlbGVjdFNjcmVlblNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUlkID0gYXdhaXQgZWxlY3Ryb25BUEkuc2VsZWN0U2NyZWVuU291cmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcignS2jDtG5nIHTDrG0gdGjhuqV5IG3DoG4gaMOsbmggxJHhu4MgY2hpYSBz4bq7LicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZWN0cm9uQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmRhdG9yeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZU1lZGlhU291cmNlOiAnZGVza3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lTWVkaWFTb3VyY2VJZDogc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RnJhbWVSYXRlOiAzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5GcmFtZVJhdGU6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2hhcmVTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShlbGVjdHJvbkNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXM/LmdldERpc3BsYXlNZWRpYSkge1xuICAgICAgICAgICAgICAgIHNoYXJlU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xuICAgICAgICAgICAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVSYXRlOiAzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB7IGlkZWFsOiAxOTIwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHsgaWRlYWw6IDEwODAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlTdXJmYWNlOiAnbW9uaXRvcicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU0NSRUVOX1NIQVJFX05PVF9TVVBQT1JURUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcmVlblNoYXJlU3RyZWFtUmVmLmN1cnJlbnQgPSBzaGFyZVN0cmVhbTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gc2hhcmVTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgIHRyYWNrLm9uZW5kZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcFNjcmVlblNoYXJlKCkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdG9wRmlsdGVyUHJvY2Vzc2luZygpO1xuICAgICAgICAgICAgc2V0TG9jYWxTdHJlYW0oc2hhcmVTdHJlYW0pO1xuICAgICAgICAgICAgYXdhaXQgcmVwbGFjZVZpZGVvVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgc2V0SXNTY3JlZW5TaGFyaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTY3JlZW5TaGFyZV0gRXJyb3Igc3RhcnRpbmcgc2NyZWVuIHNoYXJlOicsIGVycik7XG4gICAgICAgICAgICBpZiAoZXJyPy5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCdC4bqhbiDEkcOjIHThu6sgY2jhu5FpIHF1eeG7gW4gY2hpYSBz4bq7IG3DoG4gaMOsbmguJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnI/Lm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCdLaMO0bmcgdMOsbSB0aOG6pXkgbcOgbiBow6xuaCBwaMO5IGjhu6NwIMSR4buDIGNoaWEgc+G6uy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCdDaGlhIHPhursgbcOgbiBow6xuaCBjaMawYSDEkcaw4bujYyBo4buXIHRy4bujIHRyb25nIG3DtGkgdHLGsOG7nW5nIG7DoHkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9LCBbaXNTY3JlZW5TaGFyaW5nLCByZXBsYWNlVmlkZW9UcmFjaywgc3RvcEZpbHRlclByb2Nlc3NpbmcsIHN0b3BTY3JlZW5TaGFyZV0pO1xuICAgIGNvbnN0IGFwcGx5RmlsdGVyID0gdXNlQ2FsbGJhY2soYXN5bmMgKGZpbHRlcikgPT4ge1xuICAgICAgICBzZXRDdXJyZW50RmlsdGVyKGZpbHRlcik7XG4gICAgICAgIGlmIChpc1NjcmVlblNoYXJpbmcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0ZpbHRlcl0gQ2Fubm90IGFwcGx5IGZpbHRlciB3aGlsZSBzaGFyaW5nIHNjcmVlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF3Q2FtZXJhU3RyZWFtUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmaWx0ZXIgPT09ICdub25lJykge1xuICAgICAgICAgICAgc3RvcEZpbHRlclByb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYVRyYWNrID0gcmF3Q2FtZXJhU3RyZWFtUmVmLmN1cnJlbnQuZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgIGF3YWl0IHJlcGxhY2VWaWRlb1RyYWNrKGNhbWVyYVRyYWNrKTtcbiAgICAgICAgICAgIHNldExvY2FsU3RyZWFtKHJhd0NhbWVyYVN0cmVhbVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFydEZpbHRlclByb2Nlc3NpbmcoZmlsdGVyKTtcbiAgICB9LCBbaXNTY3JlZW5TaGFyaW5nLCByZXBsYWNlVmlkZW9UcmFjaywgc3RhcnRGaWx0ZXJQcm9jZXNzaW5nLCBzdG9wRmlsdGVyUHJvY2Vzc2luZ10pO1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFUlJPUiBIQU5ETElORyBIRUxQRVJTXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGNvbnN0IGhhbmRsZUdldFVzZXJNZWRpYUVycm9yID0gdXNlQ2FsbGJhY2soKGVycikgPT4ge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtnZXRVc2VyTWVkaWEgRVJST1JdICR7dGltZXN0YW1wfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbZ2V0VXNlck1lZGlhIEVSUk9SXSBFcnJvciBuYW1lOiAke2Vyci5uYW1lfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbZ2V0VXNlck1lZGlhIEVSUk9SXSBFcnJvciBtZXNzYWdlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbZ2V0VXNlck1lZGlhIEVSUk9SXSBGdWxsIGVycm9yOmAsIGVycik7XG4gICAgICAgIHN3aXRjaCAoZXJyLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ05vdEFsbG93ZWRFcnJvcic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2dldFVzZXJNZWRpYSBFUlJPUl0gTm90QWxsb3dlZEVycm9yOiBQZXJtaXNzaW9uIGRlbmllZCBieSB1c2VyIG9yIHN5c3RlbScpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ2FtZXJhL21pY3JvcGhvbmUgcGVybWlzc2lvbiBkZW5pZWQuIFBsZWFzZSBhbGxvdyBhY2Nlc3MgaW4gV2luZG93cyBTZXR0aW5ncyAoUHJpdmFjeSDihpIgQ2FtZXJhL01pY3JvcGhvbmUpLic7XG4gICAgICAgICAgICBjYXNlICdOb3RGb3VuZEVycm9yJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbZ2V0VXNlck1lZGlhIEVSUk9SXSBOb3RGb3VuZEVycm9yOiBObyBtZWRpYSBkZXZpY2UgZm91bmQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05vIGNhbWVyYS9taWNyb3Bob25lIGZvdW5kLiBQbGVhc2UgY29ubmVjdCBhIGRldmljZS4nO1xuICAgICAgICAgICAgY2FzZSAnTm90UmVhZGFibGVFcnJvcic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2dldFVzZXJNZWRpYSBFUlJPUl0gTm90UmVhZGFibGVFcnJvcjogRGV2aWNlIGlzIGFscmVhZHkgaW4gdXNlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdDYW1lcmEvbWljcm9waG9uZSBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFwcGxpY2F0aW9uLic7XG4gICAgICAgICAgICBjYXNlICdPdmVyY29uc3RyYWluZWRFcnJvcic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2dldFVzZXJNZWRpYSBFUlJPUl0gT3ZlcmNvbnN0cmFpbmVkRXJyb3I6IENvbnN0cmFpbnRzIGNhbm5vdCBiZSBzYXRpc2ZpZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0NhbWVyYS9taWNyb3Bob25lIGNvbnN0cmFpbnRzIGNhbm5vdCBiZSBzYXRpc2ZpZWQuIFBsZWFzZSB0cnkgZGlmZmVyZW50IHNldHRpbmdzLic7XG4gICAgICAgICAgICBjYXNlICdTZWN1cml0eUVycm9yJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbZ2V0VXNlck1lZGlhIEVSUk9SXSBTZWN1cml0eUVycm9yOiBOb3QgaW4gc2VjdXJlIGNvbnRleHQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1NlY3VyaXR5IGVycm9yOiBBcHAgbXVzdCBydW4gaW4gc2VjdXJlIGNvbnRleHQuJztcbiAgICAgICAgICAgIGNhc2UgJ1R5cGVFcnJvcic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2dldFVzZXJNZWRpYSBFUlJPUl0gVHlwZUVycm9yOiBJbnZhbGlkIGNvbnN0cmFpbnRzIG9yIEFQSSBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnZhbGlkIG1lZGlhIGNvbnN0cmFpbnRzIG9yIEFQSSBub3QgYXZhaWxhYmxlLic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtnZXRVc2VyTWVkaWEgRVJST1JdIFVua25vd24gZXJyb3I6ICR7ZXJyLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gYWNjZXNzIGNhbWVyYS9taWNyb3Bob25lLic7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEdFVCBVU0VSIE1FRElBIFdJVEggREVUQUlMRUQgRVJST1IgSEFORExJTkdcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgY29uc3QgZ2V0VXNlck1lZGlhID0gdXNlQ2FsbGJhY2soYXN5bmMgKHZpZGVvLCBhdWRpbykgPT4ge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbZ2V0VXNlck1lZGlhXSAke3RpbWVzdGFtcH0gLSBTdGFydGluZyByZXF1ZXN0YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbZ2V0VXNlck1lZGlhXSBWaWRlbzogJHt2aWRlb30sIEF1ZGlvOiAke2F1ZGlvfWApO1xuICAgICAgICAvLyBDaGVjayBpZiBtZWRpYURldmljZXMgQVBJIGlzIGF2YWlsYWJsZVxuICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gJ01lZGlhRGV2aWNlcyBBUEkgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXIuJztcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtnZXRVc2VyTWVkaWEgRVJST1JdICR7ZXJyb3JNc2d9YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gJ2dldFVzZXJNZWRpYSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4nO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW2dldFVzZXJNZWRpYSBFUlJPUl0gJHtlcnJvck1zZ31gKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9nIGVudmlyb25tZW50IGluZm9cbiAgICAgICAgY29uc29sZS5sb2coYFtnZXRVc2VyTWVkaWFdIEVudmlyb25tZW50IGluZm86YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbZ2V0VXNlck1lZGlhXSBPcmlnaW46ICR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtnZXRVc2VyTWVkaWFdIFVSTDogJHt3aW5kb3cubG9jYXRpb24uaHJlZn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtnZXRVc2VyTWVkaWFdIElzIHNlY3VyZSBjb250ZXh0OiAke3dpbmRvdy5pc1NlY3VyZUNvbnRleHR9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbZ2V0VXNlck1lZGlhXSBNZWRpYURldmljZXMgYXZhaWxhYmxlOiAkeyEhbmF2aWdhdG9yLm1lZGlhRGV2aWNlc31gKTtcbiAgICAgICAgLy8gUHJlcGFyZSBjb25zdHJhaW50cyB3aXRoIGRldmljZSBzZWxlY3Rpb25cbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICB2aWRlbzogdmlkZW9cbiAgICAgICAgICAgICAgICA/IHZpZGVvRGV2aWNlSWRcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogeyBleGFjdDogdmlkZW9EZXZpY2VJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHsgaWRlYWw6IDEyODAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogeyBpZGVhbDogNzIwIH0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogeyBpZGVhbDogMTI4MCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiA3MjAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2luZ01vZGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBhdWRpbzogYXVkaW9cbiAgICAgICAgICAgICAgICA/IGF1ZGlvRGV2aWNlSWRcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogeyBleGFjdDogYXVkaW9EZXZpY2VJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh2aWRlb0RldmljZUlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2dldFVzZXJNZWRpYV0gVXNpbmcgc2VsZWN0ZWQgdmlkZW8gZGV2aWNlOiAke3ZpZGVvRGV2aWNlSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvRGV2aWNlSWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbZ2V0VXNlck1lZGlhXSBVc2luZyBzZWxlY3RlZCBhdWRpbyBkZXZpY2U6ICR7YXVkaW9EZXZpY2VJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgW2dldFVzZXJNZWRpYV0gQ29uc3RyYWludHM6YCwgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMsIG51bGwsIDIpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbZ2V0VXNlck1lZGlhXSBDYWxsaW5nIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLi4uYCk7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2dldFVzZXJNZWRpYV0g4pyFIFN1Y2Nlc3MhIFN0cmVhbSBvYnRhaW5lZGApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtnZXRVc2VyTWVkaWFdIFN0cmVhbSBJRDogJHtzdHJlYW0uaWR9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2dldFVzZXJNZWRpYV0gU3RyZWFtIGFjdGl2ZTogJHtzdHJlYW0uYWN0aXZlfWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtnZXRVc2VyTWVkaWFdIFRyYWNrczpgLCBzdHJlYW0uZ2V0VHJhY2tzKCkubWFwKHRyYWNrID0+ICh7XG4gICAgICAgICAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgICAgICBpZDogdHJhY2suaWQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRyYWNrLmxhYmVsLFxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRyYWNrLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgbXV0ZWQ6IHRyYWNrLm11dGVkLFxuICAgICAgICAgICAgICAgIHJlYWR5U3RhdGU6IHRyYWNrLnJlYWR5U3RhdGUsXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgaWYgKHJhd0NhbWVyYVN0cmVhbVJlZi5jdXJyZW50ICYmIHJhd0NhbWVyYVN0cmVhbVJlZi5jdXJyZW50ICE9PSBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByYXdDYW1lcmFTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhd0NhbWVyYVN0cmVhbVJlZi5jdXJyZW50ID0gc3RyZWFtO1xuICAgICAgICAgICAgaWYgKCFpc1NjcmVlblNoYXJpbmcgJiYgY3VycmVudEZpbHRlclJlZi5jdXJyZW50ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBzZXRMb2NhbFN0cmVhbShzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgICAvLyBBZGQgdHJhY2tzIHRvIHBlZXIgY29ubmVjdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGlmIChwZWVyQ29ubmVjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbZ2V0VXNlck1lZGlhXSBBZGRpbmcgJHt0cmFjay5raW5kfSB0cmFjayB0byBwZWVyIGNvbm5lY3Rpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25SZWYuY3VycmVudD8uYWRkVHJhY2sodHJhY2ssIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2NyZWVuU2hhcmluZyAmJiBjdXJyZW50RmlsdGVyUmVmLmN1cnJlbnQgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHN0YXJ0RmlsdGVyUHJvY2Vzc2luZyhjdXJyZW50RmlsdGVyUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBoYW5kbGVHZXRVc2VyTWVkaWFFcnJvcihlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0sIFtoYW5kbGVHZXRVc2VyTWVkaWFFcnJvciwgaXNTY3JlZW5TaGFyaW5nLCBzdGFydEZpbHRlclByb2Nlc3NpbmddKTtcbiAgICAvLyBVcGRhdGUgZ2V0VXNlck1lZGlhIHJlZlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGdldFVzZXJNZWRpYVJlZi5jdXJyZW50ID0gZ2V0VXNlck1lZGlhO1xuICAgIH0sIFtnZXRVc2VyTWVkaWFdKTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gSU5JVElBTElaRSBQRUVSIENPTk5FQ1RJT05cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgY29uc3QgaW5pdFBlZXJDb25uZWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnW1BlZXJDb25uZWN0aW9uXSBJbml0aWFsaXppbmcuLi4nKTtcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUGVlckNvbm5lY3Rpb25dIENsb3NpbmcgZXhpc3RpbmcgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25SZWYuY3VycmVudC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHsgaWNlU2VydmVyczogSUNFX1NFUlZFUlMgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbUGVlckNvbm5lY3Rpb25dIENyZWF0ZWQgbmV3IFJUQ1BlZXJDb25uZWN0aW9uJyk7XG4gICAgICAgIC8vIEhhbmRsZSBJQ0UgY2FuZGlkYXRlc1xuICAgICAgICBwYy5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUGVlckNvbm5lY3Rpb25dIElDRSBjYW5kaWRhdGU6JywgZXZlbnQuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBzb2NrZXRSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCd3ZWJydGM6aWNlLWNhbmRpZGF0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZTogZXZlbnQuY2FuZGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXNlcklkOiByZW1vdGVVc2VySWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUGVlckNvbm5lY3Rpb25dIElDRSBnYXRoZXJpbmcgY29tcGxldGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gSGFuZGxlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlc1xuICAgICAgICBwYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gcGMuY29ubmVjdGlvblN0YXRlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtQZWVyQ29ubmVjdGlvbl0gQ29ubmVjdGlvbiBzdGF0ZTogJHtzdGF0ZX1gKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCBzdGF0ZSA9PT0gJ2ZhaWxlZCcgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBIYW5kbGUgcmVtb3RlIHN0cmVhbVxuICAgICAgICBwYy5vbnRyYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1BlZXJDb25uZWN0aW9uXSBSZWNlaXZlZCByZW1vdGUgdHJhY2s6JywgZXZlbnQudHJhY2sua2luZCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc3RyZWFtcyAmJiBldmVudC5zdHJlYW1zWzBdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tQZWVyQ29ubmVjdGlvbl0gU2V0dGluZyByZW1vdGUgc3RyZWFtJyk7XG4gICAgICAgICAgICAgICAgc2V0UmVtb3RlU3RyZWFtKGV2ZW50LnN0cmVhbXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBIYW5kbGUgSUNFIGNvbm5lY3Rpb24gc3RhdGVcbiAgICAgICAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHBjLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUGVlckNvbm5lY3Rpb25dIElDRSBjb25uZWN0aW9uIHN0YXRlOiAke3N0YXRlfWApO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tQZWVyQ29ubmVjdGlvbl0gSUNFIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwZWVyQ29ubmVjdGlvblJlZi5jdXJyZW50ID0gcGM7XG4gICAgICAgIHJldHVybiBwYztcbiAgICB9LCBbY2FsbElkLCByZW1vdGVVc2VySWRdKTtcbiAgICAvLyBVcGRhdGUgaW5pdFBlZXJDb25uZWN0aW9uIHJlZlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGluaXRQZWVyQ29ubmVjdGlvblJlZi5jdXJyZW50ID0gaW5pdFBlZXJDb25uZWN0aW9uO1xuICAgIH0sIFtpbml0UGVlckNvbm5lY3Rpb25dKTtcbiAgICBjb25zdCByZXF1ZXN0T2ZmZXIgPSB1c2VDYWxsYmFjaygocmVhc29uKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHNvY2tldFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbU29ja2V0XSBDYW5ub3QgcmVxdWVzdCBvZmZlciAtIHNvY2tldCBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYFtTb2NrZXRdIFJlcXVlc3Rpbmcgb2ZmZXIgKCR7cmVhc29ufSkgZm9yIGNhbGxJZCAke2NhbGxJZH1gKTtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3dlYnJ0YzpyZXF1ZXN0LW9mZmVyJywge1xuICAgICAgICAgICAgY2FsbElkLFxuICAgICAgICAgICAgZnJvbVVzZXJJZDogX2xvY2FsVXNlcklkLFxuICAgICAgICAgICAgdGFyZ2V0VXNlcklkOiByZW1vdGVVc2VySWQsXG4gICAgICAgIH0pO1xuICAgIH0sIFtjYWxsSWQsIF9sb2NhbFVzZXJJZCwgcmVtb3RlVXNlcklkXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvZmZlclJldHJ5VGltZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwob2ZmZXJSZXRyeVRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIG9mZmVyUmV0cnlUaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFNUQVJUIENBTExcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgY29uc3Qgc3RhcnRDYWxsID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbc3RhcnRDYWxsXSAke3RpbWVzdGFtcH0gLSBTdGFydGluZyBjYWxsYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbc3RhcnRDYWxsXSBDYWxsIElEOiAke2NhbGxJZH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtzdGFydENhbGxdIElzIGluaXRpYXRvcjogJHtpc0luaXRpYXRvcn1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gc29ja2V0UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU29ja2V0IG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgcGVlciBjb25uZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBwYyA9IGluaXRQZWVyQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgLy8gR2V0IHVzZXIgbWVkaWEgKGJvdGggaW5pdGlhdG9yIGFuZCBub24taW5pdGlhdG9yIG5lZWQgdGhpcylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc3RhcnRDYWxsXSBSZXF1ZXN0aW5nIHVzZXIgbWVkaWEuLi4nKTtcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJNZWRpYShpc1ZpZGVvRW5hYmxlZCwgaXNBdWRpb0VuYWJsZWQpO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhdG9yOiBDcmVhdGUgYW5kIHNlbmQgb2ZmZXJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3N0YXJ0Q2FsbF0gQ3JlYXRpbmcgb2ZmZXIuLi4nKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3N0YXJ0Q2FsbF0gSW5pdGlhdG9yIGRldGFpbHM6Jywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Q29ubmVjdGVkOiBzb2NrZXQuY29ubmVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzb2NrZXRJZDogc29ja2V0LmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc3RhcnRDYWxsXSBPZmZlciBjcmVhdGVkOicsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmZXIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc2RwTGVuZ3RoOiBvZmZlci5zZHA/Lmxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHBjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc3RhcnRDYWxsXSBMb2NhbCBkZXNjcmlwdGlvbiBzZXQsIHNpZ25hbGluZ1N0YXRlOicsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIG9mZmVyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tzdGFydENhbGxdIFNlbmRpbmcgb2ZmZXIgdmlhIHNvY2tldC4uLicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZmVyRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbElkLFxuICAgICAgICAgICAgICAgICAgICBvZmZlcjogb2ZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFVzZXJJZDogcmVtb3RlVXNlcklkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tzdGFydENhbGxdIE9mZmVyIGRhdGEgdG8gc2VuZDonLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxJZDogb2ZmZXJEYXRhLmNhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXNlcklkOiBvZmZlckRhdGEudGFyZ2V0VXNlcklkLFxuICAgICAgICAgICAgICAgICAgICBvZmZlclR5cGU6IG9mZmVyRGF0YS5vZmZlci50eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ3dlYnJ0YzpvZmZlcicsIG9mZmVyRGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tzdGFydENhbGxdIOKchSBPZmZlciBlbWl0dGVkIHRvIHNvY2tldCcpO1xuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBzb2NrZXQgaXMgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKCFzb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tzdGFydENhbGxdIOKaoO+4jyBTb2NrZXQgbm90IGNvbm5lY3RlZCB3aGVuIHNlbmRpbmcgb2ZmZXIhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9uLWluaXRpYXRvcjogSnVzdCBzZXR1cCBwZWVyIGNvbm5lY3Rpb24gYW5kIHdhaXQgZm9yIG9mZmVyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG9mZmVyIGhhbmRsZXIgd2lsbCBjcmVhdGUgYW5zd2VyIHdoZW4gb2ZmZXIgaXMgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3N0YXJ0Q2FsbF0gTm9uLWluaXRpYXRvcjogUGVlciBjb25uZWN0aW9uIHJlYWR5LCB3YWl0aW5nIGZvciBvZmZlci4uLicpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc3RhcnRDYWxsXSBTb2NrZXQgbGlzdGVuZXJzIHNob3VsZCBiZSBzZXQgdXAgdG8gcmVjZWl2ZSBvZmZlcicpO1xuICAgICAgICAgICAgICAgIGhhc1JlY2VpdmVkT2ZmZXJSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPZmZlcignc3RhcnQnKTtcbiAgICAgICAgICAgICAgICBpZiAob2ZmZXJSZXRyeVRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChvZmZlclJldHJ5VGltZXJSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZmVyUmV0cnlUaW1lclJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUmVjZWl2ZWRPZmZlclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZmZXJSZXRyeVRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKG9mZmVyUmV0cnlUaW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlclJldHJ5VGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9mZmVyKCdyZXRyeScpO1xuICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tzdGFydENhbGxdIEVycm9yOicsIGVycik7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHN0YXJ0IGNhbGwnO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sIFtjYWxsSWQsIGlzSW5pdGlhdG9yLCByZW1vdGVVc2VySWQsIGlzVmlkZW9FbmFibGVkLCBpc0F1ZGlvRW5hYmxlZCwgaW5pdFBlZXJDb25uZWN0aW9uLCBnZXRVc2VyTWVkaWEsIHJlcXVlc3RPZmZlcl0pO1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFTkQgQ0FMTFxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBjb25zdCBlbmRDYWxsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnW2VuZENhbGxdIEVuZGluZyBjYWxsLi4uJyk7XG4gICAgICAgIHN0b3BGaWx0ZXJQcm9jZXNzaW5nKCk7XG4gICAgICAgIHN0b3BTY3JlZW5TaGFyZSgpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIC8vIFN0b3AgbG9jYWwgc3RyZWFtIHRyYWNrc1xuICAgICAgICBpZiAobG9jYWxTdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZW5kQ2FsbF0gU3RvcHBpbmcgbG9jYWwgc3RyZWFtIHRyYWNrcycpO1xuICAgICAgICAgICAgbG9jYWxTdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtlbmRDYWxsXSBTdG9wcGVkICR7dHJhY2sua2luZH0gdHJhY2tgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0TG9jYWxTdHJlYW0obnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhd0NhbWVyYVN0cmVhbVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByYXdDYW1lcmFTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICAgIHJhd0NhbWVyYVN0cmVhbVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9wIHJlbW90ZSBzdHJlYW0gdHJhY2tzXG4gICAgICAgIGlmIChyZW1vdGVTdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZW5kQ2FsbF0gU3RvcHBpbmcgcmVtb3RlIHN0cmVhbSB0cmFja3MnKTtcbiAgICAgICAgICAgIHJlbW90ZVN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0UmVtb3RlU3RyZWFtKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb3NlIHBlZXIgY29ubmVjdGlvblxuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tlbmRDYWxsXSBDbG9zaW5nIHBlZXIgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25SZWYuY3VycmVudC5jbG9zZSgpO1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25SZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tlbmRDYWxsXSBDYWxsIGVuZGVkJyk7XG4gICAgfSwgW2xvY2FsU3RyZWFtLCByZW1vdGVTdHJlYW0sIHN0b3BGaWx0ZXJQcm9jZXNzaW5nLCBzdG9wU2NyZWVuU2hhcmVdKTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gVE9HR0xFIFZJREVPL0FVRElPXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGNvbnN0IHRvZ2dsZVZpZGVvID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3RvZ2dsZVZpZGVvXSBDdXJyZW50IHN0YXRlOiAke2lzVmlkZW9FbmFibGVkfSwgdG9nZ2xpbmcuLi5gKTtcbiAgICAgICAgc2V0SXNWaWRlb0VuYWJsZWQoIWlzVmlkZW9FbmFibGVkKTtcbiAgICAgICAgaWYgKGxvY2FsU3RyZWFtKSB7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrcyA9IGxvY2FsU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSAhaXNWaWRlb0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFt0b2dnbGVWaWRlb10gVmlkZW8gdHJhY2sgJHt0cmFjay5pZH0gZW5hYmxlZDogJHt0cmFjay5lbmFibGVkfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbaXNWaWRlb0VuYWJsZWQsIGxvY2FsU3RyZWFtXSk7XG4gICAgY29uc3QgdG9nZ2xlQXVkaW8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdG9nZ2xlQXVkaW9dIEN1cnJlbnQgc3RhdGU6ICR7aXNBdWRpb0VuYWJsZWR9LCB0b2dnbGluZy4uLmApO1xuICAgICAgICBzZXRJc0F1ZGlvRW5hYmxlZCghaXNBdWRpb0VuYWJsZWQpO1xuICAgICAgICBpZiAobG9jYWxTdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gbG9jYWxTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFpc0F1ZGlvRW5hYmxlZDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW3RvZ2dsZUF1ZGlvXSBBdWRpbyB0cmFjayAke3RyYWNrLmlkfSBlbmFibGVkOiAke3RyYWNrLmVuYWJsZWR9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0F1ZGlvRW5hYmxlZCwgbG9jYWxTdHJlYW1dKTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gU0VUVVAgU09DS0VUIExJU1RFTkVSU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBzb2NrZXRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSBTb2NrZXQgbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgbGlzdGVuZXIgc2V0dXAnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXR1cCBsaXN0ZW5lcnMgZXZlbiBpZiBwZWVyIGNvbm5lY3Rpb24gbm90IHJlYWR5IHlldFxuICAgICAgICAvLyBQZWVyIGNvbm5lY3Rpb24gd2lsbCBiZSBjcmVhdGVkIGluIHN0YXJ0Q2FsbCgpXG4gICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSBTZXR0aW5nIHVwIFdlYlJUQyBsaXN0ZW5lcnMgZm9yIGNhbGxJZDonLCBjYWxsSWQpO1xuICAgICAgICBjb25zdCBoYW5kbGVPZmZlciA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gPT09PT0gT0ZGRVIgUkVDRUlWRUQgPT09PT0nKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSBPZmZlciBkYXRhOicsIHtcbiAgICAgICAgICAgICAgICBjYWxsSWQ6IGRhdGEuY2FsbElkLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ2FsbElkOiBjYWxsSWQsXG4gICAgICAgICAgICAgICAgZnJvbVVzZXJJZDogZGF0YS5mcm9tVXNlcklkLFxuICAgICAgICAgICAgICAgIG9mZmVyVHlwZTogZGF0YS5vZmZlcj8udHlwZSxcbiAgICAgICAgICAgICAgICBvZmZlclNkcExlbmd0aDogZGF0YS5vZmZlcj8uc2RwPy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFzUmVjZWl2ZWRPZmZlclJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvZmZlclJldHJ5VGltZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwob2ZmZXJSZXRyeVRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIG9mZmVyUmV0cnlUaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmNhbGxJZCAhPT0gY2FsbElkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIOKdjCBPZmZlciBjYWxsSWQgbWlzbWF0Y2g6JywgZGF0YS5jYWxsSWQsICdleHBlY3RlZDonLCBjYWxsSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSDinIUgT2ZmZXIgY2FsbElkIG1hdGNoZXMsIHByb2Nlc3NpbmcuLi4nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHBjID0gcGVlckNvbm5lY3Rpb25SZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAvLyBJZiBwZWVyIGNvbm5lY3Rpb24gZG9lc24ndCBleGlzdCBvciBpcyBjbG9zZWQsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Nsb3NlZCA9ICFwYyB8fCBwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgcGMuY29ubmVjdGlvblN0YXRlID09PSAnY2xvc2VkJztcbiAgICAgICAgICAgICAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIFBlZXIgY29ubmVjdGlvbiBub3QgZm91bmQgb3IgY2xvc2VkLCBjcmVhdGluZyBuZXcgb25lLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5pdFBlZXJDb25uZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTb2NrZXRdIGluaXRQZWVyQ29ubmVjdGlvbiBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGMgPSBpbml0UGVlckNvbm5lY3Rpb25SZWYuY3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdXNlciBtZWRpYSBpZiBub3QgYWxyZWFkeSBvYnRhaW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gR2V0dGluZyB1c2VyIG1lZGlhIGZvciBhbnN3ZXIuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ2V0VXNlck1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU29ja2V0XSBnZXRVc2VyTWVkaWEgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGdldFVzZXJNZWRpYVJlZi5jdXJyZW50KGlzVmlkZW9FbmFibGVkLCBpc0F1ZGlvRW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRG91YmxlIGNoZWNrIGFmdGVyIGNyZWF0aW5nIC0gaWYgc3RpbGwgY2xvc2VkLCBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICAgICAgICAgICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnIHx8IHBjLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTb2NrZXRdIFBlZXIgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGltbWVkaWF0ZWx5IGFmdGVyIGNyZWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluYWwgY2hlY2sgLSBlbnN1cmUgcGMgaXMgbm90IG51bGxcbiAgICAgICAgICAgICAgICBpZiAoIXBjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTb2NrZXRdIFBlZXIgY29ubmVjdGlvbiBpcyBudWxsIGFmdGVyIGNyZWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluYWwgY2hlY2sgc2lnbmFsaW5nIHN0YXRlIGJlZm9yZSBzZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgcGMuY29ubmVjdGlvblN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU29ja2V0XSBDYW5ub3Qgc2V0IHJlbW90ZSBkZXNjcmlwdGlvbjogcGVlciBjb25uZWN0aW9uIGlzIGNsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU29ja2V0XSBTaWduYWxpbmcgc3RhdGU6JywgcGMuc2lnbmFsaW5nU3RhdGUsICdDb25uZWN0aW9uIHN0YXRlOicsIHBjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihkYXRhLm9mZmVyKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIFJlbW90ZSBkZXNjcmlwdGlvbiBzZXQnKTtcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHF1ZXVlZCBJQ0UgY2FuZGlkYXRlcyBub3cgdGhhdCByZW1vdGUgZGVzY3JpcHRpb24gaXMgc2V0XG4gICAgICAgICAgICAgICAgaWYgKGljZUNhbmRpZGF0ZVF1ZXVlUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1NvY2tldF0gUHJvY2Vzc2luZyAke2ljZUNhbmRpZGF0ZVF1ZXVlUmVmLmN1cnJlbnQubGVuZ3RofSBxdWV1ZWQgSUNFIGNhbmRpZGF0ZXNgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgaWNlQ2FuZGlkYXRlUXVldWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwYy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gUXVldWVkIElDRSBjYW5kaWRhdGUgYWRkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU29ja2V0XSBFcnJvciBhZGRpbmcgcXVldWVkIElDRSBjYW5kaWRhdGU6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpY2VDYW5kaWRhdGVRdWV1ZVJlZi5jdXJyZW50ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHBjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHBjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gQW5zd2VyIGNyZWF0ZWQgYW5kIHNldCwgc2lnbmFsaW5nU3RhdGU6JywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuc3dlckRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyOiBhbnN3ZXIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFVzZXJJZDogZGF0YS5mcm9tVXNlcklkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIFNlbmRpbmcgYW5zd2VyOicsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbElkOiBhbnN3ZXJEYXRhLmNhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXNlcklkOiBhbnN3ZXJEYXRhLnRhcmdldFVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyVHlwZTogYW5zd2VyRGF0YS5hbnN3ZXIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Q29ubmVjdGVkOiBzb2NrZXQuY29ubmVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzb2NrZXRJZDogc29ja2V0LmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ3dlYnJ0YzphbnN3ZXInLCBhbnN3ZXJEYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0g4pyFIEFuc3dlciBlbWl0dGVkIHRvIHNvY2tldCcpO1xuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBzb2NrZXQgaXMgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKCFzb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTb2NrZXRdIOKaoO+4jyBTb2NrZXQgbm90IGNvbm5lY3RlZCB3aGVuIHNlbmRpbmcgYW5zd2VyIScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU29ja2V0XSBFcnJvciBoYW5kbGluZyBvZmZlcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gaGFuZGxlIGluY29taW5nIGNhbGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlQW5zd2VyID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSA9PT09PSBBTlNXRVIgUkVDRUlWRUQgPT09PT0nKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSBBbnN3ZXIgZGF0YTonLCB7XG4gICAgICAgICAgICAgICAgY2FsbElkOiBkYXRhLmNhbGxJZCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENhbGxJZDogY2FsbElkLFxuICAgICAgICAgICAgICAgIGZyb21Vc2VySWQ6IGRhdGEuZnJvbVVzZXJJZCxcbiAgICAgICAgICAgICAgICBhbnN3ZXJUeXBlOiBkYXRhLmFuc3dlcj8udHlwZSxcbiAgICAgICAgICAgICAgICBhbnN3ZXJTZHBMZW5ndGg6IGRhdGEuYW5zd2VyPy5zZHA/Lmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5jYWxsSWQgIT09IGNhbGxJZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSDinYwgQW5zd2VyIGNhbGxJZCBtaXNtYXRjaDonLCBkYXRhLmNhbGxJZCwgJ2V4cGVjdGVkOicsIGNhbGxJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIOKchSBBbnN3ZXIgY2FsbElkIG1hdGNoZXMsIHByb2Nlc3NpbmcuLi4nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGMgPSBwZWVyQ29ubmVjdGlvblJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmICghcGMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGRhdGEuYW5zd2VyKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIFJlbW90ZSBkZXNjcmlwdGlvbiBzZXQgZnJvbSBhbnN3ZXInKTtcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHF1ZXVlZCBJQ0UgY2FuZGlkYXRlcyBub3cgdGhhdCByZW1vdGUgZGVzY3JpcHRpb24gaXMgc2V0XG4gICAgICAgICAgICAgICAgaWYgKGljZUNhbmRpZGF0ZVF1ZXVlUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1NvY2tldF0gUHJvY2Vzc2luZyAke2ljZUNhbmRpZGF0ZVF1ZXVlUmVmLmN1cnJlbnQubGVuZ3RofSBxdWV1ZWQgSUNFIGNhbmRpZGF0ZXNgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgaWNlQ2FuZGlkYXRlUXVldWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwYy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gUXVldWVkIElDRSBjYW5kaWRhdGUgYWRkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU29ja2V0XSBFcnJvciBhZGRpbmcgcXVldWVkIElDRSBjYW5kaWRhdGU6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpY2VDYW5kaWRhdGVRdWV1ZVJlZi5jdXJyZW50ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTb2NrZXRdIEVycm9yIGhhbmRsaW5nIGFuc3dlcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gaGFuZGxlIGNhbGwgYW5zd2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZUljZUNhbmRpZGF0ZSA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5jYWxsSWQgIT09IGNhbGxJZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gUmVjZWl2ZWQgSUNFIGNhbmRpZGF0ZTonLCBkYXRhKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGMgPSBwZWVyQ29ubmVjdGlvblJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmICghcGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIFBlZXIgY29ubmVjdGlvbiBub3QgcmVhZHksIHF1ZXVlaW5nIElDRSBjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlUXVldWVSZWYuY3VycmVudC5wdXNoKGRhdGEuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiByZW1vdGUgZGVzY3JpcHRpb24gaXMgc2V0XG4gICAgICAgICAgICAgICAgaWYgKCFwYy5yZW1vdGVEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gUmVtb3RlIGRlc2NyaXB0aW9uIG5vdCBzZXQgeWV0LCBxdWV1ZWluZyBJQ0UgY2FuZGlkYXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGljZUNhbmRpZGF0ZVF1ZXVlUmVmLmN1cnJlbnQucHVzaChkYXRhLmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoZGF0YS5jYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gSUNFIGNhbmRpZGF0ZSBhZGRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElmIGVycm9yIGlzIGJlY2F1c2UgcmVtb3RlIGRlc2NyaXB0aW9uIGlzIG51bGwsIHF1ZXVlIGl0XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdyZW1vdGUgZGVzY3JpcHRpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gUmVtb3RlIGRlc2NyaXB0aW9uIG5vdCBzZXQsIHF1ZXVlaW5nIElDRSBjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlUXVldWVSZWYuY3VycmVudC5wdXNoKGRhdGEuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTb2NrZXRdIEVycm9yIGhhbmRsaW5nIElDRSBjYW5kaWRhdGU6JywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbignd2VicnRjOm9mZmVyJywgaGFuZGxlT2ZmZXIpO1xuICAgICAgICBzb2NrZXQub24oJ3dlYnJ0YzphbnN3ZXInLCBoYW5kbGVBbnN3ZXIpO1xuICAgICAgICBzb2NrZXQub24oJ3dlYnJ0YzppY2UtY2FuZGlkYXRlJywgaGFuZGxlSWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSBDbGVhbmluZyB1cCBXZWJSVEMgbGlzdGVuZXJzJyk7XG4gICAgICAgICAgICBzb2NrZXQub2ZmKCd3ZWJydGM6b2ZmZXInLCBoYW5kbGVPZmZlcik7XG4gICAgICAgICAgICBzb2NrZXQub2ZmKCd3ZWJydGM6YW5zd2VyJywgaGFuZGxlQW5zd2VyKTtcbiAgICAgICAgICAgIHNvY2tldC5vZmYoJ3dlYnJ0YzppY2UtY2FuZGlkYXRlJywgaGFuZGxlSWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCBpbmNsdWRlIGluaXRQZWVyQ29ubmVjdGlvbiwgZ2V0VXNlck1lZGlhLCBldGMuIGluIGRlcHNcbiAgICAgICAgLy8gdG8gYXZvaWQgcmUtc2V0dGluZyB1cCBsaXN0ZW5lcnMuIFRoZXNlIGZ1bmN0aW9ucyBhcmUgc3RhYmxlICh1c2VDYWxsYmFjaykuXG4gICAgICAgIC8vIFRoZSBoYW5kbGVycyB1c2UgcmVmcy9jdXJyZW50IHZhbHVlcyB3aGVuIG5lZWRlZC5cbiAgICB9LCBbY2FsbElkXSk7XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEFUVEFDSCBTVFJFQU1TIFRPIFZJREVPIEVMRU1FTlRTXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChsb2NhbFZpZGVvUmVmLmN1cnJlbnQgJiYgbG9jYWxTdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW9dIEF0dGFjaGluZyBsb2NhbCBzdHJlYW0gdG8gdmlkZW8gZWxlbWVudCcpO1xuICAgICAgICAgICAgbG9jYWxWaWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCA9IGxvY2FsU3RyZWFtO1xuICAgICAgICB9XG4gICAgfSwgW2xvY2FsU3RyZWFtXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlbW90ZVZpZGVvUmVmLmN1cnJlbnQgJiYgcmVtb3RlU3RyZWFtKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvXSBBdHRhY2hpbmcgcmVtb3RlIHN0cmVhbSB0byB2aWRlbyBlbGVtZW50Jyk7XG4gICAgICAgICAgICByZW1vdGVWaWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCA9IHJlbW90ZVN0cmVhbTtcbiAgICAgICAgfVxuICAgIH0sIFtyZW1vdGVTdHJlYW1dKTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQ0xFQU5VUCBPTiBVTk1PVU5UXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFVzZSByZWYgdG8gc3RvcmUgbGF0ZXN0IGVuZENhbGwgZnVuY3Rpb24gdG8gYXZvaWQgY2xlYW51cCByZS1ydW5uaW5nXG4gICAgY29uc3QgZW5kQ2FsbFJlZiA9IHVzZVJlZihlbmRDYWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBlbmRDYWxsUmVmLmN1cnJlbnQgPSBlbmRDYWxsO1xuICAgIH0sIFtlbmRDYWxsXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQ2xlYW51cF0gQ29tcG9uZW50IHVubW91bnRpbmcsIGNsZWFuaW5nIHVwLi4uJyk7XG4gICAgICAgICAgICAvLyBVc2UgcmVmIHRvIGNhbGwgbGF0ZXN0IGVuZENhbGwgd2l0aG91dCB0cmlnZ2VyaW5nIHJlLXJ1bnNcbiAgICAgICAgICAgIGVuZENhbGxSZWYuY3VycmVudCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBFbXB0eSBkZXBzIC0gb25seSBydW4gb24gdW5tb3VudFxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbFN0cmVhbSxcbiAgICAgICAgcmVtb3RlU3RyZWFtLFxuICAgICAgICBpc0Nvbm5lY3RlZCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHN0YXJ0Q2FsbCxcbiAgICAgICAgZW5kQ2FsbCxcbiAgICAgICAgdG9nZ2xlVmlkZW8sXG4gICAgICAgIHRvZ2dsZUF1ZGlvLFxuICAgICAgICBpc1ZpZGVvRW5hYmxlZCxcbiAgICAgICAgaXNBdWRpb0VuYWJsZWQsXG4gICAgICAgIGFwcGx5RmlsdGVyLFxuICAgICAgICBjdXJyZW50RmlsdGVyLFxuICAgICAgICBzdGFydFNjcmVlblNoYXJlLFxuICAgICAgICBzdG9wU2NyZWVuU2hhcmUsXG4gICAgICAgIGlzU2NyZWVuU2hhcmluZyxcbiAgICAgICAgbG9jYWxWaWRlb1JlZixcbiAgICAgICAgcmVtb3RlVmlkZW9SZWYsXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiZ2V0U29ja2V0IiwiRklMVEVSX0NPTkZJRyIsIm5vbmUiLCJsYWJlbCIsImVtb2ppIiwiYmVhdXR5IiwiY3NzRmlsdGVyIiwid2FybSIsImNvb2wiLCJwYXJ0eSIsIm92ZXJsYXkiLCJjdHgiLCJ3aWR0aCIsImhlaWdodCIsInRpbWUiLCJzYXZlIiwiZ2xvYmFsQWxwaGEiLCJpIiwieCIsInkiLCJzaXplIiwiZmlsbFN0eWxlIiwiYmVnaW5QYXRoIiwiYXJjIiwiTWF0aCIsIlBJIiwiZmlsbCIsInJlc3RvcmUiLCJiaXJ0aGRheSIsImJhbGxvb25Db2xvcnMiLCJmb3JFYWNoIiwiY29sb3IiLCJpbmRleCIsImJ4IiwiYnkiLCJyYWRpdXMiLCJncmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiZWxsaXBzZSIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibW92ZVRvIiwicXVhZHJhdGljQ3VydmVUbyIsInN0cm9rZSIsImxpbmVUbyIsImNsb3NlUGF0aCIsImNha2VIZWlnaHQiLCJmaWxsUmVjdCIsImN4IiwiSUNFX1NFUlZFUlMiLCJ1cmxzIiwidXNlcm5hbWUiLCJjcmVkZW50aWFsIiwidXNlV2ViUlRDIiwiY2FsbElkIiwiY29udmVyc2F0aW9uSWQiLCJfY29udmVyc2F0aW9uSWQiLCJpc0luaXRpYXRvciIsImxvY2FsVXNlcklkIiwiX2xvY2FsVXNlcklkIiwicmVtb3RlVXNlcklkIiwidmlkZW9EZXZpY2VJZCIsImF1ZGlvRGV2aWNlSWQiLCJsb2NhbFN0cmVhbSIsInNldExvY2FsU3RyZWFtIiwicmVtb3RlU3RyZWFtIiwic2V0UmVtb3RlU3RyZWFtIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImVycm9yIiwic2V0RXJyb3IiLCJpc1ZpZGVvRW5hYmxlZCIsInNldElzVmlkZW9FbmFibGVkIiwiaXNBdWRpb0VuYWJsZWQiLCJzZXRJc0F1ZGlvRW5hYmxlZCIsImN1cnJlbnRGaWx0ZXIiLCJzZXRDdXJyZW50RmlsdGVyIiwiaXNTY3JlZW5TaGFyaW5nIiwic2V0SXNTY3JlZW5TaGFyaW5nIiwicGVlckNvbm5lY3Rpb25SZWYiLCJzb2NrZXRSZWYiLCJsb2NhbFZpZGVvUmVmIiwicmVtb3RlVmlkZW9SZWYiLCJpY2VDYW5kaWRhdGVRdWV1ZVJlZiIsImhhc1JlY2VpdmVkT2ZmZXJSZWYiLCJvZmZlclJldHJ5VGltZXJSZWYiLCJyYXdDYW1lcmFTdHJlYW1SZWYiLCJzY3JlZW5TaGFyZVN0cmVhbVJlZiIsInByb2Nlc3NlZEZpbHRlclN0cmVhbVJlZiIsImZpbHRlckNhbnZhc1JlZiIsImZpbHRlclZpZGVvUmVmIiwiZmlsdGVyQW5pbWF0aW9uRnJhbWVSZWYiLCJjdXJyZW50RmlsdGVyUmVmIiwiaW5pdFBlZXJDb25uZWN0aW9uUmVmIiwiZ2V0VXNlck1lZGlhUmVmIiwic3luY1NvY2tldCIsImN1cnJlbnRTb2NrZXQiLCJjb25uZWN0ZWQiLCJjdXJyZW50IiwiY29uc29sZSIsImxvZyIsImlkIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJyZXBsYWNlVmlkZW9UcmFjayIsInRyYWNrIiwicGMiLCJzZW5kZXIiLCJnZXRTZW5kZXJzIiwiZmluZCIsInMiLCJraW5kIiwicmVwbGFjZVRyYWNrIiwic3RvcEZpbHRlclByb2Nlc3NpbmciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImdldFRyYWNrcyIsInN0b3AiLCJwYXVzZSIsImVyciIsInNyY09iamVjdCIsInN0YXJ0RmlsdGVyUHJvY2Vzc2luZyIsImZpbHRlciIsInJhd1N0cmVhbSIsInZpZGVvRWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJtdXRlZCIsInBsYXlzSW5saW5lIiwiYXV0b3BsYXkiLCJwbGF5IiwiY2F0Y2giLCJjYW52YXMiLCJnZXRDb250ZXh0IiwicmVuZGVyIiwidmlkZW8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjbGVhclJlY3QiLCJjb25maWciLCJkcmF3SW1hZ2UiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInByb2Nlc3NlZFN0cmVhbSIsImNhcHR1cmVTdHJlYW0iLCJwcm9jZXNzZWRUcmFjayIsImdldFZpZGVvVHJhY2tzIiwic3RvcFNjcmVlblNoYXJlIiwiY2FtZXJhU3RyZWFtIiwiY2FtZXJhVHJhY2siLCJzdGFydFNjcmVlblNoYXJlIiwibmF2aWdhdG9yIiwiZWxlY3Ryb25BUEkiLCJ3aW5kb3ciLCJ1bmRlZmluZWQiLCJzaGFyZVN0cmVhbSIsInNlbGVjdFNjcmVlblNvdXJjZSIsInNvdXJjZUlkIiwiZWxlY3Ryb25Db25zdHJhaW50cyIsImF1ZGlvIiwibWFuZGF0b3J5IiwiY2hyb21lTWVkaWFTb3VyY2UiLCJjaHJvbWVNZWRpYVNvdXJjZUlkIiwibWF4RnJhbWVSYXRlIiwibWluRnJhbWVSYXRlIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiZ2V0RGlzcGxheU1lZGlhIiwiZnJhbWVSYXRlIiwiaWRlYWwiLCJkaXNwbGF5U3VyZmFjZSIsIkVycm9yIiwib25lbmRlZCIsIm5hbWUiLCJhcHBseUZpbHRlciIsIndhcm4iLCJoYW5kbGVHZXRVc2VyTWVkaWFFcnJvciIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm1lc3NhZ2UiLCJlcnJvck1zZyIsImxvY2F0aW9uIiwib3JpZ2luIiwiaHJlZiIsImlzU2VjdXJlQ29udGV4dCIsImNvbnN0cmFpbnRzIiwiZGV2aWNlSWQiLCJleGFjdCIsImZhY2luZ01vZGUiLCJlY2hvQ2FuY2VsbGF0aW9uIiwibm9pc2VTdXBwcmVzc2lvbiIsImF1dG9HYWluQ29udHJvbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdHJlYW0iLCJhY3RpdmUiLCJtYXAiLCJlbmFibGVkIiwicmVhZHlTdGF0ZSIsImFkZFRyYWNrIiwiZXJyb3JNZXNzYWdlIiwiaW5pdFBlZXJDb25uZWN0aW9uIiwiY2xvc2UiLCJSVENQZWVyQ29ubmVjdGlvbiIsImljZVNlcnZlcnMiLCJvbmljZWNhbmRpZGF0ZSIsImV2ZW50IiwiY2FuZGlkYXRlIiwic29ja2V0IiwiZW1pdCIsInRhcmdldFVzZXJJZCIsIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwic3RhdGUiLCJjb25uZWN0aW9uU3RhdGUiLCJvbnRyYWNrIiwic3RyZWFtcyIsIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwiaWNlQ29ubmVjdGlvblN0YXRlIiwicmVxdWVzdE9mZmVyIiwicmVhc29uIiwiZnJvbVVzZXJJZCIsInN0YXJ0Q2FsbCIsIm9mZmVyIiwic29ja2V0Q29ubmVjdGVkIiwic29ja2V0SWQiLCJjcmVhdGVPZmZlciIsInR5cGUiLCJzZHBMZW5ndGgiLCJzZHAiLCJsZW5ndGgiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwic2lnbmFsaW5nU3RhdGUiLCJvZmZlckRhdGEiLCJvZmZlclR5cGUiLCJlbmRDYWxsIiwidG9nZ2xlVmlkZW8iLCJ2aWRlb1RyYWNrcyIsInRvZ2dsZUF1ZGlvIiwiYXVkaW9UcmFja3MiLCJnZXRBdWRpb1RyYWNrcyIsImhhbmRsZU9mZmVyIiwiZGF0YSIsImV4cGVjdGVkQ2FsbElkIiwib2ZmZXJTZHBMZW5ndGgiLCJpc0Nsb3NlZCIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwiYWRkSWNlQ2FuZGlkYXRlIiwiUlRDSWNlQ2FuZGlkYXRlIiwiYW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwiYW5zd2VyRGF0YSIsImFuc3dlclR5cGUiLCJoYW5kbGVBbnN3ZXIiLCJhbnN3ZXJTZHBMZW5ndGgiLCJoYW5kbGVJY2VDYW5kaWRhdGUiLCJwdXNoIiwicmVtb3RlRGVzY3JpcHRpb24iLCJpbmNsdWRlcyIsIm9uIiwib2ZmIiwiZW5kQ2FsbFJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../packages/app/hooks/useWebRTC.js\n"));

/***/ })

});